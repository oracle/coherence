/*
 * Copyright (c) 2000, 2024, Oracle and/or its affiliates.
 *
 * Licensed under the Universal Permissive License v 1.0 as shown at
 * https://oss.oracle.com/licenses/upl.
 */

// ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache

package com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService;

import com.oracle.coherence.common.collections.NullableSortedMap;
import com.oracle.coherence.common.util.Duration;
import com.oracle.coherence.common.util.MemorySize;
import com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.partitionedCache.BinaryMap;
import com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.partitionedCache.Storage;
import com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.partitionedCache.ViewMap;

import com.tangosol.coherence.component.net.Cluster;
import com.tangosol.coherence.component.net.Lease;
import com.tangosol.coherence.component.net.MemberSet;
import com.tangosol.coherence.component.net.Message;
import com.tangosol.coherence.component.net.Poll;
import com.tangosol.coherence.component.net.RequestContext;
import com.tangosol.coherence.component.net.memberSet.SingleMemberSet;
import com.tangosol.coherence.component.net.message.MapEventMessage;
import com.tangosol.coherence.component.net.message.RequestMessage;
import com.tangosol.coherence.component.net.message.requestMessage.DistributedCacheKeyRequest;
import com.tangosol.coherence.component.net.message.requestMessage.chainedRequest.BackupRequest;
import com.tangosol.coherence.component.net.message.requestMessage.distributedCacheRequest.KeySetRequest;
import com.tangosol.coherence.component.net.message.requestMessage.distributedCacheRequest.PartialRequest;
import com.tangosol.coherence.component.net.message.requestMessage.distributedCacheRequest.partialRequest.FilterRequest;
import com.tangosol.coherence.component.net.requestContext.AsyncContext;
import com.tangosol.coherence.component.net.requestContext.asyncContext.AsyncAggregatorContext;
import com.tangosol.coherence.component.net.requestContext.asyncContext.AsyncProcessorContext;
import com.tangosol.coherence.component.util.PartialJob;
import com.tangosol.coherence.component.util.daemon.queueProcessor.service.Grid;
import com.oracle.coherence.common.base.Blocking;
import com.oracle.coherence.common.base.Collector;
import com.oracle.coherence.common.base.Continuation;
import com.oracle.coherence.common.internal.Platform;
import com.oracle.coherence.persistence.AsyncPersistenceException;
import com.oracle.coherence.persistence.PersistenceException;
import com.oracle.coherence.persistence.PersistenceManager;
import com.oracle.coherence.persistence.PersistentStore;
import com.tangosol.application.ContainerHelper;
import com.tangosol.coherence.config.Config;
import com.tangosol.coherence.config.ResolvableParameterList;
import com.tangosol.coherence.config.unit.Millis;
import com.tangosol.config.expression.Parameter;
import com.tangosol.internal.net.NamedCacheDeactivationListener;
import com.tangosol.internal.net.service.grid.DefaultPartitionedCacheDependencies;
import com.tangosol.internal.net.service.grid.PartitionedCacheDependencies;
import com.tangosol.internal.tracing.Span;
import com.tangosol.internal.tracing.TracingHelper;
import com.tangosol.internal.util.BMEventFabric;
import com.tangosol.internal.util.ConversionHelper;
import com.tangosol.internal.util.HeuristicCommitException;
import com.tangosol.internal.util.LockContentionException;
import com.tangosol.internal.util.QueryResult;
import com.tangosol.io.DeltaCompressor;
import com.tangosol.io.ReadBuffer;
import com.tangosol.io.Serializer;
import com.tangosol.io.SizeEstimatingBufferOutput;
import com.tangosol.io.WriteBuffer;
import com.tangosol.license.LicenseException;
import com.tangosol.net.ActionPolicy;
import com.tangosol.net.BackingMapManager;
import com.tangosol.net.CacheService;
import com.tangosol.net.GuardSupport;
import com.tangosol.net.Member;
import com.tangosol.net.NamedCache;
import com.tangosol.net.PriorityTask;
import com.tangosol.net.RequestIncompleteException;
import com.tangosol.net.RequestPolicyException;
import com.tangosol.net.RequestTimeoutException;
import com.tangosol.net.ServiceStoppedException;
import com.tangosol.net.cache.CacheEvent;
import com.tangosol.net.cache.LocalCache;
import com.tangosol.net.cache.ReadWriteBackingMap;
import com.tangosol.net.events.EventDispatcherRegistry;
import com.tangosol.net.events.internal.InterceptorManager;
import com.tangosol.net.events.internal.ServiceDispatcher;
import com.tangosol.net.events.internal.StorageDispatcher;
import com.tangosol.net.events.partition.cache.EntryEvent;
import com.tangosol.net.internal.CopyOnWriteLongList;
import com.tangosol.net.internal.EntryInfo;
import com.tangosol.net.internal.MemberInfo;
import com.tangosol.net.internal.PartitionInfo;
import com.tangosol.net.internal.PartitionVersions;
import com.tangosol.net.internal.StorageVersion;
import com.tangosol.net.partition.DefaultVersionedPartitions;
import com.tangosol.net.partition.PartitionSet;
import com.tangosol.net.partition.VersionAwareMapListener;
import com.tangosol.net.partition.VersionedOwnership;
import com.tangosol.net.partition.VersionedPartitions;
import com.tangosol.net.security.DoAsAction;
import com.tangosol.net.security.SecurityHelper;
import com.tangosol.run.component.EventDeathException;
import com.tangosol.run.xml.SimpleElement;
import com.tangosol.run.xml.XmlElement;
import com.tangosol.run.xml.XmlValue;
import com.tangosol.util.Base;
import com.tangosol.util.Binary;
import com.tangosol.util.BinaryEntry;
import com.tangosol.util.BinaryWriteBuffer;
import com.tangosol.util.ChainedCollection;
import com.tangosol.util.ChainedMap;
import com.tangosol.util.ClassFilter;
import com.tangosol.util.ConcurrentMap;
import com.tangosol.util.Converter;
import com.tangosol.util.ConverterCollections;
import com.tangosol.util.CopyOnWriteMap;
import com.tangosol.util.EntrySetMap;
import com.tangosol.util.ExternalizableHelper;
import com.tangosol.util.Filter;
import com.tangosol.util.FilterEnumerator;
import com.tangosol.util.HashHelper;
import com.tangosol.util.ImmutableArrayList;
import com.tangosol.util.InvocableMapHelper;
import com.tangosol.util.KeyValueArrayMap;
import com.tangosol.util.Listeners;
import com.tangosol.util.LiteMap;
import com.tangosol.util.LiteSet;
import com.tangosol.util.LongArray;
import com.tangosol.util.MapTrigger;
import com.tangosol.util.MapTriggerListener;
import com.tangosol.util.NullImplementation;
import com.tangosol.util.PrimitiveSparseArray;
import com.tangosol.util.ResourceRegistry;
import com.tangosol.util.SafeHashMap;
import com.tangosol.util.SafeLinkedList;
import com.tangosol.util.SegmentedConcurrentMap;
import com.tangosol.util.SetMap;
import com.tangosol.util.SimpleMapEntry;
import com.tangosol.util.SparseArray;
import com.tangosol.util.ValueExtractor;
import com.tangosol.util.aggregator.AbstractAsynchronousAggregator;
import com.tangosol.util.aggregator.QueryRecorder;
import com.tangosol.util.comparator.EntryComparator;
import com.tangosol.util.comparator.SafeComparator;
import com.tangosol.util.filter.AlwaysFilter;
import com.tangosol.util.filter.InKeySetFilter;
import com.tangosol.util.filter.KeyAssociatedFilter;
import com.tangosol.util.filter.LimitFilter;
import com.tangosol.util.filter.PartitionedFilter;
import com.tangosol.util.processor.AbstractAsynchronousProcessor;
import java.io.IOException;
import java.security.AccessController;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.ConcurrentModificationException;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicLong;
import java.util.concurrent.atomic.AtomicReferenceArray;

/**
 * See PartitionedCacheService.doc in the main depot
 * (//dev/main/doc/coherence-core).
 * 
 * The message range from [51, 100] is reserved for usage by the
 * PartitionedCache component.
 * 
 * Currently used MessageTypes:
 * 51    AggregateAllRequest
 * 52    AggregateFilterRequest
 * 53    BackupAllRequest
 * 54    ClearRequest
 * 55    ContainsAllRequest
 * 56    ContainsKeyRequest
 * 57    ContainsValueRequest
 * 58    GetAllRequest
 * 59    GetRequest
 * 60    IndexRequest
 * 61    InvokeAllRequest
 * 62    InvokeFilterRequest
 * 63    InvokeRequest
 * 64    KeyIteratorRequest
 * 65    KeyListenerRequest
 * 66    ListenerRequest
 * 67    LockRequest
 * 68    MapEvent
 * 69    PartialMapResponse
 * 70    PartialValueResponse
 * 71    PutAllRequest
 * 72    PutRequest
 * 73    QueryRequest
 * 74    QueryResponse
 * 75    RemoveAllRequest
 * 76    RemoveRequest
 * 77    SizeRequest
 * 78    StorageIdRequest
 * 79    UnlockRequest
 * 80    BackupSingleRequest
 * 81    BackupLockRequest
 * 82    BackupListenerRequest
 * 83    StorageConfirmRequest
 * 84    UpdateIndexRequest
 * 85    KeyListenerAllRequest
 * 86    BackupListenerAllRequest
 * 87    PartitionedQueryRequest
 * 88    PartitionedQueryResponse
 */
@SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
public class PartitionedCache
        extends    com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService
        implements com.tangosol.net.CacheService,
                   com.tangosol.net.DistributedCacheService
    {
    // ---- Fields declarations ----
    
    /**
     * Property AddedDaemons
     *
     * Indicates how many additional threads were added to process the deferred
     * index rebuild
     */
    private int __m_AddedDaemons;
    
    /**
     * Property BackingMapContext
     *
     * The BackingMapContext (lazily created) is used by the BackingMapManager
     * (if provided) and Storage indexes.
     */
    private transient PartitionedCache.BackingMapContext __m_BackingMapContext;
    
    /**
     * Property BackingMapManager
     *
     * Interface that provides the backing map storage implementations for the
     * cache.
     */
    private transient com.tangosol.net.BackingMapManager __m_BackingMapManager;
    
    /**
     * Property BackupAllEnvelopeSize
     *
     * The size of BackupAllRequest envelope; used in optimized size estimation
     * for serialization.
     * 
     * @see $BackupAllRequest#getEstimatedByteSize
     */
    private java.util.concurrent.atomic.AtomicInteger __m_BackupAllEnvelopeSize;
    
    /**
     * Property BackupCountOpt
     *
     * Specifies the number of members that will retain backup data that does
     * not require write-behind, i.e. data that is not vulnerable to being lost
     * even if the entire cluster were shut down.
     */
    private int __m_BackupCountOpt;
    
    /**
     * Property BackupDeltaCompressor
     *
     * Interface that provides a strategy for the backup compressor.
     */
    private transient com.tangosol.io.DeltaCompressor __m_BackupDeltaCompressor;
    
    /**
     * Property BackupSingleEnvelopeSize
     *
     * The size of BackupSingleRequest envolope; used in optimized size
     * estimation for serialization.
     * 
     * @see $BackupSingleRequest#getEstimatedByteSize
     */
    private java.util.concurrent.atomic.AtomicInteger __m_BackupSingleEnvelopeSize;
    
    /**
     * Property BinaryEntryConverter
     *
     * A Converter that converts an $EntryStatus object to a BinaryEntry.
     */
    private com.tangosol.util.Converter __m_BinaryEntryConverter;
    
    /**
     * Property BinaryMapArray
     *
     * Holds the $BinaryMap references indexed by the cache id.
     * 
     * @see $BinaryMap#CacheId
     */
    private com.tangosol.util.LongArray __m_BinaryMapArray;
    
    /**
     * Property EventDeltaCompressor
     *
     * Interface that provides a strategy for the event compressor.
     */
    private transient com.tangosol.io.DeltaCompressor __m_EventDeltaCompressor;
    
    /**
     * Property EventsHelper
     *
     */
    private PartitionedCache.EventsHelper __m_EventsHelper;

    /**
     * Property OldestEventResendNextMillis
     *
     * Interval between resends of potentially "stuck" oldest event.
     */
    private transient long __m_EventResendInterval;

    /**
     * Property IndexingStartTime
     *
     * Start of one index build event for all partitions. Modified and accessed
     * on service thread.
     */
    private long __m_IndexingStartTime;
    
    /**
     * Property IndexPendingPartitions
     *
     * This PartitionSet that contains partitions that have a pending index
     * rebuild due to partition redistribution or initial index creation.
     * 
     * @volatile
     */
    private volatile com.tangosol.net.partition.PartitionSet __m_IndexPendingPartitions;
    
    /**
     * Property IndexProcessingPartitions
     *
     * This PartitionSet that contains partitions that index rebuild are being
     * processed,  used in condition check for index rebuild optimization,  see
     * scheduleInitialIndexUpdate.
     * 
     * @volatile
     */
    private volatile com.tangosol.net.partition.PartitionSet __m_IndexProcessingPartitions;
    
    /**
     * Property IndexUpdateCount
     *
     * A number of currently executing index update requests. This value is
     * only used by the service thread.
     * 
     * Note: this number is never greater than the "fair CPU count" (see
     * IndexUpdateRequest$Poll.onResponse).
     * 
     * @see scheduleIndexUpdate
     */
    private int __m_IndexUpdateCount;
    
    /**
     * Property LazyLookupReadBuffer
     *
     */
    private PartitionedCache.LazyLookup __m_LazyLookupReadBuffer;
    
    /**
     * Property LeaseGranularity
     *
     * The lease granularity.
     * 
     * Valid values are:
     *   Lease.BY_THREAD  - thread based ownership (default)
     *   Lease.BY_MEMBER - member based ownership
     */
    private int __m_LeaseGranularity;
    
    /**
     * Property LockingNextMillis
     *
     * The LockingNextMillis value is the time (in local system millis) at
     * which the next deferred lock evaluation will be performed.
     * 
     * Initial value is Long.MAX_VALUE.
     */
    private transient long __m_LockingNextMillis;

    /**
     * Property OldestEventResendNextMillis
     *
     * The time at which the oldest event should be resent if it is determined
     * to be "old enough", or far enough behind the current event.
     */
    private transient long __m_OldestEventResendNextMillis;

    /**
     * Property PendingEvents
     *
     * An array of pending event-related items indexed by the corresponding
     * SUID. The SUID represent an event originator (cache server) and the
     * value is a $MapEvent containing all necessary data to re-deliver an
     * event in the case of a ownership-enabled node fail-over.
     * 
     * For a SUID that represents the local node, the value could be "null".
     * Those entries are used to ensure in-order event delivery and calculate
     * the OldestPendingEventSUID property.
     */
    private transient com.tangosol.util.LongArray __m_PendingEvents;
    
    /**
     * Property PendingIndexUpdate
     *
     * A list of IndexUpdateRequest messages that are waiting to be processed. 
     * 
     * @see scheduleIndexUpdate
     */
    private java.util.concurrent.ConcurrentLinkedQueue __m_PendingIndexUpdate;
    
    /**
     * Property PendingResultInfo
     *
     * An array of sorted maps of pending result-related items keyed by the
     * corresponding SUID. 
     * 
     * Used for requests that need to implement idempotent re-execution in the
     * case of a failover.
     */
    private transient com.tangosol.util.SparseArray[] __m_PendingResultInfo;
    
    /**
     * Property ProcessedEvents
     *
     * An array of already processed events indexed by the corresponding SUID.
     * Used to prevent processing the same event twice in a case of a failover.
     * The values are always nulls.
     */
    private transient com.tangosol.util.LongArray __m_ProcessedEvents;
    
    /**
     * Property ReferencesBinaryMap
     *
     * Map keyed by cache name with a corresponding value being a binary map
     * interface.
     */
    private java.util.Map __m_ReferencesBinaryMap;
    
    /**
     * Property RequestCoordinator
     *
     * The RequestCoordinator.
     */
    private PartitionedCache.RequestCoordinator __m_RequestCoordinator;
    
    /**
     * Property ResourceCoordinator
     *
     */
    private PartitionedCache.ResourceCoordinator __m_ResourceCoordinator;
    
    /**
     * Property ScheduledBackupsThreshold
     *
     * Specifies the ratio in percentage of partition size at which it becomes
     * beneficial to back up an entire partition for a given cache.
     * 
     * Undocumented: configured via
     * coherence.distributed.scheduledbackupsthreshold, see onInit
     */
    private int __m_ScheduledBackupsThreshold;

    /**
     * Property MaxPartialResponseSize
     *
     * Specifies the size in bytes after which a query-type response message
     * will be broken up into chunks for it to be "streamed".
     * This is to prevent reaching the 2GB message size limit.
     *
     * Undocumented: configured via
     * coherence.distributed.max.response.size, see onInit
     */
    private MemorySize __m_MaxPartialResponseSize;

    /**
     * Property ScopedCacheStore
     *
     * Map keyed by cache name with a corresponding value being a map (keyed by
     * class loader with a corresponding value being a NamedCache reference).
     */
    private com.tangosol.net.internal.ScopedCacheReferenceStore __m_ScopedCacheStore;
    
    /**
     * Property SendBackupsTask
     *
     * The task that is responsible to send scheduled backup message
     * ($BackupAllRequest) for the pending backup changes.
     */
    private PartitionedCache.SendBackupsTask __m_SendBackupsTask;
    
    /**
     * Property StandardLeaseMillis
     *
     * The duration of a standard Lease in milliseconds. Zero indicates an
     * indefinite lease duration.
     */
    private long __m_StandardLeaseMillis;
    
    /**
     * Property StatsIndexingTime
     *
     * Cumulative elapsed time taken to build all indices, reset when
     * resetStats() is called.
     */
    private java.util.concurrent.atomic.AtomicLong __m_StatsIndexingTime;
    
    /**
     * Property StorageArray
     *
     * The StorageArray holds the storage units ($Storage) indexed by the cache
     * id.
     * 
     * As of Coherence 3.7, we use the copy-on-write array, which produces safe
     * iterators. Additionally, any changes to the StorageArray only happen on
     * the service thread.
     * 
     * @see $BinaryMap#CacheId
     * @see $Storage
     */
    private com.tangosol.util.LongArray __m_StorageArray;
    
    /**
     * Property StorageGraveyard
     *
     * Time-limited cache, mapping cache-id to cache-name, of recently
     * destroyed caches.
     * 
     * See COH-3275
     */
    private java.util.Map __m_StorageGraveyard;
    
    /**
     * Property StrictPartitioning
     *
     * Specifies whether or not the PartitionSplittingBackingMap(s) used as
     * PartitionedKeyIndex and BackupMap should be operating in a strict mode. 
     * 
     * @see $Storage#instantiateResourceMap, $Storage#instantiateBackupMap
     * @since Coherence 3.5
     */
    private boolean __m_StrictPartitioning;
    
    /**
     * Property SUID_CACHE
     *
     * The SUID domain used for tracking caches ids.
     */
    public static final int SUID_CACHE = 3;
    
    /**
     * Property SUID_EVENT
     *
     * The SUID domain used for tracking events.
     */
    public static final int SUID_EVENT = 2;
    
    /**
     * Property SUID_FILTER
     *
     * The SUID domain used for tracking filter regisrations.
     */
    public static final int SUID_FILTER = 1;
    
    /**
     * Property TaskSplitThreshold
     *
     * Specifies the size at which it becomes beneficial to split tasks into
     * partitioned sub-tasks.
     * 
     * Undocumented: configured via
     * tangosol.coherence.distributed.tasksplitthreshold, see onInit
     */
    private int __m_TaskSplitThreshold;
    
    /**
     * Property TLOContext
     *
     * Threadlocal Invocation Context
     */
    private ThreadLocal __m_TLOContext;
    private static com.tangosol.util.ListMap __mapChildren;
    
    // Static initializer
    static
        {
        __initStatic();
        }
    
    // Default static initializer
    private static void __initStatic()
        {
        // register child classes
        __mapChildren = new com.tangosol.util.ListMap();
        __mapChildren.put("Acknowledgement", com.tangosol.coherence.component.util.daemon.queueProcessor.service.Grid.Acknowledgement.get_CLASS());
        __mapChildren.put("AggregateAllRequest", PartitionedCache.AggregateAllRequest.get_CLASS());
        __mapChildren.put("AggregateFilterRequest", PartitionedCache.AggregateFilterRequest.get_CLASS());
        __mapChildren.put("BackingMapContext", PartitionedCache.BackingMapContext.get_CLASS());
        __mapChildren.put("BackupAllRequest", PartitionedCache.BackupAllRequest.get_CLASS());
        __mapChildren.put("BackupAssignment", com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.BackupAssignment.get_CLASS());
        __mapChildren.put("BackupConfirmRequest", PartitionedCache.BackupConfirmRequest.get_CLASS());
        __mapChildren.put("BackupListenerAllRequest", PartitionedCache.BackupListenerAllRequest.get_CLASS());
        __mapChildren.put("BackupListenerRequest", PartitionedCache.BackupListenerRequest.get_CLASS());
        __mapChildren.put("BackupLockRequest", PartitionedCache.BackupLockRequest.get_CLASS());
        __mapChildren.put("BackupSingleRequest", PartitionedCache.BackupSingleRequest.get_CLASS());
        __mapChildren.put("BatchContext", PartitionedCache.BatchContext.get_CLASS());
        __mapChildren.put("BinaryMap", BinaryMap.get_CLASS());
        __mapChildren.put("BusEventMessage", com.tangosol.coherence.component.util.daemon.queueProcessor.service.Grid.BusEventMessage.get_CLASS());
        __mapChildren.put("CentralDistribution", com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.CentralDistribution.get_CLASS());
        __mapChildren.put("ClearRequest", PartitionedCache.ClearRequest.get_CLASS());
        __mapChildren.put("ConfigRequest", com.tangosol.coherence.component.util.daemon.queueProcessor.service.Grid.ConfigRequest.get_CLASS());
        __mapChildren.put("ConfigResponse", com.tangosol.coherence.component.util.daemon.queueProcessor.service.Grid.ConfigResponse.get_CLASS());
        __mapChildren.put("ConfigSync", com.tangosol.coherence.component.util.daemon.queueProcessor.service.Grid.ConfigSync.get_CLASS());
        __mapChildren.put("ConfigUpdate", com.tangosol.coherence.component.util.daemon.queueProcessor.service.Grid.ConfigUpdate.get_CLASS());
        __mapChildren.put("ContainsAllRequest", PartitionedCache.ContainsAllRequest.get_CLASS());
        __mapChildren.put("ContainsKeyRequest", PartitionedCache.ContainsKeyRequest.get_CLASS());
        __mapChildren.put("ContainsValueRequest", PartitionedCache.ContainsValueRequest.get_CLASS());
        __mapChildren.put("Contention", com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.Contention.get_CLASS());
        __mapChildren.put("ConverterFromBinary", PartitionedCache.ConverterFromBinary.get_CLASS());
        __mapChildren.put("ConverterKeyToBinary", com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.ConverterKeyToBinary.get_CLASS());
        __mapChildren.put("ConverterValueToBinary", PartitionedCache.ConverterValueToBinary.get_CLASS());
        __mapChildren.put("DispatchEvent", com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.DispatchEvent.get_CLASS());
        __mapChildren.put("DispatchNotification", com.tangosol.coherence.component.util.daemon.queueProcessor.service.Grid.DispatchNotification.get_CLASS());
        __mapChildren.put("DistributionPlanUpdate", com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.DistributionPlanUpdate.get_CLASS());
        __mapChildren.put("DistributionRequest", PartitionedCache.DistributionRequest.get_CLASS());
        __mapChildren.put("GetAllRequest", PartitionedCache.GetAllRequest.get_CLASS());
        __mapChildren.put("GetRequest", PartitionedCache.GetRequest.get_CLASS());
        __mapChildren.put("IndexRequest", PartitionedCache.IndexRequest.get_CLASS());
        __mapChildren.put("InvocationContext", PartitionedCache.InvocationContext.get_CLASS());
        __mapChildren.put("InvokeAllRequest", PartitionedCache.InvokeAllRequest.get_CLASS());
        __mapChildren.put("InvokeFilterRequest", PartitionedCache.InvokeFilterRequest.get_CLASS());
        __mapChildren.put("InvokeRequest", PartitionedCache.InvokeRequest.get_CLASS());
        __mapChildren.put("KeyIteratorRequest", PartitionedCache.KeyIteratorRequest.get_CLASS());
        __mapChildren.put("KeyListenerAllRequest", PartitionedCache.KeyListenerAllRequest.get_CLASS());
        __mapChildren.put("KeyListenerRequest", PartitionedCache.KeyListenerRequest.get_CLASS());
        __mapChildren.put("ListenerRequest", PartitionedCache.ListenerRequest.get_CLASS());
        __mapChildren.put("LockRequest", PartitionedCache.LockRequest.get_CLASS());
        __mapChildren.put("MapEvent", PartitionedCache.MapEvent.get_CLASS());
        __mapChildren.put("MemberConfigUpdate", com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.MemberConfigUpdate.get_CLASS());
        __mapChildren.put("MemberJoined", com.tangosol.coherence.component.util.daemon.queueProcessor.service.Grid.MemberJoined.get_CLASS());
        __mapChildren.put("MemberRecovered", com.tangosol.coherence.component.util.daemon.queueProcessor.service.Grid.MemberRecovered.get_CLASS());
        __mapChildren.put("MemberWelcome", PartitionedCache.MemberWelcome.get_CLASS());
        __mapChildren.put("MemberWelcomeRequest", PartitionedCache.MemberWelcomeRequest.get_CLASS());
        __mapChildren.put("MemberWelcomeRequestTask", com.tangosol.coherence.component.util.daemon.queueProcessor.service.Grid.MemberWelcomeRequestTask.get_CLASS());
        __mapChildren.put("NotifyConnectionClose", com.tangosol.coherence.component.util.daemon.queueProcessor.service.Grid.NotifyConnectionClose.get_CLASS());
        __mapChildren.put("NotifyConnectionOpen", com.tangosol.coherence.component.util.daemon.queueProcessor.service.Grid.NotifyConnectionOpen.get_CLASS());
        __mapChildren.put("NotifyMemberJoined", com.tangosol.coherence.component.util.daemon.queueProcessor.service.Grid.NotifyMemberJoined.get_CLASS());
        __mapChildren.put("NotifyMemberLeaving", com.tangosol.coherence.component.util.daemon.queueProcessor.service.Grid.NotifyMemberLeaving.get_CLASS());
        __mapChildren.put("NotifyMemberLeft", com.tangosol.coherence.component.util.daemon.queueProcessor.service.Grid.NotifyMemberLeft.get_CLASS());
        __mapChildren.put("NotifyMessageReceipt", com.tangosol.coherence.component.util.daemon.queueProcessor.service.Grid.NotifyMessageReceipt.get_CLASS());
        __mapChildren.put("NotifyPollClosed", com.tangosol.coherence.component.util.daemon.queueProcessor.service.Grid.NotifyPollClosed.get_CLASS());
        __mapChildren.put("NotifyResponse", com.tangosol.coherence.component.util.daemon.queueProcessor.service.Grid.NotifyResponse.get_CLASS());
        __mapChildren.put("NotifyServiceAnnounced", com.tangosol.coherence.component.util.daemon.queueProcessor.service.Grid.NotifyServiceAnnounced.get_CLASS());
        __mapChildren.put("NotifyServiceJoining", com.tangosol.coherence.component.util.daemon.queueProcessor.service.Grid.NotifyServiceJoining.get_CLASS());
        __mapChildren.put("NotifyServiceLeaving", com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.NotifyServiceLeaving.get_CLASS());
        __mapChildren.put("NotifyServiceLeft", com.tangosol.coherence.component.util.daemon.queueProcessor.service.Grid.NotifyServiceLeft.get_CLASS());
        __mapChildren.put("NotifyServiceQuiescence", com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.NotifyServiceQuiescence.get_CLASS());
        __mapChildren.put("NotifyShutdown", com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.NotifyShutdown.get_CLASS());
        __mapChildren.put("NotifySnapshotRecoverRequest", com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.NotifySnapshotRecoverRequest.get_CLASS());
        __mapChildren.put("NotifyStartup", com.tangosol.coherence.component.util.daemon.queueProcessor.service.Grid.NotifyStartup.get_CLASS());
        __mapChildren.put("OwnershipRequest", PartitionedCache.OwnershipRequest.get_CLASS());
        __mapChildren.put("OwnershipResponse", com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.OwnershipResponse.get_CLASS());
        __mapChildren.put("PartialMapResponse", PartitionedCache.PartialMapResponse.get_CLASS());
        __mapChildren.put("PartialValueResponse", PartitionedCache.PartialValueResponse.get_CLASS());
        __mapChildren.put("PartitionAbandonRequest", PartitionedCache.PartitionAbandonRequest.get_CLASS());
        __mapChildren.put("PartitionControl", PartitionedCache.PartitionControl.get_CLASS());
        __mapChildren.put("PartitionFilter", com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.PartitionFilter.get_CLASS());
        __mapChildren.put("PartitionRecoverCleanup", com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.PartitionRecoverCleanup.get_CLASS());
        __mapChildren.put("PartitionRecoverRequest", PartitionedCache.PartitionRecoverRequest.get_CLASS());
        __mapChildren.put("PartitionStatsUpdate", com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.PartitionStatsUpdate.get_CLASS());
        __mapChildren.put("PartitionSwapRequest", PartitionedCache.PartitionSwapRequest.get_CLASS());
        __mapChildren.put("PartitionVersionSyncRequest", PartitionedCache.PartitionVersionSyncRequest.get_CLASS());
        __mapChildren.put("PersistenceControl", PartitionedCache.PersistenceControl.get_CLASS());
        __mapChildren.put("PingRequest", com.tangosol.coherence.component.util.daemon.queueProcessor.service.Grid.PingRequest.get_CLASS());
        __mapChildren.put("PinningIterator", PartitionedCache.PinningIterator.get_CLASS());
        __mapChildren.put("ProtocolContext", com.tangosol.coherence.component.util.daemon.queueProcessor.service.Grid.ProtocolContext.get_CLASS());
        __mapChildren.put("PutAllRequest", PartitionedCache.PutAllRequest.get_CLASS());
        __mapChildren.put("PutRequest", PartitionedCache.PutRequest.get_CLASS());
        __mapChildren.put("QueryRequest", PartitionedCache.QueryRequest.get_CLASS());
        __mapChildren.put("PartitionedQueryRequest", PartitionedCache.PartitionedQueryRequest.get_CLASS());
        __mapChildren.put("QueryResponse", PartitionedCache.QueryResponse.get_CLASS());
        __mapChildren.put("PartitionedQueryResponse", PartitionedCache.PartitionedQueryResponse.get_CLASS());
        __mapChildren.put("RemoveAllRequest", PartitionedCache.RemoveAllRequest.get_CLASS());
        __mapChildren.put("RemoveRequest", PartitionedCache.RemoveRequest.get_CLASS());
        __mapChildren.put("Response", com.tangosol.coherence.component.util.daemon.queueProcessor.service.Grid.Response.get_CLASS());
        __mapChildren.put("ResultInfo", PartitionedCache.ResultInfo.get_CLASS());
        __mapChildren.put("SendBackupsTask", PartitionedCache.SendBackupsTask.get_CLASS());
        __mapChildren.put("SizeRequest", PartitionedCache.SizeRequest.get_CLASS());
        __mapChildren.put("SnapshotArchiveRequest", com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.SnapshotArchiveRequest.get_CLASS());
        __mapChildren.put("SnapshotListRequest", PartitionedCache.SnapshotListRequest.get_CLASS());
        __mapChildren.put("SnapshotRequest", PartitionedCache.SnapshotRequest.get_CLASS());
        __mapChildren.put("Storage", Storage.get_CLASS());
        __mapChildren.put("StorageConfirmRequest", StorageConfirmRequest.get_CLASS());
        __mapChildren.put("StorageIdRequest", StorageIdRequest.get_CLASS());
        __mapChildren.put("TransferRequest", PartitionedCache.TransferRequest.get_CLASS());
        __mapChildren.put("TransferResponse", com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.TransferResponse.get_CLASS());
        __mapChildren.put("UnlockRequest", PartitionedCache.UnlockRequest.get_CLASS());
        __mapChildren.put("UpdateIndexRequest", PartitionedCache.UpdateIndexRequest.get_CLASS());
        __mapChildren.put("ViewMap", ViewMap.get_CLASS());
        __mapChildren.put("WrapperGuardable", com.tangosol.coherence.component.util.daemon.queueProcessor.service.Grid.WrapperGuardable.get_CLASS());
        }
    
    // Default constructor
    public PartitionedCache()
        {
        this(null, null, true);
        }
    
    // Initializing constructor
    public PartitionedCache(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
        {
        super(sName, compParent, false);
        
        if (fInit)
            {
            __init();
            }
        }
    
    // Main initializer
    public void __init()
        {
        // private initialization
        __initPrivate();
        
        // state initialization: public and protected properties
        try
            {
            setAcceptingClients(false);
            setAcceptingOthers(false);
            setBackupAllEnvelopeSize(new java.util.concurrent.atomic.AtomicInteger());
            setBackupCount(0);
            setBackupCountOpt(0);
            setBackupSingleEnvelopeSize(new java.util.concurrent.atomic.AtomicInteger());
            setBinaryMapArray(new com.tangosol.util.CopyOnWriteLongArray());
            setDaemonState(0);
            setDefaultGuardRecovery(0.9F);
            setDefaultGuardTimeout(60000L);
            setDistributionNextMillis(9223372036854775807L);
            setDistributionRepeatMillis(2000);
            setDistributionSynchronized(true);
            setFinalizing(false);
            setLeaseGranularity(0);
            setLockingNextMillis(9223372036854775807L);
            setMessageClassMap(new java.util.HashMap());
            setNotifier(new com.oracle.coherence.common.base.SingleWaiterMultiNotifier());
            setOldestPendingRequestSUIDCounter(new java.util.concurrent.atomic.AtomicLong());
            setOwnershipEnabled(true);
            setPartitionListeners(new com.tangosol.util.Listeners());
            setPendingIndexUpdate(new java.util.concurrent.ConcurrentLinkedQueue());
            setProcessedEvents(new com.tangosol.util.SparseArray());
            setReferencesBinaryMap(new com.tangosol.util.SafeHashMap());
            setResourceRegistry(new com.tangosol.util.SimpleResourceRegistry());
            setScopedCacheStore(new com.tangosol.net.internal.ScopedCacheReferenceStore());
            setSerializerMap(new java.util.WeakHashMap());
            setStandardLeaseMillis(0L);
            setStatsIndexingTime(new java.util.concurrent.atomic.AtomicLong());
            setStorageArray(new com.tangosol.util.CopyOnWriteLongArray());
            setStrictPartitioning(true);
            setSuspendPollLimit(new java.util.concurrent.atomic.AtomicLong());
            setTLOContext(new java.lang.ThreadLocal());
            setTLORecoveryThread(new java.lang.ThreadLocal());
            }
        catch (java.lang.Exception e)
            {
            // re-throw as a runtime exception
            throw new com.tangosol.util.WrapperException(e);
            }
        
        // containment initialization: children
        _addChild(new PartitionedCache.Continuations("Continuations", this, true), "Continuations");
        _addChild(new PartitionedCache.DaemonPool("DaemonPool", this, true), "DaemonPool");
        _addChild(new com.tangosol.coherence.component.util.daemon.queueProcessor.service.Grid.EventDispatcher("EventDispatcher", this, true), "EventDispatcher");
        _addChild(new PartitionedCache.EventsHelper("EventsHelper", this, true), "EventsHelper");
        _addChild(new com.tangosol.coherence.component.util.daemon.queueProcessor.service.Grid.Guard("Guard", this, true), "Guard");
        _addChild(new PartitionedCache.LazyLookup("LazyLookup", this, true), "LazyLookup");
        _addChild(new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.MemberConfigListener("MemberConfigListener", this, true), "MemberConfigListener");
        _addChild(new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.PartitionConfig("PartitionConfig", this, true), "PartitionConfig");
        _addChild(new com.tangosol.coherence.component.util.daemon.queueProcessor.service.Grid.PollArray("PollArray", this, true), "PollArray");
        _addChild(new com.tangosol.coherence.component.util.daemon.queueProcessor.service.Grid.ReceiveQueue("ReceiveQueue", this, true), "ReceiveQueue");
        _addChild(new PartitionedCache.RequestCoordinator("RequestCoordinator", this, true), "RequestCoordinator");
        _addChild(new PartitionedCache.ResourceCoordinator("ResourceCoordinator", this, true), "ResourceCoordinator");
        _addChild(new PartitionedCache.ServiceConfig("ServiceConfig", this, true), "ServiceConfig");
        _addChild(new PartitionedCache.TransferControl("TransferControl", this, true), "TransferControl");
        
        // signal the end of the initialization
        set_Constructed(true);
        }
    
    // Private initializer
    protected void __initPrivate()
        {
        
        super.__initPrivate();
        }
    
    // Getter for virtual constant ServiceType
    public String getServiceType()
        {
        return "DistributedCache";
        }
    
    // Getter for virtual constant SUIDCounterLength
    public int getSUIDCounterLength()
        {
        return 4;
        }
    
    //++ getter for static property _Instance
    /**
     * Getter for property _Instance.<p>
    * Auto generated
     */
    public static com.tangosol.coherence.Component get_Instance()
        {
        return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache();
        }
    
    //++ getter for static property _CLASS
    /**
     * Getter for property _CLASS.<p>
    * Property with auto-generated accessor that returns the Class object for a
    * given component.
     */
    public static Class get_CLASS()
        {
        Class clz;
        try
            {
            clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache".replace('/', '.'));
            }
        catch (ClassNotFoundException e)
            {
            throw new NoClassDefFoundError(e.getMessage());
            }
        return clz;
        }
    
    //++ getter for autogen property _Module
    /**
     * This is an auto-generated method that returns the global [design time]
    * parent component.
    * 
    * Note: the class generator will ignore any custom implementation for this
    * behavior.
     */
    private com.tangosol.coherence.Component get_Module()
        {
        return this;
        }
    
    //++ getter for autogen property _ChildClasses
    /**
     * This is an auto-generated method that returns the map of design time
    * [static] children.
    * 
    * Note: the class generator will ignore any custom implementation for this
    * behavior.
     */
    protected java.util.Map get_ChildClasses()
        {
        return __mapChildren;
        }
    
    // Declared at the super level
    /**
     * Abandon the provided partitions.
     */
    protected void abandonPartitions(com.tangosol.net.partition.PartitionSet parts)
        {
        super.abandonPartitions(parts);
        
        if (collectOwnedPartitions(/*fPrimary*/ true).isEmpty())
            {
            getStorageGraveyard().clear();
            }
        }
    
    protected com.tangosol.util.Binary applyDelta(java.util.Map mapBackup, com.tangosol.util.Binary binKey, com.tangosol.util.Binary binDelta)
        {
        // Note: we use a lazy old value lookup to avoid unnecessary read operations
        //       on the backup map which may be costly
        PartitionedCache.LazyLookup lazyLookup = getLazyLookup(mapBackup, binKey);
        try
            {
            return getBackupDeltaCompressor().applyDelta(lazyLookup, binDelta).toBinary();
            }
        catch (RuntimeException e)
            {
            // soft assertion
            _trace("Failed to apply delta: partition=" + getKeyPartition(binKey) +
                   "; key=" + binKey + "; old=" + lazyLookup.toBinary() +
                   "; new=" + binDelta + "; " + getStackTrace(e), 1);
        
            doBackupRemove(mapBackup, binKey);
            return null;
            }
        finally
            {
            lazyLookup.reset();
            }
        }
    
    // Declared at the super level
    /**
     * Assign the specified orphaned partition to this member. This can only be
    * called on a service thread.
     */
    protected void assignOrphan(int iPartition)
        {
        if (isActivePersistence())
            {
            PartitionedCache.PartitionControl ctrl = (PartitionedCache.PartitionControl) ensurePartitionControl(iPartition);
            ctrl.preparePersistentExtents();
            }
        
        super.assignOrphan(iPartition);
        }
    
    /**
     * Throw RequestTimeoutException if the current thread has been interrupted.
     */
    public void checkInterrupt()
        {
        // import com.tangosol.net.RequestTimeoutException;
        
        if (Thread.currentThread().isInterrupted())
           {
           throw new RequestTimeoutException("Request processing has been interrupted");
           }
        heartbeat();
        }
    
    // Declared at the super level
    /**
     * Return true iff it is required to lock the partitions before assign
    * orphans.
     */
    public boolean checkLockRequired()
        {
        // import com.tangosol.net.events.partition.TransferEvent$Type as com.tangosol.net.events.partition.TransferEvent.Type;
        
        return super.checkLockRequired() || getEventsHelper().hasServiceInterceptors(com.tangosol.net.events.partition.TransferEvent.Type.ASSIGNED);
        }
    
    /**
     * Check that the cache action represented by the specified RequestMessage
    * is allowed by the currently configured quorum ActionPolicy, or throw an
    * appropriate exception otherwise.
    * 
    * Unlike the $BinaryMap#checkQuorum, we are not allowed to block here;
    * service suspension is handled separately by
    * #onServiceSuspended/#onServiceResumed
     */
    public void checkQuorum(com.tangosol.coherence.component.net.message.RequestMessage msg, boolean fReadOnly)
        {
        // import com.tangosol.net.ActionPolicy;
        // import com.tangosol.net.CacheService$CacheAction as com.tangosol.net.CacheService.CacheAction;
        // import com.tangosol.net.RequestPolicyException;
        
        ActionPolicy policy = getActionPolicy();
        if (!policy.isAllowed(this, fReadOnly ? com.tangosol.net.CacheService.CacheAction.READ : com.tangosol.net.CacheService.CacheAction.WRITE))
            {
            throw new RequestPolicyException(
                    "Cache " + (fReadOnly ? "reads" : "writes") + " are disallowed by " + policy);
            }
        }
    
    /**
     * Remove current and all remaining elements of the specified iterator.
     */
    private void clearIterator(java.util.Iterator iter)
        {
        iter.remove();
        while (iter.hasNext())
            {
            iter.next();
            iter.remove();
            }
        }
    
    // Declared at the super level
    /**
     * Create a new Default dependencies object by copying the supplies
    * dependencies.  Each class or component that uses dependencies implements
    * a Default dependencies class which provides the clone functionality.  
    * The dependency injection design pattern requires every component in the
    * component hierarchy to implement clone, producing their variant of the
    * dependencies interface.
    * 
    * @return the cloned dependencies
     */
    protected com.tangosol.internal.net.service.DefaultServiceDependencies cloneDependencies(com.tangosol.net.ServiceDependencies deps)
        {
        // import com.tangosol.internal.net.service.grid.DefaultPartitionedCacheDependencies;
        // import com.tangosol.internal.net.service.grid.PartitionedCacheDependencies;
        
        return new DefaultPartitionedCacheDependencies((PartitionedCacheDependencies) deps);
        }
    
    /**
     * Collect pending events associated with the supplied partition.  If there
    * are multiple pending events, they are accumulated in a list.
    * 
    * @param iPartition  the partition to collect the pending events for
    * 
    * @return a List of MapEvents or a single MapEvent
     */
    public Object collectPendingEvents(int iPartition)
        {
        // import com.tangosol.util.LongArray;
        // import com.tangosol.util.LongArray$Iterator as com.tangosol.util.LongArray.Iterator;
        // import java.util.Iterator;
        
        Object    oCollected = null;
        LongArray laPending  = getPendingEvents();
        int       lMemberId  = getThisMember().getId();
        
        synchronized (laPending)
            {
            long lOldestSUID = getOldestPendingEventSUID();
            if (lOldestSUID == -1L)
                {
                return null;
                }
            
            for (com.tangosol.util.LongArray.Iterator crawler = laPending.iterator(lOldestSUID); crawler.hasNext(); )
                {
                PartitionedCache.MapEvent event          = (PartitionedCache.MapEvent) crawler.next();
                long      lSUID          = crawler.getIndex();
                int       lEventMemberId = getMemberId(lSUID);
                if (lEventMemberId != lMemberId)
                    {
                    // we have iterated over all the member's events
                    break;
                    }
        
                // collect pending events for the given partition.
                if (event != null && getKeyPartition(event.getKey()) == iPartition)
                    {
                    oCollected = Storage.accumulateMapEvents(oCollected, event);
                    }
                }
            }
        
        return oCollected;
        }
    
    /**
     * Collect results associated with all pending responses related to the
    * supplied partition.  The results are organized into a LongArray indexed
    * by SUIDs and values of Map<binKey, binResult>.
    * 
    * @param iPartition  the partition to collect the result for or null if
    * there are no results
    * 
    * @return a LongArray (keyed by request SUID) of the Map<Binary, Binary>
    * result map
     */
    protected com.tangosol.util.LongArray collectPendingResults(int iPartition)
        {
        // import com.tangosol.util.LongArray;
        // import com.tangosol.util.SparseArray;
        // import java.util.Iterator;
        // import java.util.Map;
        
        LongArray   laCollected = null; // LongArray<SUID, Map<Key, Value>>
        LongArray[] alaPending  = getPendingResultInfo();
        
        for (int i = 0, c = alaPending.length; i < c; ++i)
            {
            LongArray laPending = alaPending[i];
        
            synchronized (laPending)
                {
                // check if there is anything in the PendingResultInfo array
                for (Iterator iter = laPending.iterator(); iter.hasNext(); )
                    {
                    PartitionedCache.ResultInfo info      = (PartitionedCache.ResultInfo) iter.next();
                    Map         mapResult = info.extractResults(iPartition);
                    if (mapResult != null)
                        {
                        if (laCollected == null)
                            {
                            laCollected = new SparseArray();
                            }
        
                        laCollected.set(info.getSUID(), mapResult);
                        }
                    }
                }
            }
        
        return laCollected;
        }
    
    /**
     * Add all unprocessed keys to the (optionally) specified collection.
     */
    protected java.util.Collection collectResultOnException(java.util.Collection colResult, Object[] aoStatus, Object[] aoKey, int iFrom, int iTo, Throwable e)
        {
        // import com.tangosol.util.SafeLinkedList;
        
        if (colResult == null)
            {
            colResult = new SafeLinkedList();
            }
        
        // Note: status is set to null if the processAll() threw an exception.
        // See Storage.invokeAll()
        for (int i = iFrom; i < iTo; i++)
            {
            if (aoStatus == null || ((Storage.EntryStatus) aoStatus[i]) == null)
                {
                colResult.add(aoKey[i]);
                }
            }
        return colResult;
        }
    
    /**
     * Return a Map<String, $Storage> keyed by the cache names.
     */
    public java.util.Map collectValidStorages()
        {
        // import java.util.HashMap;
        // import java.util.Iterator;
        // import java.util.Map;
        
        Map mapStorage = new HashMap();
        for (Iterator iterStore = getStorageArray().iterator(); iterStore.hasNext(); )
            {
            Storage storage = (Storage) iterStore.next();
            if (storage.isValid())
                {
                // populate a map of valid storage instances allowing lazy conversion
                mapStorage.put(storage.getCacheName(), storage);
                }
            }
        
        return mapStorage;
        }
    
    // From interface: com.tangosol.net.CacheService
    // From interface: com.tangosol.net.DistributedCacheService
    // Declared at the super level
    /**
     * Configure the component by transforming XML into a Dependencies object
    * and then injecting that Dependencies object into the component.
     */
    public synchronized void configure(com.tangosol.run.xml.XmlElement xml)
        {
        // import com.tangosol.internal.net.service.grid.DefaultPartitionedCacheDependencies;
        // import com.tangosol.internal.net.service.grid.LegacyXmlPartitionedCacheHelper as com.tangosol.internal.net.service.grid.LegacyXmlPartitionedCacheHelper;
        
        setDependencies(com.tangosol.internal.net.service.grid.LegacyXmlPartitionedCacheHelper.fromXml(xml,
            new DefaultPartitionedCacheDependencies(), getOperationalContext(),
            getContextClassLoader()));
        
        setServiceConfig(xml);
        }
    
    /**
     * Return an XmlElement that holds cache info; specifically the cache name
    * and id.
     */
    public com.tangosol.run.xml.XmlElement createCacheInfo(String sCacheName, long lCacheId)
        {
        // import com.tangosol.run.xml.SimpleElement;
        // import com.tangosol.run.xml.XmlElement;
        
        if (lCacheId == 0L)
            {
            lCacheId = generateCacheId();
            }
        
        XmlElement xmlCacheInfo = new SimpleElement("cache-info");
        xmlCacheInfo.addAttribute("id").setLong(lCacheId);
        xmlCacheInfo.addAttribute("name").setString(sCacheName);
        
        return xmlCacheInfo;
        }
    
    // Declared at the super level
    /**
     * Create a ResolvableParameterList with the service level parameters (e.g.
    * "service-name", "class-loader")
     */
    protected com.tangosol.coherence.config.ResolvableParameterList createResolver()
        {
        // import com.tangosol.coherence.config.ResolvableParameterList;
        // import com.tangosol.config.expression.Parameter;
        
        ResolvableParameterList resolver = super.createResolver();
        
        resolver.add(new Parameter("manager-context", getBackingMapManager().getContext()));
        return resolver;
        }
    
    /**
     * Create an return a list of "post-welcome" requests (e.g. index and
    * listeners) that need to be sent to the specified joining member for it to
    * process after being welcomed and before accepting clients.   (see
    * $MemberWelcomeRequest$Poll.onCompletion)
     */
    public java.util.List createWelcomeRequests(com.tangosol.coherence.component.net.Member member)
        {
        // import Component.Net.Member;
        // import com.tangosol.util.Filter;
        // import com.tangosol.util.MapListenerSupport as com.tangosol.util.MapListenerSupport;
        // import com.tangosol.util.MapTrigger;
        // import com.tangosol.util.ValueExtractor as com.tangosol.util.ValueExtractor;
        // import java.util.Comparator;
        // import java.util.Iterator;
        // import java.util.LinkedList;
        // import java.util.List;
        // import java.util.Map;
        // import java.util.Map$Entry as java.util.Map.Entry;
        // import java.util.Set;
        
        List listRequests = new LinkedList();
        if (isAcceptingClients())
            {
            if (!isOwnershipDisabled(member))
                {
                // addListener
                Member   memberThis  = getThisMember();
                int      nMemberThis = memberThis.getId();
                Object[] aMap        = getReferencesBinaryMap().values().toArray();
                for (int i = 0, c = aMap.length; i < c; i++)
                    {
                    BinaryMap mapBinary = (BinaryMap) aMap[i];
        
                    // see $BinaryMap#addMapListener
                    com.tangosol.util.MapListenerSupport support = mapBinary.getListenerSupport();
                    synchronized (support)
                        {
                        if (support.isEmpty())
                            {
                            continue;
                            }
        
                        // we only need to deal with global filters; key based
                        // filters will get re-distributed as a part of distribution process
                        for (Iterator iter = support.getFilterSet().iterator(); iter.hasNext();)
                            {
                            Filter filter = (Filter) iter.next();
        
                            PartitionedCache.ListenerRequest msg =
                                (PartitionedCache.ListenerRequest) instantiateMessage("ListenerRequest");
                            msg.setCacheId(mapBinary.getCacheId());
                            msg.setAdd(true);
                            msg.setFilter(filter);
                            msg.setFilterId(mapBinary.getFilterId(filter));
                            msg.setLite(!support.containsStandardListeners(filter));
                            msg.setMemberId(nMemberThis);
        
                            listRequests.add(msg);
                            }
                        }
                    }
        
                // addIndex, addTrigger
                if (getThisMember() == getOwnershipSenior())
                    {
                    for (Iterator iterStore = getStorageArray().iterator(); iterStore.hasNext();)
                        {
                        Storage storage = (Storage) iterStore.next();
        
                        // PartitionedCache.IndexRequest(s) are processed on daemon threads after acquiring
                        // the LOCK_ALL; to ensure synchronization all we need is a psuedo-lock
                        lockSynthetic(storage);
                        try
                            {
                            // COH-3966: recreate indices from the source extractor,
                            //           not the created indices (see IndexAwareExtractor)
                            Map mapExtractor = storage.getIndexExtractorMap();
                            if (!mapExtractor.isEmpty())
                                {
                                for (Iterator iter = mapExtractor.entrySet().iterator();
                                     iter.hasNext();)
                                    {
                                    java.util.Map.Entry      entry      = (java.util.Map.Entry) iter.next();
                                    com.tangosol.util.ValueExtractor  extractor  = (com.tangosol.util.ValueExtractor) entry.getKey();
                                    Comparator comparator = (Comparator) entry.getValue();
        
                                    PartitionedCache.IndexRequest msg =
                                        (PartitionedCache.IndexRequest) instantiateMessage("IndexRequest");
                                    msg.setCacheId(storage.getCacheId());
                                    msg.setAdd(true);
                                    msg.setExtractor(extractor);
                                    msg.setOrdered(comparator != null);
                                    msg.setComparator(comparator);
        
                                    listRequests.add(msg);
                                    }
                                }
        
                            Set setTriggers = storage.getTriggerSet();
                            if (setTriggers != null)
                                {
                                for (Iterator iter = setTriggers.iterator(); iter.hasNext();)
                                    {
                                    MapTrigger trigger = (MapTrigger) iter.next();
        
                                    PartitionedCache.ListenerRequest msg =
                                        (PartitionedCache.ListenerRequest) instantiateMessage("ListenerRequest");
                                    msg.setCacheId(storage.getCacheId());
                                    msg.setAdd(true);
                                    msg.setTrigger(trigger);
        
                                    listRequests.add(msg);
                                    }
                                }
                            }
                        finally
                            {
                            unlockSynthetic(storage);
                            }
                        }
                    }
                }
            }
        
        return listRequests;
        }
    
    /**
     * Defer a backup-all operation on the specified cache.  Called on the
    * service thread only.
    * 
    * @param ctx  the request context
    * @param iPartition  the partition that the corresponding backup request
    * represents
    * @param lCacheId  the id of the cache to perform a backup update on
    * @param mapEntries  the map (Map<Binary, Binary) of entries to update
    * @param mapEvents  the map of event holders
    * @param memberOwner  the primary owner (may be null)
     */
    protected void deferBackup(com.tangosol.coherence.component.net.RequestContext ctx, int iPartition, long lCacheId, java.util.Map mapEntries, java.util.Map mapEvents, com.tangosol.coherence.component.net.Member memberOwner)
        {
        // TODO: implement the deferral logic
        _trace("Deferring the backup request for partition " + iPartition + ", cache id=" + lCacheId, 3);
        }
    
    /**
     * Defer a backup-all operation on the specified cache.  Called on the
    * service thread only.
    * 
    * @param ctx  the request context
    * @param parts  the partitions that the corresponding backup request
    * represents
    * @param lCacheId  the id of the cache to perform a backup update on
    * @param mapEntries  the map (Map<Binary, Binary) of entries to update
    * @param mapEvents  the map of event holders
    * @param memberOwner  the primary owner (may be null)
     */
    protected void deferBackup(com.tangosol.coherence.component.net.RequestContext ctx, com.tangosol.net.partition.PartitionSet parts, long lCacheId, java.util.Map mapEntries, java.util.Map mapEvents, com.tangosol.coherence.component.net.Member memberOwner)
        {
        // TODO: implement the deferral logic
        _trace("Deferring the backup request for " + parts + ", cache id=" + lCacheId, 3);
        }
    
    /**
     * Serialize the specified message.
    * 
    * @return the message size
     */
    protected com.oracle.coherence.persistence.PersistentStore deserializeStore(String sGUID, com.tangosol.io.ReadBuffer bufStore)
        {
        // import com.oracle.coherence.persistence.PersistenceManager;
        // import com.tangosol.util.BinaryWriteBuffer;
        // import java.io.IOException;
        
        // TODO: hraja - this should be on PartitionedCache.PersistenceControl
        
        PartitionedCache.PersistenceControl ctrlPersistence = (PartitionedCache.PersistenceControl) getPersistenceControl();
        PersistenceManager  mgrEvents       = ctrlPersistence.getEventsManager();
        
        if (mgrEvents != null)
            {
            try
                {
                mgrEvents.read(sGUID, bufStore.getBufferInput());
                }
            catch (IOException e)
                {
                _trace("Unable to read previous MapEvents store from old primary owner of partition.", 1);
                _trace(e);
                }
            
            }
        return null;
        }
    
    // From interface: com.tangosol.net.CacheService
    // From interface: com.tangosol.net.DistributedCacheService
    public void destroyCache(com.tangosol.net.NamedCache cache)
        {
        // import java.util.Map;
        
        if (cache.getCacheService() != this)
            {
            throw new IllegalArgumentException(
                "The cache to destroy is not owned by this service: " + this);
            }
        
        releaseCache(cache);
        
        String     sName     = cache.getCacheName();
        BinaryMap mapBinary = (BinaryMap) getReferencesBinaryMap().get(sName);
        
        if (mapBinary != null)
            {
            // only the Service senior is allowed to create or destroy the cache
            StorageIdRequest msg = (StorageIdRequest)
                instantiateMessage("StorageIdRequest");
            
            msg.addToMember(getServiceOldestMember());
            msg.setCacheNames(new String[] {sName});
            msg.setCacheAction(StorageIdRequest.CACHE_DESTROY);
        
            poll(msg);
        
            // COH-11578: there is a chance that a configMap update reflecting
            // the "destroy" command has not reached this node yet;
            // we need to prevent clients to use the same BinaryMap again
        
            mapBinary.setConfirmed(false);
            }
        }
    
    /**
     * Ensure that the persistent store will consider the specified storage
    * destroyed.
    * This method is called on the service thread only.
     */
    public void destroyPersistentExtent(Storage storage)
        {
        // import com.tangosol.net.partition.PartitionSet;
        // import com.tangosol.util.LongArray;
        
        if (getPersistenceManager() != null && storage != null)
            {
            LongArray    laCaches = getPersistentCacheIds();
            long         lCacheId = storage.getCacheId();
            PartitionSet parts    = calculatePartitionSet(getThisMember(), 0);
        
            laCaches.remove(lCacheId);
        
            for (int iPart = parts.next(0); iPart >= 0; iPart = parts.next(iPart + 1))
                {
                getPartitionControl(iPart).deletePersistentExtent(lCacheId, laCaches);
                }
            }
        }
    
    /**
     * Dispatch post-commit UEM events.
     */
    public void dispatchServerEvents(java.util.Set setEntryInfo, java.util.Set setEntryInfoOOB)
        {
        // import com.tangosol.net.internal.EntryInfo;
        // import java.util.Iterator;
        // import java.util.HashSet;
        // import java.util.Set;
        
        PartitionedCache.EventsHelper evtHelper = getEventsHelper();
        if (setEntryInfoOOB != null)
            {
            Set setEntries = new HashSet(setEntryInfoOOB.size());
            for (Iterator iter = setEntryInfoOOB.iterator(); iter.hasNext(); )
                {
                EntryInfo info = (EntryInfo) iter.next();
        
                evtHelper.onEntryChanged(info, null);
        
                setEntries.add(info.getBinaryEntry());
                }
        
            evtHelper.onOutOfBandChanges(setEntries);
            }
        
        if (setEntryInfo != null)
            {
            Set setEntries = new HashSet(setEntryInfo.size());
            for (Iterator iter = setEntryInfo.iterator(); iter.hasNext(); )
                {
                EntryInfo info = (EntryInfo) iter.next();
        
                evtHelper.onEntryChanged(info, null);
        
                setEntries.add(info.getBinaryEntry());
                }
        
            evtHelper.onTransactionPostCommit(setEntries);
            }
        }
    
    /**
     * Perform a backup operation on the specified partition slice.  Called on
    * the service thread only.
    * 
    * @param ctx                       the request context
    * @param partsSkip           partitions to skip processing (couold be null)
    * @param lCacheId             the id of the cache to perform a backup
    * update on
    * @param mapEntries        the map (Map<Binary, Binary) of entries to
    * update
    * @param mapEvents         the map of event holders
    * @param mapResults        the map of results to decompress
    * @param memberOwner  the primary owner (may be null)
     */
    protected void doBackupAll(com.tangosol.coherence.component.net.RequestContext ctx, com.tangosol.net.partition.PartitionSet partsSkip, long lCacheId, java.util.Map mapEntries, java.util.Map mapEvents, java.util.Map mapResults, com.tangosol.coherence.component.net.Member memberOwner)
        {
        // import com.tangosol.util.Base;
        // import com.tangosol.util.Binary;
        // import com.tangosol.util.ExternalizableHelper as com.tangosol.util.ExternalizableHelper;
        // import java.util.HashMap;
        // import java.util.HashSet;
        // import java.util.Iterator;
        // import java.util.Map;
        // import java.util.Map$Entry as java.util.Map.Entry;
        // import java.util.Set;

        Storage storage = getKnownStorage(lCacheId);
        _assert(storage != null);
        
        Map     mapBackup     = storage.getBackupMap();
        boolean fPreferPutAll = storage.isPreferPutAllBackup();
        Map     mapUpdate     = null;
        Set     setRemove     = null;
        
        // Service thread; unconditionally follow requests by the primary owner
        for (Iterator iter = mapEntries.entrySet().iterator(); iter.hasNext();)
            {
            java.util.Map.Entry   entry       = (java.util.Map.Entry) iter.next();
            Binary  binKey      = (Binary) entry.getKey();
            Binary  binValue    = (Binary) entry.getValue();
            Binary  binValueOld = null;
            Object  oEvent      = null;
            boolean fRemove     = Binary.EMPTY.equals(binValue);
            boolean fBlind      = fPreferPutAll;
            int     nPartition  = getKeyPartition(binKey);
        
            if (partsSkip != null && partsSkip.contains(nPartition))
                {
                continue;
                }
        
            if (isBackupOwner(nPartition))
                {
                // intern the binary key
                binKey = storage.getCanonicalKey(binKey);
                if (mapEvents != null)
                    {
                    oEvent = mapEvents.get(binKey);
                    fBlind &= !PartitionedCache.MapEvent.isCompressedOldValue(oEvent);
                    }
        
                if (binValue == null)
                    {
                    // null indicates no-diff (see prepareBackupAllRequest)
                    binValue = binValueOld = (Binary) mapBackup.get(binKey);
                    }
                else if (fRemove)
                    {
                    // BINARY_EXISTS indicates a remove op (see prepareBackupAllRequest)
                    if (fBlind)
                        {
                        if (setRemove == null)
                            {
                            setRemove = new HashSet(mapEntries.size());
                            }
                        setRemove.add(binKey);
                        }
                    else
                        {
                        binValueOld = doBackupRemove(mapBackup, binKey);
                        }
                    }
                else
                    {
                    // a "normal" update
                    binValue = applyDelta(mapBackup, binKey, binValue);
                    if (binValue == null)
                        {
                        // delta application failed; return immediately
                        return;
                        }
        
                    if (fBlind)
                        {
                        if (mapUpdate == null)
                            {
                            mapUpdate = new HashMap(mapEntries.size());
                            }
                        mapUpdate.put(binKey, binValue);
                        }
                    else
                        {
                        binValueOld = doBackupPut(mapBackup, binKey, binValue);
                        }
                    }
        
                if (!fBlind && isBackupPersistence())
                    {
                    // actual persistence is done async
                    persistBackup(nPartition, lCacheId, binKey, binValue, fRemove);
                    }
        
                if (mapResults != null)
                    {
                    // "decompress" the results
                    Binary binResult = (Binary) mapResults.get(binKey);
                    if (binResult != null)
                        {
                        mapResults.put(binKey, Storage.decompressResult(binResult, binValueOld, binValue));
                        }
                    }

                registerEvent(PartitionedCache.MapEvent.decompressEventHolder(
                    oEvent, lCacheId, binKey, binValueOld, binValue), memberOwner);
                }
            else // !isBackupOwner(binKey)
                {
                // we received a backup request for a key that we are not the backup owner
                // for.  This could happen as a result of updates during a backup transfer
                // arriving on the old backup (this member) after the backup was released.
                }
            }
        
        if (mapUpdate != null)
            {
            doBackupPutAll(mapBackup, mapUpdate);
            if (isBackupPersistence())
                {
                persistBackup(lCacheId, mapUpdate);
                }
            }
        if (setRemove != null)
            {
            doBackupRemoveAll(mapBackup, setRemove);
            if (isBackupPersistence())
                {
                persistBackup(lCacheId, setRemove);
                }
            }
        }
    
    /**
     * Do a put operation on the specified backup map.  Called on the service
    * thread only.
    * 
    * @param mapBackup  the backup storage map
    * @param binKey          the binary key to update
    * @param binValue        the binary value to update
    * 
    * @return the previous value associated with binKey, or null
     */
    protected com.tangosol.util.Binary doBackupPut(java.util.Map mapBackup, com.tangosol.util.Binary binKey, com.tangosol.util.Binary binValue)
        {
        // import com.tangosol.util.Binary;
        
        try
            {
            return (Binary) mapBackup.put(binKey, binValue);
            }
        catch (IllegalStateException e)
            {
            // COH-2718 - be tolerant of backup operations on un-owned partitions;
            //            swallow the exception and log an innocuous msg
            //
            // COH-2862 - Since Coherence 3.6, this should not be possible
            _trace("Deferring backup update operation for partition " + getKeyPartition(binKey) +
                   " during partition transfer", 2);
            }
        return null;
        }
    
    /**
     * Do a putAll operation on the specified backup map.  Called on the service
    * thread only.
    * 
    * @param mapBackup  the backup storage map
    * @param mapUpdate   the map of updates to make to the backup map
     */
    protected void doBackupPutAll(java.util.Map mapBackup, java.util.Map mapUpdate)
        {
        // import com.tangosol.net.partition.PartitionSet;
        // import com.tangosol.util.Binary;
        // import java.util.Iterator;
        // import java.util.Map$Entry as java.util.Map.Entry;
        
        try
            {
            mapBackup.putAll(mapUpdate);
            }
        catch (IllegalStateException e)
            {
            // COH-2718 - be tolerant of backup operations on un-owned partitions;
            //            switch to an iterator to finish the update
            //
            // COH-2862 - Since Coherence 3.6, this should not be possible
            PartitionSet parts = new PartitionSet(getPartitionCount());
            for (Iterator iter = mapUpdate.entrySet().iterator(); iter.hasNext(); )
                {
                java.util.Map.Entry  entry      = (java.util.Map.Entry) iter.next();
                Binary binKey     = (Binary) entry.getKey();
                int    nPartition = getKeyPartition(binKey);
        
                if (!parts.contains(nPartition))
                    {
                    try
                        {
                        mapBackup.put(binKey, entry.getValue());
                        }
                    catch (IllegalStateException e2)
                        {
                        parts.add(nPartition);
                        }
                    }
                }
        
            _trace("Deferred backup update operation for partitions " + parts
                 + " during partition transfer", 2);
            }
        }
    
    /**
     * Do a remove operation on the specified backup map.  Called on the service
    * thread only.
    * 
    * @param mapBackup  the backup storage map
    * @param binKey          the binary key to remove
    * 
    * @return the previous value associated with binKey, or null
     */
    protected com.tangosol.util.Binary doBackupRemove(java.util.Map mapBackup, com.tangosol.util.Binary binKey)
        {
        // import com.tangosol.util.Binary;
        
        try
            {
            return (Binary) mapBackup.remove(binKey);
            }
        catch (IllegalStateException e)
            {
            // COH-2718 - be tolerant of backup operations on un-owned partitions;
            //            swallow the exception and log an innocuous msg
            //
            // COH-2862 - Since Coherence 3.6, this should not be possible
            _trace("Deferring backup remove operation for partition " + getKeyPartition(binKey) +
                   " during partition transfer", 2);
            }
        return null;
        }
    
    /**
     * Do a removeAll operation on the specified backup map.  Called on the
    * service thread only.
    * 
    * @param mapBackup  the backup storage map
    * @param setKeys        the set of keys to remove from the backup map
     */
    protected void doBackupRemoveAll(java.util.Map mapBackup, java.util.Set setKeys)
        {
        // import com.tangosol.net.partition.PartitionSet;
        // import com.tangosol.util.Binary;
        // import java.util.Iterator;
        
        try
            {
            mapBackup.keySet().removeAll(setKeys);
            }
        catch (IllegalStateException e)
            {
            // COH-2718 - be tolerant of backup operations on un-owned partitions;
            //            switch to an iterator to finish the update
            //
            // COH-2862 - Since Coherence 3.6, this should not be possible
            PartitionSet parts = new PartitionSet(getPartitionCount());
            for (Iterator iter = setKeys.iterator(); iter.hasNext(); )
                {
                Binary binKey     = (Binary) iter.next();
                int    nPartition = getKeyPartition(binKey);
        
                if (!parts.contains(nPartition))
                    {
                    try
                        {
                        mapBackup.remove(binKey);
                        }
                    catch (IllegalStateException e2)
                        {
                        parts.add(nPartition);
                        }
                    }
                }
        
            _trace("Deferred backup remove operation for partitions " + parts
                 + " during partition transfer", 2);
            }
        }
    
    /**
     * Ensures that a $BinaryMap is created for the given cache name and id.
     */
    public BinaryMap ensureBinaryMap(String sCacheName, long lCacheId)
        {
        // import java.util.Map;
        
        Map        mapRefsBinary = getReferencesBinaryMap();
        BinaryMap mapBinary     = (BinaryMap) mapRefsBinary.get(sCacheName);
        
        if (mapBinary == null)
            {
            mapBinary = (BinaryMap) mapRefsBinary.computeIfAbsent(sCacheName,
                k -> instantiateBinaryMap(sCacheName, lCacheId));
        
            getBinaryMapArray().set(lCacheId, mapBinary);
            }
        
        return mapBinary;
        }
    
    protected BinaryMap ensureCache(String sName)
        {
        // import java.util.Map;
        
        if (sName == null || sName.length() == 0)
            {
            sName = "Default";
            }
        
        // check if the necessary Binary Map already exists
        Map        mapRefsBinary = getReferencesBinaryMap();
        BinaryMap mapBinary;
        
        do
            {
            mapBinary = (BinaryMap) mapRefsBinary.get(sName);
            if (mapBinary == null)
                {
                StorageIdRequest msg = (StorageIdRequest)
                    instantiateMessage("StorageIdRequest");
                msg.addToMember(getThisMember());
                msg.setCacheNames(new String[] {sName});
                msg.setCacheAction(StorageIdRequest.CACHE_CREATE);
                msg.setCreateBinaryMap(true);
        
                poll(msg);
        
                mapBinary = (BinaryMap) mapRefsBinary.get(sName);
                }
        
            // COH-4544: ensure that prior to returning control to the client,
            //           that all storage owners which could service requests
            //           have heard of the (possibly) new cache.
            //
            // Note: perform the confirmation unconditionally to address the
            //       possibility that 2 clients/threads concurrently ensureCache
            //       (allowing the 2nd client/thread to see the BinaryMap instance
            //       before all members have heard)
            }
        while (!mapBinary.confirmCache());
        
        return mapBinary;
        }
    
    // From interface: com.tangosol.net.CacheService
    // From interface: com.tangosol.net.DistributedCacheService
    public com.tangosol.net.NamedCache ensureCache(String sName, ClassLoader loader)
        {
        // import com.tangosol.net.NamedCache;
        // import com.tangosol.net.internal.ScopedCacheReferenceStore as com.tangosol.net.internal.ScopedCacheReferenceStore;
        // import java.util.Map;
        
        if (!isRunning())
            {
            throw new IllegalStateException("Service is not running: " + this);
            }
        
        if (sName == null || sName.length() == 0)
            {
            sName = "Default";
            }
        
        if (loader == null)
            {
            loader = getContextClassLoader();
            _assert(loader != null, "ContextClassLoader is missing");
            }
        
        // the implementation is optimized for caches that already
        // exist and already have the requested class-loader view
        ViewMap   mapCache = null;
        com.tangosol.net.internal.ScopedCacheReferenceStore store    = getScopedCacheStore();
        
        mapCache = (ViewMap) store.getCache(sName, loader);
        if (mapCache != null)
            {
            return mapCache;
            }
        
        // otherwise, the binary map needs to be obtained, a view
        // for the class-loader created, and that registered
        
        // get the binary map
        BinaryMap mapBinary = ensureCache(sName);
        
        // create the view (if it doesn't exist already) and store
        // the view ref
        synchronized (this)
            {
            mapCache = (ViewMap) store.getCache(sName, loader);
            if (mapCache != null)
                {
                // since we first checked, someone created the cache
                return mapCache;
                }
        
            // create the classloader view of the binary map
            mapCache = (ViewMap) _newChild("ViewMap");
            mapCache.setBinaryMap(mapBinary);
            mapCache.setClassLoader(loader);
        
            // store the view
            store.putCache(mapCache, loader);
            }
        
        return mapCache;
        }
    
    /**
     * Ensure the index is ready to be used for the specified partition.
     */
    public void ensureIndexReady(int nPartition)
        {
        // import com.oracle.coherence.common.base.Blocking;
        // import com.tangosol.util.Base;
        
        long cMax           = 1L;
        long cSoftTimeout   = (long) (getDefaultGuardTimeout() * getDefaultGuardRecovery());
        long ldtStartTime   = Base.getSafeTimeMillis();
        long ldtSoftTimeout = ldtStartTime + cSoftTimeout;
        while (getIndexPendingPartitions().contains(nPartition))
            {
            try
                {
                Object oMonitor = Base.getCommonMonitor(System.identityHashCode(this) + nPartition);
                synchronized (oMonitor)
                    {
                    Blocking.wait(oMonitor, 100L);
                    }
        
                long ldtNow = Base.getSafeTimeMillis();
                     cMax   = Math.max(cMax, ldtNow - ldtStartTime);
        
                if (ldtNow + (cMax << 4) > ldtSoftTimeout)
                    {
                    heartbeat();
                    ldtSoftTimeout = ldtNow + cSoftTimeout;
                    ldtStartTime   = ldtNow;
                    cMax           = 1L;
                    }
                }
            catch (InterruptedException e)
                {
                Thread.currentThread().interrupt();
                throw Base.ensureRuntimeException(e);
                }
            }
        }
    
    /**
     * Ensure an active thread local InvocationContext.
     */
    public PartitionedCache.InvocationContext ensureInvocationContext()
        {
        ThreadLocal        tloCtx = getTLOContext();
        PartitionedCache.InvocationContext ctx    = (PartitionedCache.InvocationContext) tloCtx.get();
        if (ctx == null)
            {
            tloCtx.set(ctx = instantiateInvocationContext());
            }
        
        ctx.setActive(true);
        return ctx;
        }
    
    /**
     * Ensure an active thread local InvocationContext with the caller's pinned
    * single partition.
    * 
    * @param nPartition  the externally pinned single partition
    * 
    * @return the InvocationContext
     */
    public PartitionedCache.InvocationContext ensureInvocationContext(int nPartition)
        {
        PartitionedCache.InvocationContext ctx = ensureInvocationContext();
        ctx.getPrePinnedPartitions().add(nPartition);
        return ctx;
        }
    
    /**
     * Ensure an active thread local InvocationContext with the caller's pinned
    * partition set.
    * 
    * @param partMask  the externally pinned partition set
    * 
    * @return the InvocationContext
     */
    public PartitionedCache.InvocationContext ensureInvocationContext(com.tangosol.net.partition.PartitionSet partMask)
        {
        PartitionedCache.InvocationContext ctx = ensureInvocationContext();
        ctx.getPrePinnedPartitions().add(partMask);
        return ctx;
        }
    
    /**
     * Ensure storages for already known NamedCaches. Called on the service
    * thread only at the very end of the startup sequence.
     */
    protected void ensureKnownStorage()
        {
        // import com.tangosol.run.xml.XmlElement;
        // import java.util.Enumeration;
        // import java.util.Map;
        
        _assert(isOwnershipEnabled() || getServiceState() >= SERVICE_STOPPING);
        
        Map mapConfig = getServiceConfigMap();
        for (Enumeration e = getCacheNames(); e.hasMoreElements();)
            {
            String     sCacheName   = (String) e.nextElement();
            XmlElement xmlCacheInfo = (XmlElement) mapConfig.get(sCacheName);
            long       lCacheId     = xmlCacheInfo.getSafeAttribute("id").getLong();
        
            _assert(sCacheName.equals(xmlCacheInfo.getSafeAttribute("name").getString()));
        
            ensureStorageInternal(sCacheName, lCacheId, /*fInit*/ false);
            }
        }
    
    /**
     * Ensure that all known (and valid) storages are known to the persistent
    * store, and reflected in the service-managed metadata-extent.
    * This method is called from the service thread only.
     */
    protected void ensurePersistentExtents(com.oracle.coherence.persistence.PersistentStore store)
        {
        ensurePersistentExtents(store, false);
        }
    
    /**
     * Ensure that all known (and valid) storages are known to the persistent
    * store, and reflected in the service-managed metadata-extent.
    * This method is called from the service thread only.
     */
    protected void ensurePersistentExtents(com.oracle.coherence.persistence.PersistentStore store, boolean fSnapshot)
        {
        // import com.tangosol.persistence.CachePersistenceHelper as com.tangosol.persistence.CachePersistenceHelper;
        // import com.tangosol.util.LongArray;
        // import com.tangosol.util.LongArray$Iterator as com.tangosol.util.LongArray.Iterator;
        
        LongArray laCaches = getPersistentCacheIds(fSnapshot);
        
        // need to "ensure" all of the cache-ids
        for (com.tangosol.util.LongArray.Iterator iter = laCaches.iterator(); iter.hasNext(); )
            {
            iter.next();
            long lCacheId = iter.getIndex();
        
            store.ensureExtent(lCacheId);
            }
        
        com.tangosol.persistence.CachePersistenceHelper.storeCacheNames(store, laCaches);
        }
    
    /**
     * Return the $ResultInfo object associated with the specified context,
    * creating one if none exists.
    * 
    * @param context    the RequestContext to ensure a $ResultInfo for
     */
    protected PartitionedCache.ResultInfo ensureResultInfo(com.tangosol.coherence.component.net.RequestContext context)
        {
        return ensureResultInfo(context, /*fOnlyIfPending*/ false);
        }
    
    /**
     * Return the $ResultInfo object associated with the specified context,
    * creating one if none exists.
    * If fOnlyIfPresent is specified, a $ResultInfo is create only if the SUID
    * is pending (registered in PendingRequestInfo).
    * 
    * @param context                the RequestContext to ensure a $ResultInfo
    * for
    * @param fOnlyIfPending   true iff a $ResultInfo should only be created for
    * pending SUIDs
     */
    protected PartitionedCache.ResultInfo ensureResultInfo(com.tangosol.coherence.component.net.RequestContext context, boolean fOnlyIfPending)
        {
        // import com.tangosol.util.LongArray;
        
        PartitionedCache.ResultInfo resultInfo = getResultInfo(context);
        if (resultInfo == null && !fOnlyIfPending)
            {
            // there is no existing result info for this request;
            // create and associate a PartitionedCache.ResultInfo with the SUID.
        
            long      lSUID  = context.getRequestSUID();
            LongArray laSUID = getPendingResultInfo(lSUID);
        
            // PartitionedCache.ResultInfo objects are created quite frequently, so we manually
            // construct and link it instead of using the _newChild() approach
            _linkChild(resultInfo = new PartitionedCache.ResultInfo());
            resultInfo.ensurePartitions();
            resultInfo.setSUID(lSUID);
        
            synchronized (laSUID)
                {
                PartitionedCache.ResultInfo infoPrev = (PartitionedCache.ResultInfo) laSUID.set(lSUID, resultInfo);
                if (infoPrev != null)
                    {
                    laSUID.set(lSUID, infoPrev); // TODO: evaluate adding LA.setIfAbsent()
                    resultInfo = infoPrev;
                    }
                }
            }
        
        return resultInfo;
        }
    
    /**
     * Ensure the storage for the specified cache id. Called on the service
    * thread or a transport thread.
    * 
    * @see #getStorage(long)
     */
    public Storage ensureStorage(long lCacheId)
        {
        // import com.tangosol.util.LongArray;
        
        _assert(isOwnershipEnabled());
        
        LongArray aStorage = getStorageArray();
        Storage  storage  = (Storage) aStorage.get(lCacheId);
        
        if (storage == null)
            {
            synchronized (aStorage)
                {
                storage = (Storage) aStorage.get(lCacheId);
        
                if (storage == null)
                    {
                    storage = (Storage) _newChild("Storage");
                    storage.setCacheId(lCacheId);
        
                    aStorage.set(lCacheId, storage);
                    }
                }
            }
        return storage;
        }
    
    /**
     * Ensure the storage map for the specified cache id iff fCheckGraveyard is
    * false or the cache id is not in the storage graveyard.
    * Called on the service thread only.
    * 
    * @param lCacheId   the cache id
    * @param fCheckGraveyard  true if the StorageGraveyard should; if the
    * lCacheId is in the graveyard null is returned
    * 
    * @see #getStorage(long)
     */
    public Storage ensureStorage(long lCacheId, boolean fCheckGraveyard)
        {
        return fCheckGraveyard && getStorageGraveyard().containsKey(Long.valueOf(lCacheId))
                    ? null : ensureStorage(lCacheId);
        }
    
    /**
     * Ensure that a storage with the specified name is created.
    * 
    * This method may block, so it must not be called on the service thread.
     */
    public void ensureStorage(com.tangosol.util.LongArray laCaches)
        {
        // import com.tangosol.util.LongArray$Iterator as com.tangosol.util.LongArray.Iterator;
        
        String[] asCacheNames = new String[laCaches.getSize()];
        long[]   alCacheIds   = new long[asCacheNames.length];
        
        int i = 0;
        for (com.tangosol.util.LongArray.Iterator crawler = laCaches.iterator(); crawler.hasNext(); )
            {
            String sCache = (String) crawler.next();
        
            // if Storage has not been created commence the cache creation
            // (StorageIdRequest) protocol
        
            if (sCache == null)
                {
                _trace("Unexpected null cache name in caches to create: " + laCaches, 2);
                }
            else if (getStorage(sCache) == null)
                {
                asCacheNames[i] = sCache;
                alCacheIds[i++] = crawler.getIndex();
                }
            }
        
        if (i > 0)
            {
            // poll the service thread to ensure the cache (possibly requiring a
            // poll to the senior member to create the cache-id)
            //
            // Note: unlike the #ensureCache operation, we do not need to ensure
            //       that all storage members have created the cache before proceeding
        
            StorageIdRequest msg = (StorageIdRequest)
                instantiateMessage("StorageIdRequest");
            msg.addToMember(getThisMember());
            msg.setCacheNames(asCacheNames);
            msg.setCacheIds(alCacheIds);
            msg.setCacheAction(StorageIdRequest.CACHE_CREATE);
            msg.setCreateBinaryMap(false);
            msg.compressCacheNames();
        
            poll(msg);
            }
        }
    
    /**
     * Either ensure $Storage is created or a $BinaryMap and dispatch relevant
    * events.
    * 
    * @param sName  cache name
    * @param lCacheId  the id of the cache
    * @param fInit  whether this Storage is being created due to initialization
    * and therefore must override any existing $Storage instances with the same
    * name
     */
    public void ensureStorageInternal(String sName, long lCacheId, boolean fInit)
        {
        // import com.tangosol.net.events.internal.StorageDispatcher as com.tangosol.net.events.internal.StorageDispatcher;
        // import com.tangosol.net.events.partition.cache.CacheLifecycleEvent$Type as com.tangosol.net.events.partition.cache.CacheLifecycleEvent.Type;
        
        PartitionedCache.EventsHelper events = getEventsHelper();
        com.tangosol.net.events.internal.StorageDispatcher    dispatcher;
        if (isOwnershipEnabled())
            {
            Storage storage = fInit
                ? ensureUniqueStorage(lCacheId, sName)
                : ensureStorage(lCacheId);
        
            storage.ensureInitialized(sName, fInit);
        
            dispatcher = storage.getEventDispatcher();
            }
        else
            {
            // create the binary map upfront so that we can reference the dispatcher
            BinaryMap mapBinary = ensureBinaryMap(sName, lCacheId);
        
            events.onCacheConfigured(mapBinary);
        
            dispatcher = mapBinary.getDispatcher();
            }
        
        events.onCacheLifecycle(dispatcher, com.tangosol.net.events.partition.cache.CacheLifecycleEvent.Type.CREATED);
        }
    
    /**
     * Ensure the unique storage for the specified cache id.  Called on the
    * service thread.
    * 
    * @see #getStorage(long)
     */
    public Storage ensureUniqueStorage(long lCacheId, String sName)
        {
        _assert(isOwnershipEnabled());
        
        Storage storage = getStorage(lCacheId);
        if (storage != null)
            {
            return storage;
            }
           
        Storage storageOld = getStorage(sName);
        if (storageOld != null && storageOld.getCacheId() != lCacheId)
            {
            // the storage with the same name but a different cacheId already exist;
            // it must have been created by a partition transfer request that was
            // initiated prior to the cache destruction
            // (which may be possible when the service senior and distribution coordinator
            // are different members);
            // we need to remove the stale storage now
        
            removeStorage(storageOld.getCacheId());
            storageOld.invalidate();
        
            _trace("Removing a stale storage for cache \"" + sName + '"', 1);
            }
        
        return ensureStorage(lCacheId);
        }
    
    /**
     * Ensure the unique storage for the specified cache id.  Called on the
    * service thread.
    * 
    * @see #getStorage(long)
     */
    public Storage ensureUniqueStorage(long lCacheId, String sName, boolean fCheckGraveyard)
        {
        return fCheckGraveyard && getStorageGraveyard().containsKey(Long.valueOf(lCacheId))
                    ? null : ensureUniqueStorage(lCacheId, sName);
        }
    
    /**
     * Estimate serialized byte size of an event.
     */
    public int estimateEventByteSize(com.tangosol.coherence.component.net.message.MapEventMessage msgEvent)
        {
        // import Component.Net.MemberSet;
        // import Component.Net.Message.MapEventMessage as com.tangosol.coherence.component.net.message.MapEventMessage;
        // import com.tangosol.util.Binary;
        // import com.tangosol.util.ExternalizableHelper as com.tangosol.util.ExternalizableHelper;
        
        final int PLONG_SIZE = com.tangosol.util.ExternalizableHelper.PACKED_LONG_SIZE;
        final int PINT_SIZE  = com.tangosol.util.ExternalizableHelper.PACKED_INT_SIZE;
        final int INT_SIZE   = Integer.BYTES;
        final int SHORT_SIZE = Short.BYTES;
        final int BIN_SIZE   = com.tangosol.util.ExternalizableHelper.BINARY_SIZE;
        final int BYTE_SIZE  = Byte.BYTES;
        
        int cb = PLONG_SIZE + PLONG_SIZE + PINT_SIZE; // EventSUID + OldestPendingEventSUID + event-type
        
        // ToMemberSet
        MemberSet set      = msgEvent.ensureToMemberSet();
        int       cMembers = set.size();
        
        cb += SHORT_SIZE; // cMembers
        cb += cMembers == 1
                ? SHORT_SIZE
                : cMembers < 255
                    ? BYTE_SIZE + cMembers * SHORT_SIZE
                    : BYTE_SIZE + set.getBitSetCount() * INT_SIZE;
        
        int nType  = msgEvent.getEventType();
        int nEvent = nType & com.tangosol.coherence.component.net.message.MapEventMessage.EVT_TYPE_MASK;
        
        // INSERT does not need an old value
        if (nEvent != com.tangosol.coherence.component.net.message.MapEventMessage.ENTRY_INSERTED &&
            (nType & (com.tangosol.coherence.component.net.message.MapEventMessage.EVT_OPT_OLD_SKIP | com.tangosol.coherence.component.net.message.MapEventMessage.EVT_OPT_OLD_SWAP)) == 0)
            {
            Binary binOldVal = msgEvent.getOldValue();
        
            cb += binOldVal == null ? BYTE_SIZE : binOldVal.length() + BIN_SIZE;
            }
        
        // DELETE does not need a new value
        if (nEvent != com.tangosol.coherence.component.net.message.MapEventMessage.ENTRY_DELETED &&
            (nType & (com.tangosol.coherence.component.net.message.MapEventMessage.EVT_OPT_NEW_SKIP | com.tangosol.coherence.component.net.message.MapEventMessage.EVT_OPT_NEW_SWAP)) == 0)
            {
            Binary binNewVal = msgEvent.getNewValue();
        
            cb += binNewVal == null ? BYTE_SIZE : binNewVal.length() + BIN_SIZE;
            }
        
        long[] alFilterId = msgEvent.getFilterId();
        int    cFilters   = alFilterId == null ? 0 : alFilterId.length;
        
        cb += SHORT_SIZE + cFilters * PLONG_SIZE + // cFilter (short) + Ids +
              PLONG_SIZE + PINT_SIZE;              // version + partition
        
        return cb;
        }
    
    /**
     * Estimate serialized byte size of an event holder;  could contain more
    * than one event.
     */
    public int estimateEventHolderByteSize(Object oEventHolder)
        {
        // import Component.Net.Message.MapEventMessage;
        // import com.tangosol.util.ExternalizableHelper as com.tangosol.util.ExternalizableHelper;
        // import java.util.Iterator;
        // import java.util.List;
        
        final int PINT_SIZE = com.tangosol.util.ExternalizableHelper.PACKED_INT_SIZE;
        
        int cb = 0;
        if (oEventHolder == null)
            {
            cb += PINT_SIZE; // number of event
            }
        else if (oEventHolder instanceof MapEventMessage)
            {
            MapEventMessage msgEvent = (MapEventMessage) oEventHolder;
        
            cb = PINT_SIZE + //event number
                 PINT_SIZE + //message type
                 estimateEventByteSize(msgEvent); //event
            }
        else
            {
            List listEvents = (List) oEventHolder;
        
            cb += PINT_SIZE; // listEvent size
            for (Iterator iter = listEvents.iterator(); iter.hasNext();)
                {
                MapEventMessage msgEvent = (MapEventMessage) iter.next();
                
                cb += PINT_SIZE + // message type
                      estimateEventByteSize(msgEvent); // event
                }
            }
        
        return cb;
        }
    
    // Declared at the super level
    /**
     * Return an estimate of the serialized size of the supplied message in
    * bytes.
    * 
    * @param msg  the message to estimate
     */
    public int estimateMessageSize(com.tangosol.coherence.component.net.Message msg)
            throws java.io.IOException
        {
        // import Component.Net.Message.RequestMessage.ChainedRequest.BackupRequest;
        // import com.tangosol.io.SizeEstimatingBufferOutput;
        // import com.tangosol.util.ExternalizableHelper as com.tangosol.util.ExternalizableHelper;
        // import java.util.concurrent.atomic.AtomicInteger;
        
        int nMessageType = msg.getMessageType();
        
        if ((nMessageType == PartitionedCache.BackupSingleRequest.MESSAGE_TYPE && getBackupSingleEnvelopeSize().get() == 0) ||
            (nMessageType == PartitionedCache.BackupAllRequest.MESSAGE_TYPE && getBackupAllEnvelopeSize().get() == 0))
            {
            BackupRequest msgBackup = (BackupRequest) msg;
        
            msgBackup.setEstimating(true);
        
            AtomicInteger atomicEnvelopeSize = nMessageType == PartitionedCache.BackupSingleRequest.MESSAGE_TYPE
                    ? getBackupSingleEnvelopeSize() : getBackupAllEnvelopeSize();
                
            atomicEnvelopeSize.compareAndSet(0,
                    serializeMessage(msgBackup, new SizeEstimatingBufferOutput()));
        
            msgBackup.setEstimating(false);
            }
        
        int cbMsg = msg.getEstimatedByteSize();
        
        return cbMsg < 0
            ? serializeMessage(msg, new SizeEstimatingBufferOutput())
            : cbMsg;
        }
    
    /**
     * Evaluate all pending lock requests. Called on the service thread only.
    * 
    * @see #onNotify
     */
    protected void evaluateLockRequests()
        {
        // import com.tangosol.run.component.EventDeathException;
        // import java.util.Iterator;
        // import java.util.ArrayList;
        // import java.util.List;
        
        long lTime     = getClusterTime();
        long lVariance = getClusterTimeVariance();
        long lNext     = Long.MAX_VALUE;
        
        synchronized (this)
            {
            // reset; this must be done before "scheduleLockEvaluation" is called
            setLockingNextMillis(lNext);
            }
        
        for (Iterator iterStore = getStorageArray().iterator(); iterStore.hasNext();)
            {
            Storage storage = (Storage) iterStore.next();
            if (!storage.isValid())
                {
                continue;
                }
        
            List listRetry   = null;
            List listPending = storage.getPendingLockRequest();
            synchronized (listPending)
                {
                int cPending = listPending.size();
                if (cPending > 0)
                    {
                    listRetry = new ArrayList(cPending);
                    for (Iterator iter = listPending.iterator(); iter.hasNext();)
                        {
                        PartitionedCache.LockRequest msgLock = (PartitionedCache.LockRequest) iter.next();
        
                        long lTimeout = msgLock.getLeaseWaitTimeout();
                        if (lTimeout <= lTime + lVariance)
                            {
                            iter.remove();
        
                            // this is going to be a last attempt
                            listRetry.add(msgLock);
                            }
                        else if (lTimeout != Long.MAX_VALUE)
                            {
                            lNext = Math.min(lNext, lTimeout);
                            }
                        }
                    }
                }
        
            if (listRetry != null)
                {
                for (Iterator iter = listRetry.iterator(); iter.hasNext();)
                    {
                    PartitionedCache.LockRequest msgLock = (PartitionedCache.LockRequest) iter.next();
                    try
                        {
                        msgLock.onReceived();
                        }
                    catch (EventDeathException ignored) {}
                    }
                }
            }
        
        if (lNext != Long.MAX_VALUE)
            {
            scheduleLockEvaluation(lNext - lTime);
            }
        }
    
    /**
     * Calculate a delta ReadBuffer from two specified ReadBuffers. New value
    * must not be null. 
    * 
    * @return null for for "no-difference"
     */
    public com.tangosol.io.ReadBuffer extractDelta(com.tangosol.io.ReadBuffer bufOld, com.tangosol.io.ReadBuffer bufNew)
        {
        return getBackupDeltaCompressor().extractDelta(bufOld, bufNew);
        }
    
    /**
     * Process any outstanding event from the ThreadLocal queue.
     */
    protected void flushEvents()
        {
        // import com.tangosol.internal.util.BMEventFabric$EventQueue as com.tangosol.internal.util.BMEventFabric.EventQueue;
        
        com.tangosol.internal.util.BMEventFabric.EventQueue queue = (com.tangosol.internal.util.BMEventFabric.EventQueue) getResourceCoordinator().getTloEventQueue().get();
        
        if (!flushOOBEvents() && queue != null && !queue.isEmpty())
            {
            processChanges();
            }
        }
    
    /**
     * Process any outstanding event.
     */
    protected boolean flushOOBEvents()
        {
        if (!getResourceCoordinator().getUnmanagedEventQueue().isEmpty())
            {
            processChanges();
            return true;
            }
        return false;
        }
    
    /**
     * Return a generated cache id that has not been reserved.
     */
    public long generateCacheId()
        {
        // import com.tangosol.persistence.CachePersistenceHelper as com.tangosol.persistence.CachePersistenceHelper;
        // import com.tangosol.util.LongArray;
        
        // create unique cache id
        long      lCacheId;
        LongArray laBinaryMap = getBinaryMapArray();
        do
            {
            lCacheId = getSUIDRange(SUID_CACHE, com.tangosol.persistence.CachePersistenceHelper.RESERVED_META_EXTENTS);
            }
        while (laBinaryMap.exists(lCacheId));
        
        return lCacheId;
        }
    
    // Accessor for the property "AddedDaemons"
    /**
     * Getter for property AddedDaemons.<p>
    * Indicates how many additional threads were added to process the deferred
    * index rebuild
     */
    public int getAddedDaemons()
        {
        return __m_AddedDaemons;
        }
    
    // Accessor for the property "BackingMapContext"
    /**
     * Getter for property BackingMapContext.<p>
    * The BackingMapContext (lazily created) is used by the BackingMapManager
    * (if provided) and Storage indexes.
     */
    public PartitionedCache.BackingMapContext getBackingMapContext()
        {
        return __m_BackingMapContext;
        }
    
    // From interface: com.tangosol.net.CacheService
    // From interface: com.tangosol.net.DistributedCacheService
    // Accessor for the property "BackingMapManager"
    /**
     * Getter for property BackingMapManager.<p>
    * Interface that provides the backing map storage implementations for the
    * cache.
     */
    public com.tangosol.net.BackingMapManager getBackingMapManager()
        {
        return __m_BackingMapManager;
        }
    
    // Accessor for the property "BackupAllEnvelopeSize"
    /**
     * Getter for property BackupAllEnvelopeSize.<p>
    * The size of BackupAllRequest envelope; used in optimized size estimation
    * for serialization.
    * 
    * @see $BackupAllRequest#getEstimatedByteSize
     */
    public java.util.concurrent.atomic.AtomicInteger getBackupAllEnvelopeSize()
        {
        return __m_BackupAllEnvelopeSize;
        }
    
    // Accessor for the property "BackupCountOpt"
    /**
     * Getter for property BackupCountOpt.<p>
    * Specifies the number of members that will retain backup data that does
    * not require write-behind, i.e. data that is not vulnerable to being lost
    * even if the entire cluster were shut down.
     */
    public int getBackupCountOpt()
        {
        return __m_BackupCountOpt;
        }
    
    // Accessor for the property "BackupDeltaCompressor"
    /**
     * Getter for property BackupDeltaCompressor.<p>
    * Interface that provides a strategy for the backup compressor.
     */
    public com.tangosol.io.DeltaCompressor getBackupDeltaCompressor()
        {
        return __m_BackupDeltaCompressor;
        }
    
    // Accessor for the property "BackupSingleEnvelopeSize"
    /**
     * Getter for property BackupSingleEnvelopeSize.<p>
    * The size of BackupSingleRequest envolope; used in optimized size
    * estimation for serialization.
    * 
    * @see $BackupSingleRequest#getEstimatedByteSize
     */
    public java.util.concurrent.atomic.AtomicInteger getBackupSingleEnvelopeSize()
        {
        return __m_BackupSingleEnvelopeSize;
        }
    
    // Accessor for the property "BinaryEntryConverter"
    /**
     * Getter for property BinaryEntryConverter.<p>
    * A Converter that converts an $EntryStatus object to a BinaryEntry.
     */
    public com.tangosol.util.Converter getBinaryEntryConverter()
        {
        return __m_BinaryEntryConverter;
        }
    
    // Accessor for the property "BinaryMapArray"
    /**
     * Getter for property BinaryMapArray.<p>
    * Holds the $BinaryMap references indexed by the cache id.
    * 
    * @see $BinaryMap#CacheId
     */
    public com.tangosol.util.LongArray getBinaryMapArray()
        {
        return __m_BinaryMapArray;
        }
    
    /**
     * Return the cache name for the specified cache id (if it exists), or null
    * otherwise.
    * 
    * @param lCacheId   the cache-id to return the name for
     */
    public String getCacheName(long lCacheId)
        {
        // import com.tangosol.run.xml.XmlElement;
        // import java.util.Enumeration;
        // import java.util.Map;
        
        if (isOwnershipEnabled())
            {
            Storage storage = getKnownStorage(lCacheId);
            return storage == null ? null : storage.getCacheName();
            }
        
        Map mapConfig = getServiceConfigMap();
        for (Enumeration e = getCacheNames(); e.hasMoreElements(); )
            {
            String     sCacheName = (String) e.nextElement();
            XmlElement xmlElement = (XmlElement) mapConfig.get(sCacheName);
        
            if (xmlElement != null &&
                xmlElement.getSafeAttribute("id").getLong() == lCacheId)
                {
                return sCacheName;
                }
            }
        
        return null;
        }
    
    // From interface: com.tangosol.net.CacheService
    // From interface: com.tangosol.net.DistributedCacheService
    public java.util.Enumeration getCacheNames()
        {
        // import com.tangosol.util.ClassFilter;
        // import com.tangosol.util.FilterEnumerator;
        // import java.util.ConcurrentModificationException;
        // import java.util.Map;
        
        // instead of synchronizing on the map and blocking all
        // the "put" and "remove" operations, we just catch any
        // ConcurrentModificationException and try again
        
        Map mapConfig = getServiceConfigMap();
        while (true)
            {
            try
                {
                return new FilterEnumerator(
                    mapConfig.keySet().iterator(), new ClassFilter(String.class));
                }
            catch (ConcurrentModificationException ignored) {}
            }
        }
    
    // Declared at the super level
    /**
     * Getter for property DistributionContendMillis.<p>
    * The DistributionContendMillis value specifies the maximum number of
    * milliseconds to contend for a partition lock in order to perform
    * distribution or 
    * building snapshot.
     */
    public long getDistributionContendMillis()
        {
        // import com.tangosol.net.partition.PartitionSet;
        
        // since the asynchronous index update communicates using the service thread,
        // we should not block it (see COH-15478).
        PartitionSet partsPending = getIndexPendingPartitions();
        return partsPending == null || partsPending.isEmpty() ? super.getDistributionContendMillis() : 0L;
        }
    
    // Accessor for the property "EventDeltaCompressor"
    /**
     * Getter for property EventDeltaCompressor.<p>
    * Interface that provides a strategy for the event compressor.
     */
    public com.tangosol.io.DeltaCompressor getEventDeltaCompressor()
        {
        return __m_EventDeltaCompressor;
        }
    
    // Accessor for the property "EventsHelper"
    /**
     * Getter for property EventsHelper.<p>
     */
    public PartitionedCache.EventsHelper getEventsHelper()
        {
        return __m_EventsHelper;
        }

    /**
     * Getter for property EventResendInterval
     *
     * Interval between resends of potentially "stuck" oldest event.
     */
    public long getEventResendInterval()
        {
        return __m_EventResendInterval;
        }


    // Accessor for the property "IndexingStartTime"
    /**
     * Getter for property IndexingStartTime.<p>
    * Start of one index build event for all partitions. Modified and accessed
    * on service thread.
     */
    public long getIndexingStartTime()
        {
        return __m_IndexingStartTime;
        }
    
    // Accessor for the property "IndexPendingPartitions"
    /**
     * Getter for property IndexPendingPartitions.<p>
    * This PartitionSet that contains partitions that have a pending index
    * rebuild due to partition redistribution or initial index creation.
    * 
    * @volatile
     */
    public com.tangosol.net.partition.PartitionSet getIndexPendingPartitions()
        {
        return __m_IndexPendingPartitions;
        }
    
    // Accessor for the property "IndexProcessingPartitions"
    /**
     * Getter for property IndexProcessingPartitions.<p>
    * This PartitionSet that contains partitions that index rebuild are being
    * processed,  used in condition check for index rebuild optimization,  see
    * scheduleInitialIndexUpdate.
    * 
    * @volatile
     */
    public com.tangosol.net.partition.PartitionSet getIndexProcessingPartitions()
        {
        return __m_IndexProcessingPartitions;
        }
    
    // Accessor for the property "IndexUpdateCount"
    /**
     * Getter for property IndexUpdateCount.<p>
    * A number of currently executing index update requests. This value is only
    * used by the service thread.
    * 
    * Note: this number is never greater than the "fair CPU count" (see
    * IndexUpdateRequest$Poll.onResponse).
    * 
    * @see scheduleIndexUpdate
     */
    public int getIndexUpdateCount()
        {
        return __m_IndexUpdateCount;
        }
    
    /**
     * Return the thread local InvocationContext.
     */
    public PartitionedCache.InvocationContext getInvocationContext()
        {
        PartitionedCache.InvocationContext ctx = (PartitionedCache.InvocationContext) getTLOContext().get();
        
        return ctx != null && ctx.isActive() ? ctx : null;
        }
    
    /**
     * Return the initialized storage for the specified cache id (if it exists),
    * or null otherwise.
    * 
    * Note: null is returned if this member is not OwnershipEnabled
     */
    public Storage getKnownStorage(long lCacheId)
        {
        if (isOwnershipEnabled())
            {
            Storage storage = getStorage(lCacheId);
        
            // check to see that the storage name is known
            if (storage != null && storage.isValid())
                {
                return storage;
                }
            }
        return null;
        }
    
    protected PartitionedCache.LazyLookup getLazyLookup(java.util.Map mapLookup, Object oKey)
        {
        PartitionedCache.LazyLookup lazyLookup = getLazyLookupReadBuffer();
        
        lazyLookup.setLookupMap(mapLookup);
        lazyLookup.setLookupKey(oKey);
        return lazyLookup;
        }
    
    // Accessor for the property "LazyLookupReadBuffer"
    /**
     * Getter for property LazyLookupReadBuffer.<p>
     */
    public PartitionedCache.LazyLookup getLazyLookupReadBuffer()
        {
        return __m_LazyLookupReadBuffer;
        }
    
    // Accessor for the property "LeaseGranularity"
    /**
     * Getter for property LeaseGranularity.<p>
    * The lease granularity.
    * 
    * Valid values are:
    *   Lease.BY_THREAD  - thread based ownership (default)
    *   Lease.BY_MEMBER - member based ownership
     */
    public int getLeaseGranularity()
        {
        return __m_LeaseGranularity;
        }
    
    // Accessor for the property "LockingNextMillis"
    /**
     * Getter for property LockingNextMillis.<p>
    * The LockingNextMillis value is the time (in local system millis) at which
    * the next deferred lock evaluation will be performed.
    * 
    * Initial value is Long.MAX_VALUE.
     */
    public long getLockingNextMillis()
        {
        return __m_LockingNextMillis;
        }

    /**
     * Getter for property OldestEventResendNextMillis
     *
     * The time at which the oldest event should be resent if it is determined
     * to be "old enough", or far enough behind the current event.
     */
    public long getOldestEventResendNextMillis()
        {
        return __m_OldestEventResendNextMillis;
        }

    // Accessor for the property "OldestPendingEventSUID"
    /**
     * Getter for property OldestPendingEventSUID.<p>
    * The SUID for the oldest event originated at this cache server that has
    * not yet been delivered to its recipient.
     */
    public long getOldestPendingEventSUID()
        {
        return calculateOldestSUID(getPendingEvents(), getThisMember().getId());
        }
    
    // Accessor for the property "PendingEvents"
    /**
     * Getter for property PendingEvents.<p>
    * An array of pending event-related items indexed by the corresponding
    * SUID. The SUID represent an event originator (cache server) and the value
    * is a $MapEvent containing all necessary data to re-deliver an event in
    * the case of a ownership-enabled node fail-over.
    * 
    * For a SUID that represents the local node, the value could be "null".
    * Those entries are used to ensure in-order event delivery and calculate
    * the OldestPendingEventSUID property.
     */
    public com.tangosol.util.LongArray getPendingEvents()
        {
        return __m_PendingEvents;
        }
    
    // Accessor for the property "PendingIndexUpdate"
    /**
     * Getter for property PendingIndexUpdate.<p>
    * A list of IndexUpdateRequest messages that are waiting to be processed. 
    * 
    * @see scheduleIndexUpdate
     */
    public java.util.concurrent.ConcurrentLinkedQueue getPendingIndexUpdate()
        {
        return __m_PendingIndexUpdate;
        }
    
    // Accessor for the property "PendingResultInfo"
    /**
     * Getter for property PendingResultInfo.<p>
    * An array of sorted maps of pending result-related items keyed by the
    * corresponding SUID. 
    * 
    * Used for requests that need to implement idempotent re-execution in the
    * case of a failover.
     */
    public com.tangosol.util.SparseArray[] getPendingResultInfo()
        {
        return __m_PendingResultInfo;
        }
    
    // Accessor for the property "PendingResultInfo"
    /**
     * Return the PendingResultInfo which would contain the SUIDs for the
    * specified suid
     */
    public com.tangosol.util.LongArray getPendingResultInfo(long lSUID)
        {
        // import com.tangosol.util.LongArray;
        
        LongArray[] ala = getPendingResultInfo();
        return ala[getMemberId(lSUID) % ala.length];
        }
    
    /**
     * Return a LongArray of the cache-ids mapped to the associated cache-name,
    * of the valid storages that are persistent.
     */
    public com.tangosol.util.LongArray getPersistentCacheIds()
        {
        return getPersistentCacheIds(false);
        }
    
    /**
     * Return a LongArray of the cache-ids mapped to the associated cache-name,
    * of the valid storages that are persistent.
     */
    public com.tangosol.util.LongArray getPersistentCacheIds(boolean fSnapshot)
        {
        // import com.tangosol.net.BackingMapManager;
        // import com.tangosol.util.LongArray;
        // import com.tangosol.util.SparseArray;
        // import java.util.Iterator;
        
        BackingMapManager manager  = getBackingMapManager();
        LongArray         laCaches = new SparseArray();
        for (Iterator iter = getStorageArray().iterator(); iter.hasNext(); )
            {
            Storage storage  = (Storage) iter.next();
            String   sCache   = storage.getCacheName();
            long     lCacheId = storage.getCacheId();
        
            if (storage.isValid() && manager.isBackingMapPersistent(sCache, fSnapshot))
                {
                laCaches.set(lCacheId, sCache);
                }
            }
        
        return laCaches;
        }
    
    // Accessor for the property "ProcessedEvents"
    /**
     * Getter for property ProcessedEvents.<p>
    * An array of already processed events indexed by the corresponding SUID.
    * Used to prevent processing the same event twice in a case of a failover.
    * The values are always nulls.
     */
    public com.tangosol.util.LongArray getProcessedEvents()
        {
        return __m_ProcessedEvents;
        }
    
    // Accessor for the property "ReferencesBinaryMap"
    /**
     * Getter for property ReferencesBinaryMap.<p>
    * Map keyed by cache name with a corresponding value being a binary map
    * interface.
     */
    public java.util.Map getReferencesBinaryMap()
        {
        return __m_ReferencesBinaryMap;
        }
    
    // Accessor for the property "RequestCoordinator"
    /**
     * Getter for property RequestCoordinator.<p>
    * The RequestCoordinator.
     */
    public PartitionedCache.RequestCoordinator getRequestCoordinator()
        {
        return __m_RequestCoordinator;
        }
    
    // Accessor for the property "ResourceCoordinator"
    /**
     * Getter for property ResourceCoordinator.<p>
     */
    public PartitionedCache.ResourceCoordinator getResourceCoordinator()
        {
        return __m_ResourceCoordinator;
        }
    
    /**
     * Get the  $ResultInfo object associated with the specified context. Or
    * null if no $ResultInfo is associated. This method also performs necessary
    * cleanup tasks.
     */
    protected PartitionedCache.ResultInfo getResultInfo(com.tangosol.coherence.component.net.RequestContext context)
        {
        // import com.tangosol.util.LongArray;
        
        if (context == null)
            {
            return null;
            }
        
        long      lSUID        = context.getRequestSUID();
        long      lSUIDPending = context.getOldestPendingSUID();
        LongArray laPending    = getPendingResultInfo(lSUID);
        
        synchronized (laPending)
            {
            removeSUIDRange(laPending, getBaseSUID(lSUIDPending), lSUIDPending, /*fValues*/ false);
        
            return (PartitionedCache.ResultInfo) laPending.get(lSUID);
            }
        }
    
    // Accessor for the property "ScheduledBackupsThreshold"
    /**
     * Getter for property ScheduledBackupsThreshold.<p>
    * Specifies the ratio in percentage of partition size at which it becomes
    * beneficial to back up an entire partition for a given cache.
    * 
    * Undocumented: configured via
    * coherence.distributed.scheduledbackupsthreshold, see onInit
     */
    public int getScheduledBackupsThreshold()
        {
        return __m_ScheduledBackupsThreshold;
        }

    /**
     * Getter for property MaxPartialResponseSize.
     *
     * Specifies the size in bytes after which a query-type response message
     * will be broken up into chunks for it to be "streamed".
     * This is to prevent reaching the 2GB message size limit.
     *
     * Undocumented: configured via
     * coherence.distributed.max.response.size, see onInit
     */
    public MemorySize getMaxPartialResponseSize()
        {
        return __m_MaxPartialResponseSize;
        }

    // Accessor for the property "ScopedCacheStore"
    /**
     * Getter for property ScopedCacheStore.<p>
    * Map keyed by cache name with a corresponding value being a map (keyed by
    * class loader with a corresponding value being a NamedCache reference).
     */
    public com.tangosol.net.internal.ScopedCacheReferenceStore getScopedCacheStore()
        {
        return __m_ScopedCacheStore;
        }
    
    // Accessor for the property "SendBackupsTask"
    /**
     * Getter for property SendBackupsTask.<p>
    * The task that is responsible to send scheduled backup message
    * ($BackupAllRequest) for the pending backup changes.
     */
    public PartitionedCache.SendBackupsTask getSendBackupsTask()
        {
        return __m_SendBackupsTask;
        }
    
    // Accessor for the property "StandardLeaseMillis"
    /**
     * Getter for property StandardLeaseMillis.<p>
    * The duration of a standard Lease in milliseconds. Zero indicates an
    * indefinite lease duration.
     */
    public long getStandardLeaseMillis()
        {
        return __m_StandardLeaseMillis;
        }
    
    // Accessor for the property "StatsIndexingTime"
    /**
     * Getter for property StatsIndexingTime.<p>
    * Cumulative elapsed time taken to build all indices, reset when
    * resetStats() is called.
     */
    public java.util.concurrent.atomic.AtomicLong getStatsIndexingTime()
        {
        return __m_StatsIndexingTime;
        }
    
    /**
     * Return the Storage for the specified cache id or null if doesn't exist.
    * 
    * @see #ensureStorage(long)
     */
    public Storage getStorage(long lCacheId)
        {
        return (Storage) getStorageArray().get(lCacheId);
        }
    
    /**
     * Helper method to retrieve the Storage for the specified cache name. It
    * returns null if the storage doesn't exist or has not been fully
    * configured.
     */
    public Storage getStorage(String sCacheName)
        {
        // import java.util.Iterator;
        
        BinaryMap mapBinary = (BinaryMap) getReferencesBinaryMap().get(sCacheName);
        if (mapBinary == null)
            {
            // there could be no entries in ReferencesBinaryMap on a server
            for (Iterator iter = getStorageArray().iterator(); iter.hasNext();)
                {
                Storage storage = (Storage) iter.next();
        
                if (sCacheName.equals(storage.getCacheName()))
                    {
                    return storage;
                    }
                }
            return null;
            }
        else
            {
            // it's possible the storage is not fully configured yet
            Storage storage = getStorage(mapBinary.getCacheId());
            return storage != null && sCacheName.equals(storage.getCacheName()) ? storage : null;
            }
        }
    
    // Accessor for the property "StorageArray"
    /**
     * Getter for property StorageArray.<p>
    * The StorageArray holds the storage units ($Storage) indexed by the cache
    * id.
    * 
    * As of Coherence 3.7, we use the copy-on-write array, which produces safe
    * iterators. Additionally, any changes to the StorageArray only happen on
    * the service thread.
    * 
    * @see $BinaryMap#CacheId
    * @see $Storage
     */
    public com.tangosol.util.LongArray getStorageArray()
        {
        return __m_StorageArray;
        }
    
    // From interface: com.tangosol.net.DistributedCacheService
    // Accessor for the property "StorageEnabledMembers"
    /**
     * Getter for property StorageEnabledMembers.<p>
    * @see com.tangosol.net.DistributedCacheService interface
    * @see #StorageMemberSet property
     */
    public java.util.Set getStorageEnabledMembers()
        {
        return getOwnershipMemberSet();
        }
    
    // Accessor for the property "StorageGraveyard"
    /**
     * Getter for property StorageGraveyard.<p>
    * Time-limited cache, mapping cache-id to cache-name, of recently destroyed
    * caches.
    * 
    * See COH-3275
     */
    public java.util.Map getStorageGraveyard()
        {
        return __m_StorageGraveyard;
        }
    
    // Accessor for the property "TaskSplitThreshold"
    /**
     * Getter for property TaskSplitThreshold.<p>
    * Specifies the size at which it becomes beneficial to split tasks into
    * partitioned sub-tasks.
    * 
    * Undocumented: configured via
    * tangosol.coherence.distributed.tasksplitthreshold, see onInit
     */
    public int getTaskSplitThreshold()
        {
        return __m_TaskSplitThreshold;
        }
    
    // Accessor for the property "TLOContext"
    /**
     * Getter for property TLOContext.<p>
    * Threadlocal Invocation Context
     */
    public ThreadLocal getTLOContext()
        {
        return __m_TLOContext;
        }
    
    // Declared at the super level
    /**
     * Getter for property WaitMillis.<p>
    * The number of milliseconds that the daemon will wait for notification.
    * Zero means to wait indefinitely. Negative value means to skip waiting
    * altogether.
    * 
    * @see #onWait
     */
    public long getWaitMillis()
        {
        // import com.tangosol.util.Base;
        
        long cWait1 = super.getWaitMillis();
        long ldtNow = Base.getLastSafeTimeMillis();
        long cWait2 = getLockingNextMillis() - ldtNow;
        return cWait1 <= 0L ? cWait2 : Math.min(cWait1, cWait2);
        }

    /**
     * Determine whether the specified partition contains data that can be
     * persisted or not.
     *
     * @param iPartition  partition number to check
     *
     * @return true if there is data, false otherwise
     */
    public boolean hasPersistentData(int iPartition)
        {
        if (super.hasPersistentData(iPartition))
            {
            return true;
            }

        BackingMapManager manager = getBackingMapManager();
        for (Iterator iterStore = getStorageArray().iterator(); iterStore.hasNext();)
            {
            Storage storage = (Storage) iterStore.next();
            if (storage.isValid() && manager.isBackingMapPersistent(storage.getCacheName()))
                {
                if (storage.hasData(iPartition))
                    {
                    return true;
                    }
                }
            }

        return false;
        }

    // Declared at the super level
    /**
     * Initialize the service config for this member.
    * 
    * @return  the config element to put in the service config map.
     */
    protected com.tangosol.run.xml.XmlElement initServiceConfig()
        {
        // import com.tangosol.run.xml.XmlElement;
        
        XmlElement xmlConfig   = super.initServiceConfig();
        String     sCompressor = getEventDeltaCompressor().getClass().getName();
        
        xmlConfig.addAttribute("delta-compressor").setString(sCompressor);
        return xmlConfig;
        }
    
    /**
     * Instantiate a BatchContext which, upon completion, will post the
    * specified response message to clients.
    * 
    * @param msgResponse   the client response, or null
     */
    public PartitionedCache.BatchContext instantiateBatchContext(com.tangosol.coherence.component.net.Message msgResponse)
        {
        // import java.util.concurrent.atomic.AtomicInteger;
        
        PartitionedCache.BatchContext ctxBatch = new PartitionedCache.BatchContext();
        _linkChild(ctxBatch);
        
        ctxBatch.setPrimaryResponse(msgResponse);
        ctxBatch.setOutstandingOperationCounter(new AtomicInteger(1));  // assume single-threaded execution
        
        return ctxBatch;
        }
    
    /**
     * Instantiate a binary map for the specified cache name and cache id.
     */
    public BinaryMap instantiateBinaryMap(String sName, long lCacheId)
        {
        // import com.tangosol.net.BackingMapManager;
        
        BinaryMap         mapBinary = (BinaryMap) _newChild("BinaryMap");
        BackingMapManager mgr       = getBackingMapManager();
        
        _assert(mgr != null);
        
        mapBinary.setCacheId(lCacheId);
        mapBinary.setCacheName(sName);
        mapBinary.setReadLocator(mgr.getReadLocator(sName));
        
        return mapBinary;
        }
    
    public PartitionedCache.ConverterFromBinary instantiateFromBinaryConverter(ClassLoader loader)
        {
        PartitionedCache.ConverterFromBinary conv =
            (PartitionedCache.ConverterFromBinary) _newChild("ConverterFromBinary");
        conv.setSerializer(ensureSerializer(loader));
        return conv;
        }
    
    /**
     * Instantiate an $InvocationContext.
     */
    protected PartitionedCache.InvocationContext instantiateInvocationContext()
        {
        // PartitionedCache.InvocationContext objects are created quite frequently,
        // so we manually link it instead of using _newChild() approach
        
        PartitionedCache.InvocationContext ctx = new PartitionedCache.InvocationContext();
        
        _linkChild(ctx);
        
        ctx.initialize();
        
        return ctx;
        }
    
    public PartitionedCache.ConverterValueToBinary instantiateValueToBinaryConverter(ClassLoader loader)
        {
        PartitionedCache.ConverterValueToBinary conv =
            (PartitionedCache.ConverterValueToBinary) _newChild("ConverterValueToBinary");
        conv.setSerializer(ensureSerializer(loader));
        return conv;
        }
    
    // Declared at the super level
    /**
     * Check whether or not all operations are allowed for this service.
     */
    public boolean isAllAllowed()
        {
        // import com.tangosol.net.CacheService$CacheAction as com.tangosol.net.CacheService.CacheAction;
        
        return super.isAllAllowed()
            && getActionPolicy().isAllowed(this, com.tangosol.net.CacheService.CacheAction.READ)
            && getActionPolicy().isAllowed(this, com.tangosol.net.CacheService.CacheAction.WRITE);
        }
    
    // Declared at the super level
    /**
     * Returns {@code true} if this service is compatible with the specified
    * service type.
    * <p>
    * This is mainly used during rolling updgrade where a new but compatible
    * service type is being used.
    * For example when PagedTopic was introduced, this is compatible with the
    * DistributedCache type.
    * 
    * @param sType  the type of this service running on the senior member
    * 
    * @return {@code true} if this service is compatible with the senior
    * member's service type
     */
    public boolean isCompatibleServiceType(String sType)
        {
        // import com.tangosol.net.CacheService;
        
        return getServiceType().equals(sType) || CacheService.TYPE_PAGED_TOPIC.equals(sType);
        }
    
    /**
     * Determine if need to rebuild index in the event of partition transfer.
     */
    public boolean isIndexed()
        {
        // import java.util.Iterator;
        
        for (Iterator iterStore = getStorageArray().iterator(); iterStore.hasNext();)
            {
            Storage storage = (Storage) iterStore.next();
            if (storage.isIndexed())
                {
                return true;
                }
            }
        
        return false;
        }
    
    // From interface: com.tangosol.net.DistributedCacheService
    public boolean isLocalStorageEnabled()
        {
        return isOwnershipEnabled();
        }
    
    /**
     * Return true iff partition is still pending or being processed for index
    * rebuild.
     */
    protected boolean isPartitionIndexPending(int nPartition)
        {
        return getIndexPendingPartitions().contains(nPartition) &&
                    !getIndexProcessingPartitions().contains(nPartition);
        }
    
    /**
     * Return true if the specified caches are created.
     */
    protected boolean isStorageCreated(java.util.Iterator iter)
        {
        while (iter.hasNext())
            {
            if (getStorage((String) iter.next()) == null)
                {
                return false;
                }
            }
        return true;
        }
    
    // Accessor for the property "StrictPartitioning"
    /**
     * Getter for property StrictPartitioning.<p>
    * Specifies whether or not the PartitionSplittingBackingMap(s) used as
    * PartitionedKeyIndex and BackupMap should be operating in a strict mode. 
    * 
    * @see $Storage#instantiateResourceMap, $Storage#instantiateBackupMap
    * @since Coherence 3.5
     */
    public boolean isStrictPartitioning()
        {
        return __m_StrictPartitioning;
        }
    
    // Declared at the super level
    /**
     * Getter for property SuspendedFully.<p>
    * As opposed to the Suspended this property indicates if the service has
    * finished the process of suspending itself, i.e. it has ensured that all
    * in-flight operations have completed.   Note this only refers to
    * operations which are "owned" by this service instance as we cannot
    * locally prevent new operations coming in from the outside and must still
    * honor them even while fully suspended in order to let our peers also
    * fully suspend.  Thus from a clustered perspective a service is not
    * finished suspending until all its members have become fully suspended.
    * 
    * This property has no specific meaning if the service is not suspend.
     */
    public boolean isSuspendedFully()
        {
        // import com.tangosol.net.cache.ReadWriteBackingMap;
        // import com.tangosol.net.cache.ReadWriteBackingMap$WriteQueue as com.tangosol.net.cache.ReadWriteBackingMap.WriteQueue;
        // import java.util.Iterator;
        // import java.util.Map;
        
        if (super.isSuspendedFully())
            {
            for (Iterator iter = getStorageArray().iterator(); iter.hasNext(); )
                {
                Storage storage = (Storage) iter.next();
                Map      map     = storage.getBackingMap();
                if (map instanceof ReadWriteBackingMap)
                    {
                    com.tangosol.net.cache.ReadWriteBackingMap.WriteQueue queue = ((ReadWriteBackingMap) map).getWriteQueue();
                    if (queue != null && !queue.isFlushed())
                        {
                        queue.flush(); // async flush
                        return false;
                        }
                    }
                }
        
            return true;    
            }
        
        return false;
        }
    
    /**
     * Return true iff the task should be split into sub-tasks.
    * 
    * @param cEntries the number of entries the task will operate upon.
     */
    public boolean isTaskSplitWorthy(int cEntries)
        {
        return cEntries > getTaskSplitThreshold() && getDaemonPool().getDaemonCount() > 1;
        }
    
    /**
     * Register a key based storage request by acquiring an exclusive lock for a
    * key.
    * 
    * @param fEnter if true, enter the gate; otherwise assume that the gate is
    * already entered
     */
    public boolean lockKey(Storage storage, com.tangosol.util.Binary binKey, boolean fEnter)
        {
        return lockKey(storage, binKey, fEnter, /*cWait*/ -1L);
        }
    
    /**
     * Register a key based storage request by acquiring an exclusive lock for a
    * key.
    * 
    * @param fEnter if true, enter the gate; otherwise assume that the gate is
    * already entered
     */
    public boolean lockKey(Storage storage, com.tangosol.util.Binary binKey, boolean fEnter, long cWait)
        {
        int     nPartition = getKeyPartition(binKey);
        boolean fEntered   = false;
        
        PartitionedCache.PartitionControl ctrl = (PartitionedCache.PartitionControl) getPartitionControl(nPartition);
        
        if (fEnter && cWait == 0L && (ctrl == null || ctrl.isLocked()))
            {
            return false;
            }
        
        if ((!fEnter || (fEntered = enterPartition(nPartition, cWait))) &&
            isPrimaryOwner(nPartition))
            {
            if (getResourceCoordinator().lock(storage, binKey, cWait))
                {
                return true;
                }
            }
        
        if (fEntered)
            {
            exitPartition(nPartition);
            }
        return false;
        }
    
    /**
     * Place a synthetic lock for a given storage. The only purpose of this lock
    * is to block the LOCK_ALL requests.
     */
    protected void lockSynthetic(Storage storage)
        {
        // import com.tangosol.util.Binary;
        
        getResourceCoordinator().lock(storage, new Binary(), -1L);
        }
    
    /**
     * Merge messages from two arrays and return the merged array. If any of the
    * arrays is not specified, just return the other one.
     */
    protected com.tangosol.coherence.component.net.Message[] merge(com.tangosol.coherence.component.net.Message[] aMsgOne, com.tangosol.coherence.component.net.Message[] aMsgTwo)
        {
        // import Component.Net.Message;
        
        // we should always choose Message[0] over null
        if (aMsgOne == null)
            {
            return aMsgTwo;
            }
        if (aMsgTwo == null)
            {
            return aMsgOne;
            }
        if (aMsgOne.length == 0)
            {
            return aMsgTwo;
            }
        if (aMsgTwo.length == 0)
            {
            return aMsgOne;
            }
        
        Message[] aMsgAll = new Message[aMsgOne.length + aMsgTwo.length];
        System.arraycopy(aMsgOne, 0, aMsgAll, 0, aMsgOne.length);
        System.arraycopy(aMsgTwo, 0, aMsgAll, aMsgOne.length, aMsgTwo.length);
        
        return aMsgAll;
        }
    
    /**
     * Merge the transferred results for the specified partition and SUID. The
    * caller should not modify the passed in map.
    * 
    * @param lSUID             the request SUID
    * @param iPart              the partition
    * @param mapResult   a result map for the specified SUID and partition 
     */
    protected void mergeTransferredResults(long lSUID, int iPart, java.util.Map mapResult)
        {
        // import Component.Net.RequestContext as com.tangosol.coherence.component.net.RequestContext;
        
        com.tangosol.coherence.component.net.RequestContext context = (com.tangosol.coherence.component.net.RequestContext) instantiateRequestContext();
        context.setOldestPendingSUID(-1L);
        context.setRequestSUID(lSUID);
        
        // COH-6384: If the SUID being transferred in was created by this member
        // (meaning we are the 'client'), only create a PartitionedCache.ResultInfo if the SUID
        // is still "pending".  Since we are the request initiator, if we have
        // removed the request SUID already, it must be completed and any results
        // should be discarded.
        boolean fOnlyIfPending = getMemberId(lSUID) == getThisMember().getId();
        
        PartitionedCache.ResultInfo resultInfo = ensureResultInfo(context, fOnlyIfPending);
        if (resultInfo != null)
            {
            resultInfo.mergeResults(iPart, mapResult);
            }
        }
    
    // Declared at the super level
    /**
     * Move the specified partition from one store index to another. Called on
    * the service thread only.
    * 
    * @param iPartition       the partition number to move
    * @param iBackupFrom   the store index of the partition that this service
    * currently owns
    * @param iBackupTo       the store index to move the partition to
    * 
    * @see #preparePartition, releasePartition, transferPartition,
    * receivePartition
     */
    protected void movePartition(int iPartition, int iBackupTo)
        {
        // import com.oracle.coherence.persistence.PersistentStore;
        // import java.util.Iterator;
        
        AutoCloseable closeable = null;
        
        if (isActivePersistence())
            {
            PartitionedCache.PartitionControl ctrl  = (PartitionedCache.PartitionControl) getPartitionControl(iPartition);
            PersistentStore   store = null;
            if (iBackupTo == 0)
                {
                store = ctrl.ensurePersistentStore();
                }
            else
                {
                if (isBackupPersistence())
                    {
                    // prepare extents for backups
                    store = ctrl.ensurePersistentStore(null, /*fEventsStore*/ false, /*fBackupStore*/ true);
                    }
                }
        
            // ensure we have exclusive access to the store which primarily acts as a
            // hint to the store that it should defer any maintenance
            if (store != null && store.isOpen())
                {
                closeable = store.exclusively();
                }
        
            if (iBackupTo == 0)
                {        
                ctrl.preparePersistentExtents();
                }
            else
                {
                if (isBackupPersistence())
                    {
                    ctrl.preparePersistentBackupExtents();
                    }
                }
            }
        
        try
            {
            for (Iterator iterStore = getStorageArray().iterator(); iterStore.hasNext();)
                {
                Storage storage = (Storage) iterStore.next();
                if (storage.isValid())
                    {
                    storage.movePartition(iPartition, iBackupTo > 0);
                    }
                }
        
            // Note: it is important to call super last, as it marks the persisted partition
            //       (if any) as valid, so any updates to the partition should occur first
            super.movePartition(iPartition, iBackupTo);
            }
        finally
            {
            if (closeable != null)
                {
                try
                    {
                    closeable.close();
                    }
                catch (Exception ignored) {}
                }
            }
        }
    
    /**
     * Called on the service or a daemon pool thread.
     */
    public void onAggregateAllRequest(PartitionedCache.AggregateAllRequest msgRequest)
        {
        // import Component.Util.Daemon.QueueProcessor.Service.Grid.PartitionedService$PinningIterator as com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.PinningIterator;
        // import com.tangosol.net.GuardSupport;
        // import com.tangosol.net.security.StorageAccessAuthorizer as com.tangosol.net.security.StorageAccessAuthorizer;
        // import com.tangosol.net.partition.PartitionSet;
        // import com.tangosol.util.Binary;
        // import com.tangosol.util.ConverterCollections;
        // import com.tangosol.util.InvocableMap$EntryAggregator as com.tangosol.util.InvocableMap.EntryAggregator;
        // import com.tangosol.util.InvocableMap$StreamingAggregator as com.tangosol.util.InvocableMap.StreamingAggregator;
        // import com.tangosol.util.NullImplementation;
        // import java.util.HashSet;
        // import java.util.Set;
        
        PartitionedCache.PartialValueResponse msgResponse =
            (PartitionedCache.PartialValueResponse) instantiateMessage("PartialValueResponse");
        msgResponse.respondTo(msgRequest);
        
        Storage storage = validateRequestForStorage(msgRequest, msgResponse, true);
        if (storage == null)
            {
            return;
            }
        
        Set             setKeys = msgRequest.getKeySetSafe();
        com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.PinningIterator pinner  = createPinningIterator(setKeys);
        
        Set setKeysPinned = new HashSet(setKeys.size());
        
        while (pinner.hasNext())
            {
            Binary binKey = (Binary) pinner.next();
        
            // Note: we instantiate a Storage.BinaryEntry here directly, as
            //       it is passed in read-only form to the aggregation
            setKeysPinned.add(binKey);
            }
        
        PartitionSet partsPinned = pinner.getPinnedPartitions();
        
        PartitionedCache.InvocationContext ctxInvoke = ensureInvocationContext(partsPinned);
        ctxInvoke.markReadOnlyRequest();
        
        try
            {
            com.tangosol.util.InvocableMap.EntryAggregator agent = msgRequest.deserializeAggregator();
        
            ctxInvoke.prepareAccess(msgRequest.getRequestContext(), storage,
                Storage.BinaryEntry.ACCESS_READ_ANY, com.tangosol.net.security.StorageAccessAuthorizer.REASON_AGGREGATE);
        
            Object oResult;
            if (agent instanceof com.tangosol.util.InvocableMap.StreamingAggregator)
                {
                oResult = storage.aggregateByStreaming(setKeysPinned, (com.tangosol.util.InvocableMap.StreamingAggregator) agent);
                }
            else
                {
                oResult = agent.aggregate(ConverterCollections.getSet(setKeysPinned,
                    storage.getKeyToBinaryEntryConverter(), NullImplementation.getConverter()));
                }
        
            msgResponse.setResult(getBackingMapContext().getValueToInternalConverter().convert(oResult));
            msgResponse.setRejectPartitions(pinner.getRejectedPartitions());
            }
        catch (Throwable e)
            {
            // this exception should be set right away since
            // the response could be sent back on a different thread
            msgResponse.setException(tagException(e));
            }
        
        // COH-22088: if the thread was interrupted due to the guardian we must reset
        //            (heartbeat and clear the interrupt bit) to avoid an exception when
        //            invoking an interruptible method
        GuardSupport.reset();
        
        processChanges(msgResponse);
        
        releaseInvocationContext(ctxInvoke);
        
        msgRequest.setProcessedPartitions(partsPinned); // will be used to update stats
        
        // lastly, exit the partitions
        unpinPartitions(partsPinned);
        }
    
    /**
     * Called on the service or a daemon pool thread.
     */
    public void onAggregateFilterRequest(PartitionedCache.AggregateFilterRequest msgRequest)
        {
        // import com.tangosol.net.GuardSupport;
        // import com.tangosol.net.partition.PartitionSet;
        // import com.tangosol.net.security.StorageAccessAuthorizer as com.tangosol.net.security.StorageAccessAuthorizer;
        // import com.tangosol.util.Filter;
        // import com.tangosol.util.InvocableMap$EntryAggregator as com.tangosol.util.InvocableMap.EntryAggregator;
        // import com.tangosol.util.InvocableMap$StreamingAggregator as com.tangosol.util.InvocableMap.StreamingAggregator;
        // import com.tangosol.util.aggregator.QueryRecorder;
        // import com.tangosol.util.aggregator.QueryRecorder$RecordType as com.tangosol.util.aggregator.QueryRecorder.RecordType;
        
        PartitionedCache.PartialValueResponse msgResponse =
            (PartitionedCache.PartialValueResponse) instantiateMessage("PartialValueResponse");
        msgResponse.respondTo(msgRequest);
        
        Storage storage = validateRequestForStorage(msgRequest, msgResponse, true);
        if (storage == null)
            {
            return;
            }
        
        flushOOBEvents();
        
        PartitionSet partMask = msgRequest.getRequestMaskSafe();
        Filter       filter   = msgRequest.getFilter();
        
        PartitionSet partReject = pinOwnedPartitions(partMask);
        
        PartitionedCache.InvocationContext ctxInvoke = ensureInvocationContext(partMask);
        ctxInvoke.markReadOnlyRequest();
        
        try
            {
            com.tangosol.util.InvocableMap.EntryAggregator agent = msgRequest.deserializeAggregator();
        
            ctxInvoke.prepareAccess(msgRequest.getRequestContext(), storage,
                Storage.BinaryEntry.ACCESS_READ_ANY, com.tangosol.net.security.StorageAccessAuthorizer.REASON_AGGREGATE);
        
            if (agent instanceof QueryRecorder)
                {
                Object oResult = ((QueryRecorder) agent).getType() == com.tangosol.util.aggregator.QueryRecorder.RecordType.TRACE
                        ? storage.trace(filter, partMask)
                        : storage.explain(filter, partMask); 
                msgResponse.setResult(getBackingMapContext().getValueToInternalConverter().convert(oResult));
                }
            else if (agent instanceof com.tangosol.util.InvocableMap.StreamingAggregator)
                {
                Object oResult = storage.aggregateByStreaming(filter, (com.tangosol.util.InvocableMap.StreamingAggregator) agent, partMask, msgRequest.checkTimeoutRemaining());
                msgResponse.setResult(getBackingMapContext().getValueToInternalConverter().convert(oResult));
                }
            else
                {
                storage.aggregateByProbe(filter, agent, partMask, msgRequest, msgResponse);
                }
        
            msgResponse.setRejectPartitions(partReject);
            }
        catch (Throwable e)
            {
            // this exception should be set right away since
            // the response could be sent back on a different thread
            msgResponse.setException(tagException(e));
            }
        
        // COH-22088: if the thread was interrupted due to the guardian we must reset
        //            (heartbeat and clear the interrupt bit) to avoid an exception when
        //            invoking an interruptible method
        GuardSupport.reset();
        
        processChanges(msgResponse);
        
        releaseInvocationContext(ctxInvoke);
        
        msgRequest.setProcessedPartitions(partMask);
        
        // lastly, exit the partitions
        unpinPartitions(partMask);
        }
    
    /**
     * Called on the service thread only.
     */
    public void onBackupAllRequest(PartitionedCache.BackupAllRequest msgRequest, com.tangosol.net.partition.PartitionSet partsSkip)
        {
        // import Component.Net.Member as com.tangosol.coherence.component.net.Member;
        // import Component.Net.RequestContext as com.tangosol.coherence.component.net.RequestContext;
        // import com.tangosol.net.internal.StorageVersion;
        // import com.tangosol.net.partition.PartitionSet;
        // import com.tangosol.net.partition.VersionedPartitions;
        // import com.tangosol.net.partition.VersionedPartitions$VersionedIterator as com.tangosol.net.partition.VersionedPartitions.VersionedIterator;
        // import com.tangosol.util.PrimitiveSparseArray;
        // import java.util.Iterator;
        // import java.util.Map;
        // import java.util.Map$Entry as java.util.Map.Entry;
        
        if (isOwnershipEnabled())
            {
            long    lCacheId     = msgRequest.getCacheId();
            Map     mapEntries   = msgRequest.getMap();
            Map     mapEvents    = msgRequest.getEventHolderMap();
            Map     mapResults   = msgRequest.getResultMap();
            com.tangosol.coherence.component.net.Member  memberOwner  = msgRequest.getOriginatingMember();
            com.tangosol.coherence.component.net.RequestContext ctx          = msgRequest.getRequestContext();
            Map     mapGraveYard = getStorageGraveyard();

            if (lCacheId == -1L)
                {
                // The BackupAllRequest spans multiple caches.
                // Each of the maps (entries, events) holds a mapping from
                // cache-id to a map holding the data for that cache.
                long lCacheIdResults = msgRequest.getResultsCacheId();
                for (Iterator iter = mapEntries.keySet().iterator(); iter.hasNext(); )
                    {
                    Long LId = (Long) iter.next();
                    long lId = LId.longValue();
        
                    if (getKnownStorage(lId) == null)
                        {
                        if (mapGraveYard.containsKey(LId))
                            {
                            // the Storage has been concurrently destroyed
                            continue;
                            }
                        deferBackup(ctx, msgRequest.getPartitionSet(), lId, (Map) mapEntries.get(LId),
                                    (Map) mapEvents.get(LId), memberOwner);
                        }
                    else
                        {
                        doBackupAll(ctx, partsSkip, lId,
                                    (Map) mapEntries.get(LId), (Map) mapEvents.get(LId),
                                    lId == lCacheIdResults ? mapResults : null, memberOwner);
                        }
                    }
                }
            else
                {
                // Single-cache backup-all
        
                if (getKnownStorage(lCacheId) == null)
                    {
                    if (mapGraveYard.containsKey(Long.valueOf(lCacheId)))
                        {
                        // the Storage has been concurrently destroyed
                        }
                    else
                        {
                        deferBackup(ctx, msgRequest.getPartitionSet(), lCacheId, mapEntries, mapEvents, memberOwner);
                        }
                    }
                else
                    {
                    doBackupAll(ctx, partsSkip, lCacheId, mapEntries, mapEvents, mapResults, memberOwner);
                    }
                }
        
            // register the partition result
            PrimitiveSparseArray paVersions = msgRequest.getPartitionVersions();
            if (paVersions.getSize() == 1 && partsSkip == null)
                {
                // common case optimization
                registerMultiResult(ctx, (int) paVersions.getFirstIndex(), mapResults);
                }
            else
                {
                PartitionSet parts = msgRequest.getPartitionSet();
                if (partsSkip != null)
                    {
                    parts.remove(partsSkip);
                    }
                registerMultiResult(ctx, parts, mapResults);
                }
        
            // maintain the latest version, so if we do become primary we can maintain
            // the property of montonically increasing version numbers from the
            // perspective of MapListeners
            Map mapVersions = msgRequest.getMapEventVersions();
            for (Iterator iter = mapVersions.entrySet().iterator(); iter.hasNext(); )
                {
                java.util.Map.Entry entry       = (java.util.Map.Entry) iter.next();
                long  lCacheIdCur = ((Long) entry.getKey()).longValue();
        
                Storage storage = getKnownStorage(lCacheIdCur);
        
                if (storage != null)
                    {
                    VersionedPartitions versions       = (VersionedPartitions) entry.getValue();
                    StorageVersion      storageVersion = storage.getVersion();
        
                    for (com.tangosol.net.partition.VersionedPartitions.VersionedIterator iterPart = versions.iterator(); iterPart.hasNext(); )
                        {
                        long lVersion = iterPart.nextVersion();
        
                        storageVersion.resetSubmitted(iterPart.getPartition(), lVersion);
                        }
                    }
                // else either storage has been destroyed or has not been created; for
                // the latter we simply wait for the next backup
                }
            }
        else
            {
            _assert(getServiceState() >= SERVICE_STOPPING);
            }
        }
    
    /**
     * Called on the service thread only.
     */
    public void onBackupListenerAllRequest(PartitionedCache.BackupListenerAllRequest msgRequest, com.tangosol.net.partition.PartitionSet partsSkip)
        {
        // import Component.Net.Member as com.tangosol.coherence.component.net.Member;
        // import com.tangosol.persistence.CachePersistenceHelper as com.tangosol.persistence.CachePersistenceHelper;
        // import com.tangosol.util.Binary;
        // import java.util.Iterator;
        // import java.util.Set;
        
        
        long              lExtentId = msgRequest.getCacheId();
        Storage          storage   = getKnownStorage(lExtentId);
        com.tangosol.coherence.component.net.Member            member    = getServiceMemberSet().getMember(msgRequest.getMemberId());
        
        if (storage != null && member != null)
            {
            boolean fAdd      = msgRequest.isAdd();
            boolean fLite     = msgRequest.isLite();
            Set     setKeys   = msgRequest.getKeySet();
            long    ldtJoined = getServiceMemberSet().getServiceJoinTime(member.getId());
        
            for (Iterator iter = setKeys.iterator(); iter.hasNext();)
                {
                Binary            binKey     = (Binary) iter.next();
                int               nPartition = getKeyPartition(binKey);
                PartitionedCache.PartitionControl ctrl       = (PartitionedCache.PartitionControl) getPartitionControl(nPartition);
                PersistentStore   store      = (storage.isPersistent() && isBackupPersistence())
                                                   ? ctrl.getPersistentBackupStore()
                                                   : null;
        
                if (partsSkip != null && partsSkip.contains(nPartition))
                    {
                    continue;
                    }
        
                // add/remove the key listener to/from the storage
                if (msgRequest.isAdd())
                    {
                    storage.addKeyListener(member, binKey, fLite, false);
                    // persist if enabled
                    if (store != null)
                        {
                        com.tangosol.persistence.CachePersistenceHelper.registerListener(store, lExtentId, binKey, ldtJoined, fLite, /*oToken*/ null);
                        }
                    }
                else
                    {
                    storage.removeKeyListener(member, binKey, false);
                    // un-persist
                    if (store != null)
                        {
                        com.tangosol.persistence.CachePersistenceHelper.unregisterListener(store, lExtentId, binKey, ldtJoined, /*oToken*/ null);
                        }
                    }
                }
            }
        }
    
    public void onBackupListenerRequest(PartitionedCache.BackupListenerRequest msgRequest)
        {
        long                                        lExtentId = msgRequest.getCacheId();
        Storage                                     storage   = getKnownStorage(lExtentId);
        com.tangosol.coherence.component.net.Member member    = getServiceMemberSet().getMember(msgRequest.getMemberId());

        if (storage != null && member != null)
            {
            PartitionedCache.PartitionControl ctrl      = (PartitionedCache.PartitionControl) getPartitionControl(msgRequest.getPartition());
            PersistentStore                   store     = (storage.isPersistent() && isBackupPersistence())
                                                            ? ctrl.getPersistentBackupStore()
                                                            : null;
            boolean                           fLite     = msgRequest.isLite();
            Binary                            binKey    = msgRequest.getKey();
            long                              ldtJoined = store == null ? 0 : getServiceMemberSet().getServiceJoinTime(member.getId());
        
            // add/remove the key listener to/from the storage
            if (msgRequest.isAdd())
                {
                storage.addKeyListener(member, binKey, fLite, false);
        
                if (store != null)
                    {
                    com.tangosol.persistence.CachePersistenceHelper.registerListener(store, lExtentId, binKey, ldtJoined, fLite, /*oToken*/ null);
                    }
                }
            else
                {
                storage.removeKeyListener(member, binKey, false);
        
                if (store != null)
                    {
                    com.tangosol.persistence.CachePersistenceHelper.unregisterListener(store, lExtentId, binKey, ldtJoined, /*oToken*/ null);
                    }
                }
            }
        }
    
    public void onBackupLockRequest(PartitionedCache.BackupLockRequest msgRequest)
        {
        // import Component.Net.Lease;
        // import com.tangosol.persistence.CachePersistenceHelper as com.tangosol.persistence.CachePersistenceHelper;
        // import com.tangosol.util.Binary;
        // import java.util.Map;
        
        Storage storage = getKnownStorage(msgRequest.getCacheId());
        if (storage != null)
            {
            Lease             lease     = msgRequest.getLease();
            long              lExtentId = msgRequest.getCacheId();
            PartitionedCache.PartitionControl ctrl      = (PartitionedCache.PartitionControl) getPartitionControl(msgRequest.getPartition());
            PersistentStore   store     = (storage.isPersistent() && isBackupPersistence())
                                            ? ctrl.getPersistentBackupStore()
                                            : null;
            long              ldtJoined = store == null ? 0 : getServiceMemberSet().getServiceJoinTime(lease.getHolderId());
            Binary            binKey    = msgRequest.getKey();
            Map               mapLease  = storage.getBackupLeaseMap();
        
            // update the backup lease map
            if (msgRequest.isLock())
                {
                if (getServiceMemberSet().contains(lease.getHolderId()))
                    {
                    mapLease.put(binKey, lease);
                    if (store != null)
                        {
                        com.tangosol.persistence.CachePersistenceHelper.registerLock(store, lExtentId, binKey, ldtJoined, lease.getHolderThreadId(), /*oToken*/ null);
                        }
                    }
                }
            else
                {
                mapLease.remove(binKey);
                if (store != null)
                    {
                    com.tangosol.persistence.CachePersistenceHelper.unregisterLock(store, lExtentId, binKey, ldtJoined, lease.getHolderThreadId(), /*oToken*/ null);
                    }
                }
            }
        }
    
    /**
     * Called on the service thread only.
     */
    public void onBackupSingleRequest(PartitionedCache.BackupSingleRequest msgRequest)
        {
        // import Component.Net.Member as com.tangosol.coherence.component.net.Member;
        // import Component.Net.RequestContext as com.tangosol.coherence.component.net.RequestContext;
        // import com.tangosol.util.Binary;
        // import com.tangosol.util.ExternalizableHelper as com.tangosol.util.ExternalizableHelper;
        // import java.util.Collections;
        // import java.util.Map;
        // import java.util.Set;
        
        if (isOwnershipEnabled())
            {
            long     lCacheId    = msgRequest.getCacheId();
            Storage storage     = getKnownStorage(lCacheId);
            Object   oEvent      = msgRequest.getEventHolder();
            Binary   binKey      = msgRequest.getKey();
            Binary   binValue    = com.tangosol.util.ExternalizableHelper.asBinary(msgRequest.getValue());
            boolean  fRemove     = Binary.EMPTY.equals(binValue);
            com.tangosol.coherence.component.net.Member   memberOwner = msgRequest.getOriginatingMember();
            com.tangosol.coherence.component.net.RequestContext  ctx         = msgRequest.getRequestContext();
            int      iPartition  = msgRequest.getPartition();
            long     lVersion    = msgRequest.getMapEventVersion();
        
            if (storage == null)
                {
                if (getStorageGraveyard().containsKey(Long.valueOf(lCacheId)))
                    {
                    // the Storage has been concurrently destroyed
                    }
                else
                    {
                    deferBackup(ctx, iPartition, lCacheId,
                                Collections.singletonMap(binKey, binValue),
                                Collections.singletonMap(binKey, oEvent),
                                memberOwner);
                    }
                }
            else
                {
                Map     mapBackup   = storage.getBackupMap();
                boolean fResult     = msgRequest.getResult() != null;
                boolean fEvent      = oEvent != null;
                Binary  binValueOld = null;
        
                // intern the binary key
                binKey = storage.getCanonicalKey(binKey);
                if (binValue == null)
                    {
                    // null indicates no-diff (see prepareBackupSingleRequest)
                    binValue = binValueOld = (Binary) mapBackup.get(binKey);
                    }
                else if (fRemove)
                    {
                    // BINARY_EXISTS indicates a remove op (see prepareBackupSingleRequest)
                    binValueOld = doBackupRemove(mapBackup, binKey);
                    }
                else
                    {
                    // a "normal" update
                    binValue = applyDelta(mapBackup, binKey, binValue);
                    if (binValue == null)
                        {
                        // delta application failed; return immediately
                        return;
                        }
        
                    if (fEvent || fResult || !storage.isPreferPutAllBackup())
                        {
                        binValueOld = doBackupPut(mapBackup, binKey, binValue);
                        }
                    else
                        {
                        // if we don't need to raise events or decompress the result,
                        // use the putAll (if preferred) to avoid reading the old value
                        doBackupPutAll(mapBackup, Collections.singletonMap(binKey, binValue));
                        }
                    }
                if (isBackupPersistence())
                    {
                    // persist backup, done asynchronously
                    persistBackup(iPartition, lCacheId, binKey, binValue, fRemove);
                    }
        
                // register the result for the key
                registerSingleResult(ctx, binKey,
                    Storage.decompressResult(msgRequest.getResult(), binValueOld, binValue));
        
                if (fEvent)
                    {
                    // register the events
                    registerEvent(PartitionedCache.MapEvent.decompressEventHolder(
                        oEvent, lCacheId, binKey, binValueOld, binValue), memberOwner);
                    }
        
                // maintain the latest version, so if we do become primary we can maintain
                // the property of montonically increasing version numbers from the
                // perspective of MapListeners
                if (lVersion > 0)
                    {
                    storage.getVersion().resetSubmitted(iPartition, lVersion);
                    }
                }
            }
        else
            {
            _assert(getServiceState() >= SERVICE_STOPPING);
            }
        }
    
    /**
     * Called on the service or a daemon pool thread.
     */
    public void onClearRequest(PartitionedCache.ClearRequest msgRequest)
        {
        // import com.tangosol.net.partition.PartitionSet;
        // import com.tangosol.net.GuardSupport;
        // import com.tangosol.net.security.StorageAccessAuthorizer as com.tangosol.net.security.StorageAccessAuthorizer;
        // import com.tangosol.run.xml.XmlElement;
        // import com.tangosol.run.xml.XmlValue;
        // import com.tangosol.util.Base;
        // import com.tangosol.util.LongArray;
        // import java.util.Map;
        
        PartitionedCache.PartialValueResponse msgResponse =
            (PartitionedCache.PartialValueResponse) instantiateMessage("PartialValueResponse");
        msgResponse.respondTo(msgRequest);
        
        Storage storage = validateRequestForStorage(msgRequest, msgResponse, false);
        if (storage == null)
            {
            return;
            }
        
        PartitionSet partMask   = msgRequest.getRequestMaskSafe();
        PartitionSet partReject = pinOwnedPartitions(partMask);
        
        msgResponse.setRejectPartitions(partReject);
        
        PartitionedCache.InvocationContext ctxInvoke = ensureInvocationContext(partMask);
        try
            {
            // clear acquires a global lock thus key-based locks
            // (ctxInvoke.lockEntry()) can be avoided
            ctxInvoke.lockStorage(storage);
        
            // Note: lockAll() does not mark any entries as 'managed', with
            //       changes being automatically published by Storage, however
            //       entries are marked as 'managed' if interceptors
            //       or triggers are present
        
            ctxInvoke.prepareAccess(msgRequest.getRequestContext(), storage,
                Storage.BinaryEntry.ACCESS_WRITE_ANY, com.tangosol.net.security.StorageAccessAuthorizer.REASON_CLEAR);
        
            if (msgRequest.isTruncate())
                {
                Storage  storageNew = storage.truncate();
                LongArray laStorage  = getStorageArray();
                synchronized (laStorage)
                    {
                    laStorage.set(storageNew.getCacheId(), storageNew);
                    }
        
                // update service config map to notify every member of the truncation
                if (getThisMember() == getOwnershipSenior(/*fIncludeLeaving*/ true))
                    {
                    String     sCacheName   = storageNew.getCacheName();
                    Map        mapConfig    = getServiceConfigMap();
                    XmlElement xmlCacheInfo = (XmlElement) ((XmlElement) mapConfig.get(sCacheName)).clone();
                    XmlValue   xmlAttr      = xmlCacheInfo.
                                              getAttribute(PartitionedCache.ServiceConfig.TRUNCATE_TIME_ATTRIBUTE);
        
                    xmlCacheInfo.addAttribute(PartitionedCache.ServiceConfig.TRUNCATE_TIME_ATTRIBUTE)
                        .setInt(xmlAttr == null ? 1 : xmlAttr.getInt() + 1);
        
                    mapConfig.put(sCacheName, xmlCacheInfo);
                    }
                }
            else
                {
                storage.clear(ctxInvoke, partMask);
                }
            }
        catch (Throwable e)
            {
            msgResponse.setException(tagException(e));
            }
        
        // COH-22088: if the thread was interrupted due to the guardian we must reset
        //            (heartbeat and clear the interrupt bit) to avoid an exception when
        //            invoking an interruptible method
        GuardSupport.reset();
        
        processChanges(/*ctx*/ null, /*job*/ null, -1L,
            ctxInvoke.getEntryStatuses(), instantiateBatchContext(msgResponse));
        
        // release all state held by the InvocationContext without
        // unpinning partitions
        ctxInvoke.release(/*fUnpin*/ false);
        
        unpinPartitions(partMask);
        }
    
    /**
     * Called on the service or a daemon pool thread.
     */
    public void onContainsAllRequest(PartitionedCache.ContainsAllRequest msgRequest)
        {
        // import Component.Util.Daemon.QueueProcessor.Service.Grid.PartitionedService$PinningIterator as com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.PinningIterator;
        // import com.tangosol.net.partition.PartitionSet;
        // import com.tangosol.util.Binary;
        // import java.util.Map;
        // import java.util.Set;
        
        PartitionedCache.PartialValueResponse msgResponse =
            (PartitionedCache.PartialValueResponse) instantiateMessage("PartialValueResponse");
        msgResponse.respondTo(msgRequest);
        msgResponse.setResult(Boolean.TRUE);
        
        Storage storage = validateRequestForStorage(msgRequest, msgResponse, false);
        if (storage == null)
            {
            return;
            }
        
        Set             setKeys = msgRequest.getKeySetSafe();
        com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.PinningIterator pinner  = createPinningIterator(setKeys);
        try
            {
            while (pinner.hasNext())
                {
                if (!storage.containsKey((Binary) pinner.next()))
                    {
                    msgResponse.setResult(Boolean.FALSE);
                    break;
                    }
                }
            
            msgResponse.setRejectPartitions(pinner.getRejectedPartitions());
            }
        catch (Throwable e)
            {
            msgResponse.setException(tagException(e));
            }
        
        processChanges(msgResponse);
        
        PartitionSet partsPinned = pinner.getPinnedPartitions();
        msgRequest.setProcessedPartitions(partsPinned);
        
        unpinPartitions(partsPinned);
        }
    
    /**
     * Called on the service or a daemon pool thread.
     */
    public void onContainsKeyRequest(PartitionedCache.ContainsKeyRequest msgRequest)
        {
        // import com.tangosol.util.Binary;
        // import java.util.Map;
        
        PartitionedCache.Response msgResponse = (PartitionedCache.Response) instantiateMessage("Response");
        msgResponse.respondTo(msgRequest);
        
        Storage storage = validateRequestForStorage(msgRequest, msgResponse, false);
        if (storage == null)
            {
            return;
            }
        
        try
            {
            Binary binKey     = msgRequest.getKey();
            int    nPartition = getKeyPartition(binKey);
            if (pinOwnedPartition(nPartition))
                {
                try
                    {
                    boolean fContains = storage.containsKey(binKey);
                    msgResponse.setValue(Boolean.valueOf(fContains));
                    }
                finally
                    {
                    unpinPartition(nPartition);
                    }
        
                msgRequest.setProcessedPartition(nPartition);
                }
            else
                {
                msgResponse.setResult(PartitionedCache.Response.RESULT_RETRY);
                }
            }
        catch (Throwable e)
            {
            msgResponse.setResult(PartitionedCache.Response.RESULT_FAILURE);
            msgResponse.setValue(tagException(e));
            }
        
        processChanges(msgResponse);
        }
    
    /**
     * Called on the service or a daemon pool thread.
     */
    public void onContainsValueRequest(PartitionedCache.ContainsValueRequest msgRequest)
        {
        // import com.tangosol.net.partition.PartitionSet;
        // import com.tangosol.util.Binary;
        
        PartitionedCache.PartialValueResponse msgResponse =
            (PartitionedCache.PartialValueResponse) instantiateMessage("PartialValueResponse");
        msgResponse.respondTo(msgRequest);
        
        Storage storage = validateRequestForStorage(msgRequest, msgResponse, false);
        if (storage == null)
            {
            return;
            }
        
        PartitionSet partMask   = msgRequest.getRequestMaskSafe();
        PartitionSet partReject = pinOwnedPartitions(partMask);
        Binary       binValue   = msgRequest.getValue();
        
        try
            {
            // no need to filter out "in-transfer" keys
            boolean fContains = storage.containsValue(binValue);
        
            msgResponse.setResult(Boolean.valueOf(fContains));
            msgResponse.setRejectPartitions(partReject);
            }
        catch (Throwable e)
            {
            msgResponse.setException(tagException(e));
            }
        
        processChanges(msgResponse);
        
        msgRequest.setProcessedPartitions(partMask);
        
        unpinPartitions(partMask);
        }
    
    // Declared at the super level
    /**
     * This event occurs when dependencies are injected into the component. 
    * Unless this is a base component, call super.onDependencies to allow all
    * super components to process the Dependencies.  Each component is free to
    * chose how it consumes dependencies.  Typically, the  dependencies are
    * copied into the component's properties.  This technique isolates
    * Dependency Injection from the rest of the component code since components
    * continue to access properties just as they did before. 
    * 
    * However, for read-only dependency properties, the component can access
    * the dependencies directly as shown in the example below for
    * PartitionedCache dependencies.  The advantage to this technique is that
    * the property only exists in the dependencies object, it is not duplicated
    * in the component properties.
    * 
    * PartitionedCacheDependencies deps = (PartitionedCacheDependencies)
    * getDependencies();
    * deps.getFoo();
    * 
     */
    protected void onDependencies(com.tangosol.net.ServiceDependencies deps)
        {
        // import com.tangosol.coherence.config.Config;
        // import com.tangosol.io.DeltaCompressor;
        // import com.tangosol.internal.net.service.grid.PartitionedCacheDependencies;
        // import com.tangosol.util.NullImplementation;
        // import com.tangosol.util.SparseArray;
        // import com.oracle.coherence.common.internal.Platform;
        
        super.onDependencies(deps);
        
        PartitionedCacheDependencies partitionedDeps = (PartitionedCacheDependencies) deps;
        
        setBackupCountOpt(partitionedDeps.getBackupCountAfterWriteBehind());
        setLeaseGranularity(partitionedDeps.getLeaseGranularity());
        setStrictPartitioning(partitionedDeps.isStrictPartitioning());
        setStandardLeaseMillis(partitionedDeps.getStandardLeaseMillis());
        
        DeltaCompressor compressor = partitionedDeps.getDeltaCompressor();
        setEventDeltaCompressor(compressor);
        // COH-5548: use a null compressor when backup-count-after-writebehind is 0 because
        //           the backup-map may not have the value
        setBackupDeltaCompressor(partitionedDeps.getBackupCountAfterWriteBehind() == 0
            ? NullImplementation.getDeltaCompressor()
            : compressor);
        
        int cDaemons = deps.getWorkerThreadCountMin();
        SparseArray[] alaPending = new SparseArray[
            cDaemons == 0
                ? 1
                : 3 * (cDaemons > 0 ? cDaemons : Platform.getPlatform().getFairShareProcessors())];
        for (int i = 0, c = alaPending.length; i < c; ++i)
            {
            alaPending[i] = new SparseArray();
            }
        setPendingResultInfo(alaPending);
        }
    
    // Declared at the super level
    /**
     * Event notification called right before the daemon thread terminates. This
    * method is guaranteed to be called only once and on the daemon's thread.
     */
    protected void onExit()
        {
        releaseAllCache();
        releaseAllStorage();
        
        // Note: calling super will release client threads which should be done after 
        //       releasing storage 
        super.onExit();
        
        getEventsHelper().unregisterServiceDispatcher();
        
        getRequestCoordinator().clearBacklog();
        }
    
    // Declared at the super level
    /**
     * Called when the service is AcceptingOthers.
    * 
    * Note: specializations of this event *must* either call this implemenation
    * via super or call setAcceptingClients(true) to notify any clients waiting
    * for the service to start.
     */
    protected void onFinalizeStartup()
        {
        // import com.tangosol.net.partition.PartitionSet;
        
        // initialize partition based data structures after service config validation
        // and prior to accepting clients
        if (isOwnershipEnabled())
            {
            setIndexPendingPartitions(new PartitionSet(getPartitionCount()));
            setIndexProcessingPartitions(new PartitionSet(getPartitionCount()));
            }
        
        super.onFinalizeStartup();
        
        // ensureKnownStorage() should only be called after AcceptingClients flag is set
        // to true, at which point the client thread performing the service "start" sequence
        // is notified, allowing it to release all acquired monitors (cluster, service, etc).
        // This is critical, since the backing map instantiation caused by ensureKnownStorage()
        // call may attempt to acquire synchronization on the cluster and/or service.
        //
        // While the client thread is now free to perform cache requests, those calls will be
        // blocked waiting for a response from the StorageIdRequest poll until the known storages
        // are initialized below (since We are running on the service thread).
        
        getEventsHelper().onServiceStarted();
        
        if (isOwnershipEnabled())
            {
            ensureKnownStorage();
            }
        }
    
    /**
     * Called on the service or a daemon pool thread.
     */
    public void onGetAllRequest(PartitionedCache.GetAllRequest msgRequest)
        {
        // import com.tangosol.internal.util.LockContentionException;
        // import com.tangosol.net.GuardSupport;
        // import com.tangosol.net.partition.PartitionSet;
        // import com.tangosol.net.security.StorageAccessAuthorizer as com.tangosol.net.security.StorageAccessAuthorizer;
        // import com.tangosol.util.Binary;
        // import com.tangosol.util.ChainedCollection;
        // import com.tangosol.util.ChainedMap;
        // import com.tangosol.util.NullImplementation;
        // import java.util.Collections;
        // import java.util.Collection;
        // import java.util.Iterator;
        // import java.util.Map;
        // import java.util.Map$Entry as java.util.Map.Entry;
        
        PartitionedCache.PartialMapResponse msgResponse = (PartitionedCache.PartialMapResponse) instantiateMessage("PartialMapResponse");
        msgResponse.respondTo(msgRequest);
        
        Storage storage = validateRequestForStorage(msgRequest, msgResponse, false);
        if (storage == null)
            {
            return;
            }
        
        Collection colKeys = msgRequest.getKeySetSafe();  // the keys are sorted (see KeySetRequest#instantiateKeySet)
        int        cKeys   = colKeys.size();
        int        cbLimit = msgRequest.getSizeThreshold();
        int        cStatus = 0;
        
        Map          mapPartKeys   = splitKeysByPartition(colKeys.iterator());
        PartitionSet partsPinned   = instantiatePartitionSet(/*fFill*/ false);
        PartitionSet partsRejected = null;
        boolean      fBackupRead   = !msgRequest.isCoherentResult();
        
        // pin partitions where necessary
        for (Iterator iter = mapPartKeys.keySet().iterator(); iter.hasNext(); )
            {
            int iPart = ((Integer) iter.next()).intValue();
        
            if (isPrimaryOwner(iPart) && pinOwnedPartition(iPart))
                {
                partsPinned.add(iPart);
                }
            else if (!fBackupRead || !isBackupOwner(iPart))
                {
                if (partsRejected == null)
                    {
                    partsRejected = instantiatePartitionSet(/*fFill*/ false);
                    }
                    
                partsRejected.add(iPart);
        
                colKeys.removeAll((Collection) mapPartKeys.get(Integer.valueOf(iPart)));
                }
            }
        
        // adjust the set of keys if reading from backup
        if (fBackupRead)
            {
            if (!partsPinned.isEmpty())
                {
                // mixed-mode: client requested 'incoherent reads' however we became
                // primary for some of the targetted partitions
        
                Collection[] acol = new Collection[partsPinned.cardinality()];
                for (int iPart = partsPinned.next(0), i = 0; iPart >= 0; iPart = partsPinned.next(iPart + 1))
                    {
                    acol[i++] = (Collection) mapPartKeys.remove(Integer.valueOf(iPart));
                    }
                colKeys = acol.length == 1 ? acol[0] : new ChainedCollection(acol);
                }
            }
        
        // lock all keys for primary partitions
        PartitionedCache.InvocationContext ctxInvoke = ensureInvocationContext();
        try
            {
            while (true)
                {
                Iterator iterKeys = fBackupRead && partsPinned.isEmpty()
                            ? NullImplementation.getIterator() : colKeys.iterator();
                try
                    {
                    while (iterKeys.hasNext())
                        {
                        // lock all the keys in the getAll request and prepare 
                        ctxInvoke.lockEntry(storage, (Binary) iterKeys.next(), /*fEnter*/ false);
                        }
        
                    break; // user-space request complete
                    }
                catch (LockContentionException e)
                    {
                    // this request was involved in a deadlock; release acquired
                    // locks allowing the winning thread to acquire all locks and
                    // subsequently re-request the locks
                    ctxInvoke.rollback(e, msgRequest);
                    }
                }
        
            ctxInvoke.getPrePinnedPartitions().add(partsPinned);
        
            ctxInvoke.prepareAccess(msgRequest.getRequestContext(), storage,
                Storage.BinaryEntry.ACCESS_READ_ANY, com.tangosol.net.security.StorageAccessAuthorizer.REASON_GET);
        
            Map mapResult = Collections.emptyMap();
        
            // get data from primary
            if (!partsPinned.isEmpty())
                {
                mapResult = storage.getAll(ctxInvoke, colKeys);
                }
        
            // less common case of backup read
            if (fBackupRead && !mapPartKeys.isEmpty())
                {
                if (partsRejected == null)
                    {
                    partsRejected = instantiatePartitionSet(/*fFill*/ false);
                    }
        
                Map mapTemp = storage.getAllFromBackup(mapPartKeys, partsRejected);
        
                mapResult = mapResult.isEmpty()
                    ? mapTemp
                    : new ChainedMap(mapResult, mapTemp);
                }
        
            int      cResult   = mapResult.size();
            int      cEntries  = 0;
            int      cbSize    = 0;
            Binary[] abinKey   = new Binary[cResult];
            Binary[] abinVal   = new Binary[cResult];
            
            for (Iterator iter = mapResult.entrySet().iterator(); iter.hasNext(); )
                {
                java.util.Map.Entry  entry  = (java.util.Map.Entry) iter.next();
                Binary binKey = (Binary) entry.getKey();
                Binary binVal = (Binary) entry.getValue();
        
                abinKey[cEntries] = binKey;
                abinVal[cEntries] = binVal;
                ++cEntries;
        
                if (cbLimit != 0)
                    {
                    cbSize += binKey.length() + binVal.length();
                    if (cbSize > cbLimit)
                        {
                        break;
                        }
                    }
                }
        
            msgResponse.setKey  (abinKey);
            msgResponse.setValue(abinVal);
            msgResponse.setSize (cEntries);
            msgResponse.setRejectPartitions(partsRejected);
            }
        catch (Throwable e)
            {
            msgResponse.setException(tagException(e));
            }
        
        // COH-22088: if the thread was interrupted due to the guardian we must reset
        //            (heartbeat and clear the interrupt bit) to avoid an exception when
        //            invoking an interruptible method
        GuardSupport.reset();
        
        // even if there was an exception, we need to backup potential changes
        // (synthetic inserts caused by read-through)
        processChanges(null, null, msgRequest.getCacheId(),
                ctxInvoke.getEntryStatuses(),
                instantiateBatchContext(msgResponse));
        
        releaseInvocationContext(ctxInvoke);
        
        msgRequest.setProcessedPartitions(partsPinned);
        
        unpinPartitions(partsPinned);
        }
    
    /**
     * Called on the service or a daemon pool thread.
     */
    public void onGetRequest(PartitionedCache.GetRequest msgRequest)
        {
        // import Component.Net.RequestContext as com.tangosol.coherence.component.net.RequestContext;
        // import com.tangosol.net.GuardSupport;
        // import com.tangosol.net.security.StorageAccessAuthorizer as com.tangosol.net.security.StorageAccessAuthorizer;
        // import com.tangosol.util.Binary;
        // import java.util.Collection;
        // import java.util.Map;
        
        PartitionedCache.Response msgResponse = (PartitionedCache.Response) instantiateMessage("Response");
        msgResponse.respondTo(msgRequest);
        
        Storage storage = validateRequestForStorage(msgRequest, msgResponse, false);
        if (storage == null)
            {
            return;
            }
        
        PartitionedCache.InvocationContext ctxInvoke = ensureInvocationContext();
        com.tangosol.coherence.component.net.RequestContext            context   = msgRequest.getRequestContext();
        Binary             binKey    = msgRequest.getKey();
        Storage.EntryStatus       status    = null;
        
        int     iPart   = getKeyPartition(binKey);
        boolean fBackup = !msgRequest.isCoherentResult() && isBackupOwner(iPart);
        try
            {
            // Note: we need to lock the key prior to get(), as our get() is
            //       a mutation as it can cause a read-through insertion
            status = fBackup ? null : ctxInvoke.lockEntry(storage, binKey, isConcurrent());
        
            Binary binValue = Binary.NO_BINARY;
        
            while (binValue == Binary.NO_BINARY ||
                   status == null && !fBackup)
                {
                if (status == null && !fBackup)
                    {
                    msgResponse.setResult(PartitionedCache.Response.RESULT_RETRY);
                    post(msgResponse);
                    return;
                    }
        
                binValue = fBackup
                        ? storage.getFromBackup(binKey)
                        : storage.get(ctxInvoke, status, binKey);
        
                fBackup &= isBackupOwner(iPart);
                }
        
            // a "get" request could result in a load or expiry
            msgResponse.setValue(binValue);
        
            com.tangosol.net.security.StorageAccessAuthorizer authorizer = storage.getAccessAuthorizer();
            if (authorizer != null)
                {
                authorizer.checkRead(storage.instantiateBinaryEntry(binKey, binValue, true),
                    context == null ? null : context.getSubject(), com.tangosol.net.security.StorageAccessAuthorizer.REASON_GET);
                }
        
            msgRequest.setProcessedPartition(getKeyPartition(binKey));
            }
        catch (Throwable e)
            {
            msgResponse.setResult(PartitionedCache.Response.RESULT_FAILURE);
            msgResponse.setValue(tagException(e));
            }
        
        // COH-22088: if the thread was interrupted due to the guardian we must reset
        //            (heartbeat and clear the interrupt bit) to avoid an exception when
        //            invoking an interruptible method
        GuardSupport.reset();
        
        Collection colStatus = ctxInvoke.getEntryStatuses();
        if (colStatus.size() == 1)
            {
            // optimized single-entry path
            processChanges(context, binKey, status, msgRequest.getCacheId(), msgResponse);
            }
        else
            {
            // a rare scenario of other entries enlisted by the get operation
            processChanges(context, null, msgRequest.getCacheId(), colStatus,
                    instantiateBatchContext(msgResponse));
            }
        
        releaseInvocationContext(ctxInvoke);
        }
    
    /**
     * Called on the service or a daemon pool thread.
     */
    public void onIndexRequest(PartitionedCache.IndexRequest msgRequest)
        {
        // import Component.Net.RequestContext;
        // import com.tangosol.net.partition.PartitionSet;
        // import com.tangosol.util.ValueExtractor as com.tangosol.util.ValueExtractor;
        // import com.tangosol.util.comparator.SafeComparator;
        // import java.util.Comparator;
        
        PartitionedCache.Response msgResponse = (PartitionedCache.Response) instantiateMessage("Response");
        msgResponse.respondTo(msgRequest);
        
        Storage storage = validateRequestForStorage(msgRequest, msgResponse, false);
        if (storage == null)
            {
            return;
            }
        
        try
            {
            Comparator comparator = msgRequest.getComparator();
            com.tangosol.util.ValueExtractor  extractor  = msgRequest.getExtractor();
            boolean    fAdd       = msgRequest.isAdd();
        
            // ensure a Comparator object for sorted indices, or null otherwise
            comparator = msgRequest.isOrdered()
                    ? comparator == null ? SafeComparator.INSTANCE : comparator
                    : null;
        
            // no need to pin - we are on the service thread
            PartitionSet   partsMask = calculatePartitionSet(getThisMember(), 0);
            RequestContext context   = msgRequest.getRequestContext();
            if (fAdd)
                {
                storage.addIndex(context, partsMask, extractor, comparator);
                }
            else
                {
                storage.removeIndex(context, partsMask, extractor, comparator);
                }
        
            msgResponse.setValue(partsMask);
        
            // COH-9878: always relay the request to avoid missing or partial index
            if (getThisMember() == getOwnershipSenior())
                {
                // response posted on poll completion
                msgRequest.relayRequest(msgResponse);
                return;
                }
            }
        catch (Throwable e)
            {
            msgResponse.setResult(PartitionedCache.Response.RESULT_FAILURE);
            msgResponse.setValue(tagException(e));
            }
        
        post(msgResponse);
        }
    
    // Declared at the super level
    /**
     * The "component has been initialized" method-notification (kind of
    * WM_NCCREATE event) called out of setConstructed() for the topmost
    * component and that in turn notifies all the children. <p>
    * 
    * This notification gets called before the control returns back to this
    * component instantiator (using <code>new Component.X()</code> or
    * <code>_newInstance(sName)</code>) and on the same thread. In addition,
    * visual components have a "posted" notification <code>onInitUI</code> that
    * is called after (or at the same time as)  the control returns back to the
    * instatiator and possibly on a different thread.
     */
    public void onInit()
        {
        // import com.tangosol.coherence.config.Config;
        
        super.onInit();
        
        setBinaryEntryConverter(new PartitionedCache.EventsHelper.BinaryEntryConverter());
        setEventsHelper((PartitionedCache.EventsHelper) _findChild("EventsHelper"));
        setLazyLookupReadBuffer((PartitionedCache.LazyLookup) _findChild("LazyLookup"));
        setRequestCoordinator((PartitionedCache.RequestCoordinator) _findChild("RequestCoordinator"));
        setResourceCoordinator((PartitionedCache.ResourceCoordinator) _findChild("ResourceCoordinator"));
        setTaskSplitThreshold(Integer.parseInt(Config.getProperty("coherence.distributed.tasksplitthreshold", "1")));
        setScheduledBackupsThreshold(Integer.parseInt(Config.getProperty("coherence.distributed.scheduledbackupsthreshold", "60")));
        setMaxPartialResponseSize(Config.getMemorySize("coherence.distributed.max.response.size", "1m"));
        setEventResendInterval(Config.getDuration("coherence.distributed.event.resend.interval", new Duration("30s")).as(Duration.Magnitude.MILLI));
        }

    // Declared at the super level
    /**
     * Event notification for performing low frequency periodic maintenance
    * tasks.  The interval is dictated by the WaitMillis property, 
    * 
    * This is used for tasks which have a high enough cost that it is not
    * reasonable to perform them on every call to onWait() since it could be
    * called with a high frequency in the presence of work-loads with fast
    * oscillation between onWait() and onNotify().  As an example a single
    * threaded client could produce such a load.
     */
    protected void onInterval()
        {
        super.onInterval();

        getRequestCoordinator().onInterval();

        // on some environments the "NotifyDelivery" ack may become lost or be
        // held up (e.g.: hundreds of ViewCache clients with heavy writes)
        // the following attempts to get stuck events "unstuck" by re-sending
        // the oldest and hopefully cause a chain of events to clear the
        // pending events long array which can become clogged on backup members
        // due to said clean-up being solely based on oldest ack'ed event.
        LongArray laPending = getPendingEvents();
        if (laPending == null) // used in getOldestPendingEventSUID
            {
            return;
            }

        long ldtNow      = Base.getSafeTimeMillis();
        long lOldestSUID = getOldestPendingEventSUID();

        if (ldtNow > getOldestEventResendNextMillis())
            {
            if (lOldestSUID > 0 &&
                m_lOldestSUIDtemp == lOldestSUID &&
                getSUIDCounter(PartitionedCache.SUID_EVENT).get() - lOldestSUID > 100) // 100+ events behind for a cycle
                {
                PartitionedCache.MapEvent msgEvent = (PartitionedCache.MapEvent) laPending.get(lOldestSUID);

                if (msgEvent != null && !msgEvent.isDelivered())
                    {
                    msgEvent.setNotifyDelivery(true);
                    post(msgEvent);
                    }
                }
            m_lOldestSUIDtemp = lOldestSUID; // keep track of movement
            setOldestEventResendNextMillis(ldtNow + getEventResendInterval());
            }
        }

    private long m_lOldestSUIDtemp = -1;
    
    /**
     * Called on the service thread only.
     */
    public void onInvokeAllRequest(PartitionedCache.InvokeAllRequest msgRequest)
        {
        // import Component.Net.RequestContext as com.tangosol.coherence.component.net.RequestContext;
        // import Component.Util.Daemon.QueueProcessor.Service.Grid.PartitionedService$PinningIterator as com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.PinningIterator;
        // import com.tangosol.internal.util.HeuristicCommitException;
        // import com.tangosol.internal.util.LockContentionException;
        // import com.tangosol.net.GuardSupport;
        // import com.tangosol.net.partition.PartitionSet;
        // import com.tangosol.net.security.StorageAccessAuthorizer as com.tangosol.net.security.StorageAccessAuthorizer;
        // import com.tangosol.util.Binary;
        // import com.tangosol.util.InvocableMap$EntryProcessor as com.tangosol.util.InvocableMap.EntryProcessor;
        // import com.tangosol.util.KeyValueArrayMap;
        // import java.util.Collections;
        // import java.util.Iterator;
        // import java.util.Map;
        // import java.util.Map$Entry as java.util.Map.Entry;
        // import java.util.Set;
        
        PartitionedCache.PartialMapResponse msgResponse = (PartitionedCache.PartialMapResponse) instantiateMessage("PartialMapResponse");
        msgResponse.respondTo(msgRequest);
        
        Storage storage = validateRequestForStorage(msgRequest, msgResponse, true);
        if (storage == null)
            {
            return;
            }
        
        Set         setKeys      = msgRequest.getKeySetSafe();
        Object[]    aoKeyPrev    = null;
        Object[]    aoValPrev    = null;
        int         cKeys        = setKeys.size();
        int         cEntriesPrev = 0;
        com.tangosol.coherence.component.net.RequestContext     context      = msgRequest.getRequestContext();
        PartitionedCache.ResultInfo resultInfo   = getResultInfo(context);
        
        if (resultInfo != null)
            {
            Map mapPrev = resultInfo.extractResults(getKeyPartitions(setKeys));
            if (mapPrev != null)
                {
                // agent previously executed on some partitions; merge the previous results
                cEntriesPrev = mapPrev.size();
                aoKeyPrev    = new Object[cEntriesPrev];
                aoValPrev    = new Object[cEntriesPrev];
        
                int i = 0;
                for (Iterator iter = mapPrev.entrySet().iterator(); iter.hasNext(); )
                    {
                    java.util.Map.Entry  entry = (java.util.Map.Entry) iter.next();
                    Object oKey  = entry.getKey();       
        
                    aoKeyPrev[i]   = oKey;              // Binary key
                    aoValPrev[i++] = entry.getValue();  // Binary result (may be null)
                    setKeys.remove(oKey);
                    }
        
                if (setKeys.isEmpty())
                    {
                    // all partitions have been executed; nothing more to do
                    msgResponse.setSize (cEntriesPrev);
                    msgResponse.setKey  (aoKeyPrev);
                    msgResponse.setValue(aoValPrev);
        
                    post(msgResponse);
                    return;
                    }
                }
            }
        
        // prepare the key and result arrays
        int      cEntries = 0;                 // number of keys to submit to invokeAll
        int      cResults = 0;                 // number of actual results
        Binary[] aoKey    = new Binary[cKeys];
        Object[] aoVal    = new Object[cKeys]; // converted invocation result
        Object[] aoStatus = null;
        Object[] aoResult = null;
        
        // no need to sort before pinning; either the service is not concurrent,
        // or the underlying set implementation is sorted;
        // see PartitionedCache.InvokeAllRequest.instantiateKeySet
        com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.PinningIterator pinner = createPinningIterator(setKeys, msgRequest.getOwnershipVersions());
        
        while (pinner.hasNext())
            {
            aoKey[cEntries++] = (Binary) pinner.next();
            }
        
        PartitionSet       partsPinned = pinner.getPinnedPartitions();
        PartitionedCache.InvocationContext ctxInvoke   = ensureInvocationContext(partsPinned);
        try
            {
            ctxInvoke.prepareAccess(context, storage,
                Storage.BinaryEntry.ACCESS_WRITE_ANY, com.tangosol.net.security.StorageAccessAuthorizer.REASON_INVOKE);
        
            while (true)
                {
                com.tangosol.util.InvocableMap.EntryProcessor agent = msgRequest.deserializeProcessor();
                try
                    {
                    // lock all of the keys to be submitted to the invocation.
                    aoStatus = ctxInvoke.lockEntries(storage, aoKey, cEntries);
        
                    // do the invocation
                    storage.invokeAll(ctxInvoke, aoStatus, 0, cEntries, agent);
        
                    break; // user-space request complete
                    }
                catch (LockContentionException e)
                    {
                    // this request was involved in a deadlock; release acquired
                    // locks allowing the winning thread to acquire all locks and
                    // subsequently re-request the locks
                    ctxInvoke.rollback(e, msgRequest, "processor = " + agent.getClass().getName());
                    msgRequest.setProcessor(null); // force the creation of a new EP
                    }
                }
        
            // Note: we executed user code without exception thus maintain any
            //       results to ensure the request is idempotent
            aoResult = aoVal;
        
            // collect the results
            for (int i = 0; i < cEntries; i++)
                {
                // Note: result could be null if the result map returned by the
                //       entry processor does not include all keys
                Storage.EntryStatus status = (Storage.EntryStatus) aoStatus[i];
        
                aoKey   [cResults]   = status.getKey();
                aoResult[cResults++] = status.getResult();
                }
            }
        catch (HeuristicCommitException e)
            {
            // unrecoverable backing map exception
            if (isExiting())
                {
                // the service is stopped, we can ignore it;
                // the client will re-try the operation
                return;
                }
        
            onPartialCommit(msgResponse, e);
            }
        catch (Throwable e)
            {
            // this exception should be set right away since
            // the response could be sent back on a different thread
            msgResponse.setException(tagException(e));
            msgResponse.setFailedKeys(
                collectResultOnException(null, aoStatus, aoKey, 0, cEntries, e));
            }
        
        if (cEntriesPrev > 0)
            {
            // merge results
            System.arraycopy(aoKeyPrev, 0, aoKey, cResults, cEntriesPrev);
            System.arraycopy(aoValPrev, 0, aoResult, cResults, cEntriesPrev);
            }
        
        msgResponse.setSize(cResults + cEntriesPrev);
        msgResponse.setKey(aoKey);
        msgResponse.setValue(aoResult);
        msgResponse.setRejectPartitions(pinner.getRejectedPartitions());
        
        // COH-22088: if the thread was interrupted due to the guardian we must reset
        //            (heartbeat and clear the interrupt bit) to avoid an exception when
        //            invoking an interruptible method
        GuardSupport.reset();
        
        ctxInvoke.resetAccess();
        
        // register the results for the partitions that were executed
        registerMultiResult(context, partsPinned, aoResult == null
                ? Collections.emptyMap()
                : new KeyValueArrayMap(aoKey, 0, aoResult, 0, cResults));
        
        // even if there was an exception we need to backup the changes
        processChanges(context, null, msgRequest.getCacheId(),
                ctxInvoke.getEntryStatuses(), instantiateBatchContext(msgResponse));
        
        // only now, after the backup message is sent, we can unlock (COH-3304)
        releaseInvocationContext(ctxInvoke);
        
        msgRequest.setProcessedPartitions(partsPinned);
        
        // lastly, exit the partitions
        unpinPartitions(partsPinned);
        }
    
    /**
     * Called on a daemon pool thread only. Job objects are used exclusively for
    * the invokeAll() request.
     */
    public void onInvokeAllRequest(PartitionedCache.InvokeAllRequest.InvokeJob job)
        {
        // import Component.Net.RequestContext as com.tangosol.coherence.component.net.RequestContext;
        // import com.tangosol.internal.util.HeuristicCommitException;
        // import com.tangosol.internal.util.LockContentionException;
        // import com.tangosol.net.GuardSupport;
        // import com.tangosol.net.security.StorageAccessAuthorizer as com.tangosol.net.security.StorageAccessAuthorizer;
        // import com.tangosol.util.Binary;
        // import com.tangosol.util.InvocableMap$EntryProcessor as com.tangosol.util.InvocableMap.EntryProcessor;
        // import com.tangosol.util.KeyValueArrayMap;
        // import java.util.Collections;
        // import java.util.Iterator;
        // import java.util.Map;
        // import java.util.Map$Entry as java.util.Map.Entry;
        
        PartitionedCache.PartialMapResponse msgResponse = (PartitionedCache.PartialMapResponse) job.getResponse();
        
        int      iPartition  = job.getPartition();
        Map      mapJob      = job.getMap(); // <Binary, null>
        com.tangosol.coherence.component.net.RequestContext  context     = job.getRequestContext();
        int      cKeys       = mapJob.size();
        boolean  fEntered    = pinOwnedPartition(iPartition, job.getOwnershipVersion());
        long     lCacheId    = job.getCacheId();
        Storage storage     = getKnownStorage(lCacheId);
        
        try
            {
            if (storage == null || !fEntered)
                {
                msgResponse.rejectPartition(iPartition);
        
                synchronized (msgResponse)
                    {
                    // adjust the response size
                    msgResponse.setSize(msgResponse.getSize() - cKeys);
                    }
        
                // call processChanges to respond to the client with rejection
                processChanges(context, job, lCacheId, null, job.getBatchContext());
                return;
                }
        
            int      iL    = job.getResultIndex();
            int      iR    = iL;
            Object[] aoKey = msgResponse.getKey();
            Object[] aoVal = msgResponse.getValue();  // converted invocation result
        
            PartitionedCache.ResultInfo resultInfo = getResultInfo(context);
            Map         mapPrev    = resultInfo == null ? null : resultInfo.extractResults(iPartition);
            if (mapPrev != null)
                {
                // agent previously executed on this partition; use the previous results
                //
                for (Iterator iter = mapPrev.entrySet().iterator(); iter.hasNext(); )
                    {
                    java.util.Map.Entry entry = (java.util.Map.Entry) iter.next();
                    aoKey[iR]   = entry.getKey();    // Binary key
                    aoVal[iR++] = entry.getValue();  // Binary result (may be null)
                    }
        
                int cResultsPrev = mapPrev.size();
                if (cResultsPrev != cKeys)
                    {
                    // the EP (previously) returned a result map missing results for
                    // some keys; adjust the response size accordingly
                    synchronized (msgResponse)
                        {
                        msgResponse.setSize(msgResponse.getSize() - (cKeys - cResultsPrev));
                        }
                    }
        
                // call processChanges to signal the job completion
                processChanges(context, job, lCacheId, null, job.getBatchContext());
                return;
                }
        
            // prepare the response key array
            for (Iterator iter = mapJob.keySet().iterator(); iter.hasNext(); )
                {
                aoKey[iR++] = (Binary) iter.next();
                }
        
            // reuse the aoVal array to avoid the cost of the additional allocation;
            Object[] aoStatus = aoVal; 
            Object[] aoResult = null;
        
            // COH-3421: lock attempts must be protected from exceptions
            PartitionedCache.InvocationContext ctxInvoke = ensureInvocationContext(iPartition);
            try
                {
                ctxInvoke.prepareAccess(job.getRequestContext(), storage,
                    Storage.BinaryEntry.ACCESS_WRITE_ANY, com.tangosol.net.security.StorageAccessAuthorizer.REASON_INVOKE);
        
                while (true)
                    {
                    com.tangosol.util.InvocableMap.EntryProcessor agent = job.deserializeProcessor();
                    try
                        {
                        // lock all of the keys to be submitted to the invocation.
                        // Note: the job map is sorted in key order
                        for (int i = iL; i < iR; i++)
                            {
                            aoStatus[i] = ctxInvoke.lockEntry(storage, (Binary) aoKey[i], false);
                            }
        
                        // do the invocation
                        storage.invokeAll(ctxInvoke, aoStatus, iL, iR, agent);
        
                        break; // user-space request complete
                        }
                    catch (LockContentionException e)
                        {
                        // this request was involved in a deadlock; release acquired
                        // locks allowing the winning thread to acquire all locks and
                        // subsequently re-request the locks
                        ctxInvoke.rollback(e, job.getRequest(), "processor = " + agent.getClass().getName());
                        job.setProcessor(null); // force the creation of a new EP
                        }
                    }
        
                // Note: we executed user code without exception thus maintain any
                //       results to ensure the request is idempotent
                aoResult = aoStatus;
        
                // collect the results
                for (int i = iL; i < iR; i++)
                    {
                    // Note: result could be null if the result map returned by the
                    //       entry processor does not include all keys
                    Storage.EntryStatus status = (Storage.EntryStatus) aoStatus[i];
                    aoResult[i] = status == null ? null : status.getResult();
                    }
                }
            catch (HeuristicCommitException e)
                {
                // unrecoverable backing map exception
                if (isExiting())
                    {
                    // the service is stopped, we can ignore it;
                    // the client will re-try the operation
                    return;
                    }
        
                onPartialCommit(msgResponse, e);
                }
            catch (Throwable e)
                {
                msgResponse.setException(tagException(e));
        
                synchronized (msgResponse)
                    {
                    msgResponse.setFailedKeys(collectResultOnException(
                        msgResponse.getFailedKeys(), aoStatus, aoKey, iL, iR, e));
                    }
                }
        
            // COH-22088: if the thread was interrupted due to the guardian we must reset
            //            (heartbeat and clear the interrupt bit) to avoid an exception when
            //            invoking an interruptible method
            GuardSupport.reset();
        
            ctxInvoke.resetAccess();
        
            // register the results
            registerMultiResult(context, iPartition, aoResult == null
                    ? Collections.emptyMap()
                    : new KeyValueArrayMap(aoKey, iL, aoResult, iL, iR - iL));
        
            // even if there was an exception, we need to backup the changes
            processChanges(context, job, lCacheId, ctxInvoke.getEntryStatuses(), job.getBatchContext());
        
            // only now, after the backup message is sent, we can unlock (COH-3304)
            releaseInvocationContext(ctxInvoke);
            }
        finally
            {
            if (fEntered)
                {
                unpinPartition(iPartition);
                }
            }
        }
    
    /**
     * Called on the service or a daemon pool thread.
     */
    public void onInvokeFilterRequest(PartitionedCache.InvokeFilterRequest msgRequest)
        {
        // import Component.Net.RequestContext as com.tangosol.coherence.component.net.RequestContext;
        // import com.tangosol.internal.util.HeuristicCommitException;
        // import com.tangosol.internal.util.LockContentionException;
        // import com.tangosol.internal.util.QueryResult;
        // import com.tangosol.net.GuardSupport;
        // import com.tangosol.net.partition.PartitionSet;
        // import com.tangosol.net.security.StorageAccessAuthorizer as com.tangosol.net.security.StorageAccessAuthorizer;
        // import com.tangosol.util.Binary;
        // import com.tangosol.util.EntrySetMap;
        // import com.tangosol.util.Filter;
        // import com.tangosol.util.ImmutableArrayList;
        // import com.tangosol.util.InvocableMap$EntryProcessor as com.tangosol.util.InvocableMap.EntryProcessor;
        // import com.tangosol.util.SimpleMapEntry;
        // import java.util.Collections;
        // import java.util.Map;
        
        PartitionedCache.QueryResponse msgResponse = (PartitionedCache.QueryResponse) instantiateMessage("QueryResponse");
        msgResponse.respondTo(msgRequest);
        
        Storage storage = validateRequestForStorage(msgRequest, msgResponse, true);
        if (storage == null)
            {
            return;
            }

        com.tangosol.coherence.component.net.RequestContext      context      = msgRequest.getRequestContext();
        PartitionSet partMask     = msgRequest.getRequestMaskSafe();
        PartitionedCache.ResultInfo  resultInfo   = getResultInfo(context);
        Map          mapPrev      = resultInfo == null ? null : resultInfo.extractResults(partMask);
        Object[]     aoResultPrev = mapPrev == null ? null : mapPrev.entrySet().toArray();
        int          cResultsPrev = aoResultPrev == null ? 0 : aoResultPrev.length;
        
        if (partMask.isEmpty())
            {
            // all partitions have previous results; nothing more to do
            msgResponse.setResult(aoResultPrev);
            msgResponse.setSize(cResultsPrev);
            post(msgResponse);
            return;
            }
        
        flushOOBEvents();
        
        PartitionSet partReject = pinOwnedPartitions(partMask, msgRequest.getOwnershipVersions());
        
        msgResponse.setRejectPartitions(partReject);
        
        Object[] aoResult = null;
        int      cResults = 0;
        
        PartitionedCache.InvocationContext ctxInvoke = ensureInvocationContext(partMask);
        try
            {
            ctxInvoke.prepareAccess(context, storage,
                Storage.BinaryEntry.ACCESS_WRITE_ANY, com.tangosol.net.security.StorageAccessAuthorizer.REASON_INVOKE);
        
            Object[] aoStatus = null;
            int      cEntries = 0;
            while (true)
                {
                com.tangosol.util.InvocableMap.EntryProcessor agent = msgRequest.deserializeProcessor();
                try
                    {
                    // query to find and lock the matching entries
                    QueryResult result = storage.query(msgRequest.getFilter(), Storage.QUERY_INVOKE, partMask, msgRequest.checkTimeoutRemaining());

                    aoStatus = result.getResults();
                    cEntries = result.getCount();
        
                    // invoke the entry processor on the matching entries
                    storage.invokeAll(ctxInvoke, aoStatus, 0, cEntries, agent);
        
                    break; // user-space request complete
                    }
                catch (LockContentionException e)
                    {
                    // this request was involved in a deadlock; release acquired
                    // locks allowing the winning thread to acquire all locks and
                    // subsequently re-request the locks
                    ctxInvoke.rollback(e, msgRequest, "processor = " + agent.getClass().getName());
                    msgRequest.setProcessor(null); // force the creation of a new EP
                    }
                }
        
            // Note: we executed user code without exception thus maintain any
            //       results to ensure the request is idempotent
            aoResult = aoStatus;
        
            for (int i = 0; i < cEntries; ++i)
                {
                // Note: the Storage.EntryStatus result could be null if the result map
                //       returned by processAll() didn't include all the keys
                Storage.EntryStatus status    = (Storage.EntryStatus) aoStatus[i];
                Binary       binResult = status.getResult();
                
                if (binResult != null)
                    {
                    aoResult[cResults++] =
                        new SimpleMapEntry(status.getKey(), binResult);
                    }
                }
            }
        catch (HeuristicCommitException e)
            {
            // unrecoverable backing map exception
            if (isExiting())
                {
                // the service is stopped, we can ignore it;
                // the client will re-try the operation
                return;
                }
        
            onPartialCommit(msgResponse, e);
            }
        catch (Throwable e)
            {
            // since the client didn't know what keys matched, there is
            // no reason to report what keys failed
            msgResponse.setException(tagException(e));
            }
        
        if (cResultsPrev > 0)
            {
            // merge results
            Object[] aoResultTmp = aoResult;
        
            aoResult = new Object[cResultsPrev + cResults];
            System.arraycopy(aoResultPrev, 0, aoResult, 0, cResultsPrev);
            System.arraycopy(aoResultTmp,  0, aoResult, cResultsPrev, cResults);
            }
        
        msgResponse.setResult(aoResult);
        msgResponse.setSize(cResults + cResultsPrev);
        
        // COH-22088: if the thread was interrupted due to the guardian we must reset
        //            (heartbeat and clear the interrupt bit) to avoid an exception when
        //            invoking an interruptible method
        GuardSupport.reset();
        
        ctxInvoke.resetAccess();
        
        // register the results for the partitions that were executed
        registerMultiResult(context, partMask, aoResult == null
                ? Collections.emptyMap()
                : new EntrySetMap(
                        new ImmutableArrayList(aoResult, cResultsPrev, cResults).getSet()));
        
        // even if there was an exception we need to backup the changes
        processChanges(context, null, msgRequest.getCacheId(),
                ctxInvoke.getEntryStatuses(),
                instantiateBatchContext(msgResponse));
        
        // unlock the keys in the InvocationContext
        releaseInvocationContext(ctxInvoke);
        
        msgRequest.setProcessedPartitions(partMask);
        
        // lastly, exit the partitions
        unpinPartitions(partMask);
        }
    
    /**
     * Called on the service or a daemon pool thread.
     */
    public void onInvokeRequest(PartitionedCache.InvokeRequest msgRequest)
        {
        // import Component.Net.RequestContext as com.tangosol.coherence.component.net.RequestContext;
        // import com.tangosol.internal.util.HeuristicCommitException;
        // import com.tangosol.internal.util.LockContentionException;
        // import com.tangosol.net.GuardSupport;
        // import com.tangosol.net.security.StorageAccessAuthorizer as com.tangosol.net.security.StorageAccessAuthorizer;
        // import com.tangosol.util.Base;
        // import com.tangosol.util.Binary;
        // import com.tangosol.util.InvocableMap$EntryProcessor as com.tangosol.util.InvocableMap.EntryProcessor;
        // import java.util.Collection;
        // import java.util.HashSet;
        
        PartitionedCache.Response msgResponse = (PartitionedCache.Response) instantiateMessage("Response");
        msgResponse.respondTo(msgRequest);
        
        Storage storage = validateRequestForStorage(msgRequest, msgResponse, true);
        if (storage == null)
            {
            return;
            }
        
        Binary  binKey  = msgRequest.getKey();
        com.tangosol.coherence.component.net.RequestContext context = msgRequest.getRequestContext();
        if (postPriorResult(context, binKey, msgResponse))
            {
            return;
            }
        
        int     nPartition = getKeyPartition(binKey);
        boolean fEntered   = pinOwnedPartition(nPartition, msgRequest.getOwnershipVersion());
        if (!fEntered)
            {
            // the partition is closed, unowned, an (async) client request was issued
            // based on an outdated ownership view or it's a sync request and an index
            // rebuild is pending; force the client to retry
            msgResponse.setResult(PartitionedCache.Response.RESULT_RETRY);
            post(msgResponse);
            return;
            }
        
        try
            {
            PartitionedCache.InvocationContext ctxInvoke = ensureInvocationContext(nPartition);
            Storage.EntryStatus       status    = null;
            try
                {
                while (true)
                    {
                    com.tangosol.util.InvocableMap.EntryProcessor agent = msgRequest.deserializeProcessor();
        
                    status = ctxInvoke.lockEntry(storage, binKey, false);
                    try
                        {
                        ctxInvoke.prepareAccess(context,
                            storage, 0, com.tangosol.net.security.StorageAccessAuthorizer.REASON_INVOKE);
        
                        storage.invoke(ctxInvoke, status, agent);
        
                        Binary binResult = status.getResult();
                        msgResponse.setValue(binResult);
        
                        // register the result
                        registerSingleResult(context, binKey, binResult);
        
                        msgRequest.setProcessedPartition(nPartition);
         
                        break; // user-space request complete
                        }
                    catch (LockContentionException e)
                        {
                        // this request was involved in a deadlock; release acquired
                        // locks allowing the winning thread to acquire all locks and
                        // subsequently re-request the locks
                        ctxInvoke.rollback(e, msgRequest, "processor = " + agent.getClass().getName());
                        msgRequest.setProcessor(null); // force the creation of a new EP
                        }
                    }
                }
            catch (HeuristicCommitException e)
                {
                // unrecoverable backing map exception
                if (isExiting())
                    {
                    // the service is stopped, we can ignore it;
                    // the client will re-try the operation
                    return;
                    }
        
                onPartialCommit(msgResponse, e);
                }
            catch (Throwable e)
                {
                msgResponse.setResult(PartitionedCache.Response.RESULT_FAILURE);
                msgResponse.setValue(tagException(e));
                }
        
            // COH-22088: if the thread was interrupted due to the guardian we must reset
            //            (heartbeat and clear the interrupt bit) to avoid an exception when
            //            invoking an interruptible method
            GuardSupport.reset();
        
            ctxInvoke.resetAccess();
        
            Collection colStatus = ctxInvoke.getEntryStatuses();
            if (colStatus.size() == 1)
                {
                // optimized single-update version
                processChanges(context, binKey, status, msgRequest.getCacheId(), msgResponse);
                }
            else
                {
                // general multi-key update version
        
                // preserve the invocation result
                processChanges(context, null, msgRequest.getCacheId(), colStatus,
                        instantiateBatchContext(msgResponse));
                }
        
            releaseInvocationContext(ctxInvoke);
            }
        finally
            {
            if (fEntered)
                {
                unpinPartition(nPartition);
                }
            }
        }
    
    /**
     * Called on the service or a daemon pool thread.
     */
    public void onKeyIteratorRequest(PartitionedCache.KeyIteratorRequest msgRequest)
        {
        // import com.tangosol.internal.util.QueryResult;
        // import com.tangosol.net.partition.PartitionSet;
        // import com.tangosol.net.security.StorageAccessAuthorizer as com.tangosol.net.security.StorageAccessAuthorizer;
        // import com.tangosol.util.Binary;
        
        PartitionedCache.QueryResponse msgResponse = (PartitionedCache.QueryResponse) instantiateMessage("QueryResponse");
        msgResponse.respondTo(msgRequest);
        msgResponse.setKeysOnly(true);
        
        Storage storage = validateRequestForStorage(msgRequest, msgResponse, false);
        if (storage == null)
            {
            return;
            }
        
        PartitionSet partMask = msgRequest.getRequestMaskSafe();
        
        flushOOBEvents();
        
        PartitionSet partReject = pinOwnedPartitions(partMask);
        
        try
            {
            storage.checkAccess(msgRequest.getRequestContext(),
                Storage.BinaryEntry.ACCESS_READ_ANY, com.tangosol.net.security.StorageAccessAuthorizer.REASON_KEYSET);
        
            QueryResult result = storage.query(null, Storage.QUERY_KEYS, partMask, msgRequest.checkTimeoutRemaining());
        
            msgResponse.setResult(result.getResults());
            msgResponse.setSize(result.getCount());
            msgResponse.setRejectPartitions(partReject);
            }
        catch (Throwable e)
            {
            msgResponse.setException(tagException(e));
            }
        
        processChanges(msgResponse);
        
        msgRequest.setProcessedPartitions(partMask);
        
        unpinPartitions(partMask);
        }
    
    /**
     * Called on the service thread only.
    * 
    * Note: as of Coherence 12.2.1, the KeyListenerAllRequest only comes with
    * isLite() == true, isAdd() == true and isPriming() == true.
     */
    public void onKeyListenerAllRequest(PartitionedCache.KeyListenerAllRequest msgRequest)
        {
        // import Component.Net.Member as com.tangosol.coherence.component.net.Member;
        // import Component.Net.RequestContext as com.tangosol.coherence.component.net.RequestContext;
        // import Component.Util.Daemon.QueueProcessor.Service.Grid.PartitionedService$PinningIterator as com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.PinningIterator;
        // import com.tangosol.net.partition.PartitionSet;
        // import com.tangosol.net.partition.VersionAwareMapListener as com.tangosol.net.partition.VersionAwareMapListener;
        // import com.tangosol.net.partition.VersionedPartitions;
        // import com.tangosol.net.security.StorageAccessAuthorizer as com.tangosol.net.security.StorageAccessAuthorizer;
        // import com.tangosol.internal.util.KeyIndexManager;
        // import com.tangosol.internal.util.LockContentionException;
        // import com.tangosol.util.Binary;
        // import com.tangosol.util.ChainedMap;
        // import com.tangosol.util.LongArray;
        // import com.tangosol.util.LongArray$Iterator as com.tangosol.util.LongArray.Iterator;
        // import com.tangosol.util.SetMap;
        // import com.tangosol.util.SparseArray;
        // import java.util.Arrays;
        // import java.util.HashMap;
        // import java.util.Iterator;
        // import java.util.List;
        // import java.util.Map;
        // import java.util.Map$Entry as java.util.Map.Entry;
        // import java.util.Set;
        
        PartitionedCache.PartialMapResponse msgResponse = (PartitionedCache.PartialMapResponse) instantiateMessage("PartialMapResponse");
        msgResponse.respondTo(msgRequest);
        
        Storage storage = validateRequestForStorage(msgRequest, msgResponse, false);
        if (storage == null)
            {
            return;
            }
        
        com.tangosol.coherence.component.net.RequestContext         context  = msgRequest.getRequestContext();
        Set             setKeys  = msgRequest.getKeySetSafe();
        boolean         fAdd     = msgRequest.isAdd();
        boolean         fLite    = msgRequest.isLite();
        boolean         fPriming = msgRequest.isPriming();
        com.tangosol.coherence.component.net.Member          member   = msgRequest.getFromMember();
        Binary[]        abinKey  = new Binary[setKeys.size()];
        com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.PinningIterator pinner   = createPinningIterator(setKeys);
        int             cEntries = 0;
        
        while (pinner.hasNext())
            {
            abinKey[cEntries++] = (Binary) pinner.next();
            }
        
        PartitionSet       partsPinned = pinner.getPinnedPartitions();
        PartitionedCache.InvocationContext ctxInvoke   = ensureInvocationContext(partsPinned);
        PartitionedCache.BatchContext      ctxBatch    = null;
        
        try
            {
            // key listeners could be removed asynchronously (see $BinaryMap#dispatch)
            // where the caller's context is completely lost;
            // since it doesn't really represent any security risk, don't authorize them
            if (fAdd && !fLite)
                {
                ctxInvoke.prepareAccess(context, storage,
                    Storage.BinaryEntry.ACCESS_READ_ANY, com.tangosol.net.security.StorageAccessAuthorizer.REASON_LISTENER_ADD);
                }
        
            ctxInvoke.lockEntries(storage, abinKey, cEntries);
        
            ctxBatch = instantiateBatchContext(msgResponse);
        
            if (getBackupCount() > 0)
                {
                postAll(prepareBackupListenerAllRequests(
                    storage.getCacheId(), fLite, fAdd, member, abinKey, cEntries, ctxBatch));
                }
        
             VersionedPartitions versions = msgRequest.getPartitionVersions();
        
             if ((fPriming || versions != null) && fAdd)
                {
                ctxBatch.getOutstandingOperationCounter().incrementAndGet();
        
                Map mapResult = storage.getAll(ctxInvoke, Arrays.asList(abinKey));
        
                if (fPriming)
                    {
                    // simply dispatch priming events based on the latest version
                    postEvents(storage.getPrimingEvents(member, new ChainedMap(mapResult, new SetMap(setKeys))));
                    }
                else
                    {
                    int       cParts     = partsPinned.cardinality();
                    int       cMapInit   = (mapResult.size() + cParts) / cParts;
                    LongArray laPartMaps = new SparseArray();
        
                    for (Iterator iter = mapResult.entrySet().iterator(); iter.hasNext(); )
                        {
                        java.util.Map.Entry  entry   = (java.util.Map.Entry) iter.next();
                        Binary binKey  = (Binary) entry.getKey();
                        int    iPart   = getKeyPartition(binKey);
                        Map    partMap = (Map) laPartMaps.get(iPart);
        
                        if (partMap == null)
                            {
                            laPartMaps.set(iPart, partMap = new HashMap());
                            }
        
                        partMap.put(entry.getKey(), entry.getValue());
                        }
        
                    Object oHolder = null;
                    for (com.tangosol.util.LongArray.Iterator iter = laPartMaps.iterator(); iter.hasNext(); )
                        {
                        Map  mapPart  = (Map) iter.next();
                        int  iPart    = (int) iter.getIndex();
                        long lVersion = versions.getVersion(iPart);
        
                        oHolder = lVersion == com.tangosol.net.partition.VersionAwareMapListener.PRIMING
                            ? storage.getPrimingEvents(member, mapPart)
                            : storage.getPreviousEvents(member, mapPart.keySet(), iPart, lVersion, oHolder);
                        }
                    postEvents(oHolder);
                    }
        
                processChanges(context, null, msgRequest.getCacheId(),
                    ctxInvoke.getEntryStatuses(), ctxBatch);
                }
        
            for (int i = 0; i < cEntries; i++)
                {
                Binary binKey = abinKey[i];
                if (fAdd)
                    {
                    storage.addKeyListener(member, binKey, fLite, true);
                    }
                else
                    {
                    storage.removeKeyListener(member, abinKey[i], true);
                    }
                storage.persistListenerRegistration(member, binKey, fLite, fAdd);
                }
            }
        catch (Throwable e)
            {
            msgResponse.setException(tagException(e));
            msgResponse.setFailedKeys(setKeys);
            }
        
        msgResponse.setRejectPartitions(pinner.getRejectedPartitions());
        
        if (ctxBatch != null)
            {
            ctxBatch.onJobCompleted(null);
            }
            
        // only now, after the backup message is sent, we can unlock (COH-3304)
        releaseInvocationContext(ctxInvoke);
        
        unpinPartitions(partsPinned);
        }
    
    public void onKeyListenerAllRequest(PartitionedCache.KeyListenerAllRequest.KeyListenerJob job)
        {
        // import Component.Net.Member as com.tangosol.coherence.component.net.Member;
        // import Component.Net.RequestContext as com.tangosol.coherence.component.net.RequestContext;
        // import com.tangosol.net.partition.VersionAwareMapListener as com.tangosol.net.partition.VersionAwareMapListener;
        // import com.tangosol.net.security.StorageAccessAuthorizer as com.tangosol.net.security.StorageAccessAuthorizer;
        // import com.tangosol.util.Binary;
        // import com.tangosol.util.ChainedMap;
        // import com.tangosol.util.SafeLinkedList;
        // import java.util.Collection;
        // import java.util.Iterator;
        // import java.util.Set;
        // import java.util.Map;
        
        PartitionedCache.PartialMapResponse msgResponse = (PartitionedCache.PartialMapResponse) job.getResponse();
        PartitionedCache.InvocationContext  ctxInvoke   = ensureInvocationContext();
        PartitionedCache.BatchContext       ctxBatch    = job.getBatchContext();
        
        int     iPartition = job.getPartition();
        com.tangosol.coherence.component.net.RequestContext context    = job.getRequestContext();
        long    lCacheId   = job.getCacheId();
        boolean fAdd       = job.isAdd();
        boolean fLite      = job.isLite();
        boolean fPriming   = job.isPriming();
        com.tangosol.coherence.component.net.Member  member     = job.getFromMember();
        Map     map        = job.getMap();
        Set     setKeys    = map.keySet();
        
        boolean  fEntered = pinOwnedPartition(iPartition);
        Storage storage  = getKnownStorage(lCacheId);
        
        try
            {
            if (storage == null || !fEntered)
                {
                msgResponse.rejectPartition(iPartition);
        
                // call processChanges to respond to the client with rejection
                processChanges(context, job, lCacheId, null, ctxBatch);
                return;
                }
        
            ctxInvoke.getPrePinnedPartitions().add(iPartition);
        
            // key listeners could be removed asynchronously (see $BinaryMap#dispatch)
            // where the caller's context is completely lost; since it doesn't really
            // represent any security risk, only authorize "add heavy listener" requests
            if (fAdd && !fLite)
                {
                storage.checkAccess(context,
                    Storage.BinaryEntry.ACCESS_READ_ANY, com.tangosol.net.security.StorageAccessAuthorizer.REASON_LISTENER_ADD);
                }
        
            int      cEntries = 0;
            int      cKeys    = setKeys.size();
            Binary[] abinKey  = new Binary[map.size()];
        
            // prepare the response key array
            for (Iterator iter = setKeys.iterator(); iter.hasNext(); )
                {
                abinKey[cEntries++] = (Binary) iter.next();
                }
        
            ctxInvoke.lockEntries(storage, abinKey, cEntries);
        
            Collection colStatuses = null;
            if ((fPriming || job.isVersioned()) && fAdd)
                {
                // NearCache back channel for the "getAll" - send "priming" synthetic events
        
                Map  mapResult = storage.getAll(ctxInvoke, setKeys);
                long lVersion  = job.getPartitionVersion();
        
                postEvents(fPriming || lVersion == com.tangosol.net.partition.VersionAwareMapListener.PRIMING
                    ? storage.getPrimingEvents(member, new ChainedMap(mapResult, map))
                    : storage.getPreviousEvents(member, setKeys, iPartition, lVersion, null));
        
                colStatuses = ctxInvoke.getEntryStatuses();
                }
        
            if (getBackupCount() > 0)
                {
                postAll(prepareBackupListenerAllRequests(
                    storage.getCacheId(), fLite, fAdd, member, abinKey, cKeys, ctxBatch));
                }
        
            for (int i = 0; i < cKeys; i++)
                {
                Binary binKey = abinKey[i];
                if (fAdd)
                    {
                    storage.addKeyListener(member, binKey, fLite, true);
                    }
                else
                    {
                    storage.removeKeyListener(member, binKey, true);
                    }
                storage.persistListenerRegistration(member, binKey, fLite, fAdd);
                }
            
            processChanges(context, null, lCacheId, colStatuses, ctxBatch);
            }
        catch (Throwable e)
            {
            msgResponse.setException(tagException(e));
        
            synchronized (msgResponse)
                {
                Collection colFailed = msgResponse.getFailedKeys();
                if (colFailed == null)
                    {
                    msgResponse.setFailedKeys(colFailed = new SafeLinkedList());
                    }
                colFailed.addAll(setKeys);
                }
            }
        finally
            {
            releaseInvocationContext(ctxInvoke);
        
            if (fEntered)
                {
                unpinPartition(iPartition);
                }
            }
        }
    
    /**
     * Called on the service thread only.
     */
    public void onKeyListenerRequest(PartitionedCache.KeyListenerRequest msgRequest)
        {
        // import Component.Net.Member as com.tangosol.coherence.component.net.Member;
        // import Component.Net.RequestContext as com.tangosol.coherence.component.net.RequestContext;
        // import com.tangosol.net.partition.VersionAwareMapListener as com.tangosol.net.partition.VersionAwareMapListener;
        // import com.tangosol.net.security.StorageAccessAuthorizer as com.tangosol.net.security.StorageAccessAuthorizer;
        // import com.tangosol.util.Binary;
        // import java.util.List;
        
        PartitionedCache.Response msgResponse = (PartitionedCache.Response) instantiateMessage("Response");
        msgResponse.respondTo(msgRequest);
        
        Storage storage = validateRequestForStorage(msgRequest, msgResponse, false);
        if (storage == null)
            {
            return;
            }
        
        long    lCacheId = msgRequest.getCacheId();
        com.tangosol.coherence.component.net.RequestContext context  = msgRequest.getRequestContext();
        Binary  binKey   = msgRequest.getKey();
        boolean fAdd     = msgRequest.isAdd();
        boolean fLite    = msgRequest.isLite();
        boolean fRespond = true;
        
        PartitionedCache.InvocationContext ctxInvoke = ensureInvocationContext();
        
        try
            {
            Storage.EntryStatus status = ctxInvoke.lockEntry(storage, binKey, isConcurrent());
            if (status != null)
                {
                // key listeners could be removed asynchronously (see $BinaryMap#dispatch)
                // where the caller's context is completely lost;
                // since it doesn't really represent any security risk, don't authorize them 
                if (fAdd && !fLite)
                    {
                    ctxInvoke.prepareAccess(context, storage,
                        Storage.BinaryEntry.ACCESS_READ_ANY, com.tangosol.net.security.StorageAccessAuthorizer.REASON_LISTENER_ADD);
                    }
        
                com.tangosol.coherence.component.net.Member member = msgRequest.getFromMember();
                if (fAdd)
                    {
                    storage.addKeyListener(member, binKey, fLite, true);
                    }
                else
                    {
                    storage.removeKeyListener(member, binKey, true);
                    }
        
                storage.persistListenerRegistration(member, binKey, fLite, fAdd);
        
                if ((msgRequest.isPriming() || msgRequest.isVersioned()) && fAdd)
                    {
                    // NearCache back channel for a "get" - send a "priming" synthetic event
                    Binary binValue = storage.get(ctxInvoke, status, binKey);
                    long   lVersion = msgRequest.getPartitionVersion();
        
                    com.tangosol.net.security.StorageAccessAuthorizer authorizer = storage.getAccessAuthorizer();
                    if (authorizer != null)
                        {
                        authorizer.checkRead(storage.instantiateBinaryEntry(binKey, binValue, true),
                            context == null ? null : context.getSubject(), com.tangosol.net.security.StorageAccessAuthorizer.REASON_GET);
                        }
        
                    postEvents(msgRequest.isPriming() || lVersion == com.tangosol.net.partition.VersionAwareMapListener.PRIMING
                        ? storage.getPrimingEvent(member, binKey, binValue, status.getPartition())
                        : storage.getPreviousEvents(member, binKey, status.getPartition(), lVersion));
        
                    processChanges(null, binKey, status, lCacheId, null);
                    }
        
                int  iPartition = getKeyPartition(binKey);
                long lVersion   = getPartitionControl(iPartition).getVersionCounter().incrementAndGet();
                if (getBackupCount() > 0)
                    {
                    List listBackups = getBackupOwners(binKey);
                    if (!listBackups.isEmpty())
                        {
                        PartitionedCache.BackupListenerRequest msg = (PartitionedCache.BackupListenerRequest)
                            instantiateMessage("BackupListenerRequest");
                        msg.setCacheId(lCacheId);
                        msg.setKey(binKey);
                        msg.setPartition(iPartition);
                        msg.setPartitionVersion(lVersion);
                        msg.setAdd(fAdd);
                        msg.setLite(fLite);
                        msg.setMemberId(member.getId());
                        msg.setPrimaryResponse(msgResponse);
                        msg.setMemberList(listBackups);
                        post(msg); // see $BackupListenerRequest#onRequestCompleted
        
                        fRespond &= isAsyncBackup();
                        }
                    }
                }
            else
                {
                msgResponse.setResult(PartitionedCache.Response.RESULT_RETRY);
                }
            }
        catch (Throwable e)
            {
            msgResponse.setResult(PartitionedCache.Response.RESULT_FAILURE);
            msgResponse.setValue(tagException(e));
            }
        finally
            {
            releaseInvocationContext(ctxInvoke);
            }
        
        if (fRespond)
            {
            post(msgResponse);
            }
        }
    
    /**
     * Called on the service thread only.
     */
    public void onListenerRequest(PartitionedCache.ListenerRequest msgRequest)
        {
        // import Component.Net.RequestContext as com.tangosol.coherence.component.net.RequestContext;
        // import Component.Net.Member as com.tangosol.coherence.component.net.Member;
        // import com.tangosol.net.partition.PartitionSet;
        // import com.tangosol.net.partition.VersionAwareMapListener;
        // import com.tangosol.net.partition.VersionedPartitions;
        // import com.tangosol.net.partition.VersionedPartitions$VersionedIterator as com.tangosol.net.partition.VersionedPartitions.VersionedIterator;
        // import com.tangosol.net.security.StorageAccessAuthorizer as com.tangosol.net.security.StorageAccessAuthorizer;
        // import com.tangosol.util.Filter;
        // import com.tangosol.util.MapTrigger;
        // import java.util.Collections;
        
        PartitionedCache.Response msgResponse = (PartitionedCache.Response) instantiateMessage("Response");
        msgResponse.respondTo(msgRequest);
        
        Storage storage = validateRequestForStorage(msgRequest, msgResponse, false);
        if (storage == null)
            {
            return;
            }
        
        com.tangosol.coherence.component.net.RequestContext      context    = msgRequest.getRequestContext();
        Filter       filter     = msgRequest.getFilter();
        long         lFilterId  = msgRequest.getFilterId();
        MapTrigger   trigger    = msgRequest.getTrigger();
        boolean      fAdd       = msgRequest.isAdd();
        int          nMember    = msgRequest.getMemberId();
        PartitionSet partsMask  = msgRequest.getPartitions();
        PartitionSet partsOwned = calculatePartitionSet(getThisMember(), 0,/*fCheckLocked*/ true);
        
        partsMask = partsMask == null ? partsOwned : new PartitionSet(partsMask);
        partsMask.retain(partsOwned);
        
        PartitionedCache.ResultInfo  resultInfo     = getResultInfo(context);
        PartitionSet partsProcessed = resultInfo == null ? null : resultInfo.getPartitions();
        
        if (partsProcessed != null)
            {
            partsMask.remove(partsProcessed);
            }
        
        pinOwnedPartitions(partsMask);
        
        try
            {
            if (trigger == null)
                {
                com.tangosol.coherence.component.net.Member member = getServiceMemberSet().getMember(nMember);
                if (member == null)
                    {
                    // the listening member has left in the meantime
                    _trace("Ignoring a request to " + (msgRequest.isAdd() ? "add" : "remove")
                         + " a map listener for member " + nMember + " which does not belong"
                         + " to this service", 6);
                    }
                else
                    {
                    storage.checkAccess(msgRequest.getRequestContext(), Storage.BinaryEntry.ACCESS_READ_ANY,
                        fAdd ? com.tangosol.net.security.StorageAccessAuthorizer.REASON_LISTENER_ADD : com.tangosol.net.security.StorageAccessAuthorizer.REASON_LISTENER_REMOVE);
        
                    if (fAdd)
                        {
                        boolean fLite = msgRequest.isLite();
        
                        storage.addListener(member, filter, lFilterId, fLite);
        
                        VersionedPartitions versions = msgRequest.getPartitionVersions();
                        if (versions != null && isPersistEvents())
                            {
                            // send previous events
                            for (int iPart = partsMask.next(0); iPart >= 0; iPart = partsMask.next(iPart + 1))
                                {
                                long lVersion = versions.getVersion(iPart);
        
                                postEvents(storage.getPreviousEvents(
                                    member, filter, iPart, lVersion, fLite, lFilterId, /*oHolder*/ null));
                                }
                            }
                        }
                    else
                        {
                        storage.removeListener(member, filter, lFilterId);
                        }
                    }
                }
            else // trigger != null
                {
                storage.checkAccess(msgRequest.getRequestContext(), Storage.BinaryEntry.ACCESS_WRITE_ANY,
                    fAdd ? com.tangosol.net.security.StorageAccessAuthorizer.REASON_TRIGGER_ADD : com.tangosol.net.security.StorageAccessAuthorizer.REASON_TRIGGER_REMOVE);
        
                if (fAdd)
                    {
                    storage.addTrigger(partsMask, trigger);
                    }
                else
                    {
                    storage.removeTrigger(partsMask, trigger);
                    }
        
                storage.persistTriggerRegistration(partsMask, trigger, fAdd);
                }
        
            // register the results for the partitions that were executed
            registerMultiResult(context, partsMask, Collections.emptyMap());
        
            msgResponse.setValue(resultInfo == null ? partsMask : resultInfo.getPartitions());
            }
        catch (Throwable e)
            {
            msgResponse.setResult(PartitionedCache.Response.RESULT_FAILURE);
            msgResponse.setValue(tagException(e));
            }
        
        unpinPartitions(partsMask);
        
        if (getThisMember() == getOwnershipSenior()
                && msgResponse.getResult() != PartitionedCache.Response.RESULT_FAILURE)
            {
            // response posted on poll completion
            msgRequest.relayRequest(msgResponse);
            return;
            }
        
        post(msgResponse);
        }
    
    /**
     * Called on the service or a daemon pool thread.
     */
    public void onLockRequest(PartitionedCache.LockRequest msgRequest)
        {
        // import Component.Net.Lease;
        // import com.tangosol.util.Binary;
        // import java.util.List;
        
        PartitionedCache.Response msgResponse = (PartitionedCache.Response) instantiateMessage("Response");
        msgResponse.respondTo(msgRequest);
        
        Storage storage = validateRequestForStorage(msgRequest, msgResponse, false);
        if (storage == null)
            {
            return;
            }
        
        Binary binKey = msgRequest.getKey();
        try
            {
            boolean fEnter = isConcurrent();
            if (lockKey(storage, binKey, fEnter))
                {
                Lease lease = msgRequest.toLease();
                try
                    {
                    if (storage.lock(lease))
                        {
                        int  iPartition = getKeyPartition(binKey);
                        long lVersion   = getPartitionControl(iPartition).getVersionCounter().incrementAndGet();
        
                        msgResponse.setValue(Boolean.TRUE);
        
                        if (getBackupCount() > 0)
                            {
                            List listBackups = getBackupOwners(binKey);
                            if (!listBackups.isEmpty())
                                {
                                PartitionedCache.BackupLockRequest msgBackup =
                                    (PartitionedCache.BackupLockRequest) instantiateMessage("BackupLockRequest");
                                msgBackup.setCacheId(msgRequest.getCacheId());
                                msgBackup.setKey(binKey);
                                msgBackup.setPartition(iPartition);
                                msgBackup.setPartitionVersion(lVersion);
                                msgBackup.setLock(true);
                                msgBackup.setLease(lease);
                                msgBackup.setPrimaryResponse(msgResponse);
                                msgBackup.setMemberList(listBackups);
        
                                post(msgBackup);  // see $BackupLockRequest#onRelayCompleted
                                return;
                                }
                            }
                        }
                    else
                        {
                        List listPending = storage.getPendingLockRequest();
                        synchronized (listPending)
                            {
                            if (getServiceMemberSet().contains(lease.getHolderId()))
                                {
                                // someone else holds the lease at this time
                                long lWaitTimeout = msgRequest.getLeaseWaitTimeout();
                                long lTime        = getClusterTime();
                                long lVariance    = getClusterTimeVariance();
                                if (lTime + lVariance < lWaitTimeout)
                                    {
                                    // the caller can wait
                                    listPending.add(msgRequest);
                                    if (lWaitTimeout != Long.MAX_VALUE)
                                        {
                                        scheduleLockEvaluation(lWaitTimeout - lTime);
                                        }
                                    return;
                                    }
                                }
                            }
                        msgResponse.setValue(Boolean.FALSE);
                        }
                    }
                finally
                    {
                    unlockKey(storage, binKey, fEnter);
                    }
                }
            else
                {
                msgResponse.setResult(PartitionedCache.Response.RESULT_RETRY);
                }
            }
        catch (Throwable e)
            {
            msgResponse.setResult(PartitionedCache.Response.RESULT_FAILURE);
            msgResponse.setValue(tagException(e));
            }
        
        post(msgResponse);
        }
    
    /**
     * Called on the service thread only.
     */
    public void onMapEvent(PartitionedCache.MapEvent msgEvent)
        {
        // import com.tangosol.util.Base;
        // import com.tangosol.util.LongArray;

        LongArray laProcessed    = getProcessedEvents();
        long      lEventSUID     = msgEvent.getEventSUID();
        long      lOldestPending = msgEvent.getOldestPendingEventSUID();
        int       nSender        = msgEvent.getFromMember().getId();
        int       nOriginator    = getMemberId(lEventSUID);
        long      lOldestKnown   = calculateOldestSUID(laProcessed, nOriginator);

        // Event is considered duplicate if the event SUID exists in processedArray
        // and its value is null. A non-null value implies a not-yet-received event.
        boolean fSkip = laProcessed.exists(lEventSUID) && laProcessed.get(lEventSUID) == null;
        
        if (nOriginator == nSender)
            {
            if (fSkip)
                {
                // this is only possible if we learned about the originator's departure
                // later than everybody else.  We could have already processed this event
                // (sent by a backup).
                _trace("Ignoring duplicate event", 2);
                return;
                }
        
            removeSUIDRange(laProcessed, getBaseSUID(nSender), lOldestPending, false);
        
            laProcessed.set(lEventSUID, null);
            }
        else
            {
            if (!fSkip)
                {
                // departure of a primary may cause an already processed
                // and released event (below the known range) to be resent by some backup
                // (Note: lOldestKnown could be -1)
                fSkip = lEventSUID < lOldestKnown;
                }
        
            if (fSkip)
                {
                // this event has already been processed
                return;
                }
        
            // mark this event as processed; it will be cleaned up when the originator's
            // member id is recycled.  See PartitionedCache.MemberWelcomeRequest.onReceived() (COH-5132)
            laProcessed.set(lEventSUID, null);
            }
        
        // Since events could be sent by the primary in an arbitrary order (relative to their creation)
        // we need to remember the fact of existing pending ones. Otherwise we may skip the
        // not-yet-received events after the primary departure assuming it to be released event.
        if (lOldestPending > lOldestKnown && lOldestPending < lEventSUID && !laProcessed.exists(lOldestPending))
            {
            // Non-null value acts as a marker that the oldest pending event still needs to be processed.
            laProcessed.set(lOldestPending, Boolean.TRUE);  
            }
        
        BinaryMap mapBinary = (BinaryMap) getBinaryMapArray().get(msgEvent.getCacheId());
        if (mapBinary != null)
            {
            mapBinary.dispatch(msgEvent);
            }
        }
    
    // Declared at the super level
    /**
     * Event notification to perform a regular daemon activity. To get it
    * called, another thread has to set Notification to true:
    * <code>daemon.setNotification(true);</code>
    * 
    * @see #onWait
     */
    protected void onNotify()
        {
        // import com.tangosol.util.Base;
        
        super.onNotify();
        
        if (!isExiting())
            {
            // we know that the PartitionedService#onNotify() will fetch
            // the time; no need to do it twice
            long lTime = Base.getSafeTimeMillis();
        
            if (lTime >= getLockingNextMillis())
                {
                evaluateLockRequests();
                }
        
            // flush events if necessary (COH-4631)
            if (isOwnershipEnabled())
                {
                flushEvents();
                }
            }
        }
    
    // Declared at the super level
    /**
     * Called to complete the "service-left" processing for the specified
    * member.  This notification is processed only after the associated
    * endpoint has been released by the message handler.  See
    * $NotifyServiceLeft#onReceived/#proceed.
    * Called on the service thread only.
    * Called on the service thread only.
     */
    public void onNotifyServiceLeft(com.tangosol.coherence.component.net.Member member)
        {
        // import java.util.Iterator;
        // import java.util.List;
        
        super.onNotifyServiceLeft(member);
        
        if (isAcceptingClients() && getServiceState() != SERVICE_STOPPING)
            {
            if (isOwnershipEnabled())
                {
                validateStorages(member);
        
                int nId = member.getId();
            
                // clean up pending results
                removeSUIDRange(getPendingResultInfo(getBaseSUID(nId)), nId, /*fValues*/ false);
        
                // resend all non-confirmed events that could have been lost
                List listEvents = removeSUIDRange(getPendingEvents(), nId, true);
                for (Iterator iter = listEvents.iterator(); iter.hasNext();)
                    {
                    PartitionedCache.MapEvent msgEvent = (PartitionedCache.MapEvent) iter.next();
        
                    post(msgEvent);
                    }
                }
            }
        }
    
    // Declared at the super level
    /**
     * Called to complete the "service-quiescence" processing for the local
    * member.
    * Called on the service thread only.
    * 
    * @param fResume                     false to suspend this service; true to
    * resume this service
    * @param fResumeOnFailover  whether the service should be automatically
    * resumed on failover
     */
    public void onNotifyServiceQuiescence(boolean fResume, boolean fResumeOnFailover)
        {
        if (isAcceptingClients())
            {
            if (fResume)
                {
                // resume bottom-up
                super.onNotifyServiceQuiescence(fResume, fResumeOnFailover);
                getRequestCoordinator().onServiceResumed();
                }
            else
                {
                // suspend top-down
                getRequestCoordinator().onServiceSuspended();
                super.onNotifyServiceQuiescence(fResume, fResumeOnFailover);
                }
            }
        else
            {
            super.onNotifyServiceQuiescence(fResume, fResumeOnFailover);
            }
        }
    
    /**
     * Called when an unexpected exception is raised during backing-map commit, 
    * signifying that all changes may not be committed; Log and set the
    * exception on the client response. 
    * 
    * Called on the Service or worker threads
     */
    protected void onPartialCommit(com.tangosol.coherence.component.net.Message msgResponse, Throwable e)
        {
        // import Component.Net.Message.ResponseMessage.DistributedPartialResponse as com.tangosol.coherence.component.net.message.responseMessage.DistributedPartialResponse;
        
        // we are in an non-deterministic state; some parts of the transaction could have been committed
        
        _trace("Partial commit due to the backing map exception " + getStackTrace(e), 2);
        
        RuntimeException exception = tagException(e.getCause());
        
        if (msgResponse instanceof com.tangosol.coherence.component.net.message.responseMessage.DistributedPartialResponse)
            {
            ((com.tangosol.coherence.component.net.message.responseMessage.DistributedPartialResponse) msgResponse).setException(exception);
            }
        else if (msgResponse instanceof PartitionedCache.Response)
            {
            PartitionedCache.Response response = (PartitionedCache.Response) msgResponse;
            response.setResult(PartitionedCache.Response.RESULT_FAILURE);
            response.setValue(exception);
            }
        else
            {
            throw new IllegalStateException("Unknown response message: " + msgResponse);
            }
        }
    
    // Declared at the super level
    /**
     * Second phase of assigning empty partitions. This method will dispatch the
    * UEM event followed by finalizing the assignment process via
    * onFinalizeAssignPrimary. Called on the service thread only.
    * 
    * @param partsAssigned    the empty partitions that have just been assigned
    * (initially)
    * @param partsLost             the empty partitions that were lost
    * @param continuation       the continuation that calls
    * onFinalizeAssignPrimary on the service thread
     */
    protected void onPartitionsAssigned(com.tangosol.net.partition.PartitionSet partsAssigned, com.tangosol.net.partition.PartitionSet partsLost, com.oracle.coherence.common.base.Continuation continuation)
        {
        // import com.tangosol.net.partition.PartitionSet;
        // import com.oracle.coherence.common.base.Continuation;
        // import java.util.Collections;
        // import java.util.Map;
        
        boolean fEmitAssigned = partsAssigned != null && !partsAssigned.isEmpty();
        boolean fEmitLost     = partsLost     != null && !partsLost.isEmpty();
        
        if (fEmitAssigned || fEmitLost)
            {
            Map mapStorage = collectValidStorages();
        
            // emit events (either LOST or ASSIGNED); we need to make sure that
            // only the very last event carries the continuation
        
            int iPart = fEmitAssigned ? partsAssigned.next(0) : -1;
            while (iPart >= 0)
                {
                int iPartNext = partsAssigned.next(iPart + 1);
        
                getEventsHelper().onPartitionAssigned(mapStorage, iPart,
                    fEmitLost || iPartNext >= 0 ? null : continuation);
        
                iPart = iPartNext;
                }
        
            iPart = fEmitLost ? partsLost.next(0) : -1;
            while (iPart >= 0)
                {
                int iPartNext = partsLost.next(iPart + 1);
        
                getEventsHelper().onPartitionLost(mapStorage, iPart,
                    iPartNext >= 0 ? null : continuation);
        
                iPart = iPartNext;
                }
            }
        else if (continuation != null)
            {
            continuation.proceed(null);
            }
        }
    
    // Declared at the super level
    /**
     * Second phase of partition recovery.
     */
    public void onPartitionsRecovered(com.tangosol.net.partition.PartitionSet partsRecovered, String sSnapshotName, com.oracle.coherence.common.base.Continuation continuation)
        {
        // import java.util.Map;
        
        if (!partsRecovered.isEmpty())
            {
            Map mapStorage = collectValidStorages();
        
            for (int iPart = partsRecovered.next(0); iPart >= 0; iPart = partsRecovered.next(iPart + 1))
                {
                getEventsHelper().onEntriesRecovered(mapStorage, iPart, sSnapshotName,
                    partsRecovered.next(iPart + 1) >= 0 ? null : continuation);
                }
            }
        else if (continuation != null)
            {
            continuation.proceed(null);
            }
        }
    
    // Declared at the super level
    /**
     * Post-phase of restoring orphaned partitions from backup. This method will
    * dispatch the UEM event followed by finalizing the restoration process via
    * onFinalizeRestorePrimary. Called on the service thread only.
    * 
    * @param parts               the partitions that have been restored
    * @param continuation  the continuation that calls onFinalizeRestorePrimary
    * on the service thread
     */
    protected void onPartitionsRestored(com.tangosol.net.partition.PartitionSet partsRestored, com.oracle.coherence.common.base.Continuation continuation)
        {
        // import com.tangosol.net.cache.ConfigurableCacheMap as com.tangosol.net.cache.ConfigurableCacheMap;
        // import com.tangosol.util.MapEvent as com.tangosol.util.MapEvent;
        // import java.util.Iterator;
        // import java.util.Map;
        // import java.util.Map$Entry as java.util.Map.Entry;
        
        if (!partsRestored.isEmpty())
            {
            Map mapStorage = collectValidStorages();
        
            for (Iterator iter = mapStorage.values().iterator(); iter.hasNext(); )
                {
                Storage storage = (Storage) iter.next();
                com.tangosol.net.cache.ConfigurableCacheMap      mapCCM  = storage.getBackingConfigurableCache();
        
                // check if we overloaded the storage
                int cMax = mapCCM == null ? 0 : mapCCM.getHighUnits();
                if (cMax > 0 && mapCCM.getUnits() > cMax)
                    {
                    storage.scheduleEviction(0L);
                    }
                }
        
            for (int iPart = partsRestored.next(0); iPart >= 0; iPart = partsRestored.next(iPart + 1))
                {
                if (isIndexed())
                    {
                    PartitionedCache service = (PartitionedCache) get_Module();
        
                    // create partition indices
                    for (Iterator iterStore = service.getStorageArray().iterator(); iterStore.hasNext();)
                        {
                        Storage storage = (Storage) iterStore.next();
                        if (storage.isIndexed())
                            {
                            for (Iterator iterIndex = storage.getIndexExtractorMap().entrySet().iterator(); iterIndex.hasNext(); )
                                {
                                java.util.Map.Entry index      = (java.util.Map.Entry) iterIndex.next();
                                ValueExtractor      extractor  = (ValueExtractor) index.getKey();
                                Comparator          comparator = (Comparator) index.getValue();
        
                                storage.createMapIndex(storage.getPartitionIndexMap(iPart), extractor, comparator);
                                }
                                if (!service.getDaemonPool().isStarted())
                                    {
                                    // re-create partition index on service thread
                                    storage.createPartitionIndex(iPart, null);
                                    }
                            }
                        }

                    if (getDaemonPool().isStarted())
                        {
                        scheduleIndexUpdate(iPart, com.tangosol.util.MapEvent.ENTRY_INSERTED);
                        }
                    }
        
                getEventsHelper().onEntriesRestored(mapStorage, iPart,
                    partsRestored.next(iPart + 1) >= 0 ? null : continuation);
                }
            }
        else if (continuation != null)
            {
            continuation.proceed(null);
            }
        }
    
    // Declared at the super level
    /**
     * Called when this service member's view of the primary ownership has
    * changed, and client contexts (e.g. threads) may need to be updated.
     */
    public void onPrimaryOwnershipChanged(int nPartition)
        {
        super.onPrimaryOwnershipChanged(nPartition);
        
        getRequestCoordinator().updatePartitionOwner(nPartition, getPrimaryOwner(nPartition));
        }
    
    /**
     * Called on the service thread only.
     */
    public void onPutAllRequest(PartitionedCache.PutAllRequest msgRequest)
        {
        // import Component.Net.Message;
        // import Component.Net.RequestContext as com.tangosol.coherence.component.net.RequestContext;
        // import Component.Util.Daemon.QueueProcessor.Service.Grid.PartitionedService$PinningIterator as com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.PinningIterator;
        // import com.tangosol.internal.util.HeuristicCommitException;
        // import com.tangosol.internal.util.LockContentionException;
        // import com.tangosol.net.GuardSupport;
        // import com.tangosol.net.partition.PartitionSet;
        // import com.tangosol.net.security.StorageAccessAuthorizer as com.tangosol.net.security.StorageAccessAuthorizer;
        // import com.tangosol.util.Binary;
        // import com.tangosol.util.SafeLinkedList;
        // import java.util.Arrays;
        // import java.util.Collection;
        // import java.util.Collections;
        // import java.util.HashSet;
        // import java.util.Iterator;
        // import java.util.Map;
        // import java.util.Map$Entry as java.util.Map.Entry;
        // import java.util.Set;
        
        PartitionedCache.PartialValueResponse msgResponse = (PartitionedCache.PartialValueResponse)
            instantiateMessage("PartialValueResponse");
        msgResponse.respondTo(msgRequest);
        
        Storage storage = validateRequestForStorage(msgRequest, msgResponse, false);
        if (storage == null)
            {
            return;
            }
        
        Map         map        = msgRequest.getMapSafe();
        Set         setKeys    = map.keySet();
        com.tangosol.coherence.component.net.RequestContext     context    = msgRequest.getRequestContext();
        PartitionedCache.ResultInfo resultInfo = getResultInfo(context);
        if (resultInfo != null)
            {
            PartitionSet partsMask   = getKeyPartitions(setKeys);
            PartitionSet partsResult = resultInfo.getPartitions();
            if (partsMask.intersects(partsResult))
                {
                partsMask.remove(partsResult);
        
                // keys from some partitions were already updated; partsMask
                // holds those partitions that remain to be processed
                // Note: mapPrev here is empty, as putAll() carries no actual result
                if (partsMask.isEmpty())
                    {
                    // all partitions have been updated; nothing more to do
                    post(msgResponse);
                    return;
                    }
        
                // remove the keys from previously updated partitions
                for (Iterator iter = setKeys.iterator(); iter.hasNext(); )
                    {
                    int nPartition = getKeyPartition((Binary) iter.next());
                    if (!partsMask.contains(nPartition))
                        {
                        iter.remove();
                        }
                    }
        
                _assert(!setKeys.isEmpty());
                }
            }
        
        // Note 1: it is necessary to hold all key locks while sending
        //         the bulk backup  (see COH-3304).
        //
        // TODO: since we must lock all of the keys due to COH-3304,
        //       we should call into the backing-map's putAll() method
        //
        
        int             cEntries = 0;
        int             cSize    = map.size();
        Binary[]        aKeys    = new Binary[cSize];
        Binary[]        aValues  = new Binary[cSize];
        com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.PinningIterator pinner   = createPinningIterator(map.entrySet());
        for (; pinner.hasNext(); cEntries++)
            {
            java.util.Map.Entry entry       = (java.util.Map.Entry)  pinner.next();
        
            aKeys[cEntries]   = (Binary) entry.getKey();
            aValues[cEntries] = (Binary) entry.getValue();
            }
        
        PartitionSet       partsPinned  = pinner.getPinnedPartitions();
        PartitionedCache.InvocationContext ctxInvoke    = ensureInvocationContext(partsPinned);
        
        try
            {
            ctxInvoke.prepareAccess(context, storage,
                Storage.BinaryEntry.ACCESS_WRITE_ANY, com.tangosol.net.security.StorageAccessAuthorizer.REASON_PUT);
        
            while (true)
                {
                try
                    {
                    Storage.EntryStatus[] aStatus = ctxInvoke.lockEntries(storage, aKeys, cEntries);
        
                    storage.putAll(ctxInvoke, aStatus, aValues);
        
                    break; // user-space request complete
                    }
                catch (LockContentionException e)
                    {
                    // this request was involved in a deadlock; release acquired
                    // locks allowing the winning thread to acquire all locks and
                    // subsequently re-request the locks
                    ctxInvoke.rollback(e, msgRequest);
                    }
                }
            }
        catch (HeuristicCommitException e)
            {
            // unrecoverable backing map exception
            if (isExiting())
                {
                // the service is stopped, we can ignore it;
                // the client will re-try the operation
                return;
                }
        
            onPartialCommit(msgResponse, e);
            }
        catch (Throwable e)
            {
            msgResponse.setException(tagException(e));
            Collection col = new SafeLinkedList();
        
            col.addAll(Arrays.asList(aKeys));
            msgResponse.setFailedKeys(col);
            }
        
        msgResponse.setRejectPartitions(pinner.getRejectedPartitions());
        
        // COH-22088: if the thread was interrupted due to the guardian we must reset
        //            (heartbeat and clear the interrupt bit) to avoid an exception when
        //            invoking an interruptible method
        GuardSupport.reset();
        
        // register a result for the updated partitions (putAll() uses an empty map as a placeholder)
        registerMultiResult(context, partsPinned, Collections.emptyMap());
        
        // even if there was an exception, we need to backup the changes
        processChanges(context, null, msgRequest.getCacheId(), ctxInvoke.getEntryStatuses(),
                         instantiateBatchContext(msgResponse));
        
        // only now, after the backup message is sent, we can unlock (COH-3304)
        releaseInvocationContext(ctxInvoke);
        
        msgRequest.setProcessedPartitions(partsPinned);
        
        unpinPartitions(partsPinned);
        }
    
    /**
     * Called on the service or a daemon pool thread.
     */
    public void onPutRequest(PartitionedCache.PutRequest msgRequest)
        {
        // import Component.Net.RequestContext as com.tangosol.coherence.component.net.RequestContext;
        // import com.tangosol.internal.util.HeuristicCommitException;
        // import com.tangosol.internal.util.LockContentionException;
        // import com.tangosol.net.GuardSupport;
        // import com.tangosol.net.security.StorageAccessAuthorizer as com.tangosol.net.security.StorageAccessAuthorizer;
        // import com.tangosol.util.Binary;
        // import java.util.Collection;
        
        PartitionedCache.Response msgResponse = (PartitionedCache.Response) instantiateMessage("Response");
        msgResponse.respondTo(msgRequest);
        
        Storage storage = validateRequestForStorage(msgRequest, msgResponse, false);
        if (storage == null)
            {
            return;
            }
        
        Binary  binKey  = msgRequest.getKey();
        com.tangosol.coherence.component.net.RequestContext context = msgRequest.getRequestContext();
        if (postPriorResult(context, binKey, msgResponse))
            {
            return;
            }
        
        boolean      fReturn    = msgRequest.isReturnRequired();
        Storage.EntryStatus status     = null;
        Binary       binValue   = msgRequest.getValue();
        int          nPartition = getKeyPartition(binKey);
        boolean      fEntered   = pinOwnedPartition(nPartition);
        
        if (!fEntered)
            {
            // the partition is closed or unowned; force the client to retry
            msgResponse.setResult(PartitionedCache.Response.RESULT_RETRY);
            post(msgResponse);
            return;
            }
        
        PartitionedCache.InvocationContext ctxInvoke = ensureInvocationContext(nPartition);
        
        try
            {
            while (true)
                {
                status = ctxInvoke.lockEntry(storage, binKey, false);
                try
                    {
                    com.tangosol.net.security.StorageAccessAuthorizer authorizer = storage.getAccessAuthorizer();
                    if (authorizer != null)
                        {
                        authorizer.checkWrite(status.getBinaryEntry(),
                            context.getSubject(), com.tangosol.net.security.StorageAccessAuthorizer.REASON_PUT);
                        }
        
                    storage.put(ctxInvoke, status, binValue, msgRequest.getExpiryDelay(), !fReturn);
        
                    Binary binResult = status.getResult();
                    msgResponse.setValue(fReturn ? binResult : null);
        
                    // register the result
                    registerSingleResult(context, binKey, binResult);
        
                    msgRequest.setProcessedPartition(nPartition);
        
                    break; // user-space request complete
                    }
                catch (LockContentionException e)
                    {
                    // this request was involved in a deadlock; release acquired
                    // locks allowing the winning thread to acquire all locks and
                    // subsequently re-request the locks
                    ctxInvoke.rollback(e, msgRequest);
                    }
                }
            }
        catch (HeuristicCommitException e)
            {
            // unrecoverable backing map exception
            if (isExiting())
                {
                // the service is stopped, we can ignore it;
                // the client will re-try the operation
                return;
                }
        
            onPartialCommit(msgResponse, e);
            }
        catch (Throwable e)
            {
            msgResponse.setResult(PartitionedCache.Response.RESULT_FAILURE);
            msgResponse.setValue(tagException(e));
            }
        finally
            {
            // COH-22088: if the thread was interrupted due to the guardian we must reset
            //            (heartbeat and clear the interrupt bit) to avoid an exception when
            //            invoking an interruptible method
            GuardSupport.reset();
        
            Collection colEntryStatus = ctxInvoke.getEntryStatuses();
            switch (colEntryStatus.size())
                {
                case 0:
                    break;
                case 1:
                    // optimized single-update version
                    processChanges(context, binKey, status, msgRequest.getCacheId(), msgResponse);
                    break;
                default:
                    // general multi-key update version
                    processChanges(context, null, msgRequest.getCacheId(), colEntryStatus,
                    instantiateBatchContext(msgResponse));
                }
            releaseInvocationContext(ctxInvoke);
        
            if (fEntered)
                {
                unpinPartition(nPartition);
                }
            }
        }
    
    /**
     * Called on the service or a daemon pool thread.
     */
    public void onQueryRequest(PartitionedCache.QueryRequest msgRequest)
        {
        // import com.tangosol.internal.util.QueryResult;
        // import com.tangosol.net.GuardSupport;
        // import com.tangosol.net.partition.PartitionSet;
        // import com.tangosol.net.security.StorageAccessAuthorizer as com.tangosol.net.security.StorageAccessAuthorizer;
        // import com.tangosol.util.Filter;
        // import com.tangosol.util.filter.LimitFilter;

        // older clients will send regular QueryRequest
        boolean fPartitioned = msgRequest instanceof PartitionedQueryRequest;

        PartitionedCache.QueryResponse msgResponse = fPartitioned
                                                     ? (PartitionedCache.QueryResponse) instantiateMessage("PartitionedQueryResponse")
                                                     : (PartitionedCache.QueryResponse) instantiateMessage("QueryResponse");
        msgResponse.respondTo(msgRequest);

        Storage storage = validateRequestForStorage(msgRequest, msgResponse, true);
        if (storage == null)
            {
            return;
            }

        PartitionSet partMask = msgRequest.getRequestMaskSafe();
        Filter       filter   = msgRequest.getFilter();
        boolean      fKeySet  = msgRequest.isKeysOnly();
        boolean      fFirst   = true;

        flushOOBEvents();

        PartitionSet       partReject = pinOwnedPartitions(partMask);
        PartitionedCache.InvocationContext ctxInvoke  = ensureInvocationContext(partMask);
        ctxInvoke.markReadOnlyRequest();

        try
            {
            storage.checkAccess(msgRequest.getRequestContext(), Storage.BinaryEntry.ACCESS_READ_ANY,
                fKeySet ? com.tangosol.net.security.StorageAccessAuthorizer.REASON_KEYSET : com.tangosol.net.security.StorageAccessAuthorizer.REASON_ENTRYSET);

            QueryResult result = storage.query(filter,
                    fKeySet ? Storage.QUERY_KEYS : Storage.QUERY_ENTRIES, partMask, msgRequest.checkTimeoutRemaining());

            QueryResult[] aoQueryResult;
            if (partMask.cardinality() == 1 || !fPartitioned || filter instanceof LimitFilter)
                {
                aoQueryResult = new QueryResult[] { result };
                }
            else
                {
                aoQueryResult = result.split(getMaxPartialResponseSize());
                }

            for (QueryResult queryResult : aoQueryResult)
                {
                if (fFirst)
                    {
                    // first message allocation was for validation
                    fFirst = false;
                    }
                else
                    {
                    // clone msgResponse
                    msgResponse = (PartitionedCache.QueryResponse) msgResponse.cloneMessage();
                    msgResponse.respondTo(msgRequest);
                    }

                msgResponse.setKeysOnly(fKeySet);
                msgResponse.setResult(queryResult.getResults());
                msgResponse.setSize(queryResult.getCount());
                msgResponse.setRejectPartitions(partReject);
                msgResponse.setResponsePartitions(queryResult.getPartitionSet());

                if (filter instanceof LimitFilter)
                    {
                    Object oCookie = ((LimitFilter) filter).getCookie();
                    if (oCookie instanceof Integer)
                        {
                        msgResponse.setAvailable(((Integer) oCookie).intValue());
                        }
                    }

                post(msgResponse);
                }
            }
        catch (Throwable e)
            {
            msgResponse.setException(tagException(e));
            post(msgResponse);
            }

        // COH-22088: if the thread was interrupted due to the guardian we must reset
        //            (heartbeat and clear the interrupt bit) to avoid an exception when
        //            invoking an interruptible method
        GuardSupport.reset();

        processChanges();

        releaseInvocationContext(ctxInvoke);

        msgRequest.setProcessedPartitions(partMask);

        unpinPartitions(partMask);
        }
    
    /**
     * Called on the service thread only.
     */
    public void onRemoveAllRequest(PartitionedCache.RemoveAllRequest msgRequest)
        {
        // import Component.Net.RequestContext as com.tangosol.coherence.component.net.RequestContext;
        // import Component.Util.Daemon.QueueProcessor.Service.Grid.PartitionedService$PinningIterator as com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.PinningIterator;
        // import com.tangosol.internal.util.HeuristicCommitException;
        // import com.tangosol.internal.util.LockContentionException;
        // import com.tangosol.net.GuardSupport;
        // import com.tangosol.net.partition.PartitionSet;
        // import com.tangosol.net.security.StorageAccessAuthorizer as com.tangosol.net.security.StorageAccessAuthorizer;
        // import com.tangosol.util.Binary;
        // import java.util.Collection;
        // import java.util.Collections;
        // import java.util.Iterator;
        // import java.util.LinkedList;
        // import java.util.Set;
        
        PartitionedCache.PartialValueResponse msgResponse =
            (PartitionedCache.PartialValueResponse) instantiateMessage("PartialValueResponse");
        msgResponse.respondTo(msgRequest);
        
        Storage storage = validateRequestForStorage(msgRequest, msgResponse, false);
        if (storage == null)
            {
            return;
            }
        
        Set         setKeys    = msgRequest.getKeySetSafe();
        com.tangosol.coherence.component.net.RequestContext     context    = msgRequest.getRequestContext();
        PartitionedCache.ResultInfo resultInfo = getResultInfo(context);
        if (resultInfo != null)
            {
            PartitionSet partsMask   = getKeyPartitions(setKeys);
            PartitionSet partsResult = resultInfo.getPartitions();
            if (partsMask.intersects(partsResult))
                {
                partsMask.remove(partsResult);
        
                // keys from some partitions were already removed; partsMask
                // holds those partitions that remain to be processed
                // Note: mapPrev here is empty, as removeAll() carries no actual result
                if (partsMask.isEmpty())
                    {
                    // all partitions have been removed; nothing more to do
                    post(msgResponse);
                    return;
                    }
        
                // remove the keys from previously updated partitions
                for (Iterator iter = setKeys.iterator(); iter.hasNext(); )
                    {
                    int nPartition = getKeyPartition((Binary) iter.next());
                    if (!partsMask.contains(nPartition))
                        {
                        iter.remove();
                        }
                    }
        
                _assert(!setKeys.isEmpty());
                }
            }
        
        // Note 1: it is necessary to hold all key locks while sending
        //         the bulk backup  (see COH-3304)
        //
        // TODO: since we must lock all of the keys due to COH-3304,
        //       we should call into the backing-map's keySet().removeAll() method
        
        int             cEntries = 0;
        Binary[]        aKeys    = new Binary[setKeys.size()];
        com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.PinningIterator pinner   = createPinningIterator(setKeys);
        while (pinner.hasNext())
            {
            aKeys[cEntries++] = (Binary) pinner.next();
            }
        
        PartitionSet partsPinned = pinner.getPinnedPartitions();
        
        PartitionedCache.InvocationContext ctxInvoke = ensureInvocationContext(partsPinned);
        
        try
            {
            ctxInvoke.prepareAccess(context, storage,
                Storage.BinaryEntry.ACCESS_WRITE_ANY, com.tangosol.net.security.StorageAccessAuthorizer.REASON_REMOVE);
        
            while (true)
                {
                try
                    {
                    Storage.EntryStatus[] aStatus = ctxInvoke.lockEntries(storage, aKeys, cEntries);
        
                    if (storage.removeAll(ctxInvoke, aStatus))
                        {
                        // Binary.EMPTY serves as the "Removed" flag
                        msgResponse.setResult(Binary.EMPTY);
                        }
        
                    break; // user-space request complete
                    }
                catch (LockContentionException e)
                    {
                    // this request was involved in a deadlock; release acquired
                    // locks allowing the winning thread to acquire all locks and
                    // subsequently re-request the locks
                    ctxInvoke.rollback(e, msgRequest);
                    }
                }    
            }
        catch (HeuristicCommitException e)
            {
            // unrecoverable backing map exception
            if (isExiting())
                {
                // the service is stopped, we can ignore it;
                // the client will re-try the operation
                return;
                }
        
            onPartialCommit(msgResponse, e);
            }
        catch (Throwable e)
            {
            msgResponse.setException(tagException(e));
            }
        
        msgResponse.setRejectPartitions(pinner.getRejectedPartitions());
        
        // COH-22088: if the thread was interrupted due to the guardian we must reset
        //            (heartbeat and clear the interrupt bit) to avoid an exception when
        //            invoking an interruptible method
        GuardSupport.reset();
        
        // register a result for the updated partitions (removeAll() uses an empty map as a placeholder)
        registerMultiResult(context, partsPinned, Collections.emptyMap());
        
        // even if there was an exception, we need to backup the changes
        processChanges(context, null, msgRequest.getCacheId(),  ctxInvoke.getEntryStatuses(),
                       instantiateBatchContext(msgResponse));
        
        // only now, after the backup message is sent, we can unlock (COH-3304)
        releaseInvocationContext(ctxInvoke);
        
        msgRequest.setProcessedPartitions(partsPinned);
        
        unpinPartitions(partsPinned);
        }
    
    /**
     * Called on a daemon pool thread only. Job objects are used exclusively for
    * the primary storage removeAll().
     */
    public void onRemoveAllRequest(PartitionedCache.RemoveAllRequest.RemoveJob job)
        {
        // import Component.Net.RequestContext as com.tangosol.coherence.component.net.RequestContext;
        // import Component.Net.Message;
        // import com.tangosol.internal.util.HeuristicCommitException;
        // import com.tangosol.internal.util.LockContentionException;
        // import com.tangosol.net.GuardSupport;
        // import com.tangosol.net.security.StorageAccessAuthorizer as com.tangosol.net.security.StorageAccessAuthorizer;
        // import com.tangosol.util.Binary;
        // import java.util.Collections;
        // import java.util.Iterator;
        // import java.util.Map;
        // import java.util.Map$Entry as java.util.Map.Entry;
        
        PartitionedCache.PartialValueResponse msgResponse = (PartitionedCache.PartialValueResponse) job.getResponse();
        
        int      iPartition = job.getPartition();
        com.tangosol.coherence.component.net.RequestContext  context    = job.getRequestContext();
        boolean  fEntered   = pinOwnedPartition(iPartition);
        long     lCacheId   = job.getCacheId();
        Storage storage    = getKnownStorage(lCacheId);
        try
            {
            if (fEntered && storage != null)
                {
                PartitionedCache.ResultInfo resultInfo = getResultInfo(context);
                if (resultInfo != null && resultInfo.getPartitions().contains(iPartition))
                    {
                    // the keys from this partition were already removed
                    // Note: mapPrev here is empty, as removeAll() carries no actual result
        
                    // call processChanges to signal job completion
                    processChanges(context, job, lCacheId, null, job.getBatchContext());
                    return;
                    }
        
                Map                map       = job.getMap();
                int                cEntries  = 0;
                Binary[]           aKeys     = new Binary[map.size()];
                PartitionedCache.InvocationContext ctxInvoke = ensureInvocationContext(iPartition);
        
                // Note 1: the job map is sorted in key order
                // Note 2: is is necessary to hold all key locks while sending
                //         the bulk backup  (see COH-3304)
                for (Iterator iter = map.entrySet().iterator(); iter.hasNext();)
                    {
                    java.util.Map.Entry  entry      = (java.util.Map.Entry) iter.next();
                    aKeys[cEntries++] = (Binary) entry.getKey();
                    }
        
                try
                    {
                    ctxInvoke.prepareAccess(context, storage,
                        Storage.BinaryEntry.ACCESS_WRITE_ANY, com.tangosol.net.security.StorageAccessAuthorizer.REASON_REMOVE);
        
                    while (true)
                        {
                        try
                            {
                            Storage.EntryStatus[] aStatus = ctxInvoke.lockEntries(storage, aKeys, cEntries);
        
                            if (storage.removeAll(ctxInvoke, aStatus))
                                {
                                // Binary.EMPTY serves as the "Removed" flag
                                msgResponse.setResult(Binary.EMPTY);
                                }
        
                            break; // user-space request complete
                            }
                        catch (LockContentionException e)
                            {
                            // this request was involved in a deadlock; release acquired
                            // locks allowing the winning thread to acquire all locks and
                            // subsequently re-request the locks
                            ctxInvoke.rollback(e, job.getRequest());
                            }
                        }
                    }
                catch (HeuristicCommitException e)
                    {
                    // unrecoverable backing map exception
                    if (isExiting())
                        {
                        // the service is stopped, we can ignore it;
                        // the client will re-try the operation
                        return;
                        }
        
                    onPartialCommit(msgResponse, e);
                    }
                catch (Throwable e)
                    {
                    msgResponse.setException(tagException(e));
                    }
        
                // COH-22088: if the thread was interrupted due to the guardian we must reset
                //            (heartbeat and clear the interrupt bit) to avoid an exception when
                //            invoking an interruptible method
                GuardSupport.reset();
        
                // register a result for this partition (removeAll() uses an empty map as a placeholder)
                registerMultiResult(context, iPartition, Collections.emptyMap());
        
                // even if there was an exception, we need to backup the changes
                processChanges(context, job, lCacheId, ctxInvoke.getEntryStatuses(), job.getBatchContext());
        
                // only now, after the backup message is sent, we can unlock (COH-3304)
                releaseInvocationContext(ctxInvoke);
                }
            else
                {
                msgResponse.rejectPartition(iPartition);
        
                // call processChanges to respond to the client with rejection
                processChanges(context, job, lCacheId, null, job.getBatchContext());
                }
            }
        finally
            {
            if (fEntered)
                {
                unpinPartition(iPartition);
                }
            }
        }
    
    /**
     * Called on the service or a daemon pool thread.
     */
    public void onRemoveRequest(PartitionedCache.RemoveRequest msgRequest)
        {
        // import Component.Net.RequestContext as com.tangosol.coherence.component.net.RequestContext;
        // import com.tangosol.internal.util.HeuristicCommitException;
        // import com.tangosol.internal.util.LockContentionException;
        // import com.tangosol.net.GuardSupport;
        // import com.tangosol.net.security.StorageAccessAuthorizer as com.tangosol.net.security.StorageAccessAuthorizer;
        // import com.tangosol.util.Binary;
        // import java.util.Collection;
        
        PartitionedCache.Response msgResponse = (PartitionedCache.Response) instantiateMessage("Response");
        msgResponse.respondTo(msgRequest);
        
        Storage storage = validateRequestForStorage(msgRequest, msgResponse, false);
        if (storage == null)
            {
            return;
            }
        
        Binary  binKey  = msgRequest.getKey();
        com.tangosol.coherence.component.net.RequestContext context = msgRequest.getRequestContext();
        if (postPriorResult(context, binKey, msgResponse))
            {
            return;
            }
        
        int     nPartition = getKeyPartition(binKey);
        boolean fEntered   = pinOwnedPartition(nPartition);
        
        if (!fEntered)
            {
            // the partition is closed or unowned; force the client to retry
            msgResponse.setResult(PartitionedCache.Response.RESULT_RETRY);
            post(msgResponse);
            return;
            }
        
        PartitionedCache.InvocationContext ctxInvoke = ensureInvocationContext(nPartition);
        Storage.EntryStatus       status    = null;
        try
            {
            while (true)
                {
                status = ctxInvoke.lockEntry(storage, binKey, false);
                try
                    {
                    com.tangosol.net.security.StorageAccessAuthorizer authorizer = storage.getAccessAuthorizer();
                    if (authorizer != null)
                        {
                        authorizer.checkWrite(status.getBinaryEntry(),
                            context.getSubject(), com.tangosol.net.security.StorageAccessAuthorizer.REASON_REMOVE);
                        }
        
                    storage.remove(ctxInvoke, status, !msgRequest.isReturnRequired());
        
                    // the returned value is one of:
                    // - an actual Binary if the value is required and exists
                    // - the BINARY_EXISTS if the value is not required but exists
                    // - null is the entry does not exist
                    Binary binResult = status.getResult();
                    msgResponse.setValue(binResult);
        
                    // register the result
                    registerSingleResult(context, binKey, binResult);
        
                    msgRequest.setProcessedPartition(nPartition);
        
                    break; // user-space request complete
                    }
                catch (LockContentionException e)
                    {
                    // this request was involved in a deadlock; release acquired
                    // locks allowing the winning thread to acquire all locks and
                    // subsequently re-request the locks
                    ctxInvoke.rollback(e, msgRequest);
                    }
                }
            }
        catch (HeuristicCommitException e)
            {
            // unrecoverable backing map exception
            if (isExiting())
                {
                // the service is stopped, we can ignore it;
                // the client will re-try the operation
                return;
                }
        
            onPartialCommit(msgResponse, e);
            }
        catch (Throwable e)
            {
            msgResponse.setResult(PartitionedCache.Response.RESULT_FAILURE);
            msgResponse.setValue(tagException(e));
            }
        finally
            {
            // COH-22088: if the thread was interrupted due to the guardian we must reset
            //            (heartbeat and clear the interrupt bit) to avoid an exception when
            //            invoking an interruptible method
            GuardSupport.reset();
        
            Collection colEntryStatus = ctxInvoke.getEntryStatuses();
            switch (colEntryStatus.size())
                {
                case 0:
                    break;
                case 1:
                    // optimized single-update version
                    processChanges(context, binKey, status, msgRequest.getCacheId(), msgResponse);
                    break;
                default:
                    // general multi-key update version
                    processChanges(context, null, msgRequest.getCacheId(), colEntryStatus,
                    instantiateBatchContext(msgResponse));
                }
            releaseInvocationContext(ctxInvoke);
        
            if (fEntered)
                {
                unpinPartition(nPartition);
                }
            }
        }
    
    /**
     * Called on a daemon pool thread only.
     */
    public void onSendBackups(com.oracle.coherence.common.base.Continuation contProceed)
        {
        // import com.tangosol.net.partition.PartitionSet;
        // import com.tangosol.util.Binary;
        // import com.tangosol.util.LongArray;
        // import com.tangosol.util.LongArray$Iterator as com.tangosol.util.LongArray.Iterator;
        // import com.tangosol.util.PrimitiveSparseArray;
        // import java.util.Collections;
        // import java.util.HashMap;
        // import java.util.Iterator;
        // import java.util.List;
        // import java.util.Map;
        // import java.util.Map$Entry as java.util.Map.Entry;
        
        // for all partitions
        PartitionSet partsOwned = collectOwnedPartitions(true);
        
        // reduce parts owned to partitions that have backups to send &
        // can be pinned
        for (int iPart = partsOwned.next(0); iPart != -1; iPart = partsOwned.next(iPart + 1))
            {
            if (!((PartitionedCache.PartitionControl) getPartitionControl(iPart)).hasScheduledBackups() ||
                !pinOwnedPartition(iPart, /*nVersion*/ -1))
                {
                partsOwned.remove(iPart);
                }
            }
        
        // Map<List<Member>, PartitionSet>
        Map mapMemberParts = splitByBackupOwners(partsOwned);
        
        for (Iterator iter = mapMemberParts.entrySet().iterator(); iter.hasNext(); )
            {
            java.util.Map.Entry                entry       = (java.util.Map.Entry) iter.next();
            List                 listMembers = (List) entry.getKey();
            PartitionSet         parts       = (PartitionSet) entry.getValue();
            PartitionedCache.BackupAllRequest    msg         = null;
            PrimitiveSparseArray laVersions  = null;
            Map                  mapCaches   = null;
        
            if (!listMembers.isEmpty())
                {
                msg        = (PartitionedCache.BackupAllRequest) instantiateMessage("BackupAllRequest");
                mapCaches  = new HashMap();
                laVersions = msg.getPartitionVersions();
        
                msg.setMemberList(listMembers);
                }
        
            long lCacheId  = 0L;
            for (int iPart = parts.next(0); iPart >= 0; iPart = parts.next(iPart + 1))
                {
                PartitionedCache.PartitionControl ctrlPart = (PartitionedCache.PartitionControl) getPartitionControl(iPart);
        
                // increment the partition version
                if (laVersions != null)
                    {
                    _assert(!laVersions.exists(iPart));
        
                    laVersions.setPrimitive(iPart,
                            ctrlPart.getVersionCounter().incrementAndGet());
                    }
        
                LongArray laPendingBackups = ctrlPart.getPendingBackups();
        
                if (laPendingBackups.isEmpty() || msg == null)
                    {
                    if (msg == null)
                        {
                        ctrlPart.setPendingBackups(null);
                        }
        
                    continue;
                    }
        
                long[] alCacheIds = laPendingBackups.keys();
        
                for (int i = 0, c = alCacheIds.length; i < c; ++i)
                    {
                    long lCacheIdCur = alCacheIds[i];
        
                    Set setKeys;
        
                    Map mapResource = getStorage(lCacheIdCur).getBackingInternalCache();
        
                    // send partition data for given cache id if threshold reached
                    Map mapPendingBackupTotalSize = (Map) ctrlPart.getPendingBackupTotalSize();
                    if (mapPendingBackupTotalSize != null &&
                        ((Long) mapPendingBackupTotalSize.get(Long.valueOf(lCacheIdCur))).longValue() == Long.MAX_VALUE)
                        {
                        setKeys = getStorage(lCacheIdCur).collectKeySet(iPart);
                        synchronized (laPendingBackups)
                            {
                            laPendingBackups.remove(lCacheIdCur);
                            }
                        mapPendingBackupTotalSize.put(Long.valueOf(lCacheIdCur), Long.valueOf(0L));
                        }
                    else
                        {
                        synchronized (laPendingBackups)
                            {
                            setKeys = ((Map) laPendingBackups.remove(lCacheIdCur)).keySet();
                            }
                        }
        
                    // initialize mapData appropriately based on single/multi cache mode
                    Map mapData = null;
                    if (lCacheId == 0L)
                        {
                        lCacheId = lCacheIdCur;
                        mapData  = mapCaches;
                        }
                    else if (lCacheId == lCacheIdCur)
                        {
                        mapData = mapCaches;
                        }
                    else
                        {
                        if (lCacheId != -1L)
                            {
                            mapCaches = new HashMap(
                                Collections.singletonMap(Long.valueOf(lCacheId), mapData));
                            lCacheId = -1L;
                            }
        
                        mapData = (Map) mapCaches.get(Long.valueOf(lCacheIdCur));
                        if (mapData == null)
                            {
                            mapCaches.put(Long.valueOf(lCacheIdCur),
                                mapData = new HashMap(setKeys.size()));
                            }
                        }
        
                    for (Iterator iterKeys = setKeys.iterator(); iterKeys.hasNext(); )
                        {
                        Binary binKey   = (Binary) iterKeys.next();
                        Binary binValue = (Binary) mapResource.get(binKey);
        
                        mapData.put(binKey, binValue == null
                                ? Binary.EMPTY   // remove operation
                                : binValue);
                        }
                    }
                }
        
            if (msg != null)
                {
                msg.setCacheId(lCacheId);
                msg.setMap(mapCaches);
                msg.setSyncMsg(false);
        
                // scheduled backups does not support:
                //   1. event replay   # msg.setEventHolderMap(mapEvents)
                //   2. durable events # msg.setMapEventVersions(mapVersions)
                //   3. results        # msg.set(ResultsCacheId | ResultMap)
        
                post(msg);
                }
            }
        
        unpinPartitions(partsOwned);
        
        contProceed.proceed(null);
        }
    
    // Declared at the super level
    /**
     * The default implementation of this method sets AcceptingClients to true.
    * If the Service has not completed preparing at this point, then the
    * Service must override this implementation and only set AcceptingClients
    * to true when the Service has actually "finished starting".
     */
    public void onServiceStarted()
        {
        // import Component.Net.Cluster;
        // import com.tangosol.net.BackingMapManager;
        // import com.tangosol.net.cache.LocalCache;
        // import com.tangosol.util.SparseArray;
        
        // we will need the BackingMapContext regardless
        PartitionedCache.BackingMapContext context = (PartitionedCache.BackingMapContext) _newChild("BackingMapContext");
        setBackingMapContext(context);
        
        BackingMapManager manager = getBackingMapManager();
        if (manager != null)
            {
            context.setManager(manager);
            }
        
        if (isOwnershipEnabled())
            {
            setPendingEvents(new SparseArray());
        
            // COH-3275: keep a "graveyard" of cache IDs/names for at least a packet delivery
            //           timeout to protect against a delayed destroyCache update
            long cExpiry = ((Cluster) getCluster()).getClusterService().getDeliveryTimeoutMillis();
            setStorageGraveyard(new LocalCache(LocalCache.DEFAULT_UNITS, (int) cExpiry));
            }
         
        // call super.onServiceStarted() last as it will finalizeStartup
        // and possibly transition the service into AcceptingClients and
        // AcceptingOthers
        super.onServiceStarted();
        }
    
    // Declared at the super level
    /**
     * The default implementation of this method sets AcceptingClients to false.
     */
    protected void onServiceStopping()
        {
        super.onServiceStopping();
        
        releaseAllCache();
        }
    
    /**
     * Called on the service or a daemon pool thread.
     */
    public void onSizeRequest(PartitionedCache.SizeRequest msgRequest)
        {
        // import com.tangosol.net.partition.PartitionSet;
        
        PartitionedCache.PartialValueResponse msgResponse =
            (PartitionedCache.PartialValueResponse) instantiateMessage("PartialValueResponse");
        msgResponse.respondTo(msgRequest);
        
        Storage storage = validateRequestForStorage(msgRequest, msgResponse, false);
        if (storage == null)
            {
            return;
            }
        
        flushOOBEvents();
        
        PartitionSet partMask   = msgRequest.getRequestMaskSafe();
        PartitionSet partReject = pinOwnedPartitions(partMask);
        try
            {
            int cSize = -1; // unknown
            if (partReject == null
                  && !isRestoreInProgress()       // nothing being restored
                  && !isDistributionInProgress()  // nothing being xfer'd in
                  && !isTransferInProgress()      // nothing being xfer'd out
                  && partMask.equals(collectOwnedPartitions(true)))
                {
                // most common case; the distribution is stable
                cSize = storage.size();
        
                // double check whether or not anything has changed
                if (!partMask.equals(collectOwnedPartitions(true)))
                    {
                    cSize = -1;
                    }
                }
            if (cSize < 0)
                {
                // calculate it in a more expensive way 
                cSize = storage.calculateSize(partMask, true);
                }
        
            msgResponse.setResult(Integer.valueOf(cSize));
            msgResponse.setRejectPartitions(partReject);
            }
        catch (Throwable e)
            {
            msgResponse.setException(tagException(e));
            }
        
        processChanges(msgResponse);
        
        // lastly, exit the partitions
        unpinPartitions(partMask);
        }
    
    /**
     * Called on the service thread only.
     */
    public void onStorageConfirmRequest(StorageConfirmRequest msgRequest)
        {
        // import com.tangosol.net.partition.PartitionSet;
        // import com.tangosol.net.RequestPolicyException;
        
        PartitionedCache.PartialValueResponse msgResponse =
            (PartitionedCache.PartialValueResponse) instantiateMessage("PartialValueResponse");
        msgResponse.respondTo(msgRequest);
        
        PartitionSet partsMask = msgRequest.getRequestMaskSafe();
        long         lCacheId  = msgRequest.getCacheId();
        
        if (getKnownStorage(lCacheId) == null)
            {
            String sCache = (String) getStorageGraveyard().get(Long.valueOf(lCacheId));
            if (sCache == null)
                {
                // reject all partitions; this will repeat the request
                }
            else
                {
                // mark all partitions as processed, but with an exception
                partsMask.clear();
                msgResponse.setException(new RequestPolicyException(
                    "Cache \"" + sCache + "\" has been concurrently destroyed"));
                }
            }
        else
            {
            // the storage is known; respond for all partitions that we own
            partsMask.remove(collectOwnedPartitions(/*fPrimary*/ true));
        
            msgResponse.setResult(Boolean.TRUE);
            }
        
        msgResponse.setRejectPartitions(partsMask);
        post(msgResponse);
        }
    
    // Declared at the super level
    /**
     * This method dispatches the UEM events: DEPARTED if the primary transfer
    * was success or ROLLBACK if the transfer failed.
    * 
    * @param fSuccess  true if transfer was successful
    * @param parts  the partitions transferred out
     */
    public void onTransferCompleted(boolean fSuccess, Object oResult, com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.TransferRequest msg)
        {
        // import com.oracle.coherence.common.base.Continuation;
        // import java.util.Iterator;
        // import java.util.Map;
        // import java.util.Map$Entry as java.util.Map.Entry;
        
        Continuation  continuation = getContinuations().instantiateFinalizeTransferPrimary(msg);
        PartitionedCache.EventsHelper helper       = getEventsHelper();
        if (fSuccess)
            {
            Map mapResponses = (Map) oResult;
            
            for (Iterator iter = mapResponses.entrySet().iterator(); iter.hasNext();)
                {
                java.util.Map.Entry   entry      = (java.util.Map.Entry) iter.next();
                int     iPartition = ((Integer) entry.getKey()).intValue();
                boolean fMore      = iter.hasNext();
        
                helper.onTransferCompleted(fSuccess, iPartition, fMore ? null : continuation);
        
                if (!fMore)
                    {
                    continuation = null;
                    }
                }
            }
        else
            {
            int[][]          aaiOwner     = getPartitionAssignments();
            int              nMemberThis  = getThisMember().getId();
            PartitionedCache.TransferControl ctrlTransfer = (PartitionedCache.TransferControl) getTransferControl();
        
            for (PartitionedCache.TransferControl.TransferIterator iter = (PartitionedCache.TransferControl.TransferIterator) ctrlTransfer.iterateTransfersInProgress();
                 iter.hasNext(); )
                {
                iter.next();
        
                int     iPartition = iter.getPartition();
                boolean fMore      = iter.hasNext();
        
                if (aaiOwner[iPartition][0] != nMemberThis)
                    {
                    helper.onTransferCompleted(fSuccess, iPartition, fMore ? null : continuation);
                    if (!fMore)
                        {
                        continuation = null;
                        }
                    }
                }
            }
        
        if (continuation != null)
            {
            continuation.proceed(null);
            }
        }
    
    // Declared at the super level
    /**
     * TransferRequests are sent in batches and are handled as follows:
    * 
    * primary transfers:
    *   1) queue TransferRequests as they arrive for batch-processing
    *   2) modify local ownership assignments and config to reflect ownership
    *      (note: final ownership changes are handled by
    *       onPartitionConfigUpdate() as a result of the new primary owner's
    * action)
    *   3) when the last transfer is received, process all of the
    *      queued TransferRequests and finish receiving in
    * #onFinalizeReceiveTransfer.
    * 
    * backup transfers: 
    *   1) insert backup partition data as TransferRequests are received
    *   2) update the local ownership assignments to reflect ownership
    *      (note: final ownership changes are handled by
    *       onPartitionConfigUpdate() as a result of primary owner action)
    *   3) respond to each TransferRequest with RESPONSE_INCOMPLETE
    *      except for the last transfer which is replied to with
    *      RESPONSE_RELEASE.
    * 
    * see also onTransferRequestCompleted() and onFinalizeReceiveTransfer()
    * 
    * Called on the service thread only.
     */
    public void onTransferRequest(com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.TransferRequest msgRequest)
        {
        // import com.tangosol.util.LongArray;
        // import com.tangosol.util.LongArray$Iterator as com.tangosol.util.LongArray.Iterator;
        // import java.util.Map;
        
        LongArray laResultInfo = msgRequest.getPendingResults();
        if (laResultInfo != null)
            {
            int nPartition = msgRequest.getPartition();
        
            for (com.tangosol.util.LongArray.Iterator crawler = laResultInfo.iterator(); crawler.hasNext();)
                {
                Map mapResult = (Map) crawler.next();
        
                // merge the with potential previous results for the request
                mergeTransferredResults(crawler.getIndex(), nPartition, mapResult);
                }
            }
        
        // register pending events for the transferred partitions 
        registerEvent(msgRequest.getPendingEvents(), msgRequest.getFromMember());
        
        super.onTransferRequest(msgRequest);
        }
    
    /**
     * Called on the service or a daemon pool thread.
     */
    public void onUnlockRequest(PartitionedCache.UnlockRequest msgRequest)
        {
        // import Component.Net.Lease;
        // import com.tangosol.util.Binary;
        // import java.util.List;
        
        PartitionedCache.Response msgResponse = (PartitionedCache.Response) instantiateMessage("Response");
        msgResponse.respondTo(msgRequest);
        
        Storage storage = validateRequestForStorage(msgRequest, msgResponse, true);
        if (storage == null)
            {
            return;
            }
        
        Binary binKey = msgRequest.getKey();
        try
            {
            boolean fEnter = isConcurrent();
            if (lockKey(storage, binKey, fEnter))
                {
                try
                    {
                    Lease lease = msgRequest.toLease();
                    if (storage.unlock(lease))
                        {
                        int  iPartition = getKeyPartition(binKey);
                        long lVersion   = getPartitionControl(iPartition).getVersionCounter().incrementAndGet();
        
                        msgResponse.setValue(Boolean.TRUE);
        
                        if (getBackupCount() > 0)
                            {
                            List listBackups = getBackupOwners(binKey);
                            if (!listBackups.isEmpty())
                                {
                                PartitionedCache.BackupLockRequest msgBackup =
                                    (PartitionedCache.BackupLockRequest) instantiateMessage("BackupLockRequest");
                                msgBackup.setCacheId(msgRequest.getCacheId());
                                msgBackup.setKey(binKey);
                                msgBackup.setPartition(iPartition);
                                msgBackup.setPartitionVersion(lVersion);
                                msgBackup.setLock(false);
                                msgBackup.setPrimaryResponse(msgResponse);
                                msgBackup.setMemberList(listBackups);
        
                                post(msgBackup);
        
                                // now, after the backup msg has been posted, fire pending locks
                                // before returning (respons will be posted when poll closes).
                                // see $BackupLockRequest#onRelayCompleted
                                storage.firePendingLocks(binKey);
                                return;
                                }
                            }
        
                        storage.firePendingLocks(binKey);
                        }
                    else
                        {
                        msgResponse.setValue(Boolean.FALSE);
                        }
                    }
                finally
                    {
                    unlockKey(storage, binKey, fEnter);
                    }
                }
            else
                {
                msgResponse.setResult(PartitionedCache.Response.RESULT_RETRY);
                }
            }
        catch (Throwable e)
            {
            msgResponse.setResult(PartitionedCache.Response.RESULT_FAILURE);
            msgResponse.setValue(tagException(e));
            }
        
        post(msgResponse);
        }
    
    /**
     * Called on the service or a daemon pool thread.
     */
    public void onUpdateIndexRequest(PartitionedCache.UpdateIndexRequest msgRequest)
        {
        // import com.tangosol.util.Base;
        // import java.util.Queue as java.util.Queue;
        
        PartitionedCache.Response msgResponse = (PartitionedCache.Response) instantiateMessage("Response");
        msgResponse.respondTo(msgRequest);
        
        java.util.Queue queue = getPendingIndexUpdate();
        while (true)
            {
            int nPartition = msgRequest.getPartition();
        
            updateProcessingIndexPartition(nPartition, true);
        
            if (processIndexRequest(msgRequest, msgResponse))
                {
                updateProcessingIndexPartition(nPartition, false);
                updatePendingIndexPartition(nPartition, false);
        
                Object oMonitor = Base.getCommonMonitor(System.identityHashCode(this) + nPartition);
                synchronized (oMonitor)
                    {
                    oMonitor.notifyAll();
                    }
        
                msgRequest = (PartitionedCache.UpdateIndexRequest) queue.poll();
                if (msgRequest == null)
                    {
                    msgResponse.setResult(PartitionedCache.Response.RESULT_SUCCESS);
                    post(msgResponse);
                    return;
                    }
                }
            else
                {
                // the response for the retry is deferred
                updateProcessingIndexPartition(nPartition, false);
                return;
                }
            }
        }
    
    /**
     * Perform persistence of backup data.
     */
    protected void persistBackup(int nPartition, long lCacheId, com.tangosol.util.Binary binKey, com.tangosol.util.Binary binValue, boolean fRemove)
        {
        if (binValue == null)
            {
            // null is no diff, return
            return;
            }
        
        // check ownership
        if (!isBackupOwner(nPartition))
            {
            return;
            }

        Storage storage = getKnownStorage(lCacheId);
        if (storage != null && storage.isPersistent())
            {
            PartitionedCache.PartitionControl ctrlPart = (PartitionedCache.PartitionControl) getPartitionControl(nPartition);
            PersistentStore                   store    = ctrlPart.ensureOpenPersistentStore(null, true, true);
            if (store != null)
                {
                ctrlPart.ensureBackupPersistentExtent(lCacheId);
        
                Object oToken = store.begin(null, ctrlPart); // persist is async
                try
                    {
                    if (fRemove)
                        {
                        // remove
                        store.erase(lCacheId, (ReadBuffer) binKey, oToken);
                        }
                    else
                        {
                        // update or insert
                        store.store(lCacheId, (ReadBuffer) binKey, (ReadBuffer) binValue, oToken);
                        }
        
                    store.commit(oToken);
                    }
                catch (Throwable t)
                    {
                    // ensure the persistence transaction is aborted if there is a
                    // non-persistence-related failure
                    store.abort(oToken); 
                    throw Base.ensureRuntimeException(t);
                    }
        
                return;
                }
            }
        return;
        }
    
    /**
     * Perform persistence of backup data; bulk add/updates.
     */
    protected void persistBackup(long lCacheId, java.util.Map mapEntries)
        {
        Storage storage = getKnownStorage(lCacheId);
        if (storage != null && storage.isPersistent())
            {
            Map mapByPartKeys = splitKeysByPartition(mapEntries.keySet().iterator());
        
            for (Iterator iter = mapByPartKeys.entrySet().iterator(); iter.hasNext();)
                {
                java.util.Map.Entry entry       = (java.util.Map.Entry) iter.next();
                int   iPart       = ((Integer) entry.getKey()).intValue();
                Set   setPartKeys = (Set) entry.getValue();
                
                PartitionedCache.PartitionControl ctrlPart = (PartitionedCache.PartitionControl) getPartitionControl(iPart);
                PersistentStore                   store    = ctrlPart.ensureOpenPersistentStore(null, true, true);
                if (store != null)
                    {
                    ctrlPart.ensureBackupPersistentExtent(lCacheId);
        
                    Object oToken = store.begin(null, ctrlPart); // persist is async
                    try
                        {
                        for (Iterator keyIter = setPartKeys.iterator(); keyIter.hasNext();)
                            {
                            Binary binKey   = (Binary) keyIter.next();
                            Binary binValue = (Binary) mapEntries.get(binKey);
        
                            store.store(lCacheId, (ReadBuffer) binKey, (ReadBuffer) binValue, oToken);
                            }
        
                        store.commit(oToken);
                        }
                    catch (Throwable t)
                        {
                        // ensure the persistence transaction is aborted if there is a
                        // non-persistence-related failure
                        store.abort(oToken); 
                        throw Base.ensureRuntimeException(t);
                        }
        
                    }
                }
            }
        }
    
    /**
     * Perform persistence of backup data; bulk removes.
     */
    protected void persistBackup(long lCacheId, java.util.Set setRemove)
        {
        Storage storage = getKnownStorage(lCacheId);
        if (storage != null && storage.isPersistent())
            {
            Map mapByPartKeys = splitKeysByPartition(setRemove.iterator());
        
            for (Iterator iter = mapByPartKeys.entrySet().iterator(); iter.hasNext(); )
                {
                java.util.Map.Entry entry = (java.util.Map.Entry) iter.next();
                int iPart = ((Integer) entry.getKey()).intValue();
                Set   setPartKeys = (Set) entry.getValue();
                
                PartitionedCache.PartitionControl ctrlPart = (PartitionedCache.PartitionControl) getPartitionControl(iPart);
                PersistentStore                   store    = ctrlPart.ensureOpenPersistentStore(null, true, true);
                if (store != null)
                    {
                    ctrlPart.ensureBackupPersistentExtent(lCacheId);
        
                    Object oToken = store.begin(null, ctrlPart); // persist is async
                    try
                        {
                        for (Iterator keyIter = setPartKeys.iterator(); keyIter.hasNext();)
                            {
                            Binary binKey   = (Binary) keyIter.next();
        
                            store.erase(lCacheId, (ReadBuffer) binKey, oToken);
                            }
        
                        store.commit(oToken);
                        }
                    catch (Throwable t)
                        {
                        // ensure the persistence transaction is aborted if there is a
                        // non-persistence-related failure
                        store.abort(oToken); 
                        throw Base.ensureRuntimeException(t);
                        }
        
                    }
                }
            }
        }
    
    /**
     * Write the specified changes (asynchronously) to the persistent store.
    * 
    * @param ctx                            the request context
    * @param collector                  the commit-token collector to be
    * notified upon persistence completion
    * @param mapStatusByPart    the Map<PID,
    * Collection<$EntryStatus>>representing the entries to persist
     */
    protected boolean persistChanges(com.tangosol.coherence.component.net.RequestContext ctx, com.oracle.coherence.common.base.Collector collector, java.util.Map mapStatusByPart)
        {
        // import com.oracle.coherence.persistence.PersistentStore;
        // import com.tangosol.io.ReadBuffer;
        // import com.tangosol.util.Base;
        // import java.util.Collection;
        // import java.util.Iterator;
        // import java.util.Map;
        // import java.util.Map$Entry as java.util.Map.Entry;
        
        if (mapStatusByPart == null)
            {
            return false;
            }
        
        // flush the send queue (containing the backup message), as we are
        // about to go into I/O, to encourage a latency overlap
        flush();
        
        boolean fPersisted = false;
        for (Iterator iter = mapStatusByPart.entrySet().iterator(); iter.hasNext(); )
            {
            java.util.Map.Entry             entry         = (java.util.Map.Entry) iter.next();
            int               nPartition    = ((Integer) entry.getKey()).intValue();
            Collection        colPartStatus = (Collection) entry.getValue();
            PartitionedCache.PartitionControl ctrlPartition = (PartitionedCache.PartitionControl) getPartitionControl(nPartition);
            PersistentStore   store         = ctrlPartition.ensureOpenPersistentStore(/*storeFrom*/ null, /*fSeal*/ true);
        
            // commit changes to the persisted partition atomically
            Object oToken = store.begin(collector, ctrlPartition);
            try
                {
                for (Iterator iterStatus = colPartStatus.iterator(); iterStatus.hasNext(); )
                    {
                    Storage.EntryStatus status  = (Storage.EntryStatus) iterStatus.next();
                    Storage     storage = status.getStorage();
        
                    if (storage.isPersistent() && status.isAnyAction())
                        {
                        long       lExtentId = storage.getCacheId();
                        ReadBuffer bufKey    = status.getKey();
                        ReadBuffer bufValue  = status.getMergedNewValue();
        
                        ctrlPartition.ensurePersistentExtent(lExtentId);
        
                        if (bufValue == null)
                            {
                            // remove
                            store.erase(lExtentId, bufKey, oToken);
                            }
                        else
                            {
                            // update or insert
                            store.store(lExtentId, bufKey, bufValue, oToken);
                            }
        
                        fPersisted = true;
                        }
                    }
        
                store.commit(oToken);
                }
            catch (Throwable t)
                {
                // ensure the persistence transaction is aborted if there is a
                // non-persistence-related failure
                store.abort(oToken);
                throw Base.ensureRuntimeException(t);
                }
            }
        
        return fPersisted;
        }
    
    /**
     * Write the specified changes (asynchronously) to the persistent store.
    * 
    * @param ctx             the request context
    * @param collector   the commit-token collector to be notified upon
    * persistence completion
    * @param status        the $EntryStatus representing the entry to persist
     */
    protected boolean persistChanges(com.tangosol.coherence.component.net.RequestContext ctx, com.oracle.coherence.common.base.Collector collector, Storage.EntryStatus status)
        {
        // import com.oracle.coherence.persistence.PersistentStore;
        // import com.tangosol.io.ReadBuffer;
        // import com.tangosol.util.Base;
        // import java.util.Arrays;
        
        Storage storage  = status.getStorage();
        boolean  fPersist = storage.isPersistent();
        
        if (fPersist)
            {
            long       lExtentId = status.getStorage().getCacheId();
            ReadBuffer bufKey    = status.getKey();
            ReadBuffer bufValue  = status.getMergedNewValue();
        
            // flush the send queue (containing the backup message), as we are
            // about to go into I/O, to encourage a latency overlap
            flush();
        
            PartitionedCache.PartitionControl ctrl        = (PartitionedCache.PartitionControl) getPartitionControl(status.getPartition());
            PersistentStore   store       = ctrl.ensureOpenPersistentStore(/*storeFrom*/ null, /*fSeal*/ true);
            PersistentStore   storeEvents = ctrl.getPersistentEventsStore();
        
            boolean fPersistEvents = storeEvents != null && status.getMapEventsRaw() != null;
        
            ctrl.ensurePersistentExtent(lExtentId);
        
            Object oToken = store.begin(fPersistEvents ? null : collector, ctrl);
            try
                {
                if (bufValue == null)
                    {
                    // remove
                    store.erase(lExtentId, bufKey, oToken);
                    }
                else
                    {
                    // update or insert
                    store.store(lExtentId, bufKey, bufValue, oToken);
                    }
        
                if (fPersistEvents)
                    {
                    store = ctrl.getPersistentEventsStore();
                    
                    Object oTokenEvents = store.begin(collector, ctrl);
        
                    // remove MapEventsRaw for processing resetting its state
                    // immediately to not burden the collector
                    Object oMapEventsRaw;
                    synchronized (status)
                        {
                        oMapEventsRaw = status.getMapEventsRaw();
                        status.setMapEventsRaw(null);
                        }
        
                    persistMapEvents(oMapEventsRaw, store, oTokenEvents, lExtentId);
        
                    oToken = Arrays.asList(new Object[] {oToken, oTokenEvents});
                    }
        
                store.commit(oToken);
                }
            catch (Throwable t)
                {
                // ensure the persistence transaction is aborted if there is a
                // non-persistence-related failure
                store.abort(oToken);
                throw Base.ensureRuntimeException(t);
                }
        
            return true;
            }
        
        return false;
        }
    
    /**
     * Write the specified changes (asynchronously) to the persistent store.
    * 
    * @param ctx             the request context
    * @param collector   the commit-token collector to be notified upon
    * persistence completion
    * @param status        the $EntryStatus representing the entry to persist
     */
    protected void persistMapEvents(Object oEvent, com.oracle.coherence.persistence.PersistentStore store, Object oToken, long lExtentId)
        {
        // import com.tangosol.io.ReadBuffer;
        // import com.tangosol.persistence.CachePersistenceHelper as com.tangosol.persistence.CachePersistenceHelper;
        // import com.tangosol.util.Converter;
        // import com.tangosol.util.LongArray;
        // import com.tangosol.util.MapEvent as com.tangosol.util.MapEvent;
        // import java.util.Iterator;
        
        if (oEvent instanceof LongArray)
            {
            for (Iterator iter = ((LongArray) oEvent).iterator(); iter.hasNext(); )
                {
                persistMapEvents(iter.next(), store, oToken, lExtentId);
                }
            }
        else
            {
            com.tangosol.util.MapEvent  event    = (com.tangosol.util.MapEvent) oEvent;
            Converter convDown = getBackingMapContext().getValueToInternalConverter();
        
            // write the event to the store
        
            // TODO: this can be improved by:
            //   i)  better estimating the write buffer needed and
            //   ii) doing this async from the publishing thread
            ReadBuffer bufEventKey = (ReadBuffer) com.tangosol.persistence.CachePersistenceHelper.LONG_CONVERTER_DOWN.convert(Long.valueOf(event.getVersion()));
            ReadBuffer bufEvent    = (ReadBuffer) convDown.convert(event);
        
            store.store(lExtentId, bufEventKey, bufEvent, oToken);
            }
        }
    
    // Declared at the super level
    /**
     * Prevent distribution for specified partition by acquiring the
    * corresponding shared lock and ensuring that this node owns the partition.
    * 
    * @param nPartition   the partition to pin
    * 
    * @return true iff the partition was successfully entered (and is owned);
    * false otherwise
     */
    protected boolean pinOwnedPartition(int nPartition, int nVersion)
        {
        boolean fPinned = super.pinOwnedPartition(nPartition, nVersion);
        
        if (fPinned)
            {
            ensureIndexReady(nPartition);
            }
        
        return fPinned;
        }
    
    /**
     * Post messages at once.
     */
    protected void postAll(com.tangosol.coherence.component.net.Message[] aMsg)
        {
        // import Component.Net.Message;
        
        long cbPending = 0L;
        
        for (int i = 0, c = aMsg == null ? 0 : aMsg.length; i < c; i++)
            {
            Message msg = aMsg[i];
            if (msg != null)
                {
                cbPending = post(aMsg[i], cbPending);
                }
            }
        
        flush();
        }
    
    /**
     * Register and fire the specified event.
     */
    protected void postEvent(PartitionedCache.MapEvent msgEvent)
        {
        if (msgEvent == null)
            {
            return;
            }
        
        post(msgEvent);
        }
    
    /**
     * Fire all events contained in the specified event holder. The event holder
    * could be one of:
    * 
    * - $MapEvent instance
    * - $EntryStatus instance
    * - List of event holders
    * - Map of event holders keyed by the corresponding Binary key
     */
    public void postEvents(Object oHolder)
        {
        // import java.util.Collection;
        // import java.util.Iterator;
        // import java.util.Map;
        
        if (oHolder == null)
            {
            return;
            }
        
        if (oHolder instanceof PartitionedCache.MapEvent)
            {
            postEvent((PartitionedCache.MapEvent) oHolder);
            }
        else if (oHolder instanceof Map)
            {
            for (Iterator iter = ((Map) oHolder).values().iterator(); iter.hasNext();)
                {
                postEvents(iter.next());
                }
            }
        else if (oHolder instanceof Collection)
            {
            for (Iterator iter = ((Collection) oHolder).iterator(); iter.hasNext();)
                {
                postEvents(iter.next());
                }
            }
        else if (oHolder instanceof Storage.EntryStatus)
            {
            postEvents(((Storage.EntryStatus) oHolder).getMapEventHolder());
            }
        else
            {
            throw new IllegalArgumentException("Unknown event holder: " + oHolder);
            }
        }
    
    /**
     * Check for a prior execution result for the specified request context and
    * key, and populate the response message.
    * 
    * @param ctx                        the request context
    * @param binKey                  the key
    * @param msgResponse     the response message (to the client)
    * 
    * @return true iff a prior result is found
     */
    protected boolean postPriorResult(com.tangosol.coherence.component.net.RequestContext ctx, com.tangosol.util.Binary binKey, PartitionedCache.Response msgResponse)
        {
        // import java.util.Map;
        
        PartitionedCache.ResultInfo resultInfo = getResultInfo(ctx);
        Map         mapPrev    = resultInfo == null ? null : resultInfo.extractResults(binKey);
        if (mapPrev == null)
            {
            // common path
            return false;
            }
        else
            {
            msgResponse.setValue(mapPrev.get(binKey));  // Binary result (could be null)
            post(msgResponse);
        
            return true;
            }
        }
    
    /**
     * Helper method called to split the entries to be backed up into multiple
    * "BackupAllRequest" messages.
    * 
    * @param ctx            request context
    * @param msg          the message to add the content to (could be null)
    * @param colStatus  a Collection<$EntryStatus> of the keys to backup
     */
    protected PartitionedCache.BackupAllRequest prepareBackupAllRequest(com.tangosol.coherence.component.net.RequestContext ctx, PartitionedCache.BackupAllRequest msg, java.util.Collection colStatus)
        {
        // import com.tangosol.io.ReadBuffer;
        // import com.tangosol.net.partition.DefaultVersionedPartitions;
        // import com.tangosol.util.Binary;
        // import com.tangosol.util.LiteMap;
        // import java.util.Collections;
        // import java.util.HashMap;
        // import java.util.Iterator;
        // import java.util.Map;
        
        // Result data-structures:
        //   Map<Binary, Binary>
        //   the cache-id of the results
        Map  mapResults;
        long lResultsCacheId;
        
        // Backup data and events data-structures.  These can be either:
        //   single-cache: Map<Binary, ...>
        //   multi-cache:  Map<LCacheId, Map<Binary, ...> >
        Map  mapData;
        Map  mapEvents;
        Map  mapEmpty = Collections.emptyMap();
        int  cStatus  = colStatus.size();
        long lCacheId;
        Map  mapVersions;
        
        DefaultVersionedPartitions versionsCache = null;
        
        if (msg == null)
            {
            msg = (PartitionedCache.BackupAllRequest) instantiateMessage("BackupAllRequest");
        
            mapResults      = mapEmpty;
            lResultsCacheId = -1L;
            mapData         = null;
            mapEvents       = null;
            mapVersions     = null;
            lCacheId        = -1L;
            }
        else
            {
            mapResults      = msg.getResultMap();
            lResultsCacheId = msg.getResultsCacheId();
            lCacheId        = msg.getCacheId();
            mapData         = msg.getMap();
            mapEvents       = msg.getEventHolderMap();
            mapVersions     = msg.getMapEventVersions();
            }
        
        for (Iterator iterStatus = colStatus.iterator(); iterStatus.hasNext(); )
            {
            Storage.EntryStatus status      = (Storage.EntryStatus) iterStatus.next();
            Binary       binKey      = status.getKey();
            Binary       binValueOld = status.getOldValue();
            ReadBuffer   bufValueNew = status.getMergedNewValue();
            long         lCacheIdCur = status.getStorage().getCacheId();
            int          nPartition  = status.getPartition();
        
            // maps holding data for the cache corresponding to the current status
            Map mapCacheData;
            Map mapCacheEvents;
        
            if (mapData == null)
                {
                // first iteration
                lCacheId        = lCacheIdCur;
                mapCacheData    = mapData    = new HashMap(cStatus + cStatus / 3); // prevent growth/excessive collisions
                mapCacheEvents  = mapEvents  = mapEmpty;
                mapVersions     = new LiteMap();
                
                mapVersions.put(Long.valueOf(lCacheId), versionsCache = new DefaultVersionedPartitions());
                }
            else if (lCacheId == lCacheIdCur)
                {
                // single-cache mode
                mapCacheData   = mapData;
                mapCacheEvents = mapEvents;
                versionsCache  = versionsCache == null
                    ? (DefaultVersionedPartitions) mapVersions.get(Long.valueOf(lCacheId))
                    : versionsCache;
                }
            else
                {
                // multi-cache mode
                if (lCacheId != -1L)
                    {
                    // single-cache mode transitioning to multi-cache
                    Long LCacheIdOld = Long.valueOf(lCacheId);
                    Map  mapTemp     = new HashMap();
                    mapTemp.put(LCacheIdOld, mapData);
                    mapData = mapTemp;
        
                    mapTemp = new HashMap();
                    mapTemp.put(LCacheIdOld, mapEvents);
                    mapEvents = mapTemp;
        
                    lCacheId = -1L;
                    }
        
                Long LCacheIdCur = Long.valueOf(lCacheIdCur);
        
                mapCacheData = (Map) mapData.get(LCacheIdCur);
                if (mapCacheData == null)
                    {
                    mapData.put(LCacheIdCur, mapCacheData = new HashMap());
                    }
                
                mapCacheEvents = (Map) mapEvents.get(LCacheIdCur);
                if (mapCacheEvents == null)
                    {
                    mapEvents.put(LCacheIdCur, mapCacheEvents = mapEmpty);
                    }
        
                versionsCache = (DefaultVersionedPartitions) mapVersions.get(LCacheIdCur);
                if (versionsCache == null)
                    {
                    mapVersions.put(LCacheIdCur, versionsCache = new DefaultVersionedPartitions());
                    }
                }
        
            // there are three possibilities:
            // 1) no action; included here to carry the result only (see COH-6931)
            // 2) remove operation
            // 3) update operation
            mapCacheData.put(binKey,
                status.isAnyAction()
                    ? bufValueNew == null
                        ? Binary.EMPTY   // remove operation
                        : extractDelta(binValueOld, bufValueNew)
                    : null);
        
            Object oHolder = status.getMapEventHolder();
            if (oHolder != null)
                {
                if (mapCacheEvents == mapEmpty)
                    {
                    if (lCacheId == -1L)
                        {
                        mapEvents.put(Long.valueOf(lCacheIdCur), mapCacheEvents = new HashMap());
                        }
                    else
                        {
                        mapCacheEvents = new HashMap(cStatus + cStatus / 3); // see above
                        // ensure that we back up events as part of BackupAllRequest
                        mapEvents      = mapCacheEvents;
                        }
                    }
                mapCacheEvents.put(binKey, oHolder);
                }

            Binary binResult = status.getResult();
            if (ctx != null && binResult != null)
                {
                if (lResultsCacheId == -1L)
                    {
                    lResultsCacheId = lCacheIdCur;
                    }
                else
                    {
                    _assert(lResultsCacheId == lCacheIdCur);
                    }
        
                if (mapResults == mapEmpty)
                    {
                    mapResults = new HashMap();
                    }
        
                mapResults.put(binKey, Storage.compressResult(binResult, binValueOld, bufValueNew));
                }
        
            versionsCache.setPartitionVersion(nPartition,
                Math.max(status.getMaxMapEventVersion(), versionsCache.getVersion(nPartition)));
            }
        
        msg.setCacheId(lCacheId);
        msg.setMap(mapData);
        msg.setEventHolderMap(mapEvents);
        msg.setMapEventVersions(mapVersions);
        msg.setResultsCacheId(lResultsCacheId);
        
        if (ctx != null)
            {
            // only send the results if there is a request-context
            msg.setResultMap(mapResults);
            }
        
        return msg;
        }
    
    /**
     * Helper method called to split the entries to be backed up into multiple
    * "BackupAllRequest" messages.
    * 
    * @param ctx                    request context
    * @param ctxBatch           the batch job context
    * @param mapStatuses    Map<PID, Collection<EntryStatus>> representing the
    * updated entries
    * @param mapVersions   Map<PID, LVersion> representing the updated
    * partition versions
    * @param fExpiryOnly      true iff all changes are expiry only
     */
    protected PartitionedCache.BackupAllRequest[] prepareBackupAllRequests(com.tangosol.coherence.component.net.RequestContext ctx, PartitionedCache.BatchContext ctxBatch, java.util.Map mapStatuses, java.util.Map mapVersions, boolean fExpiryOnly)
        {
        // import com.tangosol.util.ChainedCollection;
        // import java.util.Collection;
        // import java.util.Collections;
        // import java.util.HashMap;
        // import java.util.Iterator;
        // import java.util.List;
        // import java.util.Map;
        // import java.util.Map$Entry as java.util.Map.Entry;
        
        boolean fSyncBackup = false;
        Map     mapMsg;
        
        if (isScheduledBackups())
            {
            scheduleBackups(new ChainedCollection(mapStatuses.values()));
            mapStatuses = mapMsg = Collections.emptyMap();
            }
        else
            {
            mapMsg = new HashMap(mapStatuses.size()); // Map<List, Message>
            }
        
        for (Iterator iter = mapStatuses.entrySet().iterator(); iter.hasNext(); )
            {
            java.util.Map.Entry   entry       = (java.util.Map.Entry) iter.next();
            Integer NPartition  = (Integer) entry.getKey();
            int     nPartition  = NPartition.intValue();
            List    listBackups = getBackupOwners(nPartition);
            if (!listBackups.isEmpty())
                {
                // Note: to simplify, if any message needs to be sent sync, then all will go sync
                fSyncBackup |= getPartitionControl(nPartition).initiateBackup();
        
                Collection        colPartStatus = (Collection) entry.getValue();
                PartitionedCache.BackupAllRequest msgBackup     = (PartitionedCache.BackupAllRequest) mapMsg.get(listBackups);
                boolean           fNew          = msgBackup == null;
                long              lVersion      = ((Long) mapVersions.get(NPartition)).longValue();
        
                msgBackup = prepareBackupAllRequest(ctx, msgBackup, colPartStatus);
                msgBackup.getPartitionVersions().setPrimitive(nPartition, lVersion);
        
                if (fNew)
                    {
                    mapMsg.put(listBackups, msgBackup);
                    }
                }
            }
        
        int cMsg = mapMsg.size();
        if (cMsg == 0)
            {
            return null;
            }
        else
            {
            PartitionedCache.BackupAllRequest[] aMsg = new PartitionedCache.BackupAllRequest[cMsg];
            int                 iMsg = 0;
            
            if (fExpiryOnly)
                {
                // expiry-only update always goes async
                fSyncBackup = false;
                }
        
            for (Iterator iter = mapMsg.entrySet().iterator(); iter.hasNext(); )
                {
                java.util.Map.Entry entry = (java.util.Map.Entry) iter.next();
        
                List              listBackups = (List) entry.getKey();
                PartitionedCache.BackupAllRequest msgBackup   = (PartitionedCache.BackupAllRequest) entry.getValue();
        
                msgBackup.setRequestContext(ctx);
                msgBackup.setBatchContext(ctxBatch);
                msgBackup.setMemberList(listBackups);
                msgBackup.setSyncMsg(fSyncBackup);
        
                aMsg[iMsg++] = msgBackup;
                }
        
            if (fSyncBackup)
                {
                // increment the pending poll count for the backup messages to be sent.
                // (see $BackupAllRequest#onRequestCompleted, $BatchContext#onPollCompleted)
                ctxBatch.getOutstandingOperationCounter().getAndAdd(cMsg);
                }
        
            return aMsg;
            }
        }
    
    /**
     * Helper method called to split the listener registrations to be backed up
    * into multiple "BackupListenerAllRequest" messages.
    * 
    * @param lCacheId   the Id for the cache that the changes occurred on.
    * @param fLite            flag indicating if the listeners are lite and map
    * events need not carry old and new values
    * @param fAdd           flag indicating if the listeners are being added or
    * removed
    * @param member     listener Member being registered 
    * @param aoKeys       array of keys for which the listener is being
    * registered or unregistered.
    * @param cSize          number of the keys
    * @param ctxBatch    the current BatchJobContext
     */
    protected PartitionedCache.BackupListenerAllRequest[] prepareBackupListenerAllRequests(long lCacheId, boolean fLite, boolean fAdd, com.tangosol.coherence.component.net.Member member, com.tangosol.util.Binary[] aoKey, int cSize, PartitionedCache.BatchContext ctxBatch)
        {
        // import com.tangosol.util.Binary;
        // import java.util.HashMap;
        // import com.tangosol.util.LiteMap;
        // import java.util.Iterator;
        // import java.util.List;
        // import java.util.Map;
        // import java.util.Map$Entry as java.util.Map.Entry;
        
        Map     mapMsg      = new HashMap(cSize); // Map<List<Member>, Message>
        Map     mapVersions = new LiteMap();      // Map<Integer, Long>
        boolean fSyncBackup = isAsyncBackup();
        
        for (int i = 0; i < cSize; i++)
            {
            Binary binKey      = aoKey[i];
            int    nPartition  = getKeyPartition(binKey);
            List   listBackups = getBackupOwners(nPartition);
        
            if (!listBackups.isEmpty())
                {
                PartitionedCache.BackupListenerAllRequest msg   = (PartitionedCache.BackupListenerAllRequest) mapMsg.get(listBackups);
        
                Integer NPartition = Integer.valueOf(nPartition);
                Long    LVersion   = (Long) mapVersions.get(NPartition);
                long    lVersion;
        
                if (LVersion == null)
                    {
                    lVersion = getPartitionControl(nPartition).getVersionCounter().incrementAndGet();
                    mapVersions.put(NPartition, Long.valueOf(lVersion));
                    }
                else
                    {
                    lVersion = LVersion.longValue();
                    }
        
                if (msg == null)
                    {
                    msg = (PartitionedCache.BackupListenerAllRequest)
                        instantiateMessage("BackupListenerAllRequest");
                    msg.setCacheId(lCacheId);
                    msg.setAdd(fAdd);
                    msg.setLite(fLite);
                    msg.setMemberId(member.getId());
                    msg.setBatchContext(ctxBatch);
                    msg.setMemberList(listBackups);
                    msg.setSyncMsg(fSyncBackup);
                    mapMsg.put(listBackups, msg);
                    }
        
                msg.addKey(binKey);
                msg.getPartitionVersions().setPrimitive(nPartition, lVersion);
                }
            }
        
        if (fSyncBackup)
            {
            // increment the pending poll count for the backup messages to be sent.
            ctxBatch.getOutstandingOperationCounter().getAndAdd(mapMsg.size());
            }
        else
            {
            // initialize backupCompletedTime so that the persist latency
            // will be calculated as the entire persist time for async only
            ctxBatch.setLastBackupCompletedTime(System.currentTimeMillis());
            }
        
        return (PartitionedCache.BackupListenerAllRequest[]) mapMsg.values().toArray(new PartitionedCache.BackupListenerAllRequest[mapMsg.size()]);
        }
    
    /**
     * Helper method called to prepare the backup request message
    * ($BackupSingleRequest) for the entry represented by the specified status.
    * 
    * @param ctx                         the request context
    * @param status                    the $EntryStatus to backup
    * @param lPartVersion         the updated partition version
    * @param msgResponse      the primary (client) response
     */
    protected PartitionedCache.BackupSingleRequest prepareBackupSingleRequest(com.tangosol.coherence.component.net.RequestContext ctx, Storage.EntryStatus status, long lPartVersion, com.tangosol.coherence.component.net.Message msgResponse)
        {
        // import com.tangosol.io.ReadBuffer;
        // import com.tangosol.util.Base;
        // import com.tangosol.util.Binary;
        // import java.util.List;
        // import java.util.concurrent.atomic.AtomicInteger;
        
        PartitionedCache.BackupSingleRequest msg         = null;
        int                  nPartition  = status.getPartition();
        List                 listBackups = getBackupOwners(nPartition);
        
        if (!listBackups.isEmpty())
            {
            boolean    fSyncBackup = getPartitionControl(nPartition).initiateBackup();
            Binary     binValueOld = status.getOldValue();
            ReadBuffer bufValueNew = status.getMergedNewValue();
            Storage   storage     = status.getStorage();
        
            if (status.isExpiryOnly())
                {
                // expiry-only update always goes async
                fSyncBackup = false;
                }
        
            msg = (PartitionedCache.BackupSingleRequest) instantiateMessage("BackupSingleRequest");
            msg.setPartitionVersion(lPartVersion);
            msg.setMapEventVersion(status.getMaxMapEventVersion());
            msg.setSyncMsg(fSyncBackup);
            msg.setOutstandingOperationCounter(new AtomicInteger(fSyncBackup ? 2 : 1));
            msg.setCacheId(storage.getCacheId());
            msg.setKey(status.getKey());
            msg.setPartition(nPartition);
            msg.setPrimaryResponse(msgResponse);
            msg.setEventHolder(status.getMapEventHolder());
            msg.setRequestContext(ctx);
            msg.setMemberList(listBackups);
        
            if (!fSyncBackup)
                {
                // initialize backupCompletedTime so that the persist latency
                // will be calculated as the entire persist time for async only
                msg.setBackupCompletedTime(Base.getSafeTimeMillis());
                }
        
            if (status.isValueRemoved())
                {
                msg.setValue(Binary.EMPTY); // Binary.EMPTY indicates remove
                }
            else if (status.isValueUpdated())
                {
                // Note: the extracted delta could be null for "no-diff"
                msg.setValue(extractDelta(binValueOld, bufValueNew));
                }
        
            if (ctx != null)
                {
                // only send the result if there is a request-context
                msg.setResult(Storage.compressResult(status.getResult(), binValueOld, bufValueNew));
                }
            }
        
        return msg;
        }
    
    /**
     * Helper method called to  prepare the backup for the entry represented by
    * the specified status.
    * 
    * @param ctx                         the request context
    * @param status                    the $EntryStatus to backup
    * @param supplierVersion   the supplier for partition version inrementor
    * @param msgResponse      the primary (client) response
     */
    protected PartitionedCache.BackupSingleRequest prepareBackupSingleRequest(com.tangosol.coherence.component.net.RequestContext ctx, Storage.EntryStatus status, java.util.function.LongSupplier supplierVersion, com.tangosol.coherence.component.net.Message msgResponse)
        {
        if (isScheduledBackups())
            {
            scheduleBackup(
                status.getPartition(),
                status.getStorage().getCacheId(),
                status.getKey());
        
            return null;
            }
        
        return prepareBackupSingleRequest(
                ctx, status, supplierVersion.getAsLong(), msgResponse);
        }
    
    // Declared at the super level
    /**
     * Ensure that the specified partition is prepared to store data. Called on
    * the service thread only. 
    *  
    * @param iPartition  the partition number to ensure 
    * @param iBackup   the partition to prepare
    *  
    * @see #releasePartition, movePartition, transferPartition, receivePartition
     */
    protected void preparePartition(int iPartition, int iBackup)
        {
        // import java.util.Iterator;
        
        super.preparePartition(iPartition, iBackup);
        
        for (Iterator iterStore = getStorageArray().iterator(); iterStore.hasNext();)
            {
            Storage storage = (Storage) iterStore.next();
            if (storage.isValid())
                {
                storage.preparePartition(iPartition, iBackup == 0);
                }
            }
        }
    
    /**
     * Publish any (unexpected) changes, sending backup messages, map events and
    * a client response as necessary.
     */
    public void processChanges()
        {
        // this method may be called to defensively check for unexpected changes;
        // avoid allocating a batch context unless we need one.
        processChanges(/*ctx*/ null, /*job*/ null, /*lCacheId*/ -1L,
            /*colStatus*/ null, /*ctxBatch*/ null);
        }
    
    /**
     * Publish the changes made to the specified key (represented by the
    * specified $EntryStatus) from the specified cache, sending backup
    * messages, map events and a client response as necessary.
    * 
    * @param msgResponse   the client response
     */
    protected void processChanges(com.tangosol.coherence.component.net.Message msgResponse)
        {
        processChanges(/*ctx*/ null, /*job*/ null, -1L,
            /*colStatus*/ null, /*ctxBatch*/ instantiateBatchContext(msgResponse));
        }
    
    /**
     * Publish the changes made to the specified key (represented by the
    * specified $EntryStatus) from the specified cache, sending backup
    * messages, map events and a client response as necessary.
    * 
    * @param ctx            the RequestContext for the current request.  May be
    * null.
    * @param binKey      the (binary) key to publish changes for
    * @param status       the $EntryStatus that captures the changes to be
    * published.
    * @param lCacheId   the Id for the cache that the changes occurred on.
     */
    protected void processChanges(com.tangosol.coherence.component.net.RequestContext ctx, com.tangosol.util.Binary binKey, Storage.EntryStatus status, long lCacheId, com.tangosol.coherence.component.net.Message msgResponse)
        {
        // import java.util.Collections;
        // import java.util.Set;
        
        Set setStatusOOB = getResourceCoordinator().finalizeInvoke();
        if (setStatusOOB == null || setStatusOOB.isEmpty())
            {
            // most common path; single entry to backup
            // Note: status could be null for read-only operations
            publishChanges(ctx, status, msgResponse);
            }
        else
            {
            // additional, unexpected changes found; fall back to sending an atomic,
            // bulk backup.  A common cause of this is an invocation which modifies
            // the backing-map directly, bypassing the "front-door" API
            Set setStatus = status == null ? null : Collections.singleton(status);
        
            publishChanges(ctx, /*job*/ null,
                setStatus, setStatusOOB, instantiateBatchContext(msgResponse));    
            }
        }
    
    /**
     * Publish the changes made to the set of keys represented by the specified
    * collection of $EntryStatus objects from the specified cache, sending
    * backup messages, map events and a client response as necessary.
    * 
    * @param ctx                 the RequestContext for which changes should be
    * published.  May be null.
    * @param job                 the PartialJob for which these changes should
    * be published.  May be null.
    * @param lCacheId       the cache-id for which changes should be published,
    * or -1 to indicate
    *                                       a multi-cache BackupAll.
    * @param colStatus      Collection<$EntryStatus> of the keys requiring
    * changes to be published
    * @param ctxBatch       the current BatchJobContext
     */
    protected void processChanges(com.tangosol.coherence.component.net.RequestContext ctx, com.tangosol.coherence.component.util.PartialJob job, long lCacheId, java.util.Collection colStatus, PartitionedCache.BatchContext ctxBatch)
        {
        // import java.util.Set;
        
        Set setStatusOOB = getResourceCoordinator().finalizeInvoke();
        if (ctxBatch == null)
            {
            // no client to respond to
            if ((colStatus    == null || colStatus.isEmpty()) &&
                (setStatusOOB == null || setStatusOOB.isEmpty()))
                {
                // no changes (events, backups) to publish
                return;
                }
        
            // (lazy) init an empty batch context to use to publish the changes
            ctxBatch = instantiateBatchContext(null);
            }
        
        publishChanges(ctx, job, colStatus, setStatusOOB, ctxBatch);
        }
    
    /**
     * @return true if the request was processed succesfully and we can proceed
    * with any other pending request
     */
    protected boolean processIndexRequest(PartitionedCache.UpdateIndexRequest msgRequest, PartitionedCache.Response msgResponse)
        {
        // import com.tangosol.util.Base;
        // import java.util.Arrays;
        // import java.util.Iterator;
        // import java.util.List;
        // import java.util.Map;
        
        int nPartition = msgRequest.getPartition();
        int nEventId   = msgRequest.getEventId();
        
        while (true)
            {
            PartitionedCache.PartitionControl ctrlPartition = (PartitionedCache.PartitionControl) getPartitionControl(nPartition);
            if (ctrlPartition == null)
                {
                // we don't own the partition anymore
                return true;
                }
        
            if (ctrlPartition.enter(0L))
                {
                try
                    {
                    if (ctrlPartition.isLocked())
                        {
                        // We entered the partition while it is still locked, which means
                        // we are on service thread. A partition transfer must have been sent, but
                        // the message receipt has not yet been received. Defer the processing
                        // until the transfer lock is released.
                        msgResponse.setValue(msgRequest);
                        if (ctrlPartition.deferResponse(msgResponse))
                            {
                            // result is set to RESULT_RETRY
                            return false;
                            }
                        // partition is unlocked at the same time; try again
                        msgResponse.setValue(null);
                        }
                    else
                        {
                        // common path; no concurrent transfers
                        if (isPrimaryOwner(nPartition))
                            {
                            Iterator iterCaches;
        
                            Map mapUpdate = msgRequest.getUpdateMap();
                            if (mapUpdate == null)
                                {
                                // rebuild all indexes
                                // (partition transfer or recovery case)
                                long[]  al = Base.randomize(getStorageArray().keys());
                                iterCaches = Arrays.stream(al).iterator();
                                }
                            else
                                {
                                // only update the specified subset of indexes
                                // (addIndex case)
                                iterCaches = Base.randomize(mapUpdate.keySet()).iterator();
                                }
        
                            ctrlPartition.beginEvent();
        
                            while (iterCaches.hasNext())
                                {
                                Storage storage = mapUpdate == null
                                                   ? (Storage) getStorage(((Long) iterCaches.next()).longValue())
                                                   : (Storage) iterCaches.next();
        
                                if (storage != null && storage.isValid() && // only operate on valid Storage instances
                                                       storage.isIndexed())
                                    {
                                    Map mapIndex = mapUpdate == null ? null : (Map) mapUpdate.get(storage);
        
                                    long ldtStart = Base.getSafeTimeMillis();
                                    while (true)
                                        {
                                        List listFailed = storage.createPartitionIndex(nPartition, mapIndex);
                                        if (listFailed == null)
                                            {
                                            break;
                                            }
        
                                        // index build failed and the failed index have been removed;
                                        // continue to create index for everything else that are left
        
                                        if (mapUpdate != null)
                                            {
                                            int cFailed = listFailed.size();
                                            for (int i = 0; i < cFailed; i++)
                                                {
                                                mapIndex.remove(listFailed.get(i));
                                                }
        
                                            if (mapIndex.isEmpty())
                                                {
                                                mapUpdate.remove(storage);
                                                if (mapUpdate.isEmpty())
                                                    {
                                                    // nothing is left to do here
                                                    break;
                                                    }
                                                }
                                            }
                                        }
                                    storage.updateIndexStatistics(ldtStart);
                                    }
                                }
        
                            ctrlPartition.endEvent(nPartition, PartitionedCache.PartitionControl.PARTITION_EVENT_INDEX_BUILD, /*fRollBack*/ false);
        
                            // pick up any OOB events
                            processChanges();
                            }
                        else
                            {
                            // we don't own the partition anymore
                            }
                        return true;
                        }
                    }
                finally
                    {
                    ctrlPartition.exit();
                    }
                }
            else
                {
                // We were not able to enter the partition, which means that the service thread
                // is in the process of transferring, and we are on worker thread.
                // Defer the processing until transfer lock is released.
                msgResponse.setValue(msgRequest);
                if (ctrlPartition.deferResponse(msgResponse))
                    {
                    // result is set to RESULT_RETRY
                    return false;
                    }
                // partition is unlocked at the same time; try again
                msgResponse.setValue(null);
                }
            }
        }
    
    /**
     * Publish changes related to a single-entry request. Called on the service
    * or a daemon pool thread.
     */
    protected void publishChanges(com.tangosol.coherence.component.net.RequestContext ctx, Storage.EntryStatus status, com.tangosol.coherence.component.net.Message msgResponse)
        {
        // import com.oracle.coherence.common.base.Collector;
        // import com.tangosol.internal.tracing.Span;
        // import com.tangosol.net.events.partition.TransactionEvent$Type as com.tangosol.net.events.partition.TransactionEvent.Type;
        // import com.tangosol.util.Base;
        // import com.tangosol.util.Binary;
        // import java.util.Collections;
        // import java.util.Set;
        
        if (status == null)
            {
            return;
            }
        
        Object               oHolder      = null;
        PartitionedCache.BackupSingleRequest msgBackup    = null;
        PartitionedCache.BatchContext        ctxBatch     = null;
        Set                  setEntryInfo = null;
        Storage             storage      = status.getStorage();
        try
            {
            status.setPending(true);
            if (status.isAnyAction())
                {
                // prepare the status to be published
                status.preparePublish();
        
                // remember the events-holder
                oHolder = status.getMapEventHolder();
        
                // increment the partition version
                int               nPartition = status.getPartition();
                PartitionedCache.PartitionControl ctrlPart   = (PartitionedCache.PartitionControl) getPartitionControl(nPartition);
        
                if (!status.isExpiryOnly() && !status.isSuppressEvents())
                    {
                    PartitionedCache.EventsHelper evtHelper = getEventsHelper();
                    if (evtHelper.hasServiceInterceptors(com.tangosol.net.events.partition.TransactionEvent.Type.COMMITTED) ||
                        evtHelper.hasStorageInterceptors(storage, status.getEventType()))
                        {
                        setEntryInfo = Collections.singleton(status.instantiateEntryInfo());
                        }
                    }
        
                // prepare the backup request
                msgBackup = prepareBackupSingleRequest(
                    ctx, status, ctrlPart.getVersionIncrementer(), msgResponse);
        
                if (msgBackup != null)
                    {
                    // client response and events posted on backup poll completion
                    // See $BackupSingleRequest#onRequestCompleted
                    msgBackup.setEntryInfos(setEntryInfo);
                    post(msgBackup);
                    }
        
                // persist the change
                if (storage.isPersistent())
                    {
                    // Use the backup request as the commit-token collector for the
                    // persistence operations (if there is a backup).  Otherwise,
                    // instantiate a PartitionedCache.BatchContext. (see comment after the try-finally)
        
                    boolean   fSync     = ctrlPart.initiatePersist();
                    Span      span      = newTracingSpan("persistence.write", null).startSpan();
                    Collector collector = null;
                    if (msgBackup == null ? !isAsyncBackup() : msgBackup.isSyncMsg())
                        {
                        if (msgBackup == null)
                            {
                            ctxBatch = instantiateBatchContext(msgResponse);
                            ctxBatch.setPersistenceTracingSpan(span);
                            ctxBatch.setEvents(oHolder);
                            ctxBatch.setEntryInfos(setEntryInfo);
        
                            if (ctxBatch.completeOnPersist(fSync, nPartition))
                                {
                                ctxBatch.getOutstandingOperationCounter().incrementAndGet();
                                }
        
                            // since there is no backup, just set the backup completion time to
                            // now so that we are actually measuring the persist time 
                            ctxBatch.setLastBackupCompletedTime(Base.getSafeTimeMillis());
        
                            collector = ctxBatch;
                            }
                        else
                            {
                            msgBackup.setCompleteOnPersist(fSync);
                            msgBackup.setPersistenceTracingSpan(span);
        
                            if (fSync)
                                {
                                msgBackup.getOutstandingOperationCounter().incrementAndGet();
                                }
        
                            collector = (Collector) msgBackup;
                            }
                        }
                    else
                        {
                        PartitionedCache.BatchContext ctxFinish = instantiateBatchContext(null);
                        ctxFinish.setPersistenceTracingSpan(span);
        
                        // initialize backupCompletedTime so that the persist latency
                        // will be calculated as the entire persist time for async only
                        ctxFinish.setLastBackupCompletedTime(Base.getSafeTimeMillis());
        
                        collector = ctxFinish;
                        }
        
                    persistChanges(ctx, collector, status);
                    }
                }
            }
        finally
            {
            // The values the status holds have been passed to the backup message,
            // and can be reset for later use.
            //
            // COH-6985: we need to reset the EntryStatus regardless of whether or not
            //           there are changes to publish
            status.reset();
            status.setPending(false);
            }
        
        
        // At this point, the flow could be logically split across multiple sets
        // of threads:
        //  * this thread that is completing the processing of the request
        //  * service/IO threads waiting on responses to backup request polls
        //  * persistence threads completing async persistence operations
        //
        // Client response and events must be sent only after backups and persistence
        // operations are completed and could be posted now (on this thread) under
        // two conditions:
        // 1) no sync backup messages were sent (due to missing backup, no change
        //    or all async) and no persistence operations
        // 2) the backup request poll as well as all persistence operations have
        //    been completed/closed concurrently, leaving us with the responsibility
        //    of posting the response and events.
        //
        // To avoid additional allocations, the "synchronization" of these flows
        // is managed differently in different scenarios:
        // 1) if we are in case 1 above, send the client response directly 
        // 2) if there is a backup msg, we use the PartitionedCache.BackupSingleRequest
        // 3) otherwise if there is persistence (and no backup), we instantiate
        //    and use a PartitionedCache.BatchContext to manage it
        
        if (msgBackup == null)
            {
            if (ctxBatch == null)
                {
                // dispatch UEM
                dispatchServerEvents(setEntryInfo, /*setEntryInfoOOB*/ null);
                // case 1 above
                publishToClients(msgResponse, oHolder);
                }
            else
                {
                // if async persistence this *will* publishToClients
                ctxBatch.onJobCompleted(null);
                }
            }
        else
            {
            // backup (with or without persistence)
            msgBackup.onPublishCompleted();
            }
        }
    
    /**
     * Publish changes related to a multi-entry request. Called on the service
    * or a daemon pool thread.
    * This method will not mutate the passed in collections.
     */
    protected void publishChanges(com.tangosol.coherence.component.net.RequestContext ctx, com.tangosol.coherence.component.util.PartialJob job, java.util.Collection colStatus, java.util.Collection colStatusOOB, PartitionedCache.BatchContext ctxBatch)
        {
        // import Component.Net.Message;
        // import com.oracle.coherence.common.base.Collector;
        // import com.tangosol.internal.tracing.Span;
        // import com.tangosol.net.events.partition.TransactionEvent$Type as com.tangosol.net.events.partition.TransactionEvent.Type;
        // import com.tangosol.util.Base;
        // import com.tangosol.util.Binary;
        // import com.tangosol.util.LiteMap;
        // import java.util.Collection;
        // import java.util.Collections;
        // import java.util.HashSet;
        // import java.util.Iterator;
        // import java.util.LinkedList;
        // import java.util.List;
        // import java.util.Map;
        // import java.util.Set;
        
        // Combine the expected status updates with the out-of-band
        // (unexpected) updates, producing a data structure to be used
        // to perform either a single-cache or multi-cache backup.
        int          cStatus    = colStatus    == null ? 0 : colStatus.size();
        int          cStatusOOB = colStatusOOB == null ? 0 : colStatusOOB.size();
        Collection[] acolStatus = new Collection[2];
        
        acolStatus[0] = colStatus    == null ? Collections.emptySet() : colStatus;
        acolStatus[1] = colStatusOOB == null ? Collections.emptySet() : colStatusOOB;
        
        
        int cSyncBackupMsgs = 0;
        if (cStatus + cStatusOOB > 0)
            {
            PartitionedCache.BackupAllRequest[] aMsg         = null;
            Map                 mapStatuses  = null;
            boolean             fPersist     = getPersistenceManager() != null;
            boolean             fPersistSync = true;
            boolean             fChangedAny  = false;
            PartitionedCache.EventsHelper       evtHelper    = getEventsHelper();
        
            boolean fServiceInterceptors = evtHelper.hasServiceInterceptors(com.tangosol.net.events.partition.TransactionEvent.Type.COMMITTED);
            boolean fStorageInterceptors = false;
            try
                {
                // collect the changes, grouped by partition
                int      cBackups          = getBackupCount();
                Object   oHolder           = null;
                boolean  fExpiryOnly       = true;
                Set      setEntryInfo      = new HashSet();
                Set      setEntryInfoOOB   = new HashSet();
                int      cPersistCompletes = 0;
                int      i                 = 0;
                Iterator iter              = acolStatus[i].iterator();
        
                while (iter.hasNext() ||
                       (i == 0 && (iter = acolStatus[++i].iterator()).hasNext()))
                    {
                    Storage.EntryStatus status = (Storage.EntryStatus) iter.next();
        
                    status.setPending(true);
        
                    boolean fChange = status.isAnyAction();
                    boolean fResult = status.getResult() != null;
        
                    // prepare the keys to be included in the backup message;
                    // only include Storage.EntryStatus objects that have been "updated" or
                    // "removed" in the backup message or have an associated result
                    if ((fChange || fResult) && (cBackups > 0 || fPersist))
                        {
                        int     nPartition = status.getPartition();
                        Integer NPartition = Integer.valueOf(nPartition);
                        if (mapStatuses == null)
                            {
                            mapStatuses = new LiteMap();
                            }
        
                        Collection colPartStatus = (Collection) mapStatuses.get(NPartition);
                        if (colPartStatus == null)
                            {
                            mapStatuses.put(NPartition, colPartStatus = new LinkedList());
                            }
        
                        // prepare the status to be published
                        status.preparePublish();
        
                        colPartStatus.add(status);
                        }
        
                    if (fChange)
                        {
                        // accumulate the $MapEvents that need to be posted
                        oHolder = Storage.accumulateMapEvents(oHolder, status.getMapEventHolder());
                        if (!status.isExpiryOnly() && !status.isSuppressEvents())
                            {    
                            fExpiryOnly = false;
        
                            fStorageInterceptors |= evtHelper.hasStorageInterceptors(status.getStorage(), status.getEventType());
        
                            if (fStorageInterceptors || fServiceInterceptors)
                                {
                                (i == 0 ? setEntryInfo : setEntryInfoOOB).add(status.instantiateEntryInfo());
                                }
                            }
        
                        fChangedAny = true;
                        }
                    }
        
                if (fChangedAny)
                    {
                    // accumulate the (client) events into the batch context
                    if (oHolder != null)
                        {
                        // Note: we know that the batch cannot be completed (and as a consequence
                        //       published to clients) concurrently as this thread has not "completed"
                        //       the processing of this job. All we are protecting against here is
                        //       concurrent accumulation of the map-events.
                        //       See BatchJobContext#isCompleted
                        synchronized (ctxBatch)
                            {
                            ctxBatch.setEvents(Storage.accumulateMapEvents(oHolder, ctxBatch.getEvents()));
                            }
                        }
        
                    if ((cStatus > 0 || cStatusOOB > 0) && (fServiceInterceptors || fStorageInterceptors))
                        {
                        ctxBatch.accumulateEntryInfos(setEntryInfo, false);
                        ctxBatch.accumulateEntryInfos(setEntryInfoOOB, true);
                        }
        
                    // prepare the backup messages
                    if (mapStatuses != null)
                        {
                        // incrementing the backup version is deferred for scheduled backups
                        Map mapVersions = isScheduledBackups() ? null : new LiteMap();
                        for (Iterator iterParts = mapStatuses.keySet().iterator(); iterParts.hasNext(); )
                            {
                            Integer NPartition = (Integer) iterParts.next();
                            int     nPartition = NPartition.intValue();
        
                            PartitionedCache.PartitionControl ctrlPartition = (PartitionedCache.PartitionControl)
                                        getPartitionControl(nPartition);
        
                            // increment the partition version
                            if (mapVersions != null)
                                {
                                long lVersion = ctrlPartition.getVersionCounter().incrementAndGet();
                                mapVersions.put(NPartition, Long.valueOf(lVersion));
                                }
        
                            if (fPersist)
                                {
                                if (ctxBatch.completeOnPersist(ctrlPartition.initiatePersist(), nPartition))
                                    {
                                    ++cPersistCompletes;
                                    }
                                }
                            }
        
                        aMsg = prepareBackupAllRequests(ctx, ctxBatch, mapStatuses, mapVersions, fExpiryOnly);
                        }
                    }
        
                postAll(aMsg);
        
                // persist the changes, if necessary
                if (fPersist && mapStatuses != null)
                    {
                    Collector collector = null;
                    Span      span      = newTracingSpan("persistence.write", null).startSpan();
        
                    if (aMsg == null || aMsg.length == 0 ? !isAsyncBackup() : aMsg[0].isSyncMsg())
                        {
                        // increment the operation counter by the # of partitions; this must
                        // happen prior to any of the calls to PersistentStore#commit, as
                        // operations may complete concurrently on persistence threads
                        ctxBatch.getOutstandingOperationCounter().addAndGet(cPersistCompletes);
        
                        // set the last backup completed time so we get a valid persist latency
                        ctxBatch.setLastBackupCompletedTime(Base.getSafeTimeMillis());
                        ctxBatch.setPersistenceTracingSpan(span);
        
                        collector = ctxBatch;
                        }
                    else
                        {
                        PartitionedCache.BatchContext ctxFinish = instantiateBatchContext(null);
                        ctxFinish.setPersistenceTracingSpan(span);
        
                        // outstanding operation counter starts at 1 assuming this thread will decrement via
                        // onJobCompleted; this will not occur for this newly created BatchContext  
                        ctxFinish.getOutstandingOperationCounter().addAndGet(cPersistCompletes - 1);
        
                        // initialize backupCompletedTime so that the persist latency
                        // will be calculated as the entire persist time for async only
                        ctxFinish.setLastBackupCompletedTime(Base.getSafeTimeMillis());
        
                        collector = ctxFinish;
                        }
        
                    persistChanges(ctx, collector, mapStatuses);
                    }
                }
            finally
                {
                int      i    = 0;
                Iterator iter = acolStatus[i].iterator();
                while (iter.hasNext() ||
                    (i == 0 && (iter = acolStatus[++i].iterator()).hasNext()))
                    {
                    Storage.EntryStatus status = (Storage.EntryStatus) iter.next();
        
                    // The values the status holds have been passed to the backup message,
                    // and can be reset for later use.
                    status.reset();
                    status.setPending(false);
                    }
                }
            }
        
        // At this point, the flow could be logically split across multiple sets
        // of threads:
        //  * service/worker threads (including this one) that are executing/completing
        //     processing of other jobs belonging to the same batch context
        //  * service/IO threads waiting on responses to backup request polls
        //  * persistence threads completing async persistence operations
        //
        // Client response and events must be sent only after backups and persistence
        // operations are completed and could be posted now (on this thread) under
        // two conditions:
        // 1) no sync backup messages were sent (due to missing backup, no change
        //    or all async) and no persistence operations
        // 2) we are completing a partial job execution. Client response/events
        //    are not posted until the backup and persistence operations for
        //    the entire batch has completed. However, there is a possibility
        //    that all backups polls as well as all persistence operations have
        //    been completed/closed by this point (before this job has been removed
        //    from the batch context); leaving us with the responsibility of posting
        //    the response and events.
        //
        // The batch context data structure is used for "synchronization" and both
        // conditions are checked by $BatchContext#onJobCompleted
        
        ctxBatch.onJobCompleted(job);  // may be null
        
        // Now, only after backup messages/events have been queued/sent, unlock the
        // keys that were locked during #processEvent
        if (cStatusOOB > 0)
            {
            PartitionedCache.ResourceCoordinator coordinator = getResourceCoordinator();
            for (Iterator iter = colStatusOOB.iterator(); iter.hasNext();)
                {
                Storage.EntryStatus status = (Storage.EntryStatus) iter.next();
                unlockKey(status.getStorage(), status.getKey(), true);
                }
            }
        }
    
    /**
     * Publish the events and client response.
    * 
    * @param msgResponse   the client response (may be null)
    * @param oEvtHolder        the Event holder (may be null)
     */
    public void publishToClients(com.tangosol.coherence.component.net.Message msgResponse, Object oEvtHolder)
        {
        if (oEvtHolder != null)
            {
            postEvents(oEvtHolder);
            }
        
        if (msgResponse != null)
            {
            post(msgResponse);
            }
        }
    
    // Declared at the super level
    /**
     * Receive the partition, and any associated data or state, as specified by
    * the $TransferRequest.
    * 
    * @param iPartition               the partition to receive
    * @param iBackup                 the backup index of the partition
    * @param listXferRequests  the list of partition transfer messages to
    * receive
    * 
    * @see #preparePartition, releasePartition, transferPartition, movePartition
     */
    protected void receivePartition(int iPartition, int iBackup, java.util.List listXferRequests)
        {
        // import com.oracle.coherence.persistence.PersistentStore;
        // import com.tangosol.io.ReadBuffer;
        // import java.util.Iterator;
        
        AutoCloseable closeable = null;
        
        if (isActivePersistence())
            {
            PartitionedCache.PartitionControl ctrl  = (PartitionedCache.PartitionControl) getPartitionControl(iPartition);
            PersistentStore   store = null;

            if (iBackup == 0)
                {
                // ensure the persistent store is opened before we move any data
                // but do *not* create the store of events
                store = ctrl.ensurePersistentStore(null, /*fEventsStore*/ false);
                }
            else
                {
                if (isBackupPersistence())
                    {
                    // backup store
                    store = ctrl.ensurePersistentStore(null, /*fEventsStore*/ false, /*fBackupStore*/ true);
                    }
                }
        
            // ensure we have exclusive access to the store which primarily acts as a
            // hint to the store that it should defer any maintenance
            if (store != null && store.isOpen())
                {
                closeable = store.exclusively();
                }
        
            if (iBackup == 0)
                {
                // creating the events store is completed prior to inserting data
                if (isPersistEvents())
                    {
                    PartitionedCache.TransferRequest msgLast   = (PartitionedCache.TransferRequest) listXferRequests.get(listXferRequests.size() - 1);
                    ReadBuffer       bufEvents = msgLast.getEventsStoreBinary();
                
                    if (bufEvents == null) // denegrate to checking all xfer msgs
                        {
                        for (Iterator iter = listXferRequests.iterator(); iter.hasNext() && bufEvents == null; )
                            {
                            PartitionedCache.TransferRequest msgXfer = (PartitionedCache.TransferRequest) iter.next();
                            bufEvents = msgXfer.getEventsStoreBinary();
                            }
                        }
        
                    if (bufEvents != null)
                        {
                        // Note: deserializeStore does not set the store on the relevant
                        //       PartitionControl; that will be done as a part of the call to super
                        deserializeStore(store.getId(), bufEvents);
                        }
                    }
                }
        
            if (iBackup == 0)
                {
                ctrl.preparePersistentExtents();
                }
            else
                {
                if (isBackupPersistence())
                    {
                    // backup store
                    ctrl.preparePersistentBackupExtents();
                    }
                }
        
            // Note: the call to super will seal the partition once it is populated.
            }
        
        try
            {
            for (Iterator iter = listXferRequests.iterator(); iter.hasNext(); )
                {
                PartitionedCache.TransferRequest msgTransfer = (PartitionedCache.TransferRequest) iter.next();
                long             lCacheId    = msgTransfer.getCacheId();
                Storage         storage     = getStorage(lCacheId);
                if (storage == null)
                    {
                    // Note: the only possibility here is that the cache has been destroyed
                    //       while receiving transfer (see $TransferControl#onReceiveStarted)
                    _assert(lCacheId == -1L || getStorageGraveyard().containsKey(Long.valueOf(lCacheId)));
                    }
                else
                    {
                    if (iBackup == 0)
                        {
                        storage.insertPrimaryTransfer        (iPartition, msgTransfer.getResource());
                        storage.insertPrimaryLeaseTransfer   (iPartition, msgTransfer.getLease());
                        storage.insertPrimaryListenerTransfer(iPartition, msgTransfer.getListener());
        
                        // ensure that any "global" meta-data are properly persisted
                        if (storage.isPersistent())
                            {
                            storage.persistGlobalMetadata(iPartition, /*oToken*/ null);
                            }
                        }
                    else
                        {
                        storage.insertBackupTransfer        (iPartition, msgTransfer.getResource());
                        storage.insertBackupLeaseTransfer   (iPartition, msgTransfer.getLease());
                        storage.insertBackupListenerTransfer(iPartition, msgTransfer.getListener());
                        // ensure that any "global" meta-data are properly persisted
                        if (storage.isPersistent() && isBackupPersistence())
                            {
                            storage.persistGlobalMetadata(iPartition, /*fBackup*/ true, /*oToken*/ null);
                            }
                        }
        
                    storage.getVersion().resetSubmitted(iPartition, msgTransfer.getMapEventVersion());            
                    }
                }
        
            // Note: it is important to call super last, as it marks the persisted partition
            //       (if any) as valid, so any updates to the partition should occur first
            super.receivePartition(iPartition, iBackup, listXferRequests);
            }
        finally
            {
            if (closeable != null)
                {
                try
                    {
                    closeable.close();
                    }
                catch (Exception ignored) {}
                }
            }
        }
    
    // Declared at the super level
    /**
     * Recover the specified partition from the specified store (which is opened
    * for reading).
    * This method may only be called if a persistence manager is configured.
    * 
    * @param iPartition        the partition being recovered
    * @param storeFrom     the PersistentStore being recovered from
    * @param storeTo          the active PersistentStore to write recovered
    * contents into, or null if no active persistence is configured
    * @param listRequests  a list of requests that will be posted to the
    * service after recovery is complete
    * 
    * @return true iff the partition was successfully recovered
     */
    public boolean recoverPartition(int iPartition, com.oracle.coherence.persistence.PersistentStore storeFrom, com.oracle.coherence.persistence.PersistentStore storeTo, java.util.List listRequests)
        {
        // import com.oracle.coherence.persistence.PersistenceException;
        // import com.oracle.coherence.persistence.PersistentStore;
        // import com.tangosol.internal.util.ConversionHelper as com.tangosol.internal.util.ConversionHelper;
        // import com.tangosol.net.partition.VersionAwareMapListener;
        // import com.tangosol.persistence.CachePersistenceHelper as com.tangosol.persistence.CachePersistenceHelper;
        // import com.tangosol.util.Base;
        // import com.tangosol.util.ConverterCollections as com.tangosol.util.ConverterCollections;
        // import com.tangosol.util.LiteMap;
        // import com.tangosol.util.LongArray;
        // import com.tangosol.util.LongArray$Iterator as com.tangosol.util.LongArray.Iterator;
        // import com.tangosol.util.MapEvent as com.tangosol.util.MapEvent;
        // import com.tangosol.util.NullImplementation;
        // import com.tangosol.util.SparseArray;
        // import com.tangosol.util.filter.AlwaysFilter;
        // import java.util.Map;
        
        // create a LongArray of Storage, indexed by the cache IDs as they were persisted
        LongArray       laStoragePrev    = com.tangosol.persistence.CachePersistenceHelper.getCacheNames(storeFrom);
        LongArray       laStorage        = new SparseArray();
        boolean         fWriteCacheNames = false;
        PersistentStore storeEvents      = getPartitionControl(iPartition).getPersistentEventsStore();
        
        for (com.tangosol.util.LongArray.Iterator iter = laStoragePrev.iterator(); iter.hasNext(); )
            {
            Storage storage = getStorage((String) iter.next());
        
            if (storage != null)
                {
                long lCacheIdPrev = iter.getIndex();
                long lCacheId     = storage.getCacheId();
        
                if (!storage.isPersistent())
                    {
                    // remove the copied extent as recovery will copy the entire store
                    com.tangosol.persistence.CachePersistenceHelper.deleteExtents(storeTo, lCacheIdPrev);
        
                    if (storeEvents != null)
                        {
                        com.tangosol.persistence.CachePersistenceHelper.deleteExtents(storeEvents, lCacheIdPrev);
                        }
                    }
        
                // mis-match in cache-ids
                if (lCacheIdPrev != lCacheId)
                    {
                    if (storage.isPersistent())
                        {
                        com.tangosol.persistence.CachePersistenceHelper.moveExtents(storeTo, lCacheIdPrev, lCacheId);
        
                        if (storeEvents != null)
                            {
                            com.tangosol.persistence.CachePersistenceHelper.moveExtents(storeEvents, lCacheIdPrev, lCacheId);
                            }
                        
                        fWriteCacheNames = true;
                        }
                    else
                        {
                        // ensure recovery is able to find the appropriate Storage
                        // instance even though it will not be written to
                        lCacheId = lCacheIdPrev;
                        }
                    }
        
                laStorage.set(lCacheId, storage);
                }
            }
        
        if (isActivePersistence())
            {
            getPartitionControl(iPartition).preparePersistentExtents();
        
            if (fWriteCacheNames)
                {
                LongArray laCacheNames = com.tangosol.util.ConverterCollections.getLongArray(
                        laStorage,
                        com.tangosol.internal.util.ConversionHelper.getCacheNameConverter(),
                        NullImplementation.getConverter());
        
                com.tangosol.persistence.CachePersistenceHelper.storeCacheNames(storeTo, laCacheNames);
        
                if (storeEvents != null)
                    {
                    com.tangosol.persistence.CachePersistenceHelper.storeCacheNames(storeTo, laCacheNames);
                    }
                }
            }
        //else on-demand recovery 
        
        // recover the persisted data
        int                 cRecovered = 0;
        PartitionedCache.PersistenceControl ctrl       = (PartitionedCache.PersistenceControl) getPersistenceControl();
        PartitionedCache.PersistenceControl.RecoveryVisitor    visitor    = ctrl.instantiateRecoveryVisitor(listRequests);
        boolean             fSuccess   = true;
        try
            {
            visitor.setStorageArray(laStorage);
            visitor.setStorageArrayPrev(laStoragePrev);
            visitor.setPartition(iPartition);
        
            storeFrom.iterate(com.tangosol.persistence.CachePersistenceHelper.instantiatePersistenceVisitor(visitor));
        
            cRecovered = visitor.getStatsEntriesRecovered();
        
            if (storeEvents != null)
                {
                for (com.tangosol.util.LongArray.Iterator iter = laStorage.iterator(); iter.hasNext(); )
                    {
                    Storage storage = (Storage) iter.next();
        
                    Map mapEventLast = new LiteMap();
        
                    storeEvents.iterate(com.tangosol.persistence.CachePersistenceHelper.instantiateEventsVisitor(
                            storage.getCacheId(),
                            AlwaysFilter.INSTANCE,
                            VersionAwareMapListener.PRIMING,
                            mapEventLast,
                            com.tangosol.persistence.CachePersistenceHelper.LONG_CONVERTER_DOWN,
                            com.tangosol.persistence.CachePersistenceHelper.LONG_CONVERTER_UP,
                            storage.getConverterValueDown(),
                            storage.getConverterUp()));
        
                    if (!mapEventLast.isEmpty())
                        {
                        long lVersionLatest = ((Long) mapEventLast.keySet().iterator().next()).longValue();
        
                        storage.getVersion().resetSubmitted(iPartition, lVersionLatest);
                        }
                    }
                }
        
            return super.recoverPartition(iPartition, storeFrom, storeTo, listRequests);
            }
        catch (Throwable t)
            {
            // ensure the persistence transaction is aborted if there is a
            // non-persistence-related failure
            fSuccess = false;
            throw Base.ensureRuntimeException(t);
            }
        finally
            {
            // schedule an index update
            if (cRecovered > 0 && isIndexed() && getDaemonPool().isStarted())
                {
                scheduleIndexUpdate(iPartition, com.tangosol.util.MapEvent.ENTRY_INSERTED);
                }
        
            if (fSuccess && ctrl.isDisabled())
                {
                // if we did not receive an exception but persistence became disabled, it
                // is likely there was an error and the caller should be aware of this, via
                // a synthetic exception, allowing partition data structures to be updated
                throw new PersistenceException("Persistence is disabled");
                }
            }
        }
    
    // Declared at the super level
    /**
     * Recover the orphaned partitions from the specified map of
    * PersistentStores (indexed by partition-id)
     */
    public void recoverPartitions(com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.PartitionRecoverRequest.RecoverJob job, java.util.Map mapStoresFrom, java.util.Map mapStoresTo, com.tangosol.net.partition.PartitionSet partsFail, com.tangosol.net.partition.PartitionSet partsFailEvents)
        {
        // import com.oracle.coherence.persistence.PersistentStore;
        // import com.tangosol.persistence.CachePersistenceHelper as com.tangosol.persistence.CachePersistenceHelper;
        // import com.tangosol.util.LongArray;
        // import com.tangosol.util.LongArray$Iterator as com.tangosol.util.LongArray.Iterator;
        // import com.tangosol.util.SparseArray;
        // import java.util.Iterator;
        // import java.util.Map;
        
        Map       mapGraveYard = getStorageGraveyard();
        LongArray laCaches     = new SparseArray();
        
        for (Iterator iter = mapStoresTo.values().iterator(); iter.hasNext(); )
            {
            PersistentStore store         = (PersistentStore) iter.next();
            LongArray       laStoreCaches = com.tangosol.persistence.CachePersistenceHelper.getCacheNames(store);
        
            for (com.tangosol.util.LongArray.Iterator crawler = laStoreCaches.iterator(); crawler.hasNext(); )
                {
                String sCache = (String) crawler.next();
        
                if (sCache == null)
                    {
                    _trace("Skipping unexpected cache name/id: " + sCache + '/' + crawler.getIndex() +
                        " from store: " + store, 3);
                    }
                else if (getStorage(sCache) == null)
                    {
                    if (!mapGraveYard.containsValue(sCache))
                        {
                        laCaches.set(crawler.getIndex(), sCache);
                        }
                    // else; the only plausible sequence that permits recovery of a storage
                    //       instance present in the graveyard is if we are recovering from
                    //       an old persistent store that was not updated after the destroy
                    }
                }
            }
        
        if (!laCaches.isEmpty())
            {
            do
                {
                ensureStorage(laCaches);
                }
            while (!isStorageCreated(laCaches.iterator()));
            }
        
        // all caches are ensured; ready to proceed with recovery
        super.recoverPartitions(job, mapStoresFrom, mapStoresTo, partsFail, partsFailEvents);
        }
    
    /**
     * Register (backup) events represented by the specified event holder sent
    * by the specified primary node. Called on the service thread.
    * 
    * @param oEvent                  the event to register
    * @param memberOwner    the primary owner (may be null) which generated the
    * event
     */
    protected void registerEvent(Object oEvent, com.tangosol.coherence.component.net.Member memberOwner)
        {
        // import com.tangosol.util.LongArray;
        // import java.util.Collection;
        // import java.util.Iterator;
        
        if (oEvent == null || memberOwner == null)
            {
            return;
            }
        
        if (oEvent instanceof PartitionedCache.MapEvent)
            {
            PartitionedCache.MapEvent msgEvent    = (PartitionedCache.MapEvent) oEvent;
            long      lEventSUID  = msgEvent.getEventSUID();
            int       nMember     = memberOwner.getId();
            long      lOldestSUID = msgEvent.getOldestPendingEventSUID();
            LongArray laPending   = getPendingEvents();
        
            _assert(lOldestSUID != -1 && lOldestSUID <= lEventSUID);
        
            synchronized (laPending)
                {
                // remove confirmed events
                removeSUIDRange(laPending, getBaseSUID(nMember), lOldestSUID, false);
                laPending.set(lEventSUID, msgEvent);
                }
            }
        else
            {
            for (Iterator iter = ((Collection) oEvent).iterator(); iter.hasNext();)
                {
                registerEvent(iter.next(), memberOwner);
                }
            }
        }
    
    /**
     * Register results for an idempotent request identified by the specified
    * context that have already been processed by the primary owner. 
    * 
    * These results are maintained both on the primary and backup owner. The
    * results on the primary owner ensure a new backup owner would receive
    * these results in addition to primary data. The results on the backup
    * owner ensure the loss of a primary causing a client to resubmit the same
    * (already processed) request is idempotent.
    * 
    * This method also performs necessary cleanup tasks.
     */
    protected void registerMultiResult(com.tangosol.coherence.component.net.RequestContext ctx, int nPartition, java.util.Map mapResults)
        {
        if (ctx != null)
            {
            ensureResultInfo(ctx).mergeResults(nPartition, mapResults);
            }
        }
    
    /**
     * Register results for an idempotent request identified by the specified
    * context that have already been processed by the primary owner. 
    * 
    * These results are maintained both on the primary and backup owner. The
    * results on the primary owner ensure a new backup owner would receive
    * these results in addition to primary data. The results on the backup
    * owner ensure the loss of a primary causing a client to resubmit the same
    * (already processed) request is idempotent.
    * 
    * This method also performs necessary cleanup tasks.
     */
    protected void registerMultiResult(com.tangosol.coherence.component.net.RequestContext ctx, com.tangosol.net.partition.PartitionSet partsResults, java.util.Map mapResults)
        {
        if (ctx != null && !partsResults.isEmpty())
            {
            // only register if the passed partition-set is non-empty
            ensureResultInfo(ctx).mergeResults(partsResults, mapResults);
            }
        }
    
    /**
     * Register results for an idempotent request identified by the specified
    * context that have already been processed by the primary owner. 
    * 
    * These results are maintained both on the primary and backup owner. The
    * results on the primary owner ensure a new backup owner would receive
    * these results in addition to primary data. The results on the backup
    * owner ensure the loss of a primary causing a client to resubmit the same
    * (already processed) request is idemptotent.
    * 
    * This method also performs necessary cleanup tasks.
     */
    protected void registerSingleResult(com.tangosol.coherence.component.net.RequestContext ctx, com.tangosol.util.Binary binKey, com.tangosol.util.Binary binResult)
        {
        // import java.util.Collections;
        
        if (ctx != null)
            {
            ensureResultInfo(ctx).mergeResults(
                    getKeyPartition(binKey), Collections.singletonMap(binKey, binResult));
            }
        }
    
    /**
     * This method is only called on the service thread and only when the
    * service is stopping or has stopped.
     */
    protected void releaseAllCache()
        {
        // import com.tangosol.net.internal.ScopedCacheReferenceStore as com.tangosol.net.internal.ScopedCacheReferenceStore;
        // import java.util.Iterator;
        // import java.util.Map;
        
        synchronized (this)
            {
            com.tangosol.net.internal.ScopedCacheReferenceStore store = getScopedCacheStore();
            for (Iterator iter = store.getAllCaches().iterator(); iter.hasNext();)
                {
                ViewMap mapCache = (ViewMap) iter.next();
                mapCache.invalidate(false);
                }
            store.clear();
        
            getReferencesBinaryMap().clear();
            getBinaryMapArray().clear();
            }
        }
    
    /**
     * This method is only called on the service thread and only when the
    * service has stopped.
     */
    protected void releaseAllStorage()
        {
        // import com.tangosol.util.LongArray;
        // import java.util.Iterator;
        // import java.util.ConcurrentModificationException;
        
        // revoke all the ownership first
        setPartitionAssignments(new int[getPartitionCount()][1 + getBackupCount()]);
        
        // invalidate all the storages
        LongArray aStorage = getStorageArray();
        synchronized (aStorage)
            {
            for (Iterator iter = aStorage.iterator(); iter.hasNext();)
                {
                ((Storage) iter.next()).invalidate();
                }
            aStorage.clear();
            }
        }
    
    // From interface: com.tangosol.net.CacheService
    // From interface: com.tangosol.net.DistributedCacheService
    public void releaseCache(com.tangosol.net.NamedCache cache)
        {
        // import com.tangosol.net.internal.ScopedCacheReferenceStore as com.tangosol.net.internal.ScopedCacheReferenceStore;
        
        if (cache.getCacheService() != this)
            {
            throw new IllegalArgumentException(
                "The cache to release is not owned by this service: " + this);
            }
        
        ViewMap mapCache = (ViewMap) cache;
        
        if (mapCache.isActive())
            {
            synchronized (this)
                {
                com.tangosol.net.internal.ScopedCacheReferenceStore store = getScopedCacheStore();
          
                // remove the cache from the reference list
                store.releaseCache(cache, mapCache.getClassLoader());
                }
        
            // invalidate the cache
            mapCache.invalidate(false);
            }
        }
    
    /**
     * Resets the thread local Invocation Context
     */
    public void releaseInvocationContext(PartitionedCache.InvocationContext ctxInvoke)
        {
        ctxInvoke.release(/*fUnpin*/ true);
        }
    
    // Declared at the super level
    /**
     * Release the specified partition. Called on the service thread only.
    * 
    * @param iPartition  the partition number to release
    * @param iBackup   the backup index to release
    * 
    * @see #preparePartition, movePartition, transferPartition, receivePartition
     */
    protected void releasePartition(int iPartition, int iBackup)
        {
        // import java.util.Iterator;
        
        super.releasePartition(iPartition, iBackup);
        
        for (Iterator iterStore = getStorageArray().iterator(); iterStore.hasNext();)
            {
            Storage storage = (Storage) iterStore.next();
            if (storage.isValid())
                {
                storage.releasePartition(iPartition, iBackup == 0);
                }
            }
        }
    
    /**
     * Remove storage of the specified cacheId from the storage array.
     */
    public Storage removeStorage(long lCacheId)
        {
        // import com.tangosol.util.LongArray;
        
        _assert(isOwnershipEnabled());
        
        LongArray aStorage = getStorageArray();
        Storage  storage  = null;
        synchronized (aStorage)
            {
            storage = (Storage) aStorage.remove(lCacheId);
            }
        
        if (storage != null)
            {
            getStorageGraveyard().put(Long.valueOf(lCacheId), storage.getCacheName());
            }
        
        return storage;
        }
    
    /**
     * For debugging purposes only.
     */
    public String reportPartitionContent(int iPartition)
        {
        // import Component.Net.Message;
        // import com.tangosol.util.Binary;
        // import com.tangosol.util.ExternalizableHelper;
        // import java.util.ConcurrentModificationException;
        // import java.util.Iterator;
        
        StringBuilder sb = new StringBuilder();
        for (Iterator iterStore = getStorageArray().iterator(); iterStore.hasNext();)
            {
            Storage storage = (Storage) iterStore.next();
            if (!storage.isValid())
                {
                continue;
                }
        
            sb.append('\n')
              .append(storage.getCacheName())
              .append('{');
        
            for (Iterator iter = storage.collectKeySet(iPartition).iterator(); iter.hasNext();)
                {
                Binary binKey = (Binary) iter.next();
                try
                    {
                    sb.append((Object) ExternalizableHelper.fromBinary(binKey, getSerializer()));
                    }
                 catch (RuntimeException e)
                    {
                    sb.append(e);
                    }
                sb.append(", ");
                }
             sb.append('}');
             }
        
        if (isConcurrent())
            {
            PartitionedCache.PartitionControl control = (PartitionedCache.PartitionControl) getPartitionControl(iPartition);
            sb.append('\n')
              .append(control);
            }
        
        return sb.length() == 0 ? "" : sb.substring(1);
        }
    
    // Declared at the super level
    /**
     * Reset the Service statistics.
    * Reset the statistics.
     */
    public void resetStats()
        {
        // import com.tangosol.net.events.internal.ServiceDispatcher;
        
        getStatsIndexingTime().set(0L);
        
        super.resetStats();
        
        ServiceDispatcher dispatcher = getEventsHelper().getServiceDispatcher();
        
        if (dispatcher != null)
            {
            dispatcher.getStats().reset();
            }
        }
    
    /**
     * Add the specified key to the pending backups and schedule to run the
    * SendBackupsTask at configured backup interval if not already scheduled.
     */
    public void scheduleBackup(int nPartition, long lCacheId, com.tangosol.util.Binary binKey)
        {
        // import Component.Util.DaemonPool as com.tangosol.coherence.component.util.DaemonPool;
        // import com.tangosol.net.cache.ConfigurableCacheMap as com.tangosol.net.cache.ConfigurableCacheMap;
        // import com.tangosol.net.cache.ConfigurableCacheMap$Entry as com.tangosol.net.cache.ConfigurableCacheMap.Entry;
        // import com.tangosol.net.partition.PartitionAwareBackingMap as com.tangosol.net.partition.PartitionAwareBackingMap;
        // import com.tangosol.util.Base;
        // import com.tangosol.util.LongArray;
        // import com.tangosol.util.SparseArray;
        // import java.util.concurrent.ConcurrentHashMap;
        
        com.tangosol.coherence.component.util.DaemonPool pool = getDaemonPool();
        
        // should not enter here without a pool
        _assert(pool.isStarted());
        
        // register the key to be backed up
        PartitionedCache.PartitionControl ctrlPartition = (PartitionedCache.PartitionControl) getPartitionControl(nPartition);
        ConcurrentHashMap mapPendingBackupTotalSize = (ConcurrentHashMap) ctrlPartition.ensurePendingBackupTotalSize();
        
        if (mapPendingBackupTotalSize.get(Long.valueOf(lCacheId)) == null)
            {
            mapPendingBackupTotalSize.put(Long.valueOf(lCacheId), Long.valueOf(0L));
            }
        
        // manage threshold
        // keep track of size of entry values, if over a certain percentage, send partition data for that cache Id
        long lPendingBackupTotalSize = ((Long) mapPendingBackupTotalSize.get(Long.valueOf(lCacheId))).longValue();
        
        if (lPendingBackupTotalSize != Long.MAX_VALUE)
            {
            LongArray         laPendingBackups          = ctrlPartition.ensurePendingBackups();
            ConcurrentHashMap map                       = (ConcurrentHashMap) laPendingBackups.get(lCacheId);
            Storage          storage                   = getStorage(lCacheId);
            com.tangosol.net.partition.PartitionAwareBackingMap              mapPABM                   = storage.getPartitionAwareBackingMap();
            com.tangosol.net.cache.ConfigurableCacheMap               mapCCM                    = (com.tangosol.net.cache.ConfigurableCacheMap) (mapPABM == null ? null :
                                                                     mapPABM.getPartitionMap(nPartition));
        
            if (mapCCM != null &&
                lPendingBackupTotalSize > (mapCCM.getUnits() * getScheduledBackupsThreshold() / 100))
                {
                mapPendingBackupTotalSize.put(Long.valueOf(lCacheId), Long.valueOf(Long.MAX_VALUE));
                if (map == null)
                    {
                    synchronized (laPendingBackups)
                        {
                        map = (ConcurrentHashMap) laPendingBackups.get(lCacheId);
        
                        if (map != null)
                            {
                            laPendingBackups.set(lCacheId, null);
                            }
                        }
                    }
                }
            else
                {
                if (map == null)
                    {
                    synchronized (laPendingBackups)
                        {
                        map = (ConcurrentHashMap) laPendingBackups.get(lCacheId);
        
                        if (map == null)
                            {
                            laPendingBackups.set(lCacheId, map = new ConcurrentHashMap());
                            }
                        }
                    }
        
        
                map.put(binKey, binKey);
        
                if (mapCCM != null)
                    {
                    com.tangosol.net.cache.ConfigurableCacheMap.Entry entry = mapCCM.getCacheEntry(binKey);
                    if (entry != null) // non-remove
                        {
                        mapPendingBackupTotalSize.put(Long.valueOf(lCacheId),
                                Long.valueOf(lPendingBackupTotalSize + entry.getUnits()));
                        }
                    }
                }
        
            PartitionedCache.SendBackupsTask task              = getSendBackupsTask();
            long             cNextBackupMillis = 0L;
            Object           oMonitor          = Base.getCommonMonitor(System.identityHashCode(this));
            if (task == null)
                {
                synchronized (oMonitor)
                    {
                    task = getSendBackupsTask();
                    if (task == null)
                        {
                        setSendBackupsTask(
                            task = (PartitionedCache.SendBackupsTask) _newChild("SendBackupsTask"));
        
                        cNextBackupMillis = getAsyncBackupInterval();
                        }
                    }
                }
        
            if (cNextBackupMillis > 0L)
                {
                pool.schedule(task, cNextBackupMillis);
                }
            }
        }
    
    /**
     * Schedule backup for the keys from the specified status collection.
    * 
    * @param colStatus  a Collection<$EntryStatus> of the keys to backup
     */
    protected void scheduleBackups(java.util.Collection colStatus)
        {
        // import com.tangosol.util.Binary;
        // import java.util.Iterator;
        
        for (Iterator iterStatus = colStatus.iterator(); iterStatus.hasNext(); )
            {
            Storage.EntryStatus status = (Storage.EntryStatus) iterStatus.next();
            Binary       binKey = status.getKey();
        
            scheduleBackup(
                status.getPartition(),
                status.getStorage().getCacheId(),
                status.getKey());
            }
        }
    
    /**
     * Schedule an index update for the specified partition. Called on the
    * service thread only.
     */
    public void scheduleIndexUpdate(int nPartition, int nEventId)
        {
        scheduleIndexUpdate(nPartition, nEventId, null);
        }
    
    /**
     * Schedule an index update for the specified partition. Called on the
    * service thread only.
    * 
    * @param mapUpdate  Map<$Storage, Map<ValueExtractor, MapIndex>> that
    * contains the storage and corresponding extractor for which the index
    * needs to be created
     */
    public void scheduleIndexUpdate(int nPartition, int nEventId, java.util.Map mapUpdate)
        {
        // import com.oracle.coherence.common.internal.Platform;
        // import com.tangosol.util.Base;
        
        // update partitions pending for the index creation or rebuild;
        updatePendingIndexPartition(nPartition, true);
        
        PartitionedCache.UpdateIndexRequest msg = (PartitionedCache.UpdateIndexRequest) instantiateMessage("UpdateIndexRequest");
        msg.setPartition(nPartition);
        msg.setEventId(nEventId);
        msg.setUpdateMap(mapUpdate);
        msg.addToMember(getThisMember());
        
        int cUpdates = getIndexUpdateCount();
        int cFair    = Platform.getPlatform().getFairShareProcessors();
        
        // start index build timer; start at first request post
        if (cUpdates == 0)
            {
            setIndexingStartTime(Base.getSafeTimeMillis());
            }
        
        if (cUpdates < cFair)
            {
            setIndexUpdateCount(cUpdates + 1);
            post(msg);
            }
        else
            {
            getPendingIndexUpdate().add(msg);
            }
        }
    
    /**
     * Schedule an initial index update for the specified partition. Called on
    * the service thread only.
     */
    public void scheduleInitialIndexUpdate(int nPartition, int nEventId, Storage storage, com.tangosol.util.ValueExtractor extractor, com.tangosol.util.MapIndex index)
        {
        // import com.tangosol.util.CopyOnWriteMap;
        // import java.util.HashMap;
        // import java.util.Iterator;
        // import java.util.Map;
        // import java.util.Queue as java.util.Queue;
        
        if (isPartitionIndexPending(nPartition))
            {
            // find a pending request that pertains to the specified partition
            // and "bundle" the index info into it
        
            java.util.Queue queuePending = getPendingIndexUpdate();
            if (queuePending != null && !queuePending.isEmpty())
                {
                for (Iterator iter = queuePending.iterator(); iter.hasNext(); )
                    {
                    PartitionedCache.UpdateIndexRequest msgPending = (PartitionedCache.UpdateIndexRequest) iter.next();
                    
                    if (msgPending.getPartition() == nPartition)
                        {
                        Map mapPrev = msgPending.getUpdateMap();
                        if (mapPrev == null)
                            {
                            // a pending request without an UpdateMap will rebuild all indexes
                            return;
                            }
        
                        Map mapIndex = (Map) mapPrev.get(storage);
                        if (mapIndex == null)
                            {
                            mapPrev.put(storage, mapIndex = new CopyOnWriteMap(HashMap.class));
                            }
                    
                        mapIndex.put(extractor, index);
                        if (isPartitionIndexPending(nPartition))
                            {
                            return;
                            }
                        else
                            {
                            // index is concurrently being processed; fall back to sub-optimal
                            // approach of scheduleIndexUpdate
                            break;
                            }
                        }
                    }
                }
            }
        
        Map mapIndex = new CopyOnWriteMap(HashMap.class);
        mapIndex.put(extractor, index);
        
        Map mapUpdate = new CopyOnWriteMap(HashMap.class);
        mapUpdate.put(storage, mapIndex);
        
        scheduleIndexUpdate(nPartition, nEventId, mapUpdate);
        }
    
    /**
     * Schedule the pending locks evaluation to perform no later then in
    * specified number of milliseconds. This call has no effect if the
    * evaluation is already scheduled to an earlier time.
     */
    protected synchronized void scheduleLockEvaluation(long cMillis)
        {
        // import com.tangosol.util.Base;
        
        long lNext = cMillis == Long.MAX_VALUE ?
            cMillis : Base.getSafeTimeMillis() + cMillis;
        setLockingNextMillis(Math.min(getLockingNextMillis(), lNext));
        }
    
    /**
     * Serialize the specified message.
    * 
    * @return the message size
     */
    protected com.tangosol.io.ReadBuffer serializeStore(com.oracle.coherence.persistence.PersistentStore store)
        {
        // import com.oracle.coherence.persistence.PersistenceManager;
        // import com.tangosol.util.BinaryWriteBuffer;
        // import java.io.IOException;
        
        BinaryWriteBuffer  buf       = new BinaryWriteBuffer(1024);
        PersistenceManager mgrEvents = getPersistenceControl().getEventsManager();
        
        if (mgrEvents != null)
            {
            try
                {
                mgrEvents.write(store.getId(), buf.getBufferOutput());
                }
            catch (IOException e)
                {
                _trace("Unable to send previous MapEvents in " + store + " to new primary owner of partition.", 1);
                _trace(e);
                }
        
            return buf.toBinary();
            }
        return null;
        }
    
    // Accessor for the property "AddedDaemons"
    /**
     * Setter for property AddedDaemons.<p>
    * Indicates how many additional threads were added to process the deferred
    * index rebuild
     */
    public void setAddedDaemons(int nDaemons)
        {
        __m_AddedDaemons = nDaemons;
        }
    
    // Accessor for the property "BackingMapContext"
    /**
     * Setter for property BackingMapContext.<p>
    * The BackingMapContext (lazily created) is used by the BackingMapManager
    * (if provided) and Storage indexes.
     */
    protected void setBackingMapContext(PartitionedCache.BackingMapContext ctx)
        {
        __m_BackingMapContext = ctx;
        }
    
    // From interface: com.tangosol.net.CacheService
    // From interface: com.tangosol.net.DistributedCacheService
    // Accessor for the property "BackingMapManager"
    /**
     * Setter for property BackingMapManager.<p>
    * Interface that provides the backing map storage implementations for the
    * cache.
     */
    public synchronized void setBackingMapManager(com.tangosol.net.BackingMapManager manager)
        {
        if (isRunning())
            {
            throw new IllegalStateException("Service is already running");
            }
        
        __m_BackingMapManager = (manager);
        }
    
    // Accessor for the property "BackupAllEnvelopeSize"
    /**
     * Setter for property BackupAllEnvelopeSize.<p>
    * The size of BackupAllRequest envelope; used in optimized size estimation
    * for serialization.
    * 
    * @see $BackupAllRequest#getEstimatedByteSize
     */
    public void setBackupAllEnvelopeSize(java.util.concurrent.atomic.AtomicInteger atomicSize)
        {
        __m_BackupAllEnvelopeSize = atomicSize;
        }
    
    // Accessor for the property "BackupCountOpt"
    /**
     * Setter for property BackupCountOpt.<p>
    * Specifies the number of members that will retain backup data that does
    * not require write-behind, i.e. data that is not vulnerable to being lost
    * even if the entire cluster were shut down.
     */
    protected void setBackupCountOpt(int cBackups)
        {
        __m_BackupCountOpt = cBackups;
        }
    
    // Accessor for the property "BackupDeltaCompressor"
    /**
     * Setter for property BackupDeltaCompressor.<p>
    * Interface that provides a strategy for the backup compressor.
     */
    protected void setBackupDeltaCompressor(com.tangosol.io.DeltaCompressor compressor)
        {
        if (isAcceptingClients())
            {
            throw new IllegalStateException("Service is already running");
            }
        
        __m_BackupDeltaCompressor = (compressor);
        }
    
    // Accessor for the property "BackupSingleEnvelopeSize"
    /**
     * Setter for property BackupSingleEnvelopeSize.<p>
    * The size of BackupSingleRequest envolope; used in optimized size
    * estimation for serialization.
    * 
    * @see $BackupSingleRequest#getEstimatedByteSize
     */
    public void setBackupSingleEnvelopeSize(java.util.concurrent.atomic.AtomicInteger atomicSize)
        {
        __m_BackupSingleEnvelopeSize = atomicSize;
        }
    
    // Accessor for the property "BinaryEntryConverter"
    /**
     * Setter for property BinaryEntryConverter.<p>
    * A Converter that converts an $EntryStatus object to a BinaryEntry.
     */
    protected void setBinaryEntryConverter(com.tangosol.util.Converter convEntry)
        {
        __m_BinaryEntryConverter = convEntry;
        }
    
    // Accessor for the property "BinaryMapArray"
    /**
     * Setter for property BinaryMapArray.<p>
    * Holds the $BinaryMap references indexed by the cache id.
    * 
    * @see $BinaryMap#CacheId
     */
    protected void setBinaryMapArray(com.tangosol.util.LongArray aBinMap)
        {
        __m_BinaryMapArray = aBinMap;
        }
    
    // From interface: com.tangosol.net.CacheService
    // From interface: com.tangosol.net.DistributedCacheService
    // Declared at the super level
    /**
     * Setter for property ContextClassLoader.<p>
    * @see com.tangosol.io.ClassLoaderAware
     */
    public void setContextClassLoader(ClassLoader loader)
        {
        // import java.util.Iterator;
        
        super.setContextClassLoader(loader);
        
        PartitionedCache.BackingMapContext ctx = getBackingMapContext();
        if (ctx != null)
            {
            ctx.setClassLoader(loader);
            }
        
        // reset storage converters
        for (Iterator iter = getStorageArray().iterator(); iter.hasNext(); )
            {
            Storage storage  = (Storage) iter.next();
        
            storage.updateConverters();
            }
        }
    
    // Accessor for the property "EventDeltaCompressor"
    /**
     * Setter for property EventDeltaCompressor.<p>
    * Interface that provides a strategy for the event compressor.
     */
    protected void setEventDeltaCompressor(com.tangosol.io.DeltaCompressor compressor)
        {
        if (isAcceptingClients())
            {
            throw new IllegalStateException("Service is already running");
            }
        
        __m_EventDeltaCompressor = (compressor);
        }
    
    // Accessor for the property "EventsHelper"
    /**
     * Setter for property EventsHelper.<p>
     */
    protected void setEventsHelper(PartitionedCache.EventsHelper evtHelper)
        {
        __m_EventsHelper = evtHelper;
        }

    /**
     * Setter for property EventResendInterval
     *
     * Interval between resends of potentially "stuck" oldest event.
     */
    public void setEventResendInterval(long ltMillis)
        {
        __m_EventResendInterval = ltMillis;
        }

    // Accessor for the property "IndexingStartTime"
    /**
     * Setter for property IndexingStartTime.<p>
    * Start of one index build event for all partitions. Modified and accessed
    * on service thread.
     */
    public void setIndexingStartTime(long lTime)
        {
        __m_IndexingStartTime = lTime;
        }
    
    // Accessor for the property "IndexPendingPartitions"
    /**
     * Setter for property IndexPendingPartitions.<p>
    * This PartitionSet that contains partitions that have a pending index
    * rebuild due to partition redistribution or initial index creation.
    * 
    * @volatile
     */
    protected void setIndexPendingPartitions(com.tangosol.net.partition.PartitionSet parts)
        {
        __m_IndexPendingPartitions = parts;
        }
    
    // Accessor for the property "IndexProcessingPartitions"
    /**
     * Setter for property IndexProcessingPartitions.<p>
    * This PartitionSet that contains partitions that index rebuild are being
    * processed,  used in condition check for index rebuild optimization,  see
    * scheduleInitialIndexUpdate.
    * 
    * @volatile
     */
    protected void setIndexProcessingPartitions(com.tangosol.net.partition.PartitionSet parts)
        {
        __m_IndexProcessingPartitions = parts;
        }
    
    // Accessor for the property "IndexUpdateCount"
    /**
     * Setter for property IndexUpdateCount.<p>
    * A number of currently executing index update requests. This value is only
    * used by the service thread.
    * 
    * Note: this number is never greater than the "fair CPU count" (see
    * IndexUpdateRequest$Poll.onResponse).
    * 
    * @see scheduleIndexUpdate
     */
    public void setIndexUpdateCount(int nCount)
        {
        __m_IndexUpdateCount = nCount;
        }
    
    // Accessor for the property "LazyLookupReadBuffer"
    /**
     * Setter for property LazyLookupReadBuffer.<p>
     */
    protected void setLazyLookupReadBuffer(PartitionedCache.LazyLookup lazyReadBuffer)
        {
        __m_LazyLookupReadBuffer = lazyReadBuffer;
        }
    
    // Accessor for the property "LeaseGranularity"
    /**
     * Setter for property LeaseGranularity.<p>
    * The lease granularity.
    * 
    * Valid values are:
    *   Lease.BY_THREAD  - thread based ownership (default)
    *   Lease.BY_MEMBER - member based ownership
     */
    protected void setLeaseGranularity(int nHeldBy)
        {
        __m_LeaseGranularity = nHeldBy;
        }
    
    // Accessor for the property "LockingNextMillis"
    /**
     * Setter for property LockingNextMillis.<p>
    * The LockingNextMillis value is the time (in local system millis) at which
    * the next deferred lock evaluation will be performed.
    * 
    * Initial value is Long.MAX_VALUE.
     */
    public void setLockingNextMillis(long ltMillis)
        {
        __m_LockingNextMillis = ltMillis;
        }

    /**
     * Setter for property OldestEventResendNextMillis
     *
     * The time at which the oldest event should be resent if it is determined
     * to be "old enough", or far enough behind the current event.
     */
    public void setOldestEventResendNextMillis(long ltMillis)
        {
        __m_OldestEventResendNextMillis = ltMillis;
        }

    // Accessor for the property "PendingEvents"
    /**
     * Setter for property PendingEvents.<p>
    * An array of pending event-related items indexed by the corresponding
    * SUID. The SUID represent an event originator (cache server) and the value
    * is a $MapEvent containing all necessary data to re-deliver an event in
    * the case of a ownership-enabled node fail-over.
    * 
    * For a SUID that represents the local node, the value could be "null".
    * Those entries are used to ensure in-order event delivery and calculate
    * the OldestPendingEventSUID property.
     */
    protected void setPendingEvents(com.tangosol.util.LongArray array)
        {
        __m_PendingEvents = array;
        }
    
    // Accessor for the property "PendingIndexUpdate"
    /**
     * Setter for property PendingIndexUpdate.<p>
    * A list of IndexUpdateRequest messages that are waiting to be processed. 
    * 
    * @see scheduleIndexUpdate
     */
    protected void setPendingIndexUpdate(java.util.concurrent.ConcurrentLinkedQueue queueUpdate)
        {
        __m_PendingIndexUpdate = queueUpdate;
        }
    
    // Accessor for the property "PendingResultInfo"
    /**
     * Setter for property PendingResultInfo.<p>
    * An array of sorted maps of pending result-related items keyed by the
    * corresponding SUID. 
    * 
    * Used for requests that need to implement idempotent re-execution in the
    * case of a failover.
     */
    private void setPendingResultInfo(com.tangosol.util.SparseArray[] aLa)
        {
        _assert(getPendingResultInfo() == null);
        __m_PendingResultInfo = (aLa);
        }
    
    // Accessor for the property "ProcessedEvents"
    /**
     * Setter for property ProcessedEvents.<p>
    * An array of already processed events indexed by the corresponding SUID.
    * Used to prevent processing the same event twice in a case of a failover.
    * The values are always nulls.
     */
    protected void setProcessedEvents(com.tangosol.util.LongArray map)
        {
        __m_ProcessedEvents = map;
        }
    
    // Accessor for the property "ReferencesBinaryMap"
    /**
     * Setter for property ReferencesBinaryMap.<p>
    * Map keyed by cache name with a corresponding value being a binary map
    * interface.
     */
    protected void setReferencesBinaryMap(java.util.Map map)
        {
        __m_ReferencesBinaryMap = map;
        }
    
    // Accessor for the property "RequestCoordinator"
    /**
     * Setter for property RequestCoordinator.<p>
    * The RequestCoordinator.
     */
    protected void setRequestCoordinator(PartitionedCache.RequestCoordinator coordinator)
        {
        __m_RequestCoordinator = coordinator;
        }
    
    // Accessor for the property "ResourceCoordinator"
    /**
     * Setter for property ResourceCoordinator.<p>
     */
    protected void setResourceCoordinator(PartitionedCache.ResourceCoordinator ctrlResource)
        {
        __m_ResourceCoordinator = ctrlResource;
        }
    
    // Accessor for the property "ScheduledBackupsThreshold"
    /**
     * Setter for property ScheduledBackupsThreshold.<p>
    * Specifies the ratio in percentage of partition size at which it becomes
    * beneficial to back up an entire partition for a given cache.
    * 
    * Undocumented: configured via
    * coherence.distributed.scheduledbackupsthreshold, see onInit
     */
    public void setScheduledBackupsThreshold(int nThreshold)
        {
        __m_ScheduledBackupsThreshold = nThreshold;
        }

    /**
     * Setter for property MaxPartialResponseSize
     *
     * Specifies the size in bytes after which a query-type response message
     * will be broken up into chunks for it to be "streamed".
     * This is to prevent reaching the 2GB message size limit.
     *
     * Undocumented: configured via
     * coherence.distributed.max.response.size, see onInit
     */
    public void setMaxPartialResponseSize(MemorySize size)
        {
        __m_MaxPartialResponseSize = size;
        }

    // Accessor for the property "ScopedCacheStore"
    /**
     * Setter for property ScopedCacheStore.<p>
    * Map keyed by cache name with a corresponding value being a map (keyed by
    * class loader with a corresponding value being a NamedCache reference).
     */
    protected void setScopedCacheStore(com.tangosol.net.internal.ScopedCacheReferenceStore store)
        {
        __m_ScopedCacheStore = store;
        }
    
    // Accessor for the property "SendBackupsTask"
    /**
     * Setter for property SendBackupsTask.<p>
    * The task that is responsible to send scheduled backup message
    * ($BackupAllRequest) for the pending backup changes.
     */
    public void setSendBackupsTask(PartitionedCache.SendBackupsTask taskBackups)
        {
        __m_SendBackupsTask = taskBackups;
        }
    
    // Accessor for the property "StandardLeaseMillis"
    /**
     * Setter for property StandardLeaseMillis.<p>
    * The duration of a standard Lease in milliseconds. Zero indicates an
    * indefinite lease duration.
     */
    protected void setStandardLeaseMillis(long cMillis)
        {
        __m_StandardLeaseMillis = (Math.max(0L, cMillis));
        }
    
    // Accessor for the property "StatsIndexingTime"
    /**
     * Setter for property StatsIndexingTime.<p>
    * Cumulative elapsed time taken to build all indices, reset when
    * resetStats() is called.
     */
    public void setStatsIndexingTime(java.util.concurrent.atomic.AtomicLong atomicTime)
        {
        __m_StatsIndexingTime = atomicTime;
        }
    
    // Accessor for the property "StorageArray"
    /**
     * Setter for property StorageArray.<p>
    * The StorageArray holds the storage units ($Storage) indexed by the cache
    * id.
    * 
    * As of Coherence 3.7, we use the copy-on-write array, which produces safe
    * iterators. Additionally, any changes to the StorageArray only happen on
    * the service thread.
    * 
    * @see $BinaryMap#CacheId
    * @see $Storage
     */
    protected void setStorageArray(com.tangosol.util.LongArray aStorage)
        {
        __m_StorageArray = aStorage;
        }
    
    // Accessor for the property "StorageGraveyard"
    /**
     * Setter for property StorageGraveyard.<p>
    * Time-limited cache, mapping cache-id to cache-name, of recently destroyed
    * caches.
    * 
    * See COH-3275
     */
    public void setStorageGraveyard(java.util.Map pStorageGraveyard)
        {
        __m_StorageGraveyard = pStorageGraveyard;
        }
    
    // Accessor for the property "StrictPartitioning"
    /**
     * Setter for property StrictPartitioning.<p>
    * Specifies whether or not the PartitionSplittingBackingMap(s) used as
    * PartitionedKeyIndex and BackupMap should be operating in a strict mode. 
    * 
    * @see $Storage#instantiateResourceMap, $Storage#instantiateBackupMap
    * @since Coherence 3.5
     */
    protected void setStrictPartitioning(boolean fStrict)
        {
        __m_StrictPartitioning = fStrict;
        }
    
    // Accessor for the property "TaskSplitThreshold"
    /**
     * Setter for property TaskSplitThreshold.<p>
    * Specifies the size at which it becomes beneficial to split tasks into
    * partitioned sub-tasks.
    * 
    * Undocumented: configured via
    * tangosol.coherence.distributed.tasksplitthreshold, see onInit
     */
    public void setTaskSplitThreshold(int nThreshold)
        {
        __m_TaskSplitThreshold = nThreshold;
        }
    
    // Accessor for the property "TLOContext"
    /**
     * Setter for property TLOContext.<p>
    * Threadlocal Invocation Context
     */
    public void setTLOContext(ThreadLocal localContext)
        {
        __m_TLOContext = localContext;
        }
    
    // Declared at the super level
    /**
     * Write a snapshot of the specified partition to the specified store (which
    * is opened for write).
    * This method may only be called if a persistence environment is configured
    * and the service is quiesced.
     */
    public void snapshotPartition(int iPartition, com.oracle.coherence.persistence.PersistentStore store, Object oToken)
        {
        // import com.tangosol.net.BackingMapManager;
        // import java.util.Iterator;
        
        // ensure the caches ids & names are registered first
        ensurePersistentExtents(store, true);
        
        BackingMapManager manager = getBackingMapManager();
        for (Iterator iterStore = getStorageArray().iterator(); iterStore.hasNext();)
            {
            Storage storage = (Storage) iterStore.next();
            if (storage.isValid() && manager.isBackingMapPersistent(storage.getCacheName(), true))
                {
                storage.snapshotPartition(iPartition, store, oToken);
                }
            }
        
        // call the super last, as this seals the store
        super.snapshotPartition(iPartition, store, oToken);
        }
    
    /**
     * Split the specified collection of $EntryStatus objects by owning member
    * into a Map of each member to the set of EntryStatus objects owned by that
    * member (Map<Member, Set<$EntryStatus> >)
    * 
    * @param iterStatus                an iteration of the $EntryStatus objects
    * to split
    * @param iStore                      the backup index to split the
    * ownership on (0 for primary storage)
    * @param fIgnoreUnchanged only consider EntryStatus objects that have been
    * changed
     */
    public java.util.Map splitEntryStatusByOwner(java.util.Iterator iterStatus, int iStore, boolean fIgnoreUnchanged)
        {
        // import Component.Net.Member;
        // import Component.Net.MemberSet.ActualMemberSet.ServiceMemberSet as com.tangosol.coherence.component.net.memberSet.actualMemberSet.ServiceMemberSet;
        // import com.tangosol.util.Binary;
        // import com.tangosol.util.LiteMap;
        // import com.tangosol.util.LiteSet;
        // import java.util.Map;
        // import java.util.Set;
        
        Map       mapByOwner  = null;
        com.tangosol.coherence.component.net.memberSet.actualMemberSet.ServiceMemberSet setMembers  = getServiceMemberSet();
        int       cPartitions = getPartitionCount();
        int[][]   aaiOwner    = getPartitionAssignments();
        
        while (iterStatus.hasNext())
            {
            Storage.EntryStatus status = (Storage.EntryStatus) iterStatus.next();
            if (fIgnoreUnchanged && !status.isAnyAction())
                {
                continue;
                }
            
            Binary binKey     = (Binary) status.getKey();
            int    iPartition = getKeyPartition(binKey);
            int    nOwner     = aaiOwner[iPartition][iStore];
            Member member     = nOwner > 0 && !setMembers.isServiceLeaving(nOwner) ?
                                    setMembers.getMember(nOwner) : null;
        
            // member could be null here, indicating that the owning partition is orphaned
            Set setMember = mapByOwner != null ? (Set) mapByOwner.get(member) : null;
            if (setMember == null)
                {
                setMember = new LiteSet();
        
                if (mapByOwner == null)
                    {
                    mapByOwner = new LiteMap();
                    }        
                mapByOwner.put(member, setMember);
                }
            setMember.add(status);
            }
        return mapByOwner;
        }
    
    // Declared at the super level
    /**
     * Transfer the specified partition according to TransferControl. Called on
    * the service thread only.
    * 
    * @param iPartition          the partition to transfer
    * @param iBackup           the backup index to transfer
    * @param fLastTransfer  true if this is the last partition to be
    * transferred
    * 
    * @see #preparePartition, releasePartition, receivePartition, movePartition
     */
    protected void transferPartition(int iPartition, int iStore, boolean fLastInTransfer)
        {
        // import Component.Net.Lease;
        // import com.tangosol.io.ReadBuffer;
        // import com.tangosol.net.cache.ConfigurableCacheMap as com.tangosol.net.cache.ConfigurableCacheMap;
        // import com.tangosol.net.cache.ConfigurableCacheMap$EvictionApprover as com.tangosol.net.cache.ConfigurableCacheMap.EvictionApprover;
        // import com.tangosol.net.events.partition.TransferEvent$Type as com.tangosol.net.events.partition.TransferEvent.Type;
        // import com.tangosol.net.partition.VersionedOwnership;
        // import com.tangosol.util.Binary;
        // import com.tangosol.util.ExternalizableHelper as com.tangosol.util.ExternalizableHelper;
        // import com.tangosol.util.LongArray;
        // import com.tangosol.util.SimpleMapEntry;
        // import java.util.ArrayList;
        // import java.util.Collections;
        // import java.util.ConcurrentModificationException;
        // import java.util.Iterator;
        // import java.util.List;
        // import java.util.Map;
        // import java.util.Map$Entry as java.util.Map.Entry;
        
        // Note: super.transferPartition() will change the (local) ownership, so
        //       we must first ensure that any out-of-band BM events are handled,
        //       so as to avoid "unowned" events
        processChanges();
        
        super.transferPartition(iPartition, iStore, fLastInTransfer);
        
        PartitionedCache.TransferControl   control       = (PartitionedCache.TransferControl) getTransferControl();
        LongArray          aStorage      = getStorageArray();
        VersionedOwnership owners        = getPartitionConfig(iPartition);
        PartitionedCache.PartitionControl  ctrlPartition = (PartitionedCache.PartitionControl) getPartitionControl(iPartition);
        long               lVersion      = ctrlPartition.getVersionCounter().get();
        PartitionedCache.EventsHelper      evtHelper     = getEventsHelper();
        boolean            fPrimary      = iStore == 0;
        boolean            fInterceptor  = fPrimary && evtHelper.hasServiceInterceptors(com.tangosol.net.events.partition.TransferEvent.Type.DEPARTING);
        
        if (aStorage.isEmpty())
            {
            // no caches
            PartitionedCache.TransferRequest msgTransfer = (PartitionedCache.TransferRequest) instantiateMessage("TransferRequest");
        
            msgTransfer.setPartition(iPartition);
            msgTransfer.setPartitionVersion(lVersion);
            msgTransfer.setStore(iStore);
            msgTransfer.setOwners(owners);
            msgTransfer.setCacheId(-1L);
            msgTransfer.setResource(new java.util.Map.Entry[0]);
            msgTransfer.setLease(new Lease[0]);
            msgTransfer.setListener(new java.util.Map.Entry[0]);
        
            // even empty transfer size must be > 0
            fLastInTransfer |= control.recordTransfer(msgTransfer, 1);
        
            msgTransfer.setPendingResults(collectPendingResults(iPartition));
            msgTransfer.setPendingEvents(collectPendingEvents(iPartition));
            msgTransfer.setLastInPartition(true);
            msgTransfer.setLastInTransfer(fLastInTransfer);
        
            control.onTransmitCommitted(msgTransfer);
        
            if (fInterceptor)
                {
                // transfer message posted as a continuation
                evtHelper.onEntriesDeparting(Collections.singletonList(msgTransfer),
                                             getContinuations().instantiateMessagePost(msgTransfer));
                }
            else
                {
                post(msgTransfer);
                }
            }
        else
            {
            List listTransfer = fInterceptor ? new ArrayList(aStorage.getSize()) : null;
        
            for (Iterator iterStore = aStorage.iterator(); iterStore.hasNext();)
                {
                // the storage must be valid since we only update on the service thread
                Storage storage = (Storage) iterStore.next();
        
                // resource data
                List             listResource = new ArrayList();
                int              cbResource   = 0;
                com.tangosol.net.cache.ConfigurableCacheMap.EvictionApprover approver     = null;
                com.tangosol.net.cache.ConfigurableCacheMap              mapCCM       = storage.getConfigurableCacheMap(iPartition);
        
                Map mapPendingBackups = fPrimary && isScheduledBackups() && ctrlPartition.hasScheduledBackups()
                        ? (Map) ctrlPartition.getPendingBackups().get(storage.getCacheId())
                        : Collections.emptyMap();
                
                try
                    {
                    if (mapCCM != null)
                        {
                        // install the eviction disapprover to prevent eviction on the service thread
                        approver = mapCCM.getEvictionApprover();
                        mapCCM.setEvictionApprover(com.tangosol.net.cache.ConfigurableCacheMap.EvictionApprover.DISAPPROVER);
                        }
        
                    for (Iterator iterResource = storage.collectKeySet(iPartition).iterator();
                         iterResource.hasNext();)
                        {
                        Binary     binKey   = (Binary) iterResource.next();
                        ReadBuffer bufValue = storage.getValueForTransfer(binKey, /*fRemove*/ false);
        
                        // decorate the value to notify the new primary that the backups are
                        // out of sync
                        if (mapPendingBackups.containsKey(binKey))
                            {
                            bufValue = com.tangosol.util.ExternalizableHelper.decorate(
                                bufValue == null ? Binary.EMPTY : bufValue,
                                com.tangosol.util.ExternalizableHelper.DECO_BACKUP, Binary.TRUE);
                            }
        
                        if (bufValue != null)
                            {
                            cbResource += binKey.length() + bufValue.length();
                            listResource.add(new SimpleMapEntry(binKey, bufValue));
                            }
                        }
                    }
                finally
                    {
                    if (mapCCM != null)
                        {
                        // restore the old eviction approver
                        mapCCM.setEvictionApprover(approver);
                        }
                    }
        
                // lease data
                List listLease = new ArrayList();
                int  cbLease   = 0;
                Map  mapLease  = storage.getLeaseMap();
                while (!mapLease.isEmpty())
                    {
                    try
                        {
                        for (Iterator iterLease = mapLease.values().iterator();
                                iterLease.hasNext();)
                            {
                            Lease  lease  = (Lease) iterLease.next();
                            Binary binKey = (Binary) lease.getResourceKey();
                            if (getKeyPartition(binKey) == iPartition)
                                {
                                cbLease += binKey.length() + 28; // see Lease.write()
                                listLease.add(lease);
                                }
                            }
                        break;
                        }
                    catch (ConcurrentModificationException e)
                        {
                        listLease.clear();
                        cbLease = 0;
                        }
                    }
        
                // listener data
                List listListen = new ArrayList();
                int  cbListen   = 0;
                Map  mapListen  = storage.getKeyListenerMap();
                while (mapListen != null && !mapListen.isEmpty())
                    {
                    try
                        {
                        for (Iterator iterListener = mapListen.entrySet().iterator();
                                iterListener.hasNext();)
                            {
                            java.util.Map.Entry  entry  = (java.util.Map.Entry) iterListener.next();
                            Binary binKey = (Binary) entry.getKey();
                            if (getKeyPartition(binKey) == iPartition)
                                {
                                cbListen += binKey.length() + ((Map) entry.getValue()).size()*8;
                                listListen.add(entry);
                                }
                            }
                        break;
                        }
                    catch (ConcurrentModificationException e)
                        {
                        listListen.clear();
                        cbListen = 0;
                        }
                    }
        
                // TODO: hraja: we should transfer the BDB data files 
                //       and re-create on the new primary owner / receiver;
                //       although we may be able to re-use the archive API / contract
                //       to send the store's data to the new owner in a PersistentStore
                //       agnostic way
        
                int     cbTransfer  = cbResource + cbLease + cbListen;
                boolean fLastInPart = !iterStore.hasNext();
        
                PartitionedCache.TransferRequest msgTransfer = (PartitionedCache.TransferRequest) instantiateMessage("TransferRequest");
                msgTransfer.setPartition(iPartition);
                msgTransfer.setPartitionVersion(lVersion);
                msgTransfer.setStore(iStore);
                msgTransfer.setOwners(owners);
                msgTransfer.setCacheId(storage.getCacheId());
                msgTransfer.setCacheName(storage.getCacheName());
                msgTransfer.setResource((java.util.Map.Entry[]) listResource.toArray(new java.util.Map.Entry[listResource.size()]));
                msgTransfer.setLease((Lease[]) listLease.toArray(new Lease[listLease.size()]));
                msgTransfer.setListener((java.util.Map.Entry[]) listListen.toArray(new java.util.Map.Entry[listListen.size()]));
                msgTransfer.setMapEventVersion(storage.getVersion().getSubmittedVersion(iPartition));
        
                fLastInTransfer |= control.recordTransfer(msgTransfer, cbTransfer);
        
                msgTransfer.setLastInPartition(fLastInPart);
                msgTransfer.setLastInTransfer(fLastInPart && fLastInTransfer);
        
                if (fLastInPart)
                    {
                    msgTransfer.setPendingResults(collectPendingResults(iPartition));
                    msgTransfer.setPendingEvents(collectPendingEvents(iPartition));
        
                    // events data
                    if (fPrimary && isPersistEvents())
                        {
                        // _assert(ctrlPartition.getPersistentEventsStore() != null);
        
                        // serialize the store into a Binary
                        msgTransfer.setEventsStoreBinary(
                            serializeStore(ctrlPartition.getPersistentEventsStore()));
                        }
        
                    control.onTransmitCommitted(msgTransfer);
                    }
        
                if (fInterceptor)
                    {
                    // COH-8423: we need to hold the entire set of entries to pass to UEM;
                    //           post all transfer requests for a given partition only after
                    //           UEM has finished to avoid eager "clean-up" of the resources
                    //           on the message serialization (see $TransferRequest#write)
                    listTransfer.add(msgTransfer);
        
                    if (fLastInPart)
                        {
                        // transfer message posted as a continuation
                        evtHelper.onEntriesDeparting(
                                listTransfer, getContinuations().instantiateMessagePost(listTransfer));
                        }
                    }
                else
                    {
                    post(msgTransfer);
                    }
                }
            }
        }
    
    /**
     * Ensure that all persistent stores truncate the provided extent.
     */
    public void truncatePersistentExtent(Storage storage)
        {
        // import com.tangosol.net.partition.PartitionSet;
        
        if (getPersistenceManager() != null && storage.isPersistent())
            {
            long         lCacheId = storage.getCacheId();
            PartitionSet parts    = calculatePartitionSet(getThisMember(), 0);
        
            for (int iPart = parts.next(0); iPart >= 0; iPart = parts.next(iPart + 1))
                {
                getPartitionControl(iPart).truncatePersistentExtent(lCacheId);
                }
            }
        }
    
    /**
     * Unregister a key based storage request.
    * 
    * @param fGate if true, exit the gate; otherwise assume that the gate will
    * be exited explicitly
     */
    public void unlockKey(Storage storage, com.tangosol.util.Binary binKey, boolean fExit)
        {
        getResourceCoordinator().unlock(storage, binKey);
        if (fExit)
            {
            exitPartition(getKeyPartition(binKey));
            }
        }
    
    /**
     * Unlock the entries in the specified array.  The passed in Object array
    * can contain either BinaryEntry objects or Binary keys.
    * 
    * @param aEntry array of BinaryEntry objects or Binary  keys to be unlocked
    * @param ofStart index of the first entry in the array to unlock
    * @param ofEnd index after the last entry in the array to unlock
    * @param fGate if true, exit the gate; otherwise assume that the gate will
    * be exited explicitly
     */
    protected void unlockKeys(Storage storage, Object[] aEntry, int ofStart, int ofEnd, boolean fExit)
        {
        // import com.tangosol.util.Binary;
        
        for (int i = ofStart; i < ofEnd; i++)
            {
            Object entry = aEntry[i];
            if (entry != null)
                {
                Binary binKey = entry instanceof Storage.BinaryEntry ?
                    ((Storage.BinaryEntry) entry).getBinaryKey() : (Binary) entry;
                unlockKey(storage, binKey, fExit);
                }
            }
        }
    
    /**
     * Release a synthetic lock for a given storage.
     */
    protected void unlockSynthetic(Storage storage)
        {
        // import com.tangosol.util.Binary;
        
        getResourceCoordinator().unlock(storage, new Binary());
        }

    /**
     * Unregister an event after a confirmed delivery. Called on the service
    * thread.
     */
    public void unregisterEvent(PartitionedCache.MapEvent msgEvent)
        {
        // import com.tangosol.util.LongArray;
        
        LongArray laPending = getPendingEvents();
        synchronized (laPending)
            {
            laPending.remove(msgEvent.getEventSUID());
            }
        }
    
    /**
     * Update elapsed index build time.
     */
    public void updateIndexBuildTime()
        {
        // import com.tangosol.util.Base;
        
        // update elapsed time, reset start time
        getStatsIndexingTime().getAndAdd(Base.getSafeTimeMillis() - getIndexingStartTime());
        setIndexingStartTime(0L);
        }
    
    /**
     * Update IndexPendingPartitions that have a pending index rebuild.  Called
    * on both service and worker threads.
     */
    public synchronized void updatePendingIndexPartition(int nPartition, boolean fAdd)
        {
        // import com.tangosol.net.partition.PartitionSet;
        
        PartitionSet parts = getIndexPendingPartitions();
        
        if (fAdd ^ parts.contains(nPartition))
            {
            // use copy-on-write to protect concurrent readers
            parts = new PartitionSet(parts);
        
            if (fAdd)
                {
                parts.add(nPartition);
                }
            else
                {
                parts.remove(nPartition);
                }
        
            setIndexPendingPartitions(parts);
            }
        }
    
    /**
     * Update IndexProcessingPartitions that index rebuild is being processed. 
    * Called on both service and worker threads.
     */
    public synchronized void updateProcessingIndexPartition(int nPartition, boolean fAdd)
        {
        // import com.tangosol.net.partition.PartitionSet;
        
        PartitionSet parts = getIndexProcessingPartitions();
        
        if (fAdd ^ parts.contains(nPartition))
            {
            // use copy-on-write to protect concurrent readers
            parts = new PartitionSet(parts);
        
            if (fAdd)
                {
                parts.add(nPartition);
                }
            else
                {
                parts.remove(nPartition);
                }
        
            setIndexProcessingPartitions(parts);
            }
        }
    
    // Declared at the super level
    /**
     * Validate the assignment array against the specified member-set.
    * 
    * @param setOwners   the ownership member-set
    * 
    * Called on the service thread only.
     */
    public void validatePartitionAssignments(com.tangosol.coherence.component.net.MemberSet setOwners)
        {
        super.validatePartitionAssignments(setOwners);
        
        getRequestCoordinator().syncAssignments();
        }
    
    // Declared at the super level
    /**
     * Check that the partition configuration is valid, or arrange to wait until
    * it does. Called on the service thread only.
    * 
    * Note: This method does not block itself, instead it delays the service
    * thread by resetting the distribution check time.
    * IMPORTANT: when called from onServiceStarted() and this node is the
    * senior service member, we hold the Service monitor.
     */
    protected boolean validatePartitionConfig()
        {
        boolean fSuccess = super.validatePartitionConfig();
        if (fSuccess)
            {
            getRequestCoordinator().syncAssignments();
            }
        
        return fSuccess;
        }
    
    /**
     * For debugging only.
     */
    public void validatePartitionedContent()
        {
        // import java.util.Iterator;
        
        for (Iterator iterStore = getStorageArray().iterator(); iterStore.hasNext();)
            {
            Storage storage = (Storage) iterStore.next();
            if (storage.isValid())
                {
                storage.validatePartitionedContent(true, false);
                storage.validatePartitionedContent(false, false);
                }
            }
        }
    
    /**
     * Validates that there is no associated (read) exception on the request,
    * and that the storage requested exists. In the event that there is no
    * storage or that there has been an exception, the response is prepared
    * such that it is safe for the caller to abort.
    * 
    * Should be called before pinning partitions.
    *  
    * @param msgRequest        the request from the client
    * @param msgResponse     the response to send back to the client
    * @param fEnsureSupport  true if a license check should be performed 
    * 
    * @return the requested $Storage, or null if the caller should return.
     */
    protected Storage validateRequestForStorage(com.tangosol.coherence.component.net.message.RequestMessage msgRequest, com.tangosol.coherence.component.net.Message msgResponse, boolean fEnsureSupport)
        {
        // import Component.Net.Message.ResponseMessage.DistributedPartialResponse as com.tangosol.coherence.component.net.message.responseMessage.DistributedPartialResponse;
        // import Component.Net.Message.RequestMessage.DistributedCacheKeyRequest as com.tangosol.coherence.component.net.message.requestMessage.DistributedCacheKeyRequest;
        // import Component.Net.Message.RequestMessage.DistributedCacheRequest as com.tangosol.coherence.component.net.message.requestMessage.DistributedCacheRequest;
        // import com.tangosol.internal.tracing.TracingHelper;
        // import com.tangosol.net.RequestPolicyException;
        
        Throwable exception = null;
        long      lCacheId  = 0L;
        
        if (msgRequest instanceof com.tangosol.coherence.component.net.message.requestMessage.DistributedCacheKeyRequest)
            {
            lCacheId = ((com.tangosol.coherence.component.net.message.requestMessage.DistributedCacheKeyRequest) msgRequest).getCacheId();
            }
        else // msgRequest instanceof com.tangosol.coherence.component.net.message.requestMessage.DistributedCacheRequest
            {
            com.tangosol.coherence.component.net.message.requestMessage.DistributedCacheRequest cacheReq = (com.tangosol.coherence.component.net.message.requestMessage.DistributedCacheRequest) msgRequest;
        
            // check for license or serialization exceptions
            exception = fEnsureSupport
                    ? ensureSupport(cacheReq, "InvocableMap")
                    : cacheReq.getReadException();
            if (exception == null)
                {
                lCacheId = cacheReq.getCacheId();
                }
            }
        
        if (exception == null)
            {
            // validate that the storage is known
            Storage storage = getStorage(lCacheId);
            if (storage == null)
                {
                String sCache = (String) getStorageGraveyard().get(Long.valueOf(lCacheId));
        
                exception = new RequestPolicyException("The reference to "
                    + (sCache == null ? "the cache" : ("cache \"" + sCache + "\""))
                    + " has been released");
                }
            else
                {
                TracingHelper.augmentSpan().setMetadata("cache", storage.getCacheName());
                return storage;
                }
            }
        
        // exception != null
        if (msgResponse instanceof com.tangosol.coherence.component.net.message.responseMessage.DistributedPartialResponse)
            {
            ((com.tangosol.coherence.component.net.message.responseMessage.DistributedPartialResponse) msgResponse).setException(tagException(exception));
            }
        else if (msgResponse instanceof PartitionedCache.Response)
            {
            ((PartitionedCache.Response) msgResponse).setValue(tagException(exception));
            }
        
        post(msgResponse);
        
        return null;
        }
    
    // Declared at the super level
    /**
     * Validate the local service config is compatible with the service config
    * in use by the senior member.
    * 
    * @return true if the configuration is validated; false otherwise
     */
    protected boolean validateServiceConfig()
        {
        boolean fSuccess = super.validateServiceConfig();
        
        // RequestCoordinator depends on PartitionCount being set
        getRequestCoordinator().initialize();
        
        return fSuccess;
        }
    
    // Declared at the super level
    /**
     * Validate the specified service config against this member.
    * 
    * @param xmlConfig   the service config
    * 
    * @return true  if this member is consistent with the specified config
     */
    protected boolean validateServiceConfig(com.tangosol.run.xml.XmlElement xmlConfig)
        {
        String sCompressor = getEventDeltaCompressor().getClass().getName();
        
        return super.validateServiceConfig(xmlConfig)
            && verifyFeature("BinaryDelta", sCompressor, 
                    xmlConfig.getSafeAttribute("delta-compressor").getString());
        }
    
    /**
     * Validate all storages in respect to:
    *     - current leases held by the departed member
    *     - proxy listeners representing the departed member.
    * 
    * Called on the service thread only.
    * 
    * @see #onNotifyServiceLeft
     */
    protected void validateStorages(com.tangosol.coherence.component.net.Member memberLeft)
        {
        // import java.util.Iterator;
        
        for (Iterator iterStore = getStorageArray().iterator(); iterStore.hasNext();)
            {
            Storage storage = (Storage) iterStore.next();
            if (storage.isValid())
                {
                storage.validateLocks();
                storage.validateListeners();
                }
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$AggregateAllRequest
    
    /**
     * @see $BinaryMap#aggregate(Collection, ...)
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class AggregateAllRequest
            extends    com.tangosol.coherence.component.net.message.requestMessage.distributedCacheRequest.KeySetRequest
        {
        // ---- Fields declarations ----
        
        /**
         * Property Aggregator
         *
         * (Transient) Cached Aggregator reference. It becomes available only
         * after the aggregator is explicitly deserialized during server side
         * processing of this message.
         * 
         * @see #deserializeAggregator()
         */
        private transient com.tangosol.util.InvocableMap.EntryAggregator __m_Aggregator;
        
        /**
         * Property AggregatorBinary
         *
         * The binary representation of an EntryAggregator.
         */
        private com.tangosol.util.Binary __m_AggregatorBinary;
        private static com.tangosol.util.ListMap __mapChildren;
        
        // Static initializer
        static
            {
            __initStatic();
            }
        
        // Default static initializer
        private static void __initStatic()
            {
            // register child classes
            __mapChildren = new com.tangosol.util.ListMap();
            __mapChildren.put("Poll", PartitionedCache.AggregateAllRequest.Poll.get_CLASS());
            }
        
        // Default constructor
        public AggregateAllRequest()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public AggregateAllRequest(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                setMessageType(51);
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // containment initialization: children
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.AggregateAllRequest();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$AggregateAllRequest".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        //++ getter for autogen property _ChildClasses
        /**
         * This is an auto-generated method that returns the map of design time
        * [static] children.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        protected java.util.Map get_ChildClasses()
            {
            return __mapChildren;
            }
        
        // Declared at the super level
        /**
         * Instantiate a copy of this message. This is quite different from the
        * standard "clone" since only the "transmittable" portion of the
        * message (and none of the internal) state should be cloned.
         */
        public com.tangosol.coherence.component.net.Message cloneMessage()
            {
            PartitionedCache.AggregateAllRequest msg = (PartitionedCache.AggregateAllRequest) super.cloneMessage();
            
            msg.setAggregatorBinary(getAggregatorBinary());
            
            return msg;
            }
        
        public com.tangosol.util.InvocableMap.EntryAggregator deserializeAggregator()
            {
            // import com.tangosol.util.ExternalizableHelper as com.tangosol.util.ExternalizableHelper;
            // import com.tangosol.util.InvocableMap$EntryAggregator as com.tangosol.util.InvocableMap.EntryAggregator;
            
            com.tangosol.util.InvocableMap.EntryAggregator aggregator = getAggregator();
            if (aggregator == null)
                {
                aggregator = (com.tangosol.util.InvocableMap.EntryAggregator) com.tangosol.util.ExternalizableHelper.fromBinary(
                    getAggregatorBinary(), getService().getSerializer());
                setAggregator(aggregator);
                }
            return aggregator;
            }
        
        // Accessor for the property "Aggregator"
        /**
         * Getter for property Aggregator.<p>
        * (Transient) Cached Aggregator reference. It becomes available only
        * after the aggregator is explicitly deserialized during server side
        * processing of this message.
        * 
        * @see #deserializeAggregator()
         */
        public com.tangosol.util.InvocableMap.EntryAggregator getAggregator()
            {
            return __m_Aggregator;
            }
        
        // Accessor for the property "AggregatorBinary"
        /**
         * Getter for property AggregatorBinary.<p>
        * The binary representation of an EntryAggregator.
         */
        public com.tangosol.util.Binary getAggregatorBinary()
            {
            return __m_AggregatorBinary;
            }
        
        // Declared at the super level
        /**
         * Getter for property Description.<p>
        * Used for debugging purposes (from toString). Create a human-readable
        * description of the specific Message data.
         */
        public String getDescription()
            {
            return super.getDescription() + ", Aggregator=" + getAggregator();
            }
        
        // Declared at the super level
        public void read(com.tangosol.io.ReadBuffer.BufferInput input)
                throws java.io.IOException
            {
            // import com.tangosol.util.Binary;
            
            super.read(input);
            
            setAggregatorBinary((Binary) readObject(input));
            
            readTracing(input);
            }
        
        // Declared at the super level
        public void run()
            {
            ((PartitionedCache) getService()).onAggregateAllRequest(this);
            }
        
        // Accessor for the property "Aggregator"
        /**
         * Setter for property Aggregator.<p>
        * (Transient) Cached Aggregator reference. It becomes available only
        * after the aggregator is explicitly deserialized during server side
        * processing of this message.
        * 
        * @see #deserializeAggregator()
         */
        public void setAggregator(com.tangosol.util.InvocableMap.EntryAggregator agent)
            {
            __m_Aggregator = agent;
            }
        
        // Accessor for the property "AggregatorBinary"
        /**
         * Setter for property AggregatorBinary.<p>
        * The binary representation of an EntryAggregator.
         */
        public void setAggregatorBinary(com.tangosol.util.Binary binAgent)
            {
            __m_AggregatorBinary = binAgent;
            }
        
        // Declared at the super level
        /**
         * Setter for property RequestTimeout.<p>
        * Transient property optionally used on the client to indicate the
        * (safe local) time after which this logical request should be
        * considered timed out.
        * 
        * Note that a single logical request message may result in multiple
        * physical request messages being sent to mulitple members; this
        * RequestTimeout value will be cloned to all resulting RequestMessage
        * instances.
        * 
        * This value is lazily calculated by #getRequestTimeout or
        * #calculateTimeoutRemaining.
         */
        public void setRequestTimeout(long ldtTimeout)
            {
            super.setRequestTimeout(ldtTimeout);
            }
        
        // Declared at the super level
        public void write(com.tangosol.io.WriteBuffer.BufferOutput output)
                throws java.io.IOException
            {
            super.write(output);
            
            writeObject(output, getAggregatorBinary());
            
            writeTracing(output);
            }

        // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$AggregateAllRequest$Poll
        
        /**
         * The Poll contains information regarding a request sent to one or
         * more Cluster Members that require responses. A Service may poll
         * other Members that are running the same Service, and the Poll is
         * used to wait for and assemble the responses from each of those
         * Members. A client thread may also use the Poll to block on a
         * response or set of responses, thus waiting for the completion of the
         * Poll. In its simplest form, which is a Poll that is sent to one
         * Member of the Cluster, the Poll actually represents the
         * request/response model.
         */
        @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
        public static class Poll
                extends    com.tangosol.coherence.component.net.message.requestMessage.distributedCacheRequest.KeySetRequest.Poll
            {
            // ---- Fields declarations ----
            
            // Default constructor
            public Poll()
                {
                this(null, null, true);
                }
            
            // Initializing constructor
            public Poll(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                {
                super(sName, compParent, false);
                
                if (fInit)
                    {
                    __init();
                    }
                }
            
            // Main initializer
            public void __init()
                {
                // private initialization
                __initPrivate();
                
                
                // signal the end of the initialization
                set_Constructed(true);
                }
            
            // Private initializer
            protected void __initPrivate()
                {
                
                super.__initPrivate();
                }
            
            // Getter for virtual constant Preprocessable
            public boolean isPreprocessable()
                {
                return true;
                }
            
            //++ getter for static property _Instance
            /**
             * Getter for property _Instance.<p>
            * Auto generated
             */
            public static com.tangosol.coherence.Component get_Instance()
                {
                return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.AggregateAllRequest.Poll();
                }
            
            //++ getter for static property _CLASS
            /**
             * Getter for property _CLASS.<p>
            * Property with auto-generated accessor that returns the Class
            * object for a given component.
             */
            public static Class get_CLASS()
                {
                Class clz;
                try
                    {
                    clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$AggregateAllRequest$Poll".replace('/', '.'));
                    }
                catch (ClassNotFoundException e)
                    {
                    throw new NoClassDefFoundError(e.getMessage());
                    }
                return clz;
                }
            
            //++ getter for autogen property _Module
            /**
             * This is an auto-generated method that returns the global [design
            * time] parent component.
            * 
            * Note: the class generator will ignore any custom implementation
            * for this behavior.
             */
            private com.tangosol.coherence.Component get_Module()
                {
                return this.get_Parent().get_Parent();
                }
            
            // Declared at the super level
            protected void processAsyncResponse(com.tangosol.coherence.component.net.Message msg)
                {
                // import Component.Net.RequestContext.AsyncContext.AsyncAggregatorContext;
                // import java.util.Collection;
                // import java.util.Iterator;
                
                PartitionedCache.AggregateAllRequest   msgRequest  = (PartitionedCache.AggregateAllRequest) get_Parent();
                AsyncAggregatorContext context     = (AsyncAggregatorContext) msgRequest.getRequestContext();
                PartitionedCache.PartialValueResponse  msgResponse = (PartitionedCache.PartialValueResponse) msg;
                
                if (msgResponse.getException() == null)
                    {
                    Object oResult = msgResponse.getResult();
                    if (oResult != null)
                        {
                        if (msgResponse.isCollection())
                            {
                            for (Iterator iter = ((Collection) oResult).iterator(); iter.hasNext();)
                                {
                                context.processPartialResult(iter.next());
                                }
                            }
                        else
                            {
                            context.processPartialResult(oResult);
                            }
                        }
                    }
                else
                    {
                    context.processException(msgResponse.getException());
                    }
                }
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$AggregateFilterRequest
    
    /**
     * @see $BinaryMap#aggregate(Filter, ...)
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class AggregateFilterRequest
            extends    com.tangosol.coherence.component.net.message.requestMessage.distributedCacheRequest.partialRequest.FilterRequest
        {
        // ---- Fields declarations ----
        
        /**
         * Property Aggregator
         *
         * (Transient) Cached Aggregator reference. It becomes available only
         * after the aggregator is explicitly deserialized during server side
         * processing of this message.
         * 
         * @see #deserializeAggregator()
         */
        private transient com.tangosol.util.InvocableMap.EntryAggregator __m_Aggregator;
        
        /**
         * Property AggregatorBinary
         *
         * The binary representation of an EntryAggregator.
         */
        private com.tangosol.util.Binary __m_AggregatorBinary;
        private static com.tangosol.util.ListMap __mapChildren;
        
        // Static initializer
        static
            {
            __initStatic();
            }
        
        // Default static initializer
        private static void __initStatic()
            {
            // register child classes
            __mapChildren = new com.tangosol.util.ListMap();
            __mapChildren.put("Poll", PartitionedCache.AggregateFilterRequest.Poll.get_CLASS());
            }
        
        // Default constructor
        public AggregateFilterRequest()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public AggregateFilterRequest(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                setMessageType(52);
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // containment initialization: children
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.AggregateFilterRequest();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$AggregateFilterRequest".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        //++ getter for autogen property _ChildClasses
        /**
         * This is an auto-generated method that returns the map of design time
        * [static] children.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        protected java.util.Map get_ChildClasses()
            {
            return __mapChildren;
            }
        
        // Declared at the super level
        /**
         * Instantiate a copy of this message. This is quite different from the
        * standard "clone" since only the "transmittable" portion of the
        * message (and none of the internal) state should be cloned.
         */
        public com.tangosol.coherence.component.net.Message cloneMessage()
            {
            PartitionedCache.AggregateFilterRequest msg = (PartitionedCache.AggregateFilterRequest) super.cloneMessage();
            
            msg.setAggregatorBinary(getAggregatorBinary());
            
            return msg;
            }
        
        public com.tangosol.util.InvocableMap.EntryAggregator deserializeAggregator()
            {
            // import com.tangosol.util.ExternalizableHelper as com.tangosol.util.ExternalizableHelper;
            // import com.tangosol.util.InvocableMap$EntryAggregator as com.tangosol.util.InvocableMap.EntryAggregator;
            
            com.tangosol.util.InvocableMap.EntryAggregator aggregator = getAggregator();
            if (aggregator == null)
                {
                aggregator = (com.tangosol.util.InvocableMap.EntryAggregator) com.tangosol.util.ExternalizableHelper.fromBinary(
                    getAggregatorBinary(), getService().getSerializer());
                setAggregator(aggregator);
                }
            return aggregator;
            }
        
        // Accessor for the property "Aggregator"
        /**
         * Getter for property Aggregator.<p>
        * (Transient) Cached Aggregator reference. It becomes available only
        * after the aggregator is explicitly deserialized during server side
        * processing of this message.
        * 
        * @see #deserializeAggregator()
         */
        public com.tangosol.util.InvocableMap.EntryAggregator getAggregator()
            {
            return __m_Aggregator;
            }
        
        // Accessor for the property "AggregatorBinary"
        /**
         * Getter for property AggregatorBinary.<p>
        * The binary representation of an EntryAggregator.
         */
        public com.tangosol.util.Binary getAggregatorBinary()
            {
            return __m_AggregatorBinary;
            }
        
        // Declared at the super level
        /**
         * Getter for property Description.<p>
        * Used for debugging purposes (from toString). Create a human-readable
        * description of the specific Message data.
         */
        public String getDescription()
            {
            return super.getDescription()
                + ", Aggregator=" + getAggregator() + ", Filter=" + getFilter();
            }
        
        // Declared at the super level
        public void read(com.tangosol.io.ReadBuffer.BufferInput input)
                throws java.io.IOException
            {
            // import com.tangosol.util.Binary;
            
            super.read(input);
            
            if (getReadException() == null)
                {
                setAggregatorBinary((Binary) readObject(input));
                readTracing(input);
                }
            }
        
        // Declared at the super level
        public void run()
            {
            ((PartitionedCache) getService()).onAggregateFilterRequest(this);
            }
        
        // Declared at the super level
        public void runCanceled(boolean fAbandoned)
            {
            // import com.tangosol.net.PriorityTask;
            // import com.tangosol.util.InvocableMap$EntryAggregator as com.tangosol.util.InvocableMap.EntryAggregator;
            
            com.tangosol.util.InvocableMap.EntryAggregator agent = getAggregator();
            if (agent instanceof PriorityTask)
                {
                ((PriorityTask) agent).runCanceled(fAbandoned);
                }
            else
                {
                super.runCanceled(fAbandoned);
                }
            }
        
        // Accessor for the property "Aggregator"
        /**
         * Setter for property Aggregator.<p>
        * (Transient) Cached Aggregator reference. It becomes available only
        * after the aggregator is explicitly deserialized during server side
        * processing of this message.
        * 
        * @see #deserializeAggregator()
         */
        public void setAggregator(com.tangosol.util.InvocableMap.EntryAggregator agent)
            {
            __m_Aggregator = agent;
            }
        
        // Accessor for the property "AggregatorBinary"
        /**
         * Setter for property AggregatorBinary.<p>
        * The binary representation of an EntryAggregator.
         */
        public void setAggregatorBinary(com.tangosol.util.Binary binAgent)
            {
            __m_AggregatorBinary = binAgent;
            }
        
        // Declared at the super level
        /**
         * Setter for property RequestTimeout.<p>
        * Transient property optionally used on the client to indicate the
        * (safe local) time after which this logical request should be
        * considered timed out.
        * 
        * Note that a single logical request message may result in multiple
        * physical request messages being sent to mulitple members; this
        * RequestTimeout value will be cloned to all resulting RequestMessage
        * instances.
        * 
        * This value is lazily calculated by #getRequestTimeout or
        * #calculateTimeoutRemaining.
         */
        public void setRequestTimeout(long ldtTimeout)
            {
            super.setRequestTimeout(ldtTimeout);
            }
        
        // Declared at the super level
        public void write(com.tangosol.io.WriteBuffer.BufferOutput output)
                throws java.io.IOException
            {
            super.write(output);
            
            writeObject(output, getAggregatorBinary());
            
            writeTracing(output);
            }

        // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$AggregateFilterRequest$Poll
        
        /**
         * The Poll contains information regarding a request sent to one or
         * more Cluster Members that require responses. A Service may poll
         * other Members that are running the same Service, and the Poll is
         * used to wait for and assemble the responses from each of those
         * Members. A client thread may also use the Poll to block on a
         * response or set of responses, thus waiting for the completion of the
         * Poll. In its simplest form, which is a Poll that is sent to one
         * Member of the Cluster, the Poll actually represents the
         * request/response model.
         */
        @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
        public static class Poll
                extends    com.tangosol.coherence.component.net.message.requestMessage.distributedCacheRequest.PartialRequest.Poll
            {
            // ---- Fields declarations ----
            
            // Default constructor
            public Poll()
                {
                this(null, null, true);
                }
            
            // Initializing constructor
            public Poll(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                {
                super(sName, compParent, false);
                
                if (fInit)
                    {
                    __init();
                    }
                }
            
            // Main initializer
            public void __init()
                {
                // private initialization
                __initPrivate();
                
                
                // signal the end of the initialization
                set_Constructed(true);
                }
            
            // Private initializer
            protected void __initPrivate()
                {
                
                super.__initPrivate();
                }
            
            // Getter for virtual constant Preprocessable
            public boolean isPreprocessable()
                {
                return true;
                }
            
            //++ getter for static property _Instance
            /**
             * Getter for property _Instance.<p>
            * Auto generated
             */
            public static com.tangosol.coherence.Component get_Instance()
                {
                return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.AggregateFilterRequest.Poll();
                }
            
            //++ getter for static property _CLASS
            /**
             * Getter for property _CLASS.<p>
            * Property with auto-generated accessor that returns the Class
            * object for a given component.
             */
            public static Class get_CLASS()
                {
                Class clz;
                try
                    {
                    clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$AggregateFilterRequest$Poll".replace('/', '.'));
                    }
                catch (ClassNotFoundException e)
                    {
                    throw new NoClassDefFoundError(e.getMessage());
                    }
                return clz;
                }
            
            //++ getter for autogen property _Module
            /**
             * This is an auto-generated method that returns the global [design
            * time] parent component.
            * 
            * Note: the class generator will ignore any custom implementation
            * for this behavior.
             */
            private com.tangosol.coherence.Component get_Module()
                {
                return this.get_Parent().get_Parent();
                }
            
            // Declared at the super level
            public void processAsyncResponse(com.tangosol.coherence.component.net.Message msg)
                {
                // import Component.Net.RequestContext.AsyncContext.AsyncAggregatorContext;
                // import java.util.Collection;
                // import java.util.Iterator;
                
                PartitionedCache.AggregateFilterRequest msgRequest  = (PartitionedCache.AggregateFilterRequest) get_Parent();
                AsyncAggregatorContext  context     = (AsyncAggregatorContext) msgRequest.getRequestContext();
                PartitionedCache.PartialValueResponse   msgResponse = (PartitionedCache.PartialValueResponse) msg;
                
                if (msgResponse.getException() == null)
                    {
                    Object oResult = msgResponse.getResult();
                    if (oResult != null)
                        {
                        if (msgResponse.isCollection())
                            {
                            for (Iterator iter = ((Collection) oResult).iterator(); iter.hasNext();)
                                {
                                context.processPartialResult(iter.next());
                                }
                            }
                        else
                            {
                            context.processPartialResult(oResult);
                            }
                        }
                    }
                else
                    {
                    context.processException(msgResponse.getException());
                    }
                }
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$BackingMapContext
    
    /**
     * The BackingMapManagerContext implementation.
     * 
     * Added decoration support methods in Coherence 3.2.
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class BackingMapContext
            extends    com.tangosol.coherence.component.util.BackingMapManagerContext
        {
        // ---- Fields declarations ----
        
        /**
         * Property FromBinaryConverter
         *
         * Binary to Object converter for keys and values.
         */
        private transient PartitionedCache.ConverterFromBinary __m_FromBinaryConverter;
        
        /**
         * Property KeyToBinaryConverter
         *
         * Serializable key Object to Binary converter. This Converter must not
         * depend on a ClassLoader and instantiated once the service starts. It
         * is also used as an externally exposed KeyPartitioningStrategy.
         * 
         * @see $Module#onServiceStarted
         */
        private transient PartitionedCache.ConverterKeyToBinary __m_KeyToBinaryConverter;
        
        /**
         * Property ValueToBinaryConverter
         *
         * Serializable value Object to Binary converter.
         */
        private transient PartitionedCache.ConverterValueToBinary __m_ValueToBinaryConverter;
        
        // Default constructor
        public BackingMapContext()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public BackingMapContext(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.BackingMapContext();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$BackingMapContext".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        // Declared at the super level
        public java.util.Map getBackingMap(String sCacheName)
            {
            Storage storage = ((PartitionedCache) get_Module()).getStorage(sCacheName);
            
            return storage == null ? null : storage.getBackingMap();
            }
        
        // Declared at the super level
        public com.tangosol.net.BackingMapContext getBackingMapContext(String sCacheName)
            {
            return ((PartitionedCache) get_Module()).getStorage(sCacheName);
            }
        
        // Accessor for the property "FromBinaryConverter"
        /**
         * Getter for property FromBinaryConverter.<p>
        * Binary to Object converter for keys and values.
         */
        public PartitionedCache.ConverterFromBinary getFromBinaryConverter()
            {
            return __m_FromBinaryConverter;
            }
        
        // Declared at the super level
        public com.tangosol.util.Converter getKeyFromInternalConverter()
            {
            return getFromBinaryConverter();
            }
        
        // Declared at the super level
        public int getKeyPartition(Object oKey)
            {
            // import com.tangosol.util.Binary;
            
            return ((PartitionedCache) get_Module()).getKeyPartition((Binary) oKey);
            }
        
        // Accessor for the property "KeyToBinaryConverter"
        /**
         * Getter for property KeyToBinaryConverter.<p>
        * Serializable key Object to Binary converter. This Converter must not
        * depend on a ClassLoader and instantiated once the service starts. It
        * is also used as an externally exposed KeyPartitioningStrategy.
        * 
        * @see $Module#onServiceStarted
         */
        public PartitionedCache.ConverterKeyToBinary getKeyToBinaryConverter()
            {
            PartitionedCache.ConverterKeyToBinary converter = __m_KeyToBinaryConverter;
            
            if (converter == null)
                {
                converter = (PartitionedCache.ConverterKeyToBinary) getService().getKeyToBinaryConverter();
                setKeyToBinaryConverter(converter);
                }
            return converter;
            }
        
        // Declared at the super level
        public com.tangosol.util.Converter getKeyToInternalConverter()
            {
            return getKeyToBinaryConverter();
            }
        
        // Declared at the super level
        public java.util.Set getPartitionKeys(String sCacheName, int nPartition)
            {
            Storage storage = ((PartitionedCache) get_Module()).getStorage(sCacheName);
            
            return storage == null ? null : storage.getPartitionKeys(nPartition);
            }
        
        // Accessor for the property "Service"
        /**
         * Getter for property Service.<p>
         */
        public PartitionedCache getService()
            {
            return (PartitionedCache) get_Module();
            }
        
        // Declared at the super level
        public com.tangosol.util.Converter getValueFromInternalConverter()
            {
            return getFromBinaryConverter();
            }
        
        // Accessor for the property "ValueToBinaryConverter"
        /**
         * Getter for property ValueToBinaryConverter.<p>
        * Serializable value Object to Binary converter.
         */
        public PartitionedCache.ConverterValueToBinary getValueToBinaryConverter()
            {
            return __m_ValueToBinaryConverter;
            }
        
        // Declared at the super level
        public com.tangosol.util.Converter getValueToInternalConverter()
            {
            return getValueToBinaryConverter();
            }
        
        // Declared at the super level
        public boolean isKeyOwned(Object oKey)
            {
            // import com.tangosol.util.Binary;
            
            return getService().isPrimaryOwner((Binary) oKey);
            }
        
        // Declared at the super level
        /**
         * The "component has been initialized" method-notification called out
        * of setConstructed() for the topmost component and that in turn
        * notifies all the children.
        * 
        * This notification gets called before the control returns back to this
        * component instantiator (using <code>new Component.X()</code> or
        * <code>_newInstance(sName)</code>) and on the same thread. In
        * addition, visual components have a "posted" notification
        * <code>onInitUI</code> that is called after (or at the same time as)
        * the control returns back to the instantiator and possibly on a
        * different thread.
         */
        public void onInit()
            {
            setConfigKey(Integer.valueOf((int) '@'));
            setClassLoader(getService().getContextClassLoader());
            
            super.onInit();
            }
        
        // Declared at the super level
        /**
         * Setter for property ClassLoader.<p>
        * The ClassLoader associated with this context.
         */
        public synchronized void setClassLoader(ClassLoader loader)
            {
            super.setClassLoader(loader);
            
            PartitionedCache service = getService();
            
            // reset the converters
            setFromBinaryConverter(service.instantiateFromBinaryConverter(loader));
            setValueToBinaryConverter(service.instantiateValueToBinaryConverter(loader));
            
            // TODO: invalidate all the ClassLoader dependent Storage indexes
            }
        
        // Accessor for the property "FromBinaryConverter"
        /**
         * Setter for property FromBinaryConverter.<p>
        * Binary to Object converter for keys and values.
         */
        protected void setFromBinaryConverter(PartitionedCache.ConverterFromBinary conv)
            {
            __m_FromBinaryConverter = conv;
            }
        
        // Accessor for the property "KeyToBinaryConverter"
        /**
         * Setter for property KeyToBinaryConverter.<p>
        * Serializable key Object to Binary converter. This Converter must not
        * depend on a ClassLoader and instantiated once the service starts. It
        * is also used as an externally exposed KeyPartitioningStrategy.
        * 
        * @see $Module#onServiceStarted
         */
        public void setKeyToBinaryConverter(PartitionedCache.ConverterKeyToBinary pKeyToBinaryConverter)
            {
            __m_KeyToBinaryConverter = pKeyToBinaryConverter;
            }
        
        // Declared at the super level
        /**
         * Setter for property Manager.<p>
        * The associated manager.
         */
        public void setManager(com.tangosol.net.BackingMapManager manager)
            {
            super.setManager(manager);
            
            // per BackingMapManager contract: call init()
            manager.init(this);
            }
        
        // Accessor for the property "ValueToBinaryConverter"
        /**
         * Setter for property ValueToBinaryConverter.<p>
        * Serializable value Object to Binary converter.
         */
        protected void setValueToBinaryConverter(PartitionedCache.ConverterValueToBinary conv)
            {
            __m_ValueToBinaryConverter = conv;
            }
        
        // Declared at the super level
        public String toString()
            {
            return super.toString() + "@" + hashCode();
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$BackupAllRequest
    
    /**
     * A message for performing batch backup operations.
     * 
     * BackupMultiRequest is also used as a Continuation for deferring the
     * processing of a request for an unowned backup partition, pending a
     * confirmation of the ownership (see #onReceived).
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class BackupAllRequest
            extends    com.tangosol.coherence.component.net.message.requestMessage.chainedRequest.backupRequest.BackupMultiRequest
        {
        // ---- Fields declarations ----
        
        /**
         * Property BatchContext
         *
         * Transient property used by the request originator to associate the
         * BackupAll requests with the original request's BatchContext.
         */
        private transient PartitionedCache.BatchContext __m_BatchContext;
        
        /**
         * Property CacheId
         *
         * The Id of the cache this request is for.
         * 
         * As of Coherence 3.6, the CacheId may be -1L, indicating that this
         * BackupAllRequest includes backup operations for multiple caches.
         */
        private long __m_CacheId;
        
        /**
         * Property EventHolderMap
         *
         * A map of holders for event(s) associated with an operation that
         * caused this message to be sent to a backup storage.
         * 
         * The EventHolderMap's keyset is a subset of the Map's keyset and each
         * value's (holder) content can be:
         * 
         * - null (no events)
         * - MapEventMessage instance (one and only one event)
         * - List of MapEventMessage's (for more than one event)
         * 
         * Note: by the time serialization occurs, the EventHolder is expected
         * to be "compressed", i.e. allowing us to skip any values that are
         * expected to be known on the receiving side.
         * 
         * As of Coherence 3.6, if the CacheId is -1L, this map holds a map
         * from CacheId to event map (Map<Long, Map<Binary, holder>>), for each
         * cache included in this BackupAll.
         */
        private java.util.Map __m_EventHolderMap;
        
        /**
         * Property Map
         *
         * Map of entries requested to be updated by this message  (Map<Binary,
         * Binary>).
         * 
         * As of Coherence 3.6, if the CacheId is -1L, this map holds a map
         * from CacheId to entry map (Map<Long, Map<Binary, Binary>>), for each
         * cache included in this BackupAll.
         */
        private java.util.Map __m_Map;
        
        /**
         * Property MapEventVersions
         *
         * A Map of versions with the following types:
         *     Map<LCacheId, VersionedPartitions>
         */
        private java.util.Map __m_MapEventVersions;
        
        /**
         * Property MESSAGE_TYPE
         *
         */
        public static final int MESSAGE_TYPE = 53;
        
        /**
         * Property ResultMap
         *
         * A map of invocation results for the operation that caused this
         * message to be sent to a backup storage.
         * 
         * The ResultMap is used only along with the RequestContext; its keySet
         * is equal to the Map's keySet and each value is an invocation result
         * converted to a Binary.
         * 
         * As of Coherence 3.6, if the CacheId is -1L, this map holds a map
         * from CacheId to result map (Map<Long, Map<Binary, Binary>>), for
         * each cache included in this BackupAll.
         */
        private java.util.Map __m_ResultMap;
        
        /**
         * Property ResultsCacheId
         *
         * The Id of the cache that the results map correspond to.
         * 
         * This property is only used if CacheId == -1.
         * 
         * Note: Even for a BackupAllRequest that spans multiple caches
         * (CacheId==-1), the result map is associated with a single cache-id.
         */
        private long __m_ResultsCacheId;
        private static com.tangosol.util.ListMap __mapChildren;
        
        // Static initializer
        static
            {
            __initStatic();
            }
        
        // Default static initializer
        private static void __initStatic()
            {
            // register child classes
            __mapChildren = new com.tangosol.util.ListMap();
            __mapChildren.put("Poll", PartitionedCache.BackupAllRequest.Poll.get_CLASS());
            }
        
        // Default constructor
        public BackupAllRequest()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public BackupAllRequest(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                setMessageType(53);
                setPartitionVersions(new com.tangosol.util.PrimitiveSparseArray());
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // containment initialization: children
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.BackupAllRequest();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$BackupAllRequest".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        //++ getter for autogen property _ChildClasses
        /**
         * This is an auto-generated method that returns the map of design time
        * [static] children.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        protected java.util.Map get_ChildClasses()
            {
            return __mapChildren;
            }
        
        // Declared at the super level
        /**
         * Instantiate a copy of this message. This is quite different from the
        * standard "clone" since only the "transmittable" portion of the
        * message (and none of the internal) state should be cloned.
         */
        public com.tangosol.coherence.component.net.Message cloneMessage()
            {
            PartitionedCache.BackupAllRequest msg = (PartitionedCache.BackupAllRequest) super.cloneMessage();
            
            msg.setCacheId(getCacheId());
            msg.setResultsCacheId(getResultsCacheId());
            msg.setBatchContext(getBatchContext());
            msg.setMap(getMap());
            msg.setResultMap(getResultMap());
            msg.setEventHolderMap(getEventHolderMap());
            msg.setMapEventVersions(getMapEventVersions());
            
            return msg;
            }
        
        // Declared at the super level
        /**
         * Perform the backup operation for all data except the specified
        * partitions.
        * 
        * @param partsSkip the partitions to skip; the value is mostly null
        * meaning that there is nothing to skip
         */
        public void doBackup(com.tangosol.net.partition.PartitionSet partsSkip)
            {
            ((PartitionedCache) getService()).onBackupAllRequest(this, partsSkip);
            }
        
        /**
         * Estimate serialized byte size for one cache's worth of backup data
        * (entries, events, and results).
         */
        public int estimateCacheBackupByteSize(java.util.Map mapEntries, java.util.Map mapEvents, java.util.Map mapResults)
            {
            // import com.tangosol.io.ReadBuffer;
            // import com.tangosol.util.Binary;
            // import com.tangosol.util.ExternalizableHelper as com.tangosol.util.ExternalizableHelper;
            // import java.util.Iterator;
            // import java.util.Map$Entry as java.util.Map.Entry;
            
            final int PINT_SIZE = com.tangosol.util.ExternalizableHelper.PACKED_INT_SIZE;
            final int BIN_SIZE  = com.tangosol.util.ExternalizableHelper.BINARY_SIZE;
            final int BYTE_SIZE = Byte.BYTES;
            
            int cEntries = mapEntries.size();
            int cEvents  = mapEvents  == null ? 0 : mapEvents.size();
            int cResults = mapResults == null ? 0 : mapResults.size();
            int cb       = 3 * PINT_SIZE; // cEntries + cEvents + cResults
            
            for (Iterator iter = mapEntries.entrySet().iterator(); iter.hasNext();)
                {
                java.util.Map.Entry      entry  = (java.util.Map.Entry) iter.next();
                Binary     binKey = (Binary) entry.getKey();
                ReadBuffer binVal = (ReadBuffer) entry.getValue();
            
                if (binKey != null)
                    {
                    cb += binKey.length() + BIN_SIZE;
                    }
            
                cb += binVal == null ? BYTE_SIZE : binVal.length() + BIN_SIZE;
            
                if (cEvents > 0)
                    {
                    Object oEventHolder = mapEvents.get(binKey);
                    cb += ((PartitionedCache) getService()).estimateEventHolderByteSize(oEventHolder);
                    }
            
                if (cResults > 0)
                    {
                    Binary binResult = (Binary) mapResults.get(binKey);
                    cb += binResult == null ? BYTE_SIZE : binResult.length() + BIN_SIZE;
                    }
                }
            
            return cb;
            }
        
        // Accessor for the property "BatchContext"
        /**
         * Getter for property BatchContext.<p>
        * Transient property used by the request originator to associate the
        * BackupAll requests with the original request's BatchContext.
         */
        public PartitionedCache.BatchContext getBatchContext()
            {
            return __m_BatchContext;
            }
        
        // Accessor for the property "CacheId"
        /**
         * Getter for property CacheId.<p>
        * The Id of the cache this request is for.
        * 
        * As of Coherence 3.6, the CacheId may be -1L, indicating that this
        * BackupAllRequest includes backup operations for multiple caches.
         */
        public long getCacheId()
            {
            return __m_CacheId;
            }
        
        // Declared at the super level
        /**
         * Getter for property Description.<p>
        * Used for debugging purposes (from toString). Create a human-readable
        * description of the specific Message data.
         */
        public String getDescription()
            {
            // import java.util.Collections;
            // import java.util.Iterator;
            // import java.util.Map;
            // import java.util.Map$Entry as java.util.Map.Entry;
            
            PartitionedCache service = (PartitionedCache) getService();
            
            String sCacheData = "";
            long   lCacheId   = getCacheId();
            
            // Map<LCacheId, Map<K,V>>
            Map mapCacheData = lCacheId != -1L
                ? Collections.singletonMap(Long.valueOf(lCacheId), getMap()) : getMap();
            
            String sDelimiter = "";
            for (Iterator iter = mapCacheData.entrySet().iterator(); iter.hasNext(); )
                {
                java.util.Map.Entry  entry      = (java.util.Map.Entry) iter.next();
                String sCacheName = service.getCacheName(((Long) entry.getKey()).longValue());
            
                sCacheData += sDelimiter + sCacheName + '(' + ((Map) entry.getValue()).size() + ')';
                sDelimiter = ", ";
                }
            
            return super.getDescription()
                 + "\nData = " + sCacheData;
            }
        
        // Declared at the super level
        /**
         * Getter for property EstimatedByteSize.<p>
        * The estimated serialized size of this message.  A negative value
        * indicates that the size is unknown and that it is safe to estimate
        * the size via a double serialization.
         */
        public int getEstimatedByteSize()
            {
            // import com.tangosol.net.partition.VersionedPartitions;
            // import com.tangosol.util.ExternalizableHelper as com.tangosol.util.ExternalizableHelper;
            // import java.util.Iterator;
            // import java.util.Map;
            // import java.util.Map$Entry as java.util.Map.Entry;
            // import java.util.Set;
            
            final int PLONG_SIZE = com.tangosol.util.ExternalizableHelper.PACKED_LONG_SIZE;
            final int PINT_SIZE  = com.tangosol.util.ExternalizableHelper.PACKED_INT_SIZE;
            final int BIN_SIZE   = com.tangosol.util.ExternalizableHelper.BINARY_SIZE;
            final int BYTE_SIZE  = Byte.BYTES;
            
            int cb     = ((PartitionedCache) getService()).getBackupAllEnvelopeSize().get();
            int cParts = getPartitionVersions().getSize();
            
            cb += cParts * (PINT_SIZE + PLONG_SIZE); // partitions * (partition + version) // BackupMultiRequest.write
            
            PartitionedCache service  = (PartitionedCache) getService();
            long    lCacheId = getCacheId();
            
            Map mapEntries = getMap();            // single or multi-cache
            Map mapEvents  = getEventHolderMap(); // single or multi-cache
            Map mapResults = getResultMap();      // single-cache
            
            if (lCacheId == -1L)
                {
                // this request spans multiple caches
                Set  setCacheIds     = mapEntries.keySet();
                long lResultsCacheId = getResultsCacheId();
            
                cb += PLONG_SIZE + PINT_SIZE; // ResultsCacheId + number of caches
            
                for (Iterator iter = setCacheIds.iterator(); iter.hasNext(); )
                    {
                    Long LCacheIdCur = (Long) iter.next();
            
                    cb += PLONG_SIZE; // lCacheIdCur
            
                    cb += estimateCacheBackupByteSize((Map) mapEntries.get(LCacheIdCur),
                            mapEvents  == null ? null : (Map) mapEvents.get(LCacheIdCur),
                            LCacheIdCur.longValue() == lResultsCacheId ? mapResults : null);
                      }
                }
            else
                {
                cb += estimateCacheBackupByteSize(mapEntries, mapEvents, mapResults);
                }
            
            Map mapEventVersions = getMapEventVersions(); // single or multi-cache
            int cCaches          = mapEventVersions == null ? 0 : mapEventVersions.size();
            
            if (cCaches > 0)
                {
                VersionedPartitions versions = (VersionedPartitions) mapEventVersions.values().iterator().next();
                int                 cClass   = PINT_SIZE + versions.getClass().getName().length();
                int                 cObject  = BYTE_SIZE + cClass + PINT_SIZE; // object type + class name + longArray size
                cb += cCaches * 
                      ((cCaches == 1 ? 0 : PLONG_SIZE) +   // cache-id
                       cObject                         +   // VersionedPartitions data strucutre
                       cParts * (PINT_SIZE + PLONG_SIZE)); // partitions * (partition + version)
                }
            
            return cb;
            }
        
        // Accessor for the property "EventHolderMap"
        /**
         * Getter for property EventHolderMap.<p>
        * A map of holders for event(s) associated with an operation that
        * caused this message to be sent to a backup storage.
        * 
        * The EventHolderMap's keyset is a subset of the Map's keyset and each
        * value's (holder) content can be:
        * 
        * - null (no events)
        * - MapEventMessage instance (one and only one event)
        * - List of MapEventMessage's (for more than one event)
        * 
        * Note: by the time serialization occurs, the EventHolder is expected
        * to be "compressed", i.e. allowing us to skip any values that are
        * expected to be known on the receiving side.
        * 
        * As of Coherence 3.6, if the CacheId is -1L, this map holds a map from
        * CacheId to event map (Map<Long, Map<Binary, holder>>), for each cache
        * included in this BackupAll.
         */
        public java.util.Map getEventHolderMap()
            {
            return __m_EventHolderMap;
            }
        
        // Accessor for the property "Map"
        /**
         * Getter for property Map.<p>
        * Map of entries requested to be updated by this message  (Map<Binary,
        * Binary>).
        * 
        * As of Coherence 3.6, if the CacheId is -1L, this map holds a map from
        * CacheId to entry map (Map<Long, Map<Binary, Binary>>), for each cache
        * included in this BackupAll.
         */
        public java.util.Map getMap()
            {
            return __m_Map;
            }
        
        // Accessor for the property "MapEventVersions"
        /**
         * Getter for property MapEventVersions.<p>
        * A Map of versions with the following types:
        *     Map<LCacheId, VersionedPartitions>
         */
        public java.util.Map getMapEventVersions()
            {
            return __m_MapEventVersions;
            }
        
        // Accessor for the property "ResultMap"
        /**
         * Getter for property ResultMap.<p>
        * A map of invocation results for the operation that caused this
        * message to be sent to a backup storage.
        * 
        * The ResultMap is used only along with the RequestContext; its keySet
        * is equal to the Map's keySet and each value is an invocation result
        * converted to a Binary.
        * 
        * As of Coherence 3.6, if the CacheId is -1L, this map holds a map from
        * CacheId to result map (Map<Long, Map<Binary, Binary>>), for each
        * cache included in this BackupAll.
         */
        public java.util.Map getResultMap()
            {
            return __m_ResultMap;
            }
        
        // Accessor for the property "ResultsCacheId"
        /**
         * Getter for property ResultsCacheId.<p>
        * The Id of the cache that the results map correspond to.
        * 
        * This property is only used if CacheId == -1.
        * 
        * Note: Even for a BackupAllRequest that spans multiple caches
        * (CacheId==-1), the result map is associated with a single cache-id.
         */
        public long getResultsCacheId()
            {
            return __m_ResultsCacheId;
            }
        
        // Declared at the super level
        /**
         * This method is called on the originating member of the request when
        * the request has been fully delivered.
         */
        public void onRequestCompleted()
            {
            // import com.tangosol.util.PrimitiveSparseArray$Iterator as com.tangosol.util.PrimitiveSparseArray.Iterator;
            
            if (isSyncMsg())
                {
                // use the BatchContext to finalize the PartitionedCache.BackupAllRequest
                getBatchContext().onBackupCompleted(this);
                }
            
            PartitionedCache service = (PartitionedCache) getService();
            for (com.tangosol.util.PrimitiveSparseArray.Iterator iter = (com.tangosol.util.PrimitiveSparseArray.Iterator) getPartitionVersions().iterator(); iter.hasNext();)
                {
                iter.nextPrimitive();
            
                PartitionedCache.PartitionControl control = (PartitionedCache.PartitionControl) service.getPartitionControl((int) iter.getIndex());
                if (control != null)
                    {
                    control.finishBackup(iter.getPrimitiveValue());
                    }
                }
            
            super.onRequestCompleted();
            }
        
        // Declared at the super level
        public void read(com.tangosol.io.ReadBuffer.BufferInput input)
                throws java.io.IOException
            {
            // import com.tangosol.util.ExternalizableHelper as com.tangosol.util.ExternalizableHelper;
            // import java.util.Collections;
            // import java.util.HashMap;
            // import java.util.Map;
            
            super.read(input);
            
            long lCacheId = com.tangosol.util.ExternalizableHelper.readLong(input);
            setCacheId(lCacheId);
            
            Map mapEntries = new HashMap();
            Map mapEvents  = new HashMap();
            Map mapResults = new HashMap();
            
            if (lCacheId == -1L)
                {
                long lResultsCacheId = com.tangosol.util.ExternalizableHelper.readLong(input);
                setResultsCacheId(lResultsCacheId);
            
                int cCaches = com.tangosol.util.ExternalizableHelper.readInt(input);
                for (int i = 0; i < cCaches; i++)
                    {
                    Map  mapCacheEntries = new HashMap();
                    Map  mapCacheEvents  = new HashMap();
                    long lCacheIdCur     = com.tangosol.util.ExternalizableHelper.readLong(input);
                    Long LCacheIdCur     = Long.valueOf(lCacheIdCur);
                    
                    readCacheBackup(input, mapCacheEntries, mapCacheEvents,
                                    lCacheIdCur == lResultsCacheId ? mapResults : null);
                    mapEntries.put(LCacheIdCur, mapCacheEntries);
                    if (!mapCacheEvents.isEmpty())
                        {
                        mapEvents.put(LCacheIdCur, mapCacheEvents);
                        }
                    }
                }
            else
                {
                readCacheBackup(input, mapEntries, mapEvents, mapResults);
            
                if (mapEvents.isEmpty())
                    {
                    mapEvents = null;
                    }
                }
            
            readTracing(input);
            
            Map mapEventVersions = Collections.emptyMap();
            if (input.available() > 0)
                {
                int cCaches = com.tangosol.util.ExternalizableHelper.readInt(input);
                if (cCaches > 1)
                    {
                    mapEventVersions = new HashMap(cCaches);
                    for (int i = 0; i < cCaches; ++i)
                        {
                        mapEventVersions.put(
                            Long.valueOf(com.tangosol.util.ExternalizableHelper.readLong(input)), // lCacheId
                            com.tangosol.util.ExternalizableHelper.readObject(input));            // VersionedPartitions
                        }
                    }
                else if (cCaches == 1)
                    {
                    _assert(lCacheId != -1L);
            
                    mapEventVersions = Collections.singletonMap(Long.valueOf(lCacheId), com.tangosol.util.ExternalizableHelper.readObject(input));
                    }
                }
            
            setMap(mapEntries);
            setEventHolderMap(mapEvents);
            setResultMap(mapResults);
            setMapEventVersions(mapEventVersions);
            }
        
        /**
         * Deserialize one cache's worth of backup data (entries, events, and
        * results).
         */
        protected void readCacheBackup(com.tangosol.io.ReadBuffer.BufferInput input, java.util.Map mapEntries, java.util.Map mapEvents, java.util.Map mapResults)
                throws java.io.IOException
            {
            // import Component.Net.Message.MapEventMessage;
            // import com.tangosol.util.ExternalizableHelper;
            
            int cEntries = ExternalizableHelper.readInt(input);
            int cEvents  = ExternalizableHelper.readInt(input);
            int cResults = ExternalizableHelper.readInt(input);
            
            PartitionedCache service = (PartitionedCache) getService();
            
            for (int i = 0; i < cEntries; i++)
                {
                // both key and value are Binary objects
                Object binKey = ExternalizableHelper.readObject(input);
                Object binVal = ExternalizableHelper.readObject(input);
            
                mapEntries.put(binKey, binVal);
                if (cEvents > 0)
                    {
                    Object oHolder = MapEventMessage.readSupplemental(input, service);
                    if (oHolder != null)
                        {
                        mapEvents.put(binKey, oHolder);
                        }
                    }
            
                if (cResults > 0)
                    {
                    Object binResult = readObject(input);
            
                    if (binResult != null)
                        {
                        mapResults.put(binKey, binResult);
                        }
                    }
                }
            }
        
        // Accessor for the property "BatchContext"
        /**
         * Setter for property BatchContext.<p>
        * Transient property used by the request originator to associate the
        * BackupAll requests with the original request's BatchContext.
         */
        public void setBatchContext(PartitionedCache.BatchContext contextBatch)
            {
            __m_BatchContext = contextBatch;
            }
        
        // Accessor for the property "CacheId"
        /**
         * Setter for property CacheId.<p>
        * The Id of the cache this request is for.
        * 
        * As of Coherence 3.6, the CacheId may be -1L, indicating that this
        * BackupAllRequest includes backup operations for multiple caches.
         */
        public void setCacheId(long lId)
            {
            __m_CacheId = lId;
            }
        
        // Accessor for the property "EventHolderMap"
        /**
         * Setter for property EventHolderMap.<p>
        * A map of holders for event(s) associated with an operation that
        * caused this message to be sent to a backup storage.
        * 
        * The EventHolderMap's keyset is a subset of the Map's keyset and each
        * value's (holder) content can be:
        * 
        * - null (no events)
        * - MapEventMessage instance (one and only one event)
        * - List of MapEventMessage's (for more than one event)
        * 
        * Note: by the time serialization occurs, the EventHolder is expected
        * to be "compressed", i.e. allowing us to skip any values that are
        * expected to be known on the receiving side.
        * 
        * As of Coherence 3.6, if the CacheId is -1L, this map holds a map from
        * CacheId to event map (Map<Long, Map<Binary, holder>>), for each cache
        * included in this BackupAll.
         */
        public void setEventHolderMap(java.util.Map mapEvents)
            {
            __m_EventHolderMap = mapEvents;
            }
        
        // Accessor for the property "Map"
        /**
         * Setter for property Map.<p>
        * Map of entries requested to be updated by this message  (Map<Binary,
        * Binary>).
        * 
        * As of Coherence 3.6, if the CacheId is -1L, this map holds a map from
        * CacheId to entry map (Map<Long, Map<Binary, Binary>>), for each cache
        * included in this BackupAll.
         */
        public void setMap(java.util.Map map)
            {
            __m_Map = map;
            }
        
        // Accessor for the property "MapEventVersions"
        /**
         * Setter for property MapEventVersions.<p>
        * A Map of versions with the following types:
        *     Map<LCacheId, VersionedPartitions>
         */
        public void setMapEventVersions(java.util.Map map)
            {
            __m_MapEventVersions = map;
            }
        
        // Declared at the super level
        /**
         * Setter for property RequestTimeout.<p>
        * Transient property optionally used on the client to indicate the
        * (safe local) time after which this logical request should be
        * considered timed out.
        * 
        * Note that a single logical request message may result in multiple
        * physical request messages being sent to mulitple members; this
        * RequestTimeout value will be cloned to all resulting RequestMessage
        * instances.
        * 
        * This value is lazily calculated by #getRequestTimeout or
        * #calculateTimeoutRemaining.
         */
        public void setRequestTimeout(long ldtTimeout)
            {
            super.setRequestTimeout(ldtTimeout);
            }
        
        // Accessor for the property "ResultMap"
        /**
         * Setter for property ResultMap.<p>
        * A map of invocation results for the operation that caused this
        * message to be sent to a backup storage.
        * 
        * The ResultMap is used only along with the RequestContext; its keySet
        * is equal to the Map's keySet and each value is an invocation result
        * converted to a Binary.
        * 
        * As of Coherence 3.6, if the CacheId is -1L, this map holds a map from
        * CacheId to result map (Map<Long, Map<Binary, Binary>>), for each
        * cache included in this BackupAll.
         */
        public void setResultMap(java.util.Map mapResults)
            {
            __m_ResultMap = mapResults;
            }
        
        // Accessor for the property "ResultsCacheId"
        /**
         * Setter for property ResultsCacheId.<p>
        * The Id of the cache that the results map correspond to.
        * 
        * This property is only used if CacheId == -1.
        * 
        * Note: Even for a BackupAllRequest that spans multiple caches
        * (CacheId==-1), the result map is associated with a single cache-id.
         */
        public void setResultsCacheId(long lId)
            {
            __m_ResultsCacheId = lId;
            }
        
        // Declared at the super level
        public void write(com.tangosol.io.WriteBuffer.BufferOutput output)
                throws java.io.IOException
            {
            // import com.tangosol.util.ExternalizableHelper as com.tangosol.util.ExternalizableHelper;
            // import java.util.Iterator;
            // import java.util.Map;
            // import java.util.Map$Entry as java.util.Map.Entry;
            // import java.util.Set;
            
            super.write(output);
            
            long lCacheId = getCacheId();
            com.tangosol.util.ExternalizableHelper.writeLong(output, lCacheId);
            
            Map mapEntries = getMap();            // single or multi-cache
            Map mapEvents  = getEventHolderMap(); // single or multi-cache
            Map mapResults = getResultMap();      // single-cache
            
            PartitionedCache service = (PartitionedCache) getService();
            
            if (!isEstimating())
                {
                if (lCacheId == -1L)
                    {
                    // this request spans multiple caches
                    Set setCacheIds = mapEntries.keySet();
            
                    // write the cache-id associated with the result-map
                    long lResultsCacheId = getResultsCacheId();
                    com.tangosol.util.ExternalizableHelper.writeLong(output, lResultsCacheId);
            
                    // write the number of caches
                    com.tangosol.util.ExternalizableHelper.writeInt(output, setCacheIds.size());
                    for (Iterator iter = setCacheIds.iterator(); iter.hasNext(); )
                        {
                        Long LCacheIdCur = (Long) iter.next();
                        long lCacheIdCur = LCacheIdCur.longValue();
            
                        com.tangosol.util.ExternalizableHelper.writeLong(output, lCacheIdCur);
                        writeCacheBackup(output, (Map) mapEntries.get(LCacheIdCur),
                                mapEvents  == null ? null : (Map) mapEvents.get(LCacheIdCur),
                                lCacheIdCur == lResultsCacheId ? mapResults : null);
                        }
                    }
                else
                    {
                    writeCacheBackup(output, mapEntries, mapEvents, mapResults);
                    }
                }
            
            writeTracing(output);
            
            Map mapEventVersions = getMapEventVersions(); // single or multi-cache
            int cCaches          = mapEventVersions == null ? 0 : mapEventVersions.size();
            
            // write the number of caches
            com.tangosol.util.ExternalizableHelper.writeInt(output, cCaches);
            
            if (!isEstimating())
                {
                if (cCaches > 1)
                    {
                    // multi-cache
            
                    for (Iterator iter = mapEventVersions.entrySet().iterator(); iter.hasNext(); )
                        {
                        java.util.Map.Entry entry = (java.util.Map.Entry) iter.next();
            
                        long lCacheIdCur = ((Long) entry.getKey()).longValue();
            
                        com.tangosol.util.ExternalizableHelper.writeLong(output, lCacheIdCur);
                        com.tangosol.util.ExternalizableHelper.writeObject(output, entry.getValue());
                        }
                    }
                else if (cCaches == 1)
                    {
                    _assert(lCacheId != -1L);
            
                    // single-cache
                    com.tangosol.util.ExternalizableHelper.writeObject(output, mapEventVersions.values().iterator().next());
                    }
                }
            }
        
        /**
         * Serialize one cache's worth of backup data (entries, events, and
        * results).
         */
        protected void writeCacheBackup(com.tangosol.io.WriteBuffer.BufferOutput output, java.util.Map mapEntries, java.util.Map mapEvents, java.util.Map mapResults)
                throws java.io.IOException
            {
            // import Component.Net.Message.MapEventMessage;
            // import com.tangosol.util.ExternalizableHelper;
            // import java.util.Iterator;
            // import java.util.Map$Entry as java.util.Map.Entry;
            
            int cEntries = mapEntries.size();
            int cEvents  = mapEvents  == null ? 0 : mapEvents.size();
            int cResults = mapResults == null ? 0 : mapResults.size();
            
            ExternalizableHelper.writeInt(output, cEntries);
            ExternalizableHelper.writeInt(output, cEvents);
            ExternalizableHelper.writeInt(output, cResults);
            for (Iterator iter = mapEntries.entrySet().iterator(); iter.hasNext();)
                {
                java.util.Map.Entry  entry  = (java.util.Map.Entry) iter.next();
                Object binKey = entry.getKey();
            
                ExternalizableHelper.writeObject(output, binKey);
                ExternalizableHelper.writeObject(output, entry.getValue());
            
                if (cEvents > 0)
                    {
                    MapEventMessage.writeSupplemental(output, mapEvents.get(binKey));
                    }
            
                if (cResults > 0)
                    {
                    writeObject(output, mapResults.get(binKey));
                    }
                }
            }

        // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$BackupAllRequest$Poll
        
        /**
         * The Poll contains information regarding a request sent to one or
         * more Cluster Members that require responses. A Service may poll
         * other Members that are running the same Service, and the Poll is
         * used to wait for and assemble the responses from each of those
         * Members. A client thread may also use the Poll to block on a
         * response or set of responses, thus waiting for the completion of the
         * Poll. In its simplest form, which is a Poll that is sent to one
         * Member of the Cluster, the Poll actually represents the
         * request/response model.
         */
        @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
        public static class Poll
                extends    com.tangosol.coherence.component.net.message.requestMessage.chainedRequest.backupRequest.BackupMultiRequest.Poll
            {
            // ---- Fields declarations ----
            
            // Default constructor
            public Poll()
                {
                this(null, null, true);
                }
            
            // Initializing constructor
            public Poll(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                {
                super(sName, compParent, false);
                
                if (fInit)
                    {
                    __init();
                    }
                }
            
            // Main initializer
            public void __init()
                {
                // private initialization
                __initPrivate();
                
                
                // signal the end of the initialization
                set_Constructed(true);
                }
            
            // Private initializer
            protected void __initPrivate()
                {
                
                super.__initPrivate();
                }
            
            //++ getter for static property _Instance
            /**
             * Getter for property _Instance.<p>
            * Auto generated
             */
            public static com.tangosol.coherence.Component get_Instance()
                {
                return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.BackupAllRequest.Poll();
                }
            
            //++ getter for static property _CLASS
            /**
             * Getter for property _CLASS.<p>
            * Property with auto-generated accessor that returns the Class
            * object for a given component.
             */
            public static Class get_CLASS()
                {
                Class clz;
                try
                    {
                    clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$BackupAllRequest$Poll".replace('/', '.'));
                    }
                catch (ClassNotFoundException e)
                    {
                    throw new NoClassDefFoundError(e.getMessage());
                    }
                return clz;
                }
            
            //++ getter for autogen property _Module
            /**
             * This is an auto-generated method that returns the global [design
            * time] parent component.
            * 
            * Note: the class generator will ignore any custom implementation
            * for this behavior.
             */
            private com.tangosol.coherence.Component get_Module()
                {
                return this.get_Parent().get_Parent();
                }
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$BackupConfirmRequest
    
    /**
     * BackupConfirmRequest is sent by the primary owner to the old backup
     * owner to confirm the ownership as a result of a failure during the
     * backup transfer.
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class BackupConfirmRequest
            extends    com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.BackupConfirmRequest
        {
        // ---- Fields declarations ----
        private static com.tangosol.util.ListMap __mapChildren;
        
        // Static initializer
        static
            {
            __initStatic();
            }
        
        // Default static initializer
        private static void __initStatic()
            {
            // register child classes
            __mapChildren = new com.tangosol.util.ListMap();
            __mapChildren.put("Poll", com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.BackupConfirmRequest.Poll.get_CLASS());
            }
        
        // Default constructor
        public BackupConfirmRequest()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public BackupConfirmRequest(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                setMessageType(40);
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // containment initialization: children
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.BackupConfirmRequest();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$BackupConfirmRequest".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        //++ getter for autogen property _ChildClasses
        /**
         * This is an auto-generated method that returns the map of design time
        * [static] children.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        protected java.util.Map get_ChildClasses()
            {
            return __mapChildren;
            }
        
        // Declared at the super level
        /**
         * Setter for property RequestTimeout.<p>
        * Transient property optionally used on the client to indicate the
        * (safe local) time after which this logical request should be
        * considered timed out.
        * 
        * Note that a single logical request message may result in multiple
        * physical request messages being sent to mulitple members; this
        * RequestTimeout value will be cloned to all resulting RequestMessage
        * instances.
        * 
        * This value is lazily calculated by #getRequestTimeout or
        * #calculateTimeoutRemaining.
         */
        public void setRequestTimeout(long ldtTimeout)
            {
            super.setRequestTimeout(ldtTimeout);
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$BackupListenerAllRequest
    
    /**
     * A BackupMultiRequest is used to backup some aspect of state for multiple
     * partitions.
     * 
     * BackupMultiRequest is also used as a Continuation for deferring the
     * processing of a request for an unowned backup partition, pending a
     * confirmation of the ownership (see #onReceived).
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class BackupListenerAllRequest
            extends    com.tangosol.coherence.component.net.message.requestMessage.chainedRequest.backupRequest.BackupMultiRequest
        {
        // ---- Fields declarations ----
        
        /**
         * Property Add
         *
         */
        private boolean __m_Add;
        
        /**
         * Property BatchContext
         *
         */
        private PartitionedCache.BatchContext __m_BatchContext;
        
        /**
         * Property CacheId
         *
         */
        private long __m_CacheId;
        
        /**
         * Property KeySet
         *
         */
        private java.util.Set __m_KeySet;
        
        /**
         * Property Lite
         *
         */
        private boolean __m_Lite;
        
        /**
         * Property MemberId
         *
         */
        private int __m_MemberId;
        private static com.tangosol.util.ListMap __mapChildren;
        
        // Static initializer
        static
            {
            __initStatic();
            }
        
        // Default static initializer
        private static void __initStatic()
            {
            // register child classes
            __mapChildren = new com.tangosol.util.ListMap();
            __mapChildren.put("Poll", PartitionedCache.BackupListenerAllRequest.Poll.get_CLASS());
            }
        
        // Default constructor
        public BackupListenerAllRequest()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public BackupListenerAllRequest(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                setMessageType(86);
                setPartitionVersions(new com.tangosol.util.PrimitiveSparseArray());
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // containment initialization: children
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.BackupListenerAllRequest();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$BackupListenerAllRequest".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        //++ getter for autogen property _ChildClasses
        /**
         * This is an auto-generated method that returns the map of design time
        * [static] children.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        protected java.util.Map get_ChildClasses()
            {
            return __mapChildren;
            }
        
        /**
         * Add key for the listener registrations.
        * 
        * @param binKey   Binary Key for which the listener is being registered
         */
        public void addKey(com.tangosol.util.Binary binKey)
            {
            // import java.util.Set;
            // import java.util.HashSet;
            
            Set setKeys = getKeySet();
            if (setKeys == null)
                {
                setKeys = new HashSet();
                setKeySet(setKeys);
                }
            
            setKeys.add(binKey);
            }
        
        // Declared at the super level
        /**
         * Instantiate a copy of this message. This is quite different from the
        * standard "clone" since only the "transmittable" portion of the
        * message (and none of the internal) state should be cloned.
         */
        public com.tangosol.coherence.component.net.Message cloneMessage()
            {
            PartitionedCache.BackupListenerAllRequest msg = (PartitionedCache.BackupListenerAllRequest) super.cloneMessage();
            
            msg.setAdd(isAdd());
            msg.setCacheId(getCacheId());
            msg.setLite(isLite());
            msg.setMemberId(getMemberId());
            msg.setBatchContext(getBatchContext());
            msg.setKeySet(getKeySet());
            
            return msg;
            }
        
        // Declared at the super level
        /**
         * Perform the backup operation for all data except the specified
        * partitions.
        * 
        * @param partsSkip the partitions to skip; the value is mostly null
        * meaning that there is nothing to skip
         */
        public void doBackup(com.tangosol.net.partition.PartitionSet partsSkip)
            {
            ((PartitionedCache) getService()).onBackupListenerAllRequest(this, partsSkip);
            }
        
        // Accessor for the property "BatchContext"
        /**
         * Getter for property BatchContext.<p>
         */
        public PartitionedCache.BatchContext getBatchContext()
            {
            return __m_BatchContext;
            }
        
        // Accessor for the property "CacheId"
        /**
         * Getter for property CacheId.<p>
         */
        public long getCacheId()
            {
            return __m_CacheId;
            }
        
        // Accessor for the property "KeySet"
        /**
         * Getter for property KeySet.<p>
         */
        public java.util.Set getKeySet()
            {
            return __m_KeySet;
            }
        
        // Accessor for the property "MemberId"
        /**
         * Getter for property MemberId.<p>
         */
        public int getMemberId()
            {
            return __m_MemberId;
            }
        
        // Accessor for the property "Add"
        /**
         * Getter for property Add.<p>
         */
        public boolean isAdd()
            {
            return __m_Add;
            }
        
        // Accessor for the property "Lite"
        /**
         * Getter for property Lite.<p>
         */
        public boolean isLite()
            {
            return __m_Lite;
            }
        
        // Declared at the super level
        /**
         * This method is called on the originating member of the request when
        * the request has been fully delivered.
         */
        public void onRequestCompleted()
            {
            // import com.tangosol.util.PrimitiveSparseArray$Iterator as com.tangosol.util.PrimitiveSparseArray.Iterator;
            
            if (isSyncMsg())
                {
                // use the BatchContext to finalize the $BackupAllListenerRequest
                PartitionedCache.BatchContext ctxBatch = getBatchContext();
                if (ctxBatch != null)
                    {
                    ctxBatch.onBackupCompleted(this);
                    }
                }
            
            super.onRequestCompleted();
            }
        
        // Declared at the super level
        public void read(com.tangosol.io.ReadBuffer.BufferInput input)
                throws java.io.IOException
            {
            // import com.tangosol.util.Binary;
            // import com.tangosol.util.ExternalizableHelper as com.tangosol.util.ExternalizableHelper;
            // import java.util.HashSet;
            // import java.util.Iterator;
            // import java.util.Set;
            
            super.read(input);
            
            setCacheId(com.tangosol.util.ExternalizableHelper.readLong(input));
            setAdd(input.readBoolean());
            setLite(input.readBoolean());
            setMemberId(com.tangosol.util.ExternalizableHelper.readInt(input));
            
            int cKeys   = com.tangosol.util.ExternalizableHelper.readInt(input);
            Set setKeys = new HashSet(cKeys);
            
            for (int i = 0; i < cKeys; i++)
                {
                // keys are Binary objects
                Object binKey = readObject(input);
                
                setKeys.add(binKey);
                }
            
            readTracing(input);
            
            setKeySet(setKeys);
            }
        
        // Accessor for the property "Add"
        /**
         * Setter for property Add.<p>
         */
        public void setAdd(boolean fAdd)
            {
            __m_Add = fAdd;
            }
        
        // Accessor for the property "BatchContext"
        /**
         * Setter for property BatchContext.<p>
         */
        public void setBatchContext(PartitionedCache.BatchContext contextBatch)
            {
            __m_BatchContext = contextBatch;
            }
        
        // Accessor for the property "CacheId"
        /**
         * Setter for property CacheId.<p>
         */
        public void setCacheId(long lId)
            {
            __m_CacheId = lId;
            }
        
        // Accessor for the property "KeySet"
        /**
         * Setter for property KeySet.<p>
         */
        public void setKeySet(java.util.Set setKey)
            {
            __m_KeySet = setKey;
            }
        
        // Accessor for the property "Lite"
        /**
         * Setter for property Lite.<p>
         */
        public void setLite(boolean fLite)
            {
            __m_Lite = fLite;
            }
        
        // Accessor for the property "MemberId"
        /**
         * Setter for property MemberId.<p>
         */
        public void setMemberId(int nId)
            {
            __m_MemberId = nId;
            }
        
        // Declared at the super level
        public void write(com.tangosol.io.WriteBuffer.BufferOutput output)
                throws java.io.IOException
            {
            // import com.tangosol.util.Binary;
            // import com.tangosol.util.ExternalizableHelper as com.tangosol.util.ExternalizableHelper;
            // import java.util.Iterator;
            // import java.util.Set;
            
            super.write(output);
            
            com.tangosol.util.ExternalizableHelper.writeLong(output, getCacheId());
            output.writeBoolean(isAdd());
            output.writeBoolean(isLite());
            com.tangosol.util.ExternalizableHelper.writeInt(output, getMemberId());
            
            Set setKeys = getKeySet();
            
            com.tangosol.util.ExternalizableHelper.writeInt(output, setKeys.size());
            
            for (Iterator iter = setKeys.iterator(); iter.hasNext();)
                {
                writeObject(output, iter.next());
                }
            
            writeTracing(output);
            }

        // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$BackupListenerAllRequest$Poll
        
        /**
         * The Poll contains information regarding a request sent to one or
         * more Cluster Members that require responses. A Service may poll
         * other Members that are running the same Service, and the Poll is
         * used to wait for and assemble the responses from each of those
         * Members. A client thread may also use the Poll to block on a
         * response or set of responses, thus waiting for the completion of the
         * Poll. In its simplest form, which is a Poll that is sent to one
         * Member of the Cluster, the Poll actually represents the
         * request/response model.
         */
        @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
        public static class Poll
                extends    com.tangosol.coherence.component.net.message.requestMessage.chainedRequest.backupRequest.BackupMultiRequest.Poll
            {
            // ---- Fields declarations ----
            
            // Default constructor
            public Poll()
                {
                this(null, null, true);
                }
            
            // Initializing constructor
            public Poll(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                {
                super(sName, compParent, false);
                
                if (fInit)
                    {
                    __init();
                    }
                }
            
            // Main initializer
            public void __init()
                {
                // private initialization
                __initPrivate();
                
                
                // signal the end of the initialization
                set_Constructed(true);
                }
            
            // Private initializer
            protected void __initPrivate()
                {
                
                super.__initPrivate();
                }
            
            //++ getter for static property _Instance
            /**
             * Getter for property _Instance.<p>
            * Auto generated
             */
            public static com.tangosol.coherence.Component get_Instance()
                {
                return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.BackupListenerAllRequest.Poll();
                }
            
            //++ getter for static property _CLASS
            /**
             * Getter for property _CLASS.<p>
            * Property with auto-generated accessor that returns the Class
            * object for a given component.
             */
            public static Class get_CLASS()
                {
                Class clz;
                try
                    {
                    clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$BackupListenerAllRequest$Poll".replace('/', '.'));
                    }
                catch (ClassNotFoundException e)
                    {
                    throw new NoClassDefFoundError(e.getMessage());
                    }
                return clz;
                }
            
            //++ getter for autogen property _Module
            /**
             * This is an auto-generated method that returns the global [design
            * time] parent component.
            * 
            * Note: the class generator will ignore any custom implementation
            * for this behavior.
             */
            private com.tangosol.coherence.Component get_Module()
                {
                return this.get_Parent().get_Parent();
                }
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$BackupListenerRequest
    
    /**
     * A message used to backup key-listener requests.
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class BackupListenerRequest
            extends    com.tangosol.coherence.component.net.message.requestMessage.chainedRequest.backupRequest.BackupSingleRequest
        {
        // ---- Fields declarations ----
        
        /**
         * Property Add
         *
         * @see $BinaryMap.addMapListener
         * @see $BinaryMap.removeMapListener
         */
        private boolean __m_Add;
        
        /**
         * Property CacheId
         *
         * The Id of the cache this request is for.
         */
        private long __m_CacheId;
        
        /**
         * Property Key
         *
         * The (binary) key that this listener request relates to.
         */
        private com.tangosol.util.Binary __m_Key;
        
        /**
         * Property Lite
         *
         * @see $BinaryMap.addMapListener
         */
        private boolean __m_Lite;
        
        /**
         * Property MemberId
         *
         * The id of the listening member.
         */
        private int __m_MemberId;
        
        /**
         * Property PrimaryResponse
         *
         * Transient property holding a response to a primary request message.
         * This property is used only when a primary owner has to defer
         * responding to a client request (i.e. Put, Remove) until the backup
         * owners confirm the receipt.
         */
        private com.tangosol.coherence.component.net.Message __m_PrimaryResponse;
        private static com.tangosol.util.ListMap __mapChildren;
        
        // Static initializer
        static
            {
            __initStatic();
            }
        
        // Default static initializer
        private static void __initStatic()
            {
            // register child classes
            __mapChildren = new com.tangosol.util.ListMap();
            __mapChildren.put("Poll", PartitionedCache.BackupListenerRequest.Poll.get_CLASS());
            }
        
        // Default constructor
        public BackupListenerRequest()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public BackupListenerRequest(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                setMessageType(82);
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // containment initialization: children
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.BackupListenerRequest();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$BackupListenerRequest".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        //++ getter for autogen property _ChildClasses
        /**
         * This is an auto-generated method that returns the map of design time
        * [static] children.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        protected java.util.Map get_ChildClasses()
            {
            return __mapChildren;
            }
        
        // Declared at the super level
        /**
         * Instantiate a copy of this message. This is quite different from the
        * standard "clone" since only the "transmittable" portion of the
        * message (and none of the internal) state should be cloned.
         */
        public com.tangosol.coherence.component.net.Message cloneMessage()
            {
            PartitionedCache.BackupListenerRequest msg = (PartitionedCache.BackupListenerRequest) super.cloneMessage();
            
            msg.setAdd(isAdd());
            msg.setCacheId(getCacheId());
            msg.setKey(getKey());
            msg.setLite(isLite());
            msg.setMemberId(getMemberId());
            msg.setPrimaryResponse(getPrimaryResponse());
            
            return msg;
            }
        
        // Declared at the super level
        /**
         * Perform the backup operation.
         */
        public void doBackup()
            {
            ((PartitionedCache) getService()).onBackupListenerRequest(this);
            }
        
        // Accessor for the property "CacheId"
        /**
         * Getter for property CacheId.<p>
        * The Id of the cache this request is for.
         */
        public long getCacheId()
            {
            return __m_CacheId;
            }
        
        // Declared at the super level
        /**
         * Getter for property EstimatedByteSize.<p>
        * The estimated serialized size of this message.  A negative value
        * indicates that the size is unknown and that it is safe to estimate
        * the size via a double serialization.
         */
        public int getEstimatedByteSize()
            {
            return -1;
            }
        
        // Accessor for the property "Key"
        /**
         * Getter for property Key.<p>
        * The (binary) key that this listener request relates to.
         */
        public com.tangosol.util.Binary getKey()
            {
            return __m_Key;
            }
        
        // Accessor for the property "MemberId"
        /**
         * Getter for property MemberId.<p>
        * The id of the listening member.
         */
        public int getMemberId()
            {
            return __m_MemberId;
            }
        
        // Accessor for the property "PrimaryResponse"
        /**
         * Getter for property PrimaryResponse.<p>
        * Transient property holding a response to a primary request message.
        * This property is used only when a primary owner has to defer
        * responding to a client request (i.e. Put, Remove) until the backup
        * owners confirm the receipt.
         */
        public com.tangosol.coherence.component.net.Message getPrimaryResponse()
            {
            return __m_PrimaryResponse;
            }
        
        // Accessor for the property "Add"
        /**
         * Getter for property Add.<p>
        * @see $BinaryMap.addMapListener
        * @see $BinaryMap.removeMapListener
         */
        public boolean isAdd()
            {
            return __m_Add;
            }
        
        // Accessor for the property "Lite"
        /**
         * Getter for property Lite.<p>
        * @see $BinaryMap.addMapListener
         */
        public boolean isLite()
            {
            return __m_Lite;
            }
        
        // Declared at the super level
        /**
         * This method is called on the originating member of the request when
        * the request has been fully delivered.
         */
        public void onRequestCompleted()
            {
            PartitionedCache service = (PartitionedCache) getService();
            
            if (service.isAsyncBackup())
                {
                // nothing to post; response have already been posted asynchronously
                }
            else
                {
                service.publishToClients(getPrimaryResponse(), null);
                }
            
            super.onRequestCompleted();
            }
        
        // Declared at the super level
        public void read(com.tangosol.io.ReadBuffer.BufferInput input)
                throws java.io.IOException
            {
            // import com.tangosol.util.Binary;
            // import com.tangosol.util.ExternalizableHelper as com.tangosol.util.ExternalizableHelper;
            
            super.read(input);
            
            setCacheId(com.tangosol.util.ExternalizableHelper.readLong(input));
            setKey((Binary) readObject(input));
            setAdd(input.readBoolean());
            setLite(input.readBoolean());
            setMemberId(com.tangosol.util.ExternalizableHelper.readInt(input));
            
            readTracing(input);
            }
        
        // Accessor for the property "Add"
        /**
         * Setter for property Add.<p>
        * @see $BinaryMap.addMapListener
        * @see $BinaryMap.removeMapListener
         */
        public void setAdd(boolean fAdd)
            {
            __m_Add = fAdd;
            }
        
        // Accessor for the property "CacheId"
        /**
         * Setter for property CacheId.<p>
        * The Id of the cache this request is for.
         */
        public void setCacheId(long lId)
            {
            __m_CacheId = lId;
            }
        
        // Accessor for the property "Key"
        /**
         * Setter for property Key.<p>
        * The (binary) key that this listener request relates to.
         */
        public void setKey(com.tangosol.util.Binary binKey)
            {
            __m_Key = binKey;
            }
        
        // Accessor for the property "Lite"
        /**
         * Setter for property Lite.<p>
        * @see $BinaryMap.addMapListener
         */
        public void setLite(boolean fLite)
            {
            __m_Lite = fLite;
            }
        
        // Accessor for the property "MemberId"
        /**
         * Setter for property MemberId.<p>
        * The id of the listening member.
         */
        public void setMemberId(int nId)
            {
            __m_MemberId = nId;
            }
        
        // Accessor for the property "PrimaryResponse"
        /**
         * Setter for property PrimaryResponse.<p>
        * Transient property holding a response to a primary request message.
        * This property is used only when a primary owner has to defer
        * responding to a client request (i.e. Put, Remove) until the backup
        * owners confirm the receipt.
         */
        public void setPrimaryResponse(com.tangosol.coherence.component.net.Message msgResponse)
            {
            __m_PrimaryResponse = msgResponse;
            }
        
        // Declared at the super level
        /**
         * Setter for property RequestTimeout.<p>
        * Transient property optionally used on the client to indicate the
        * (safe local) time after which this logical request should be
        * considered timed out.
        * 
        * Note that a single logical request message may result in multiple
        * physical request messages being sent to mulitple members; this
        * RequestTimeout value will be cloned to all resulting RequestMessage
        * instances.
        * 
        * This value is lazily calculated by #getRequestTimeout or
        * #calculateTimeoutRemaining.
         */
        public void setRequestTimeout(long ldtTimeout)
            {
            super.setRequestTimeout(ldtTimeout);
            }
        
        // Declared at the super level
        public void write(com.tangosol.io.WriteBuffer.BufferOutput output)
                throws java.io.IOException
            {
            // import com.tangosol.util.Binary;
            // import com.tangosol.util.ExternalizableHelper as com.tangosol.util.ExternalizableHelper;
            
            super.write(output);
            
            com.tangosol.util.ExternalizableHelper.writeLong(output, getCacheId());
            writeObject(output, getKey());
            output.writeBoolean(isAdd());
            output.writeBoolean(isLite());
            com.tangosol.util.ExternalizableHelper.writeInt(output, getMemberId());
            
            writeTracing(output);
            }

        // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$BackupListenerRequest$Poll
        
        /**
         * The Poll contains information regarding a request sent to one or
         * more Cluster Members that require responses. A Service may poll
         * other Members that are running the same Service, and the Poll is
         * used to wait for and assemble the responses from each of those
         * Members. A client thread may also use the Poll to block on a
         * response or set of responses, thus waiting for the completion of the
         * Poll. In its simplest form, which is a Poll that is sent to one
         * Member of the Cluster, the Poll actually represents the
         * request/response model.
         */
        @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
        public static class Poll
                extends    com.tangosol.coherence.component.net.message.requestMessage.chainedRequest.backupRequest.BackupSingleRequest.Poll
            {
            // ---- Fields declarations ----
            
            // Default constructor
            public Poll()
                {
                this(null, null, true);
                }
            
            // Initializing constructor
            public Poll(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                {
                super(sName, compParent, false);
                
                if (fInit)
                    {
                    __init();
                    }
                }
            
            // Main initializer
            public void __init()
                {
                // private initialization
                __initPrivate();
                
                
                // signal the end of the initialization
                set_Constructed(true);
                }
            
            // Private initializer
            protected void __initPrivate()
                {
                
                super.__initPrivate();
                }
            
            //++ getter for static property _Instance
            /**
             * Getter for property _Instance.<p>
            * Auto generated
             */
            public static com.tangosol.coherence.Component get_Instance()
                {
                return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.BackupListenerRequest.Poll();
                }
            
            //++ getter for static property _CLASS
            /**
             * Getter for property _CLASS.<p>
            * Property with auto-generated accessor that returns the Class
            * object for a given component.
             */
            public static Class get_CLASS()
                {
                Class clz;
                try
                    {
                    clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$BackupListenerRequest$Poll".replace('/', '.'));
                    }
                catch (ClassNotFoundException e)
                    {
                    throw new NoClassDefFoundError(e.getMessage());
                    }
                return clz;
                }
            
            //++ getter for autogen property _Module
            /**
             * This is an auto-generated method that returns the global [design
            * time] parent component.
            * 
            * Note: the class generator will ignore any custom implementation
            * for this behavior.
             */
            private com.tangosol.coherence.Component get_Module()
                {
                return this.get_Parent().get_Parent();
                }
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$BackupLockRequest
    
    /**
     * A message used to backup Lock/Unlock requests.
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class BackupLockRequest
            extends    com.tangosol.coherence.component.net.message.requestMessage.chainedRequest.backupRequest.BackupSingleRequest
        {
        // ---- Fields declarations ----
        
        /**
         * Property CacheId
         *
         * The Id of the cache this request is for.
         */
        private long __m_CacheId;
        
        /**
         * Property Key
         *
         * The (binary) key to backup the Lock/Unlock action.
         */
        private com.tangosol.util.Binary __m_Key;
        
        /**
         * Property Lease
         *
         * The lease (only used for "Lock").
         */
        private com.tangosol.coherence.component.net.Lease __m_Lease;
        
        /**
         * Property Lock
         *
         * True iff this is a backup to a "Lock" request; otherwise this is an
         * "Unlock" request.
         */
        private boolean __m_Lock;
        
        /**
         * Property PrimaryResponse
         *
         * Transient property holding a response to a primary request message.
         * This property is used only when a primary owner has to defer
         * responding to a client request until the backup owners confirm the
         * receipt.
         */
        private com.tangosol.coherence.component.net.Message __m_PrimaryResponse;
        private static com.tangosol.util.ListMap __mapChildren;
        
        // Static initializer
        static
            {
            __initStatic();
            }
        
        // Default static initializer
        private static void __initStatic()
            {
            // register child classes
            __mapChildren = new com.tangosol.util.ListMap();
            __mapChildren.put("Poll", PartitionedCache.BackupLockRequest.Poll.get_CLASS());
            }
        
        // Default constructor
        public BackupLockRequest()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public BackupLockRequest(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                setMessageType(81);
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // containment initialization: children
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.BackupLockRequest();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$BackupLockRequest".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        //++ getter for autogen property _ChildClasses
        /**
         * This is an auto-generated method that returns the map of design time
        * [static] children.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        protected java.util.Map get_ChildClasses()
            {
            return __mapChildren;
            }
        
        // Declared at the super level
        /**
         * Instantiate a copy of this message. This is quite different from the
        * standard "clone" since only the "transmittable" portion of the
        * message (and none of the internal) state should be cloned.
         */
        public com.tangosol.coherence.component.net.Message cloneMessage()
            {
            PartitionedCache.BackupLockRequest msg = (PartitionedCache.BackupLockRequest) super.cloneMessage();
            
            msg.setCacheId(getCacheId());
            msg.setKey(getKey());
            msg.setLease(getLease());
            msg.setLock(isLock());
            msg.setPrimaryResponse(getPrimaryResponse());
            
            return msg;
            }
        
        // Declared at the super level
        /**
         * Perform the backup operation.
         */
        public void doBackup()
            {
            ((PartitionedCache) getService()).onBackupLockRequest(this);
            }
        
        protected void doLockBackup()
            {
            }
        
        // Accessor for the property "CacheId"
        /**
         * Getter for property CacheId.<p>
        * The Id of the cache this request is for.
         */
        public long getCacheId()
            {
            return __m_CacheId;
            }
        
        // Declared at the super level
        /**
         * Getter for property EstimatedByteSize.<p>
        * The estimated serialized size of this message.  A negative value
        * indicates that the size is unknown and that it is safe to estimate
        * the size via a double serialization.
         */
        public int getEstimatedByteSize()
            {
            return -1;
            }
        
        // Accessor for the property "Key"
        /**
         * Getter for property Key.<p>
        * The (binary) key to backup the Lock/Unlock action.
         */
        public com.tangosol.util.Binary getKey()
            {
            return __m_Key;
            }
        
        // Accessor for the property "Lease"
        /**
         * Getter for property Lease.<p>
        * The lease (only used for "Lock").
         */
        public com.tangosol.coherence.component.net.Lease getLease()
            {
            return __m_Lease;
            }
        
        // Accessor for the property "PrimaryResponse"
        /**
         * Getter for property PrimaryResponse.<p>
        * Transient property holding a response to a primary request message.
        * This property is used only when a primary owner has to defer
        * responding to a client request until the backup owners confirm the
        * receipt.
         */
        public com.tangosol.coherence.component.net.Message getPrimaryResponse()
            {
            return __m_PrimaryResponse;
            }
        
        // Accessor for the property "Lock"
        /**
         * Getter for property Lock.<p>
        * True iff this is a backup to a "Lock" request; otherwise this is an
        * "Unlock" request.
         */
        public boolean isLock()
            {
            return __m_Lock;
            }
        
        // Declared at the super level
        /**
         * This method is called on the originating member of the request when
        * the request has been fully delivered.
         */
        public void onRequestCompleted()
            {
            ((PartitionedCache) getService()).publishToClients(getPrimaryResponse(), null);
            
            super.onRequestCompleted();
            }
        
        // Declared at the super level
        public void read(com.tangosol.io.ReadBuffer.BufferInput input)
                throws java.io.IOException
            {
            // import Component.Net.Lease;
            // import com.tangosol.util.Binary;
            // import com.tangosol.util.ExternalizableHelper as com.tangosol.util.ExternalizableHelper;
            
            super.read(input);
            
            long    lCacheId = com.tangosol.util.ExternalizableHelper.readLong(input);
            Binary  binKey   = (Binary) readObject(input);
            boolean fLock    = input.readBoolean();
            
            setCacheId(lCacheId);
            setKey(binKey);
            setLock(fLock);
            
            if (fLock)
                {
                Lease lease = Lease.instantiate(0, binKey, getService());
                lease.read(input);
                setLease(lease);
                }
            
            readTracing(input);
            }
        
        // Accessor for the property "CacheId"
        /**
         * Setter for property CacheId.<p>
        * The Id of the cache this request is for.
         */
        public void setCacheId(long lId)
            {
            __m_CacheId = lId;
            }
        
        // Accessor for the property "Key"
        /**
         * Setter for property Key.<p>
        * The (binary) key to backup the Lock/Unlock action.
         */
        public void setKey(com.tangosol.util.Binary binKey)
            {
            __m_Key = binKey;
            }
        
        // Accessor for the property "Lease"
        /**
         * Setter for property Lease.<p>
        * The lease (only used for "Lock").
         */
        public void setLease(com.tangosol.coherence.component.net.Lease lease)
            {
            __m_Lease = lease;
            }
        
        // Accessor for the property "Lock"
        /**
         * Setter for property Lock.<p>
        * True iff this is a backup to a "Lock" request; otherwise this is an
        * "Unlock" request.
         */
        public void setLock(boolean fLock)
            {
            __m_Lock = fLock;
            }
        
        // Accessor for the property "PrimaryResponse"
        /**
         * Setter for property PrimaryResponse.<p>
        * Transient property holding a response to a primary request message.
        * This property is used only when a primary owner has to defer
        * responding to a client request until the backup owners confirm the
        * receipt.
         */
        public void setPrimaryResponse(com.tangosol.coherence.component.net.Message msgResponse)
            {
            __m_PrimaryResponse = msgResponse;
            }
        
        // Declared at the super level
        /**
         * Setter for property RequestTimeout.<p>
        * Transient property optionally used on the client to indicate the
        * (safe local) time after which this logical request should be
        * considered timed out.
        * 
        * Note that a single logical request message may result in multiple
        * physical request messages being sent to mulitple members; this
        * RequestTimeout value will be cloned to all resulting RequestMessage
        * instances.
        * 
        * This value is lazily calculated by #getRequestTimeout or
        * #calculateTimeoutRemaining.
         */
        public void setRequestTimeout(long ldtTimeout)
            {
            super.setRequestTimeout(ldtTimeout);
            }
        
        // Declared at the super level
        public void write(com.tangosol.io.WriteBuffer.BufferOutput output)
                throws java.io.IOException
            {
            // import com.tangosol.util.ExternalizableHelper as com.tangosol.util.ExternalizableHelper;
            
            super.write(output);
            
            com.tangosol.util.ExternalizableHelper.writeLong(output, getCacheId());
            writeObject(output, getKey());
            
            boolean fLock = isLock();
            output.writeBoolean(fLock);
            
            if (fLock)
                {
                getLease().write(output);
                }
            
            writeTracing(output);
            }

        // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$BackupLockRequest$Poll
        
        /**
         * The Poll contains information regarding a request sent to one or
         * more Cluster Members that require responses. A Service may poll
         * other Members that are running the same Service, and the Poll is
         * used to wait for and assemble the responses from each of those
         * Members. A client thread may also use the Poll to block on a
         * response or set of responses, thus waiting for the completion of the
         * Poll. In its simplest form, which is a Poll that is sent to one
         * Member of the Cluster, the Poll actually represents the
         * request/response model.
         */
        @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
        public static class Poll
                extends    com.tangosol.coherence.component.net.message.requestMessage.chainedRequest.backupRequest.BackupSingleRequest.Poll
            {
            // ---- Fields declarations ----
            
            // Default constructor
            public Poll()
                {
                this(null, null, true);
                }
            
            // Initializing constructor
            public Poll(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                {
                super(sName, compParent, false);
                
                if (fInit)
                    {
                    __init();
                    }
                }
            
            // Main initializer
            public void __init()
                {
                // private initialization
                __initPrivate();
                
                
                // signal the end of the initialization
                set_Constructed(true);
                }
            
            // Private initializer
            protected void __initPrivate()
                {
                
                super.__initPrivate();
                }
            
            //++ getter for static property _Instance
            /**
             * Getter for property _Instance.<p>
            * Auto generated
             */
            public static com.tangosol.coherence.Component get_Instance()
                {
                return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.BackupLockRequest.Poll();
                }
            
            //++ getter for static property _CLASS
            /**
             * Getter for property _CLASS.<p>
            * Property with auto-generated accessor that returns the Class
            * object for a given component.
             */
            public static Class get_CLASS()
                {
                Class clz;
                try
                    {
                    clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$BackupLockRequest$Poll".replace('/', '.'));
                    }
                catch (ClassNotFoundException e)
                    {
                    throw new NoClassDefFoundError(e.getMessage());
                    }
                return clz;
                }
            
            //++ getter for autogen property _Module
            /**
             * This is an auto-generated method that returns the global [design
            * time] parent component.
            * 
            * Note: the class generator will ignore any custom implementation
            * for this behavior.
             */
            private com.tangosol.coherence.Component get_Module()
                {
                return this.get_Parent().get_Parent();
                }
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$BackupSingleRequest
    
    /**
     * A message for performing backup operations on a single key.
     * 
     * BackupSingleRequest is also used as a Continuation for deferring the
     * processing of a request for an unowned backup partition, pending a
     * confirmation of the ownership (see #onReceived).
     * 
     * BackupSingleRequest is also used as a Collector for async persistence
     * events (see #publishChanges).
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class BackupSingleRequest
            extends    com.tangosol.coherence.component.net.message.requestMessage.chainedRequest.backupRequest.BackupSingleRequest
            implements com.oracle.coherence.common.base.Collector
        {
        // ---- Fields declarations ----
        
        /**
         * Property BackupCompletedTime
         *
         * The System.currentTimeMillis() at which the backup finished or -1 if
         * it hasn't.
         */
        private long __m_BackupCompletedTime;
        
        /**
         * Property CacheId
         *
         * The Id of the cache this request is for.
         */
        private long __m_CacheId;
        
        /**
         * Property CompleteOnPersist
         *
         * Inform the BackupSingleRequest whether to call tryBatchCompletion
         * once the persistence task has completed (Collector.add)
         */
        private boolean __m_CompleteOnPersist;
        
        /**
         * Property EntryInfos
         *
         */
        private java.util.Set __m_EntryInfos;
        
        /**
         * Property EntryInfosOOB
         *
         */
        private java.util.Set __m_EntryInfosOOB;
        
        /**
         * Property EventHolder
         *
         * A holder for event(s) associated with an operation that caused this
         * message to be sent to a backup storage.
         * 
         * The holder content can be:
         * 
         * - null (no events)
         * - MapEventMessage instance (one and only one event)
         * - List of MapEventMessage's (for more than one event)
         * 
         * Note: by the time serialization occurs, the EventHolder is expected
         * to be "compressed", i.e. allowing us to skip any values that are
         * expected to be known on the receiving side.
         */
        private Object __m_EventHolder;
        
        /**
         * Property Key
         *
         * The resource key this request is for.
         * The Key being updated.
         */
        private com.tangosol.util.Binary __m_Key;
        
        /**
         * Property MapEventVersion
         *
         * The version of the corresponding change as discernable from the
         * MapEvent.
         * 
         * @see MapEvent#getVersion
         */
        private long __m_MapEventVersion;
        
        /**
         * Property MESSAGE_TYPE
         *
         */
        public static final int MESSAGE_TYPE = 80;
        
        /**
         * Property OutstandingOperationCounter
         *
         * The number of outstandanding "operations" that are managed by this
         * backup request.  Operations could be either the completion of the
         * job execution (on the service/worker thread), persistence (on the
         * PersistenceManager threads) or the completion of the backup (on
         * service or IO threads).
         * 
         * Transient property used only by the primary, but could be modified
         * on service, worker, persistence or I/O threads.
         */
        private java.util.concurrent.atomic.AtomicInteger __m_OutstandingOperationCounter;
        
        /**
         * Property PersistenceTracingSpan
         *
         * The tracing Span for tracking persistence.
         * 
         * @since 14.1.1.0
         */
        private com.tangosol.internal.tracing.Span __m_PersistenceTracingSpan;
        
        /**
         * Property PrimaryResponse
         *
         * Transient property holding a response to a primary request message.
         * This property is used only when a primary owner has to defer
         * responding to a client request (i.e. Put, Remove) until the backup
         * owners confirm the receipt.
         */
        private com.tangosol.coherence.component.net.Message __m_PrimaryResponse;
        
        /**
         * Property Result
         *
         * The execution "result" (may be null).
         */
        private com.tangosol.util.Binary __m_Result;
        
        /**
         * Property Value
         *
         * The updated value, or null if the entry is removed.
         */
        private com.tangosol.io.ReadBuffer __m_Value;
        private static com.tangosol.util.ListMap __mapChildren;
        
        // Static initializer
        static
            {
            __initStatic();
            }
        
        // Default static initializer
        private static void __initStatic()
            {
            // register child classes
            __mapChildren = new com.tangosol.util.ListMap();
            __mapChildren.put("Poll", PartitionedCache.BackupSingleRequest.Poll.get_CLASS());
            }
        
        // Default constructor
        public BackupSingleRequest()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public BackupSingleRequest(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                setBackupCompletedTime(-1L);
                setMessageType(80);
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // containment initialization: children
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.BackupSingleRequest();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$BackupSingleRequest".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        //++ getter for autogen property _ChildClasses
        /**
         * This is an auto-generated method that returns the map of design time
        * [static] children.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        protected java.util.Map get_ChildClasses()
            {
            return __mapChildren;
            }
        
        // From interface: com.oracle.coherence.common.base.Collector
        /**
         * Collector interface.
         */
        public void add(Object oValue)
            {
            // import com.oracle.coherence.persistence.AsyncPersistenceException;
            // import com.oracle.coherence.persistence.PersistenceException;
            // import com.tangosol.internal.tracing.Span;
            // import com.tangosol.util.Base;
            
            // See the collector contract defined by PersistentStore#begin(Collector), #persistChanges
            
            PartitionedCache             service         = (PartitionedCache) getService();
            PartitionedCache.PersistenceControl ctrlPersistence = (PartitionedCache.PersistenceControl) service.getPersistenceControl();
            PartitionedCache.PartitionControl   ctrlPartition;
            if (oValue instanceof PartitionedCache.PartitionControl)
                {
                // common case; PartitionedCache.PartitionControl is used as the receipt
                //
                // Note: the check is intentionally inverted to optimize for a successful
                //       checkcast in the common-case
                ctrlPartition = (PartitionedCache.PartitionControl) oValue;
                }
            else // oValue instanceof AsyncPersistenceException
                {
                // persistence txn was asynchronously aborted (likely an interrupt/abort)
                AsyncPersistenceException eAsync = (AsyncPersistenceException) oValue;
            
                ctrlPartition = (PartitionedCache.PartitionControl) eAsync.getReceipt();
            
                int iPart = getPartition();
                if (service.isPrimaryOwner(iPart))
                    {
                    String sGUIDFailed  = eAsync.getPersistentStore().getId();
                    String sGUIDCurrent = service.getPartitionControl(iPart).getPersistentStore().getId();
                    if (sGUIDFailed.equals(sGUIDCurrent))
                        {
                        ctrlPersistence.onActivePersistenceFailure(new PersistenceException(
                            "Asynchronous persistence operation failed for partition " + iPart, eAsync));
                        }
                    //else this appears to be write targeted to an old store; ignore the failure
                    }
                //else; the partition must have been transferred to a new owner prior to
                //      persisting; the new owner will have persisted the associated changes
                }
            
            ctrlPartition.finishPersist();
            
            if (isCompleteOnPersist())
                {
                onOperationCompleted();
                }
            
            long ldtBackupEndTime = getBackupCompletedTime();
            
            // check to see if the backup operation has completed before this persist
            // operation completed. If it has then we are adding extra latency by using persistence.
            long cLatency = ldtBackupEndTime == -1 ? 0L : Base.getSafeTimeMillis() - ldtBackupEndTime;
            ctrlPersistence.recordLatencyStats(cLatency);
            
            Span span = getPersistenceTracingSpan();
            if (span != null)
                {
                span.end();
                }
            }
        
        // Declared at the super level
        /**
         * Instantiate a copy of this message. This is quite different from the
        * standard "clone" since only the "transmittable" portion of the
        * message (and none of the internal) state should be cloned.
         */
        public com.tangosol.coherence.component.net.Message cloneMessage()
            {
            PartitionedCache.BackupSingleRequest msg = (PartitionedCache.BackupSingleRequest) super.cloneMessage();
            
            msg.setCacheId(getCacheId());
            msg.setKey(getKey());
            msg.setPrimaryResponse(getPrimaryResponse());
            msg.setEventHolder(getEventHolder());
            msg.setValue(getValue());
            msg.setResult(getResult());
            msg.setOutstandingOperationCounter(getOutstandingOperationCounter());
            msg.setMapEventVersion(getMapEventVersion());
            
            return msg;
            }
        
        // Declared at the super level
        /**
         * Perform the backup operation.
         */
        public void doBackup()
            {
            ((PartitionedCache) getService()).onBackupSingleRequest(this);
            }
        
        // From interface: com.oracle.coherence.common.base.Collector
        public void flush()
            {
            // called on a persistence thread, which should 'cooperate' with the notifier
            // by performaing a flush prior to the next I/O, sleep or termination
            
            ((PartitionedCache) get_Module()).flush();
            }
        
        // Accessor for the property "BackupCompletedTime"
        /**
         * Getter for property BackupCompletedTime.<p>
        * The System.currentTimeMillis() at which the backup finished or -1 if
        * it hasn't.
         */
        public long getBackupCompletedTime()
            {
            return __m_BackupCompletedTime;
            }
        
        // Accessor for the property "CacheId"
        /**
         * Getter for property CacheId.<p>
        * The Id of the cache this request is for.
         */
        public long getCacheId()
            {
            return __m_CacheId;
            }
        
        // Accessor for the property "EntryInfos"
        /**
         * Getter for property EntryInfos.<p>
         */
        public java.util.Set getEntryInfos()
            {
            return __m_EntryInfos;
            }
        
        // Accessor for the property "EntryInfosOOB"
        /**
         * Getter for property EntryInfosOOB.<p>
         */
        public java.util.Set getEntryInfosOOB()
            {
            return __m_EntryInfosOOB;
            }
        
        // Declared at the super level
        /**
         * Getter for property EstimatedByteSize.<p>
        * The estimated serialized size of this message.  A negative value
        * indicates that the size is unknown and that it is safe to estimate
        * the size via a double serialization.
         */
        public int getEstimatedByteSize()
            {
            // import com.tangosol.io.ReadBuffer;
            // import com.tangosol.util.Binary;
            // import com.tangosol.util.ExternalizableHelper as com.tangosol.util.ExternalizableHelper;
            
            PartitionedCache service = (PartitionedCache) getService();
            int     cb      = service.getBackupSingleEnvelopeSize().get();
            
            final int BIN_SIZE  = com.tangosol.util.ExternalizableHelper.BINARY_SIZE;
            final int BYTE_SIZE = Byte.BYTES;
            
            cb += getKey().length() + BIN_SIZE;
            
            ReadBuffer binVal = (ReadBuffer) getValue();
            cb += binVal == null ? BYTE_SIZE : binVal.length() + BIN_SIZE;
            
            Binary binResult = getResult();
            cb += binResult == null ? BYTE_SIZE : binResult.length() + BIN_SIZE;
            
            return cb += service.estimateEventHolderByteSize(getEventHolder());
            }
        
        // Accessor for the property "EventHolder"
        /**
         * Getter for property EventHolder.<p>
        * A holder for event(s) associated with an operation that caused this
        * message to be sent to a backup storage.
        * 
        * The holder content can be:
        * 
        * - null (no events)
        * - MapEventMessage instance (one and only one event)
        * - List of MapEventMessage's (for more than one event)
        * 
        * Note: by the time serialization occurs, the EventHolder is expected
        * to be "compressed", i.e. allowing us to skip any values that are
        * expected to be known on the receiving side.
         */
        public Object getEventHolder()
            {
            return __m_EventHolder;
            }
        
        // Accessor for the property "Key"
        /**
         * Getter for property Key.<p>
        * The resource key this request is for.
        * The Key being updated.
         */
        public com.tangosol.util.Binary getKey()
            {
            return __m_Key;
            }
        
        // Accessor for the property "MapEventVersion"
        /**
         * Getter for property MapEventVersion.<p>
        * The version of the corresponding change as discernable from the
        * MapEvent.
        * 
        * @see MapEvent#getVersion
         */
        public long getMapEventVersion()
            {
            return __m_MapEventVersion;
            }
        
        // Accessor for the property "OutstandingOperationCounter"
        /**
         * Getter for property OutstandingOperationCounter.<p>
        * The number of outstandanding "operations" that are managed by this
        * backup request.  Operations could be either the completion of the job
        * execution (on the service/worker thread), persistence (on the
        * PersistenceManager threads) or the completion of the backup (on
        * service or IO threads).
        * 
        * Transient property used only by the primary, but could be modified on
        * service, worker, persistence or I/O threads.
         */
        public java.util.concurrent.atomic.AtomicInteger getOutstandingOperationCounter()
            {
            return __m_OutstandingOperationCounter;
            }
        
        // Accessor for the property "PersistenceTracingSpan"
        /**
         * Getter for property PersistenceTracingSpan.<p>
        * The tracing Span for tracking persistence.
        * 
        * @since 14.1.1.0
         */
        public com.tangosol.internal.tracing.Span getPersistenceTracingSpan()
            {
            return __m_PersistenceTracingSpan;
            }
        
        // Accessor for the property "PrimaryResponse"
        /**
         * Getter for property PrimaryResponse.<p>
        * Transient property holding a response to a primary request message.
        * This property is used only when a primary owner has to defer
        * responding to a client request (i.e. Put, Remove) until the backup
        * owners confirm the receipt.
         */
        public com.tangosol.coherence.component.net.Message getPrimaryResponse()
            {
            return __m_PrimaryResponse;
            }
        
        // Accessor for the property "Result"
        /**
         * Getter for property Result.<p>
        * The execution "result" (may be null).
         */
        public com.tangosol.util.Binary getResult()
            {
            return __m_Result;
            }
        
        // Accessor for the property "Value"
        /**
         * Getter for property Value.<p>
        * The updated value, or null if the entry is removed.
         */
        public com.tangosol.io.ReadBuffer getValue()
            {
            return __m_Value;
            }
        
        // Accessor for the property "CompleteOnPersist"
        /**
         * Getter for property CompleteOnPersist.<p>
        * Inform the BackupSingleRequest whether to call tryBatchCompletion
        * once the persistence task has completed (Collector.add)
         */
        public boolean isCompleteOnPersist()
            {
            return __m_CompleteOnPersist;
            }
        
        /**
         * Called when either the request processing or a synchronous backup
        * request has completed.
        * 
        * Called from the worker, service or I/O threads.
         */
        protected void onOperationCompleted()
            {
            PartitionedCache service = (PartitionedCache) getService();
            
            if (getOutstandingOperationCounter().decrementAndGet() == 0 &&
                service.getServiceState() != PartitionedCache.SERVICE_STOPPED)
                {
                service.dispatchServerEvents(getEntryInfos(), getEntryInfosOOB());
                service.publishToClients(getPrimaryResponse(), getEventHolder());
                }
            }
        
        /**
         * Called when the thread (service, worker, or I/O if pre-processing)
        * processing the request has completed procesing (and persistence).
         */
        public void onPublishCompleted()
            {
            onOperationCompleted();
            }
        
        // Declared at the super level
        /**
         * This method is called on the originating member of the request when
        * the request has been fully delivered.
         */
        public void onRequestCompleted()
            {
            // import com.tangosol.util.Base;
            
            PartitionedCache           service       = (PartitionedCache) getService();
            PartitionedCache.PartitionControl ctrlPartition = (PartitionedCache.PartitionControl) service.getPartitionControl(getPartition());
            
            if (isSyncMsg())
                {
                onOperationCompleted();
            
                // set the time when the backup finished. This is then checked for in the add() method
                setBackupCompletedTime(Base.getSafeTimeMillis());
                }
            
            if (ctrlPartition != null)
                {
                ctrlPartition.finishBackup(getPartitionVersion());
                }
            
            super.onRequestCompleted();
            }
        
        // Declared at the super level
        public void read(com.tangosol.io.ReadBuffer.BufferInput input)
                throws java.io.IOException
            {
            // import Component.Net.Message.MapEventMessage;
            // import com.tangosol.util.Binary;
            // import com.tangosol.util.ExternalizableHelper as com.tangosol.util.ExternalizableHelper;
            
            super.read(input);
            
            setCacheId(com.tangosol.util.ExternalizableHelper.readLong(input));
            setKey((Binary) com.tangosol.util.ExternalizableHelper.readObject(input));
            setEventHolder(MapEventMessage.readSupplemental(input, getService()));
            setValue((Binary) com.tangosol.util.ExternalizableHelper.readObject(input));
            setResult((Binary) com.tangosol.util.ExternalizableHelper.readObject(input));
            
            readTracing(input);
            
            if (input.available() > 0)
                {
                setMapEventVersion(com.tangosol.util.ExternalizableHelper.readLong(input));
                }
            }
        
        // Accessor for the property "BackupCompletedTime"
        /**
         * Setter for property BackupCompletedTime.<p>
        * The System.currentTimeMillis() at which the backup finished or -1 if
        * it hasn't.
         */
        public void setBackupCompletedTime(long ldtMillis)
            {
            __m_BackupCompletedTime = ldtMillis;
            }
        
        // Accessor for the property "CacheId"
        /**
         * Setter for property CacheId.<p>
        * The Id of the cache this request is for.
         */
        public void setCacheId(long lId)
            {
            __m_CacheId = lId;
            }
        
        // Accessor for the property "CompleteOnPersist"
        /**
         * Setter for property CompleteOnPersist.<p>
        * Inform the BackupSingleRequest whether to call tryBatchCompletion
        * once the persistence task has completed (Collector.add)
         */
        public void setCompleteOnPersist(boolean fPersist)
            {
            __m_CompleteOnPersist = fPersist;
            }
        
        // Accessor for the property "EntryInfos"
        /**
         * Setter for property EntryInfos.<p>
         */
        public void setEntryInfos(java.util.Set setInfos)
            {
            __m_EntryInfos = setInfos;
            }
        
        // Accessor for the property "EntryInfosOOB"
        /**
         * Setter for property EntryInfosOOB.<p>
         */
        public void setEntryInfosOOB(java.util.Set setB)
            {
            __m_EntryInfosOOB = setB;
            }
        
        // Accessor for the property "EventHolder"
        /**
         * Setter for property EventHolder.<p>
        * A holder for event(s) associated with an operation that caused this
        * message to be sent to a backup storage.
        * 
        * The holder content can be:
        * 
        * - null (no events)
        * - MapEventMessage instance (one and only one event)
        * - List of MapEventMessage's (for more than one event)
        * 
        * Note: by the time serialization occurs, the EventHolder is expected
        * to be "compressed", i.e. allowing us to skip any values that are
        * expected to be known on the receiving side.
         */
        public void setEventHolder(Object oHolder)
            {
            __m_EventHolder = oHolder;
            }
        
        // Accessor for the property "Key"
        /**
         * Setter for property Key.<p>
        * The resource key this request is for.
        * The Key being updated.
         */
        public void setKey(com.tangosol.util.Binary binKey)
            {
            __m_Key = binKey;
            }
        
        // Accessor for the property "MapEventVersion"
        /**
         * Setter for property MapEventVersion.<p>
        * The version of the corresponding change as discernable from the
        * MapEvent.
        * 
        * @see MapEvent#getVersion
         */
        public void setMapEventVersion(long bufValue)
            {
            __m_MapEventVersion = bufValue;
            }
        
        // Accessor for the property "OutstandingOperationCounter"
        /**
         * Setter for property OutstandingOperationCounter.<p>
        * The number of outstandanding "operations" that are managed by this
        * backup request.  Operations could be either the completion of the job
        * execution (on the service/worker thread), persistence (on the
        * PersistenceManager threads) or the completion of the backup (on
        * service or IO threads).
        * 
        * Transient property used only by the primary, but could be modified on
        * service, worker, persistence or I/O threads.
         */
        public void setOutstandingOperationCounter(java.util.concurrent.atomic.AtomicInteger atomic)
            {
            __m_OutstandingOperationCounter = atomic;
            }
        
        // Accessor for the property "PersistenceTracingSpan"
        /**
         * Setter for property PersistenceTracingSpan.<p>
        * The tracing Span for tracking persistence.
        * 
        * @since 14.1.1.0
         */
        public void setPersistenceTracingSpan(com.tangosol.internal.tracing.Span spanTracing)
            {
            __m_PersistenceTracingSpan = spanTracing;
            }
        
        // Accessor for the property "PrimaryResponse"
        /**
         * Setter for property PrimaryResponse.<p>
        * Transient property holding a response to a primary request message.
        * This property is used only when a primary owner has to defer
        * responding to a client request (i.e. Put, Remove) until the backup
        * owners confirm the receipt.
         */
        public void setPrimaryResponse(com.tangosol.coherence.component.net.Message msgResponse)
            {
            __m_PrimaryResponse = msgResponse;
            }
        
        // Declared at the super level
        /**
         * Setter for property RequestTimeout.<p>
        * Transient property optionally used on the client to indicate the
        * (safe local) time after which this logical request should be
        * considered timed out.
        * 
        * Note that a single logical request message may result in multiple
        * physical request messages being sent to mulitple members; this
        * RequestTimeout value will be cloned to all resulting RequestMessage
        * instances.
        * 
        * This value is lazily calculated by #getRequestTimeout or
        * #calculateTimeoutRemaining.
         */
        public void setRequestTimeout(long ldtTimeout)
            {
            super.setRequestTimeout(ldtTimeout);
            }
        
        // Accessor for the property "Result"
        /**
         * Setter for property Result.<p>
        * The execution "result" (may be null).
         */
        public void setResult(com.tangosol.util.Binary binResult)
            {
            __m_Result = binResult;
            }
        
        // Accessor for the property "Value"
        /**
         * Setter for property Value.<p>
        * The updated value, or null if the entry is removed.
         */
        public void setValue(com.tangosol.io.ReadBuffer bufValue)
            {
            __m_Value = bufValue;
            }
        
        // Declared at the super level
        public void write(com.tangosol.io.WriteBuffer.BufferOutput output)
                throws java.io.IOException
            {
            // import Component.Net.Message.MapEventMessage;
            // import com.tangosol.util.ExternalizableHelper as com.tangosol.util.ExternalizableHelper;
            
            super.write(output);
            
            com.tangosol.util.ExternalizableHelper.writeLong(output, getCacheId());
            
            PartitionedCache service   = (PartitionedCache) getService();
            
            if (!isEstimating())
                {
                com.tangosol.util.ExternalizableHelper.writeObject(output, getKey());
                MapEventMessage.writeSupplemental(output, getEventHolder());
                com.tangosol.util.ExternalizableHelper.writeObject(output, getValue());
                com.tangosol.util.ExternalizableHelper.writeObject(output, getResult());
                }
            
            writeTracing(output);
            
            com.tangosol.util.ExternalizableHelper.writeLong(output, getMapEventVersion());
            }

        // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$BackupSingleRequest$Poll
        
        /**
         * The Poll contains information regarding a request sent to one or
         * more Cluster Members that require responses. A Service may poll
         * other Members that are running the same Service, and the Poll is
         * used to wait for and assemble the responses from each of those
         * Members. A client thread may also use the Poll to block on a
         * response or set of responses, thus waiting for the completion of the
         * Poll. In its simplest form, which is a Poll that is sent to one
         * Member of the Cluster, the Poll actually represents the
         * request/response model.
         */
        @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
        public static class Poll
                extends    com.tangosol.coherence.component.net.message.requestMessage.chainedRequest.backupRequest.BackupSingleRequest.Poll
            {
            // ---- Fields declarations ----
            
            // Default constructor
            public Poll()
                {
                this(null, null, true);
                }
            
            // Initializing constructor
            public Poll(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                {
                super(sName, compParent, false);
                
                if (fInit)
                    {
                    __init();
                    }
                }
            
            // Main initializer
            public void __init()
                {
                // private initialization
                __initPrivate();
                
                
                // signal the end of the initialization
                set_Constructed(true);
                }
            
            // Private initializer
            protected void __initPrivate()
                {
                
                super.__initPrivate();
                }
            
            //++ getter for static property _Instance
            /**
             * Getter for property _Instance.<p>
            * Auto generated
             */
            public static com.tangosol.coherence.Component get_Instance()
                {
                return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.BackupSingleRequest.Poll();
                }
            
            //++ getter for static property _CLASS
            /**
             * Getter for property _CLASS.<p>
            * Property with auto-generated accessor that returns the Class
            * object for a given component.
             */
            public static Class get_CLASS()
                {
                Class clz;
                try
                    {
                    clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$BackupSingleRequest$Poll".replace('/', '.'));
                    }
                catch (ClassNotFoundException e)
                    {
                    throw new NoClassDefFoundError(e.getMessage());
                    }
                return clz;
                }
            
            //++ getter for autogen property _Module
            /**
             * This is an auto-generated method that returns the global [design
            * time] parent component.
            * 
            * Note: the class generator will ignore any custom implementation
            * for this behavior.
             */
            private com.tangosol.coherence.Component get_Module()
                {
                return this.get_Parent().get_Parent();
                }
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$BatchContext
    
    /**
     * BatchContext represents the state associated with the processing of a
     * batch request (or a request that generates multiple updates) 
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class BatchContext
            extends    com.tangosol.coherence.Component
            implements com.oracle.coherence.common.base.Collector
        {
        // ---- Fields declarations ----
        
        /**
         * Property EntryInfos
         *
         */
        private java.util.Set __m_EntryInfos;
        
        /**
         * Property EntryInfosOOB
         *
         */
        private java.util.Set __m_EntryInfosOOB;
        
        /**
         * Property Events
         *
         * Events to be posted.  This property is polymorphic, and may be:
         * null, $MapEvent, or List<$MapEvent>
         */
        private Object __m_Events;
        
        /**
         * Property LastBackupCompletedTime
         *
         * The time at which the last backup completed.
         */
        private long __m_LastBackupCompletedTime;
        
        /**
         * Property OutstandingOperationCounter
         *
         * The number of outstandanding "operations" that are managed by this
         * backup request.  Operations could be either the completion of the
         * job execution (on the service/worker thread), persistence (on the
         * PersistenceManager threads) or the completion of the backup (on
         * service or IO threads).
         * 
         * Transient property used only by the primary, but could be modified
         * on service, worker, persistence or I/O threads.
         */
        private java.util.concurrent.atomic.AtomicInteger __m_OutstandingOperationCounter;
        
        /**
         * Property PersistenceTracingSpan
         *
         * The tracing Span for tracking persistence.
         * 
         * @since 14.1.1.0
         */
        private com.tangosol.internal.tracing.Span __m_PersistenceTracingSpan;
        
        /**
         * Property PrimaryResponse
         *
         * The primary (client) response message.
         */
        private com.tangosol.coherence.component.net.Message __m_PrimaryResponse;
        
        /**
         * Property SkipCompleteArray
         *
         * Holds the flag of whether the persistence is asynchronous indexed by
         * the partiton id.
         */
        private com.tangosol.util.SparseArray __m_SkipCompleteArray;
        
        // Default constructor
        public BatchContext()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public BatchContext(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                setLastBackupCompletedTime(-1L);
                setSkipCompleteArray(new com.tangosol.util.SparseArray());
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.BatchContext();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$BatchContext".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        /**
         * Accumulate the EntryInfos from all jobs that share the same
        * BatchContext, eg, putAll.  
        * 
        * @param setInfo  the EntryInfo set 
        * @param fOOB     true if the EntryInfo represent status from OOB change
         */
        public synchronized void accumulateEntryInfos(java.util.Set setInfo, boolean fOOB)
            {
            // import java.util.Set;
            
            Set set = fOOB ? getEntryInfosOOB() : getEntryInfos();
            
            if (set == null)
                {
                set = setInfo;
                }
            else
                {
                set.addAll(setInfo);
                }
            
            if (fOOB)
                {
                setEntryInfosOOB(set);
                }
            else
                {
                setEntryInfos(set);
                }
            }
        
        // From interface: com.oracle.coherence.common.base.Collector
        public void add(Object oValue)
            {
            // import com.oracle.coherence.persistence.AsyncPersistenceException;
            // import com.oracle.coherence.persistence.PersistenceException;
            // import com.tangosol.internal.tracing.Span;
            // import com.tangosol.util.Base;
            
            // See the collector contract defined by PersistentStore#begin(Collector), #persistChanges
            
            PartitionedCache             service         = (PartitionedCache) get_Module();
            PartitionedCache.PersistenceControl ctrlPersistence = (PartitionedCache.PersistenceControl) service.getPersistenceControl();
            PartitionedCache.PartitionControl   ctrlPartition;
            if (oValue instanceof PartitionedCache.PartitionControl)
                {
                // common case; PartitionedCache.PartitionControl is used as the receipt
                //
                // Note: the check is intentionally inverted to optimize for a successful
                //       checkcast in the common-case
                ctrlPartition = (PartitionedCache.PartitionControl) oValue;
                }
            else // oValue instanceof AsyncPersistenceException
                {
                // persistence txn was asynchronously aborted (likely an interrupt/abort)
                AsyncPersistenceException eAsync = (AsyncPersistenceException) oValue;
            
                ctrlPartition = (PartitionedCache.PartitionControl) eAsync.getReceipt();
            
                int iPart = ctrlPartition.getPartitionId();
                if (service.isPrimaryOwner(iPart))
                    {
                    String sGUIDFailed  = eAsync.getPersistentStore().getId();
                    String sGUIDCurrent = service.getPartitionControl(iPart).getPersistentStore().getId();
                    if (sGUIDFailed.equals(sGUIDCurrent))
                        {
                        ctrlPersistence.onActivePersistenceFailure(new PersistenceException(
                            "Asynchronous persistence operation failed for partition " + iPart, eAsync));
                        }
                    //else this appears to be write targeted to an old store; ignore the failure
                    }
                //else; the partition must have been transferred to a new owner prior to
                //      persisting; the new owner will have persisted the associated changes
                //      as a part of a successful transfer
                }
            
            ctrlPartition.finishPersist();
            
            long cLatency = 0L;
            if (isCompleteOnPersist(ctrlPartition.getPartitionId()))
                {
                if (tryBatchCompletion())
                    {
                    // the persistence operation was last to complete; the additional latency
                    // is the delta between the time that the last backup completed and now
                    cLatency = Base.getSafeTimeMillis() - getLastBackupCompletedTime();
                    }
                ctrlPersistence.recordLatencyStats(cLatency);
                }
            // else async persistence; TODO: consider still recording latency of the task
            
            Span span = getPersistenceTracingSpan();
            if (span != null)
                {
                span.end();
                }
            }
        
        public boolean completeOnPersist(boolean fSync, int nPartition)
            {
            // import com.tangosol.util.LongArray;
            
            LongArray laSkipComplete = getSkipCompleteArray();
            Boolean   FSkipComplete;
            
            synchronized (laSkipComplete)
                {
                FSkipComplete = (Boolean) laSkipComplete.get(nPartition);
            
                if (FSkipComplete == null)
                    {
                    laSkipComplete.set(nPartition, FSkipComplete = Boolean.valueOf(!fSync));
                    }
                }
            
            return !FSkipComplete.booleanValue();
            }
        
        // From interface: com.oracle.coherence.common.base.Collector
        public void flush()
            {
            // called on a persistence thread, which should 'cooperate' with the notifier
            // by performaing a flush prior to the next I/O, sleep or termination
            
            ((PartitionedCache) get_Module()).flush();
            }
        
        // Accessor for the property "EntryInfos"
        /**
         * Getter for property EntryInfos.<p>
         */
        public java.util.Set getEntryInfos()
            {
            return __m_EntryInfos;
            }
        
        // Accessor for the property "EntryInfosOOB"
        /**
         * Getter for property EntryInfosOOB.<p>
         */
        public java.util.Set getEntryInfosOOB()
            {
            return __m_EntryInfosOOB;
            }
        
        // Accessor for the property "Events"
        /**
         * Getter for property Events.<p>
        * Events to be posted.  This property is polymorphic, and may be: null,
        * $MapEvent, or List<$MapEvent>
         */
        public Object getEvents()
            {
            return __m_Events;
            }
        
        // Accessor for the property "LastBackupCompletedTime"
        /**
         * Getter for property LastBackupCompletedTime.<p>
        * The time at which the last backup completed.
         */
        public long getLastBackupCompletedTime()
            {
            return __m_LastBackupCompletedTime;
            }
        
        // Accessor for the property "OutstandingOperationCounter"
        /**
         * Getter for property OutstandingOperationCounter.<p>
        * The number of outstandanding "operations" that are managed by this
        * backup request.  Operations could be either the completion of the job
        * execution (on the service/worker thread), persistence (on the
        * PersistenceManager threads) or the completion of the backup (on
        * service or IO threads).
        * 
        * Transient property used only by the primary, but could be modified on
        * service, worker, persistence or I/O threads.
         */
        public java.util.concurrent.atomic.AtomicInteger getOutstandingOperationCounter()
            {
            return __m_OutstandingOperationCounter;
            }
        
        // Accessor for the property "PersistenceTracingSpan"
        /**
         * Getter for property PersistenceTracingSpan.<p>
        * The tracing Span for tracking persistence.
        * 
        * @since 14.1.1.0
         */
        public com.tangosol.internal.tracing.Span getPersistenceTracingSpan()
            {
            return __m_PersistenceTracingSpan;
            }
        
        // Accessor for the property "PrimaryResponse"
        /**
         * Getter for property PrimaryResponse.<p>
        * The primary (client) response message.
         */
        public com.tangosol.coherence.component.net.Message getPrimaryResponse()
            {
            return __m_PrimaryResponse;
            }
        
        // Accessor for the property "SkipCompleteArray"
        /**
         * Getter for property SkipCompleteArray.<p>
        * Holds the flag of whether the persistence is asynchronous indexed by
        * the partiton id.
         */
        public com.tangosol.util.SparseArray getSkipCompleteArray()
            {
            return __m_SkipCompleteArray;
            }
        
        /**
         * Return true if tryBatchCompletion should be called for the provided
        * partition.
         */
        protected boolean isCompleteOnPersist(int nPartition)
            {
            // import com.tangosol.util.LongArray;
            
            LongArray laSkipComplete = getSkipCompleteArray();
            
            synchronized (laSkipComplete)
                {
                Boolean FSkipComplete = (Boolean) laSkipComplete.get(nPartition);
                return FSkipComplete == null ? false : !FSkipComplete.booleanValue();
                }
            }
        
        /**
         * Called when the specified backup message has completed (the response
        * has been received or poll has closed).
        * 
        * @param msgBackup    the backup message
         */
        public void onBackupCompleted(com.tangosol.coherence.component.net.message.requestMessage.chainedRequest.BackupRequest msgBackup)
            {
            // import com.tangosol.util.Base;
            
            if (tryBatchCompletion())
                {
                // all jobs completed and backup was last job so we don't care
                // about any latency values
                }
            else if (msgBackup.isSyncMsg())
                {
                // all jobs not completed so we need to record the last time a
                // backup was completed if only in sync mode.
            
                setLastBackupCompletedTime(Base.getSafeTimeMillis());
                }
            }
        
        protected void onCompleted()
            {
            }
        
        /**
         * Called when a "job" has completed.  The specified job could either be
        * a PartialJob if the request was split to worker threads, or null if
        * the request was processed single-threaded.
         */
        public void onJobCompleted(com.tangosol.coherence.component.util.PartialJob job)
            {
            tryBatchCompletion();
            }
        
        // Accessor for the property "EntryInfos"
        /**
         * Setter for property EntryInfos.<p>
         */
        public void setEntryInfos(java.util.Set setInfos)
            {
            __m_EntryInfos = setInfos;
            }
        
        // Accessor for the property "EntryInfosOOB"
        /**
         * Setter for property EntryInfosOOB.<p>
         */
        public void setEntryInfosOOB(java.util.Set setB)
            {
            __m_EntryInfosOOB = setB;
            }
        
        // Accessor for the property "Events"
        /**
         * Setter for property Events.<p>
        * Events to be posted.  This property is polymorphic, and may be: null,
        * $MapEvent, or List<$MapEvent>
         */
        public void setEvents(Object oEvents)
            {
            __m_Events = oEvents;
            }
        
        // Accessor for the property "LastBackupCompletedTime"
        /**
         * Setter for property LastBackupCompletedTime.<p>
        * The time at which the last backup completed.
         */
        public void setLastBackupCompletedTime(long ldtTime)
            {
            __m_LastBackupCompletedTime = ldtTime;
            }
        
        // Accessor for the property "OutstandingOperationCounter"
        /**
         * Setter for property OutstandingOperationCounter.<p>
        * The number of outstandanding "operations" that are managed by this
        * backup request.  Operations could be either the completion of the job
        * execution (on the service/worker thread), persistence (on the
        * PersistenceManager threads) or the completion of the backup (on
        * service or IO threads).
        * 
        * Transient property used only by the primary, but could be modified on
        * service, worker, persistence or I/O threads.
         */
        public void setOutstandingOperationCounter(java.util.concurrent.atomic.AtomicInteger atomic)
            {
            __m_OutstandingOperationCounter = atomic;
            }
        
        // Accessor for the property "PersistenceTracingSpan"
        /**
         * Setter for property PersistenceTracingSpan.<p>
        * The tracing Span for tracking persistence.
        * 
        * @since 14.1.1.0
         */
        public void setPersistenceTracingSpan(com.tangosol.internal.tracing.Span spanTracing)
            {
            __m_PersistenceTracingSpan = spanTracing;
            }
        
        // Accessor for the property "PrimaryResponse"
        /**
         * Setter for property PrimaryResponse.<p>
        * The primary (client) response message.
         */
        public void setPrimaryResponse(com.tangosol.coherence.component.net.Message msgResponse)
            {
            __m_PrimaryResponse = msgResponse;
            }
        
        // Accessor for the property "SkipCompleteArray"
        /**
         * Setter for property SkipCompleteArray.<p>
        * Holds the flag of whether the persistence is asynchronous indexed by
        * the partiton id.
         */
        public void setSkipCompleteArray(com.tangosol.util.SparseArray arrayComplete)
            {
            __m_SkipCompleteArray = arrayComplete;
            }
        
        /**
         * Complete the processing of this batch context by replying to clients.
        *  Callers guarantee that job processing (e.g. persistence) as well as
        * all outstanding (synchronous) backup requests have completed (i.e.
        * PendingPollsCounter and PendingJobsCounter are both 0), however it
        * *is* possible that multiple threads will call this method
        * concurrently.
        * This method returns a boolean indicating if all jobs (described
        * above) are complete. This is so that calculations can be performed on
        * additional latency of persistence.
         */
        protected boolean tryBatchCompletion()
            {
            if (getOutstandingOperationCounter().decrementAndGet() == 0)
                {
                // all outstanding operations (worker completion, persistence, backups)
                // for the batch are complete; reply to clients
            
                PartitionedCache service = (PartitionedCache) get_Module();
                if (service.getServiceState() != PartitionedCache.SERVICE_STOPPED)
                    {
                    // dispatch UEM events
                    service.dispatchServerEvents(getEntryInfos(), getEntryInfosOOB());
            
                    // all jobs have run, and all backups have completed; respond to the client
                    service.publishToClients(getPrimaryResponse(), getEvents());
            
                    return true;
                    }
                }
            
            return false;
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$ClearRequest
    
    /**
     * @see $BinaryMap#clear
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class ClearRequest
            extends    com.tangosol.coherence.component.net.message.requestMessage.distributedCacheRequest.PartialRequest
        {
        // ---- Fields declarations ----
        
        /**
         * Property Truncate
         *
         * Specifies whether this is a truncate request.
         * 
         * A truncate request can avoid emitting events thus can be
         * significantly cheaper.
         */
        private boolean __m_Truncate;
        private static com.tangosol.util.ListMap __mapChildren;
        
        // Static initializer
        static
            {
            __initStatic();
            }
        
        // Default static initializer
        private static void __initStatic()
            {
            // register child classes
            __mapChildren = new com.tangosol.util.ListMap();
            __mapChildren.put("Poll", PartitionedCache.ClearRequest.Poll.get_CLASS());
            }
        
        // Default constructor
        public ClearRequest()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public ClearRequest(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                setMessageType(54);
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // containment initialization: children
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        // Getter for virtual constant ReadOnly
        public boolean isReadOnly()
            {
            return false;
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.ClearRequest();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$ClearRequest".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        //++ getter for autogen property _ChildClasses
        /**
         * This is an auto-generated method that returns the map of design time
        * [static] children.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        protected java.util.Map get_ChildClasses()
            {
            return __mapChildren;
            }
        
        // Declared at the super level
        /**
         * Instantiate a copy of this message. This is quite different from the
        * standard "clone" since only the "transmittable" portion of the
        * message (and none of the internal) state should be cloned.
         */
        public com.tangosol.coherence.component.net.Message cloneMessage()
            {
            PartitionedCache.ClearRequest msg = (PartitionedCache.ClearRequest) super.cloneMessage();
            
            msg.setTruncate(isTruncate());
            
            return msg;
            }
        
        // Accessor for the property "Truncate"
        /**
         * Getter for property Truncate.<p>
        * Specifies whether this is a truncate request.
        * 
        * A truncate request can avoid emitting events thus can be
        * significantly cheaper.
         */
        public boolean isTruncate()
            {
            return __m_Truncate;
            }
        
        // Declared at the super level
        /**
         * This is the event that is executed when a Message is received.
        * <p>
        * It is the main processing event of the Message called by the
        * <code>Service.onMessage()</code> event. With regards to the use of
        * Message components within clustered Services, Services are designed
        * by dragging Message components into them as static children. These
        * Messages are the components that a Service can send to other running
        * instances of the same Service within a cluster. When the onReceived
        * event is invoked by a Service, it means that the Message has been
        * received; the code in the onReceived event is therefore the Message
        * specific logic for processing a received Message. For example, when
        * onReceived is invoked on a Message named FindData, the onReceived
        * event should do the work to "find the data", because it is being
        * invoked by the Service that received the "find the data" Message.
         */
        public void onReceived()
            {
            if (isTruncate())
                {
                ((PartitionedCache) getService()).onClearRequest(this);
                }
            else
                {
                super.onReceived();
                }
            }
        
        // Declared at the super level
        /**
         * Preprocess this message.
        * 
        * @return true iff this message has been fully processed (onReceived
        * was called)
         */
        public boolean preprocess()
            {
            if (isTruncate())
                {
                return false;
                }
            
            return super.preprocess();
            }
        
        // Declared at the super level
        public void read(com.tangosol.io.ReadBuffer.BufferInput input)
                throws java.io.IOException
            {
            super.read(input);
            
            setTruncate(input.readBoolean());
            
            readTracing(input);
            }
        
        // Declared at the super level
        public void run()
            {
            ((PartitionedCache) getService()).onClearRequest(this);
            }
        
        // Declared at the super level
        /**
         * Setter for property RequestTimeout.<p>
        * Transient property optionally used on the client to indicate the
        * (safe local) time after which this logical request should be
        * considered timed out.
        * 
        * Note that a single logical request message may result in multiple
        * physical request messages being sent to mulitple members; this
        * RequestTimeout value will be cloned to all resulting RequestMessage
        * instances.
        * 
        * This value is lazily calculated by #getRequestTimeout or
        * #calculateTimeoutRemaining.
         */
        public void setRequestTimeout(long ldtTimeout)
            {
            super.setRequestTimeout(ldtTimeout);
            }
        
        // Accessor for the property "Truncate"
        /**
         * Setter for property Truncate.<p>
        * Specifies whether this is a truncate request.
        * 
        * A truncate request can avoid emitting events thus can be
        * significantly cheaper.
         */
        public void setTruncate(boolean fTruncate)
            {
            __m_Truncate = fTruncate;
            }
        
        // Declared at the super level
        public void write(com.tangosol.io.WriteBuffer.BufferOutput output)
                throws java.io.IOException
            {
            super.write(output);
            
            output.writeBoolean(isTruncate());
            
            writeTracing(output);
            }

        // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$ClearRequest$Poll
        
        /**
         * The Poll contains information regarding a request sent to one or
         * more Cluster Members that require responses. A Service may poll
         * other Members that are running the same Service, and the Poll is
         * used to wait for and assemble the responses from each of those
         * Members. A client thread may also use the Poll to block on a
         * response or set of responses, thus waiting for the completion of the
         * Poll. In its simplest form, which is a Poll that is sent to one
         * Member of the Cluster, the Poll actually represents the
         * request/response model.
         */
        @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
        public static class Poll
                extends    com.tangosol.coherence.component.net.message.requestMessage.distributedCacheRequest.PartialRequest.Poll
            {
            // ---- Fields declarations ----
            
            // Default constructor
            public Poll()
                {
                this(null, null, true);
                }
            
            // Initializing constructor
            public Poll(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                {
                super(sName, compParent, false);
                
                if (fInit)
                    {
                    __init();
                    }
                }
            
            // Main initializer
            public void __init()
                {
                // private initialization
                __initPrivate();
                
                
                // signal the end of the initialization
                set_Constructed(true);
                }
            
            // Private initializer
            protected void __initPrivate()
                {
                
                super.__initPrivate();
                }
            
            // Getter for virtual constant Preprocessable
            public boolean isPreprocessable()
                {
                return true;
                }
            
            //++ getter for static property _Instance
            /**
             * Getter for property _Instance.<p>
            * Auto generated
             */
            public static com.tangosol.coherence.Component get_Instance()
                {
                return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.ClearRequest.Poll();
                }
            
            //++ getter for static property _CLASS
            /**
             * Getter for property _CLASS.<p>
            * Property with auto-generated accessor that returns the Class
            * object for a given component.
             */
            public static Class get_CLASS()
                {
                Class clz;
                try
                    {
                    clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$ClearRequest$Poll".replace('/', '.'));
                    }
                catch (ClassNotFoundException e)
                    {
                    throw new NoClassDefFoundError(e.getMessage());
                    }
                return clz;
                }
            
            //++ getter for autogen property _Module
            /**
             * This is an auto-generated method that returns the global [design
            * time] parent component.
            * 
            * Note: the class generator will ignore any custom implementation
            * for this behavior.
             */
            private com.tangosol.coherence.Component get_Module()
                {
                return this.get_Parent().get_Parent();
                }
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$ContainsAllRequest
    
    /**
     * @see $BinaryMap#containsAll
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class ContainsAllRequest
            extends    com.tangosol.coherence.component.net.message.requestMessage.distributedCacheRequest.KeySetRequest
        {
        // ---- Fields declarations ----
        private static com.tangosol.util.ListMap __mapChildren;
        
        // Static initializer
        static
            {
            __initStatic();
            }
        
        // Default static initializer
        private static void __initStatic()
            {
            // register child classes
            __mapChildren = new com.tangosol.util.ListMap();
            __mapChildren.put("Poll", PartitionedCache.ContainsAllRequest.Poll.get_CLASS());
            }
        
        // Default constructor
        public ContainsAllRequest()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public ContainsAllRequest(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                setMessageType(55);
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // containment initialization: children
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.ContainsAllRequest();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$ContainsAllRequest".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        //++ getter for autogen property _ChildClasses
        /**
         * This is an auto-generated method that returns the map of design time
        * [static] children.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        protected java.util.Map get_ChildClasses()
            {
            return __mapChildren;
            }
        
        // Declared at the super level
        /**
         * Getter for property EstimatedByteSize.<p>
        * The estimated serialized size of this message.  A negative value
        * indicates that the size is unknown and that it is safe to estimate
        * the size via a double serialization.
         */
        public int getEstimatedByteSize()
            {
            return -1;
            }
        
        // Declared at the super level
        public void run()
            {
            ((PartitionedCache) getService()).onContainsAllRequest(this);
            }
        
        // Declared at the super level
        /**
         * Setter for property RequestTimeout.<p>
        * Transient property optionally used on the client to indicate the
        * (safe local) time after which this logical request should be
        * considered timed out.
        * 
        * Note that a single logical request message may result in multiple
        * physical request messages being sent to mulitple members; this
        * RequestTimeout value will be cloned to all resulting RequestMessage
        * instances.
        * 
        * This value is lazily calculated by #getRequestTimeout or
        * #calculateTimeoutRemaining.
         */
        public void setRequestTimeout(long ldtTimeout)
            {
            super.setRequestTimeout(ldtTimeout);
            }

        // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$ContainsAllRequest$Poll
        
        /**
         * The Poll contains information regarding a request sent to one or
         * more Cluster Members that require responses. A Service may poll
         * other Members that are running the same Service, and the Poll is
         * used to wait for and assemble the responses from each of those
         * Members. A client thread may also use the Poll to block on a
         * response or set of responses, thus waiting for the completion of the
         * Poll. In its simplest form, which is a Poll that is sent to one
         * Member of the Cluster, the Poll actually represents the
         * request/response model.
         */
        @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
        public static class Poll
                extends    com.tangosol.coherence.component.net.message.requestMessage.distributedCacheRequest.KeySetRequest.Poll
            {
            // ---- Fields declarations ----
            
            // Default constructor
            public Poll()
                {
                this(null, null, true);
                }
            
            // Initializing constructor
            public Poll(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                {
                super(sName, compParent, false);
                
                if (fInit)
                    {
                    __init();
                    }
                }
            
            // Main initializer
            public void __init()
                {
                // private initialization
                __initPrivate();
                
                
                // signal the end of the initialization
                set_Constructed(true);
                }
            
            // Private initializer
            protected void __initPrivate()
                {
                
                super.__initPrivate();
                }
            
            // Getter for virtual constant Preprocessable
            public boolean isPreprocessable()
                {
                return true;
                }
            
            //++ getter for static property _Instance
            /**
             * Getter for property _Instance.<p>
            * Auto generated
             */
            public static com.tangosol.coherence.Component get_Instance()
                {
                return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.ContainsAllRequest.Poll();
                }
            
            //++ getter for static property _CLASS
            /**
             * Getter for property _CLASS.<p>
            * Property with auto-generated accessor that returns the Class
            * object for a given component.
             */
            public static Class get_CLASS()
                {
                Class clz;
                try
                    {
                    clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$ContainsAllRequest$Poll".replace('/', '.'));
                    }
                catch (ClassNotFoundException e)
                    {
                    throw new NoClassDefFoundError(e.getMessage());
                    }
                return clz;
                }
            
            //++ getter for autogen property _Module
            /**
             * This is an auto-generated method that returns the global [design
            * time] parent component.
            * 
            * Note: the class generator will ignore any custom implementation
            * for this behavior.
             */
            private com.tangosol.coherence.Component get_Module()
                {
                return this.get_Parent().get_Parent();
                }
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$ContainsKeyRequest
    
    /**
     * @see $BinaryMap#containsKey
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class ContainsKeyRequest
            extends    com.tangosol.coherence.component.net.message.requestMessage.DistributedCacheKeyRequest
        {
        // ---- Fields declarations ----
        private static com.tangosol.util.ListMap __mapChildren;
        
        // Static initializer
        static
            {
            __initStatic();
            }
        
        // Default static initializer
        private static void __initStatic()
            {
            // register child classes
            __mapChildren = new com.tangosol.util.ListMap();
            __mapChildren.put("Poll", PartitionedCache.ContainsKeyRequest.Poll.get_CLASS());
            }
        
        // Default constructor
        public ContainsKeyRequest()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public ContainsKeyRequest(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                setMessageType(56);
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // containment initialization: children
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.ContainsKeyRequest();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$ContainsKeyRequest".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        //++ getter for autogen property _ChildClasses
        /**
         * This is an auto-generated method that returns the map of design time
        * [static] children.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        protected java.util.Map get_ChildClasses()
            {
            return __mapChildren;
            }
        
        // Declared at the super level
        /**
         * Getter for property EstimatedByteSize.<p>
        * The estimated serialized size of this message.  A negative value
        * indicates that the size is unknown and that it is safe to estimate
        * the size via a double serialization.
         */
        public int getEstimatedByteSize()
            {
            return -1;
            }
        
        // Declared at the super level
        public void run()
            {
            ((PartitionedCache) getService()).onContainsKeyRequest(this);
            }
        
        // Declared at the super level
        /**
         * Setter for property RequestTimeout.<p>
        * Transient property optionally used on the client to indicate the
        * (safe local) time after which this logical request should be
        * considered timed out.
        * 
        * Note that a single logical request message may result in multiple
        * physical request messages being sent to mulitple members; this
        * RequestTimeout value will be cloned to all resulting RequestMessage
        * instances.
        * 
        * This value is lazily calculated by #getRequestTimeout or
        * #calculateTimeoutRemaining.
         */
        public void setRequestTimeout(long ldtTimeout)
            {
            super.setRequestTimeout(ldtTimeout);
            }

        // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$ContainsKeyRequest$Poll
        
        /**
         * The Poll contains information regarding a request sent to one or
         * more Cluster Members that require responses. A Service may poll
         * other Members that are running the same Service, and the Poll is
         * used to wait for and assemble the responses from each of those
         * Members. A client thread may also use the Poll to block on a
         * response or set of responses, thus waiting for the completion of the
         * Poll. In its simplest form, which is a Poll that is sent to one
         * Member of the Cluster, the Poll actually represents the
         * request/response model.
         */
        @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
        public static class Poll
                extends    com.tangosol.coherence.component.net.message.requestMessage.DistributedCacheKeyRequest.Poll
            {
            // ---- Fields declarations ----
            
            // Default constructor
            public Poll()
                {
                this(null, null, true);
                }
            
            // Initializing constructor
            public Poll(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                {
                super(sName, compParent, false);
                
                if (fInit)
                    {
                    __init();
                    }
                }
            
            // Main initializer
            public void __init()
                {
                // private initialization
                __initPrivate();
                
                
                // signal the end of the initialization
                set_Constructed(true);
                }
            
            // Private initializer
            protected void __initPrivate()
                {
                
                super.__initPrivate();
                }
            
            // Getter for virtual constant Preprocessable
            public boolean isPreprocessable()
                {
                return true;
                }
            
            //++ getter for static property _Instance
            /**
             * Getter for property _Instance.<p>
            * Auto generated
             */
            public static com.tangosol.coherence.Component get_Instance()
                {
                return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.ContainsKeyRequest.Poll();
                }
            
            //++ getter for static property _CLASS
            /**
             * Getter for property _CLASS.<p>
            * Property with auto-generated accessor that returns the Class
            * object for a given component.
             */
            public static Class get_CLASS()
                {
                Class clz;
                try
                    {
                    clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$ContainsKeyRequest$Poll".replace('/', '.'));
                    }
                catch (ClassNotFoundException e)
                    {
                    throw new NoClassDefFoundError(e.getMessage());
                    }
                return clz;
                }
            
            //++ getter for autogen property _Module
            /**
             * This is an auto-generated method that returns the global [design
            * time] parent component.
            * 
            * Note: the class generator will ignore any custom implementation
            * for this behavior.
             */
            private com.tangosol.coherence.Component get_Module()
                {
                return this.get_Parent().get_Parent();
                }
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$ContainsValueRequest
    
    /**
     * @see $BinaryMap#containsValue
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class ContainsValueRequest
            extends    com.tangosol.coherence.component.net.message.requestMessage.distributedCacheRequest.PartialRequest
        {
        // ---- Fields declarations ----
        
        /**
         * Property Value
         *
         * Parameter of "containsValue(Object)" request.
         */
        private com.tangosol.util.Binary __m_Value;
        private static com.tangosol.util.ListMap __mapChildren;
        
        // Static initializer
        static
            {
            __initStatic();
            }
        
        // Default static initializer
        private static void __initStatic()
            {
            // register child classes
            __mapChildren = new com.tangosol.util.ListMap();
            __mapChildren.put("Poll", PartitionedCache.ContainsValueRequest.Poll.get_CLASS());
            }
        
        // Default constructor
        public ContainsValueRequest()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public ContainsValueRequest(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                setMessageType(57);
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // containment initialization: children
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.ContainsValueRequest();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$ContainsValueRequest".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        //++ getter for autogen property _ChildClasses
        /**
         * This is an auto-generated method that returns the map of design time
        * [static] children.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        protected java.util.Map get_ChildClasses()
            {
            return __mapChildren;
            }
        
        // Declared at the super level
        /**
         * Instantiate a copy of this message. This is quite different from the
        * standard "clone" since only the "transmittable" portion of the
        * message (and none of the internal) state should be cloned.
         */
        public com.tangosol.coherence.component.net.Message cloneMessage()
            {
            PartitionedCache.ContainsValueRequest msg = (PartitionedCache.ContainsValueRequest) super.cloneMessage();
            
            msg.setValue(getValue());
            
            return msg;
            }
        
        // Declared at the super level
        /**
         * Getter for property EstimatedByteSize.<p>
        * The estimated serialized size of this message.  A negative value
        * indicates that the size is unknown and that it is safe to estimate
        * the size via a double serialization.
         */
        public int getEstimatedByteSize()
            {
            return -1;
            }
        
        // Accessor for the property "Value"
        /**
         * Getter for property Value.<p>
        * Parameter of "containsValue(Object)" request.
         */
        public com.tangosol.util.Binary getValue()
            {
            return __m_Value;
            }
        
        // Declared at the super level
        public void read(com.tangosol.io.ReadBuffer.BufferInput input)
                throws java.io.IOException
            {
            // import com.tangosol.util.Binary;
            
            super.read(input);
            
            setValue((Binary) readObject(input));
            
            readTracing(input);
            }
        
        // Declared at the super level
        public void run()
            {
            ((PartitionedCache) getService()).onContainsValueRequest(this);
            }
        
        // Declared at the super level
        /**
         * Setter for property RequestTimeout.<p>
        * Transient property optionally used on the client to indicate the
        * (safe local) time after which this logical request should be
        * considered timed out.
        * 
        * Note that a single logical request message may result in multiple
        * physical request messages being sent to mulitple members; this
        * RequestTimeout value will be cloned to all resulting RequestMessage
        * instances.
        * 
        * This value is lazily calculated by #getRequestTimeout or
        * #calculateTimeoutRemaining.
         */
        public void setRequestTimeout(long ldtTimeout)
            {
            super.setRequestTimeout(ldtTimeout);
            }
        
        // Accessor for the property "Value"
        /**
         * Setter for property Value.<p>
        * Parameter of "containsValue(Object)" request.
         */
        public void setValue(com.tangosol.util.Binary binValue)
            {
            __m_Value = binValue;
            }
        
        // Declared at the super level
        public void write(com.tangosol.io.WriteBuffer.BufferOutput output)
                throws java.io.IOException
            {
            super.write(output);
            
            writeObject(output, getValue());
            
            writeTracing(output);
            }

        // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$ContainsValueRequest$Poll
        
        /**
         * The Poll contains information regarding a request sent to one or
         * more Cluster Members that require responses. A Service may poll
         * other Members that are running the same Service, and the Poll is
         * used to wait for and assemble the responses from each of those
         * Members. A client thread may also use the Poll to block on a
         * response or set of responses, thus waiting for the completion of the
         * Poll. In its simplest form, which is a Poll that is sent to one
         * Member of the Cluster, the Poll actually represents the
         * request/response model.
         */
        @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
        public static class Poll
                extends    com.tangosol.coherence.component.net.message.requestMessage.distributedCacheRequest.PartialRequest.Poll
            {
            // ---- Fields declarations ----
            
            // Default constructor
            public Poll()
                {
                this(null, null, true);
                }
            
            // Initializing constructor
            public Poll(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                {
                super(sName, compParent, false);
                
                if (fInit)
                    {
                    __init();
                    }
                }
            
            // Main initializer
            public void __init()
                {
                // private initialization
                __initPrivate();
                
                
                // signal the end of the initialization
                set_Constructed(true);
                }
            
            // Private initializer
            protected void __initPrivate()
                {
                
                super.__initPrivate();
                }
            
            // Getter for virtual constant Preprocessable
            public boolean isPreprocessable()
                {
                return true;
                }
            
            //++ getter for static property _Instance
            /**
             * Getter for property _Instance.<p>
            * Auto generated
             */
            public static com.tangosol.coherence.Component get_Instance()
                {
                return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.ContainsValueRequest.Poll();
                }
            
            //++ getter for static property _CLASS
            /**
             * Getter for property _CLASS.<p>
            * Property with auto-generated accessor that returns the Class
            * object for a given component.
             */
            public static Class get_CLASS()
                {
                Class clz;
                try
                    {
                    clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$ContainsValueRequest$Poll".replace('/', '.'));
                    }
                catch (ClassNotFoundException e)
                    {
                    throw new NoClassDefFoundError(e.getMessage());
                    }
                return clz;
                }
            
            //++ getter for autogen property _Module
            /**
             * This is an auto-generated method that returns the global [design
            * time] parent component.
            * 
            * Note: the class generator will ignore any custom implementation
            * for this behavior.
             */
            private com.tangosol.coherence.Component get_Module()
                {
                return this.get_Parent().get_Parent();
                }
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$Continuations
    
    /**
     * Continuations-related support.
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class Continuations
            extends    com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.Continuations
        {
        // ---- Fields declarations ----
        private static com.tangosol.util.ListMap __mapChildren;
        
        // Static initializer
        static
            {
            __initStatic();
            }
        
        // Default static initializer
        private static void __initStatic()
            {
            // register child classes
            __mapChildren = new com.tangosol.util.ListMap();
            __mapChildren.put("Continuation", PartitionedCache.Continuations.Continuation.get_CLASS());
            __mapChildren.put("Message", com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.Continuations.Message.get_CLASS());
            __mapChildren.put("Task", com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.Continuations.Task.get_CLASS());
            }
        
        // Default constructor
        public Continuations()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public Continuations(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            
            // containment initialization: children
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.Continuations();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$Continuations".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        //++ getter for autogen property _ChildClasses
        /**
         * This is an auto-generated method that returns the map of design time
        * [static] children.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        protected java.util.Map get_ChildClasses()
            {
            return __mapChildren;
            }
        
        // Declared at the super level
        /**
         * Instantiate a $Continuation of the specified type with the specified
        * context.
         */
        protected com.oracle.coherence.common.base.Continuation instantiate(int nType, Object oContext, com.oracle.coherence.common.base.Continuation contNext)
            {
            // inlined super here to simulate virtual construction while
            // avoiding _newChild
            
            PartitionedCache.Continuations.Continuation continuation = new PartitionedCache.Continuations.Continuation();
            
            _linkChild(continuation);
            
            continuation.setType(nType);
            continuation.setContext(oContext);
            continuation.setNext(contNext);
            
            return continuation;
            }
        
        /**
         * Instantiate a continuation to finalize receiving primary transfer
        * (#onFinalizePrimaryTransfer).
         */
        public com.oracle.coherence.common.base.Continuation instantiateEnsureStorage(com.tangosol.util.LongArray laCaches, com.oracle.coherence.common.base.Continuation contNext)
            {
            return instantiate(PartitionedCache.Continuations.Continuation.TYPE_ENSURE_STORAGE, laCaches, contNext);
            }

        // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$Continuations$Continuation
        
        /**
         * Assorted continuation actions used by PartitionedService, collected
         * into a single multi-purpose implementation.
         * 
         * This implementation is a "workaround" for the lack of anonymous
         * inner-class support in TDE.
         */
        @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
        public static class Continuation
                extends    com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.Continuations.Continuation
            {
            // ---- Fields declarations ----
            
            /**
             * Property TYPE_ENSURE_STORAGE
             *
             * Ensure that the set of cache names are created (and
             * corresponding $Storage).
             * 
             * See #ensureStorage(Set)
             */
            public static final int TYPE_ENSURE_STORAGE = 11;
            
            // Default constructor
            public Continuation()
                {
                this(null, null, true);
                }
            
            // Initializing constructor
            public Continuation(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                {
                super(sName, compParent, false);
                
                if (fInit)
                    {
                    __init();
                    }
                }
            
            // Main initializer
            public void __init()
                {
                // private initialization
                __initPrivate();
                
                
                // signal the end of the initialization
                set_Constructed(true);
                }
            
            // Private initializer
            protected void __initPrivate()
                {
                
                super.__initPrivate();
                }
            
            //++ getter for static property _Instance
            /**
             * Getter for property _Instance.<p>
            * Auto generated
             */
            public static com.tangosol.coherence.Component get_Instance()
                {
                return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.Continuations.Continuation();
                }
            
            //++ getter for static property _CLASS
            /**
             * Getter for property _CLASS.<p>
            * Property with auto-generated accessor that returns the Class
            * object for a given component.
             */
            public static Class get_CLASS()
                {
                Class clz;
                try
                    {
                    clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$Continuations$Continuation".replace('/', '.'));
                    }
                catch (ClassNotFoundException e)
                    {
                    throw new NoClassDefFoundError(e.getMessage());
                    }
                return clz;
                }
            
            //++ getter for autogen property _Module
            /**
             * This is an auto-generated method that returns the global [design
            * time] parent component.
            * 
            * Note: the class generator will ignore any custom implementation
            * for this behavior.
             */
            private com.tangosol.coherence.Component get_Module()
                {
                return this.get_Parent().get_Parent();
                }
            
            // Declared at the super level
            public void proceed(Object oResult)
                {
                // import com.tangosol.util.LongArray;
                // import java.util.Map;
                
                PartitionedCache service  = (PartitionedCache) get_Module();
                Object  oContext = getContext();
                
                switch (getType())
                    {
                    case TYPE_ENSURE_STORAGE:
                        service.ensureStorage((LongArray) oContext);
                        proceedNext(oResult);
                        break;
                
                    default:
                        super.proceed(oResult);
                    }
                }
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$ConverterFromBinary
    
    /**
     * Binary to Serializable Object converter. Used for both keys and values.
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class ConverterFromBinary
            extends    com.tangosol.coherence.component.util.Converter
        {
        // ---- Fields declarations ----
        
        // Default constructor
        public ConverterFromBinary()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public ConverterFromBinary(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.ConverterFromBinary();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$ConverterFromBinary".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        // Declared at the super level
        public Object convert(Object o)
            {
            // import com.tangosol.util.Binary;
            // import com.tangosol.util.ExternalizableHelper;
            
            return o == null ? null :
                ExternalizableHelper.fromBinary((Binary) o, getSerializer());
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$ConverterValueToBinary
    
    /**
     * Serializable Object to Binary converter. Used for values only.
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class ConverterValueToBinary
            extends    com.tangosol.coherence.component.util.Converter
        {
        // ---- Fields declarations ----
        
        /**
         * Property WriteBuffer
         *
         */
        private static transient ThreadLocal __s_WriteBuffer;
        
        // Static initializer
        static
            {
            __initStatic();
            }
        
        // Default static initializer
        private static void __initStatic()
            {
            // state initialization: static properties
            try
                {
                __s_WriteBuffer = new java.lang.ThreadLocal();
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            }
        
        // Default constructor
        public ConverterValueToBinary()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public ConverterValueToBinary(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.ConverterValueToBinary();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$ConverterValueToBinary".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        // Declared at the super level
        public Object convert(Object o)
            {
            // import com.tangosol.io.WriteBuffer;
            // import com.tangosol.util.ExternalizableHelper;

            WriteBuffer buf = (WriteBuffer) getWriteBuffer().get();
            if (buf != null)
                {
                // reset buffer to avoid generating bigger binaries if leftover size is larger
                buf.retain(0, 0);
                }
            return ExternalizableHelper.toBinary(o, getSerializer(), buf);
            }
        
        // Accessor for the property "WriteBuffer"
        /**
         * Getter for property WriteBuffer.<p>
         */
        private static ThreadLocal getWriteBuffer()
            {
            return __s_WriteBuffer;
            }
        
        // Accessor for the property "WriteBuffer"
        /**
         * Set the thread-local WriteBuffer to use for serialization.
         */
        public static void setWriteBuffer(com.tangosol.io.WriteBuffer buf)
            {
            getWriteBuffer().set(buf);
            }
        
        // Accessor for the property "WriteBuffer"
        /**
         * Setter for property WriteBuffer.<p>
         */
        private static void setWriteBuffer(ThreadLocal tlBuf)
            {
            __s_WriteBuffer = tlBuf;
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$DaemonPool
    
    /**
     * DaemonPool is a class thread pool implementation for processing queued
     * operations on one or more daemon threads.
     * 
     * The designable properties are:
     *     AutoStart
     *     DaemonCount
     * 
     * The simple API for the DaemonPool is:
     *     public void start()
     *     public boolean isStarted()
     *     public void add(Runnable task)
     *     public void stop()
     * 
     * The advanced API for the DaemonPool is:
     *     DaemonCount property
     *     Daemons property
     *     Queues property
     *     ThreadGroup property
     * 
     * The DaemonPool is composed of two key components:
     * 
     * 1) An array of WorkSlot components that may or may not share Queues with
     * other WorkSlots. 
     * 
     * 2) An array of Daemon components feeding off the Queues. This collection
     * is accessed by the DaemonCount and Daemons properties, and is managed by
     * the DaemonCount mutator.
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class DaemonPool
            extends    com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.DaemonPool
        {
        // ---- Fields declarations ----
        private static com.tangosol.util.ListMap __mapChildren;
        
        // Static initializer
        static
            {
            __initStatic();
            }
        
        // Default static initializer
        private static void __initStatic()
            {
            // register child classes
            __mapChildren = new com.tangosol.util.ListMap();
            __mapChildren.put("Daemon", com.tangosol.coherence.component.util.daemon.queueProcessor.service.Grid.DaemonPool.Daemon.get_CLASS());
            __mapChildren.put("ResizeTask", com.tangosol.coherence.component.util.daemon.queueProcessor.Service.DaemonPool.ResizeTask.get_CLASS());
            __mapChildren.put("ScheduleTask", com.tangosol.coherence.component.util.daemon.queueProcessor.Service.DaemonPool.ScheduleTask.get_CLASS());
            __mapChildren.put("StartTask", com.tangosol.coherence.component.util.daemon.queueProcessor.Service.DaemonPool.StartTask.get_CLASS());
            __mapChildren.put("StopTask", com.tangosol.coherence.component.util.daemon.queueProcessor.Service.DaemonPool.StopTask.get_CLASS());
            __mapChildren.put("WorkSlot", com.tangosol.coherence.component.util.daemon.queueProcessor.Service.DaemonPool.WorkSlot.get_CLASS());
            __mapChildren.put("WrapperTask", com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.DaemonPool.WrapperTask.get_CLASS());
            }
        
        // Default constructor
        public DaemonPool()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public DaemonPool(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                setAbandonThreshold(8);
                setDaemonCountMax(2147483647);
                setDaemonCountMin(1);
                setScheduledTasks(new java.util.HashSet());
                setStatsTaskAddCount(new java.util.concurrent.atomic.AtomicLong());
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // containment initialization: children
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.DaemonPool();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$DaemonPool".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        //++ getter for autogen property _ChildClasses
        /**
         * This is an auto-generated method that returns the map of design time
        * [static] children.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        protected java.util.Map get_ChildClasses()
            {
            return __mapChildren;
            }
        
        // Declared at the super level
        /**
         * The specified task execution has been canceled.
        * 
        * @param fAbandoned true if the task has timed-out, but all attempts to
        * interrupt it were unsuccessful in stopping the execution; otherwise
        * the task was never started
         */
        public void runCanceled(com.tangosol.net.PriorityTask task, boolean fAbandoned)
            {
            // import Component.Net.Message;
            // import Component.Net.Message.RequestMessage as com.tangosol.coherence.component.net.message.RequestMessage;
            // import Component.Net.Message.RequestMessage.DistributedCacheKeyRequest;
            // import Component.Util.PartialJob;
            // import com.tangosol.net.RequestTimeoutException;
            
            super.runCanceled(task, fAbandoned);
            
            PartitionedCache service    = (PartitionedCache) get_Module();
            com.tangosol.coherence.component.net.message.RequestMessage msgRequest = null;
            
            if (task instanceof com.tangosol.coherence.component.net.message.RequestMessage)
                {
                msgRequest = (com.tangosol.coherence.component.net.message.RequestMessage) task;
                }
            else if (task instanceof PartialJob)
                {
                msgRequest = ((PartialJob) task).getRequest();
                }
            
            RequestTimeoutException exception = null;
            try
                {
                String sMsg = (fAbandoned ? "Abandoned" : "Canceled")
                            + " execution of \""
                            + (msgRequest == null ? String.valueOf(task) : msgRequest.get_Name())
                            + "\" for service \"" + service.getServiceName()
                            + "\" on " + service.getThisMember();
                exception = new RequestTimeoutException(sMsg);
                // the current stack trace has no relevance
                exception.setStackTrace(new StackTraceElement[0]);
                }
            catch (RuntimeException e)
                {
                exception = new RequestTimeoutException(e);
                }
            
            if (msgRequest == null)
                {
                // unknown task 
                _trace(exception);
                return;
                }
            
            Message msgResponse;
            if (msgRequest instanceof DistributedCacheKeyRequest ||
                msgRequest instanceof PartitionedCache.UpdateIndexRequest)
                {
                // $Listener, $ContainsKey, $Get, $Lock, $Invoke, $Put, $Remove, $Unlock [com.tangosol.coherence.component.net.message.RequestMessage]
            
                PartitionedCache.Response msg = (PartitionedCache.Response)
                    service.instantiateMessage("Response");
                msg.setResult(PartitionedCache.Response.RESULT_FAILURE);
                msg.setValue(exception);
                msgResponse = msg;
                }
            else if (msgRequest instanceof PartitionedCache.GetAllRequest ||
                     msgRequest instanceof PartitionedCache.InvokeAllRequest)
                {
                PartitionedCache.PartialMapResponse msg = (PartitionedCache.PartialMapResponse)
                    service.instantiateMessage("PartialMapResponse");
                msg.setException(exception);
                msgResponse = msg;
                }
            else if (msgRequest instanceof PartitionedCache.InvokeFilterRequest ||
                     msgRequest instanceof PartitionedCache.KeyIteratorRequest ||
                     msgRequest instanceof PartitionedCache.QueryRequest)
                {
                PartitionedCache.QueryResponse msg = (PartitionedCache.QueryResponse)
                    service.instantiateMessage("QueryResponse");
                msg.setException(exception);
                msgResponse = msg;
                }
            else // all other requests
                {
                PartitionedCache.PartialValueResponse msg = (PartitionedCache.PartialValueResponse)
                    service.instantiateMessage("PartialValueResponse");
                msg.setException(exception);
                msgResponse = msg;
                }
            
            msgResponse.respondTo(msgRequest);
            service.post(msgResponse);
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$DistributionRequest
    
    /**
     * Suggest a redistribution of PartitionCount partitions from the message
     * receipient to the message sender.
     * 
     * In response to this message the recepient is expected to send
     * partitions' data using TransferRequests.
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class DistributionRequest
            extends    com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.DistributionRequest
        {
        // ---- Fields declarations ----
        private static com.tangosol.util.ListMap __mapChildren;
        
        // Static initializer
        static
            {
            __initStatic();
            }
        
        // Default static initializer
        private static void __initStatic()
            {
            // register child classes
            __mapChildren = new com.tangosol.util.ListMap();
            __mapChildren.put("Poll", com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.DistributionRequest.Poll.get_CLASS());
            }
        
        // Default constructor
        public DistributionRequest()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public DistributionRequest(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                setMessageType(35);
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // containment initialization: children
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.DistributionRequest();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$DistributionRequest".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        //++ getter for autogen property _ChildClasses
        /**
         * This is an auto-generated method that returns the map of design time
        * [static] children.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        protected java.util.Map get_ChildClasses()
            {
            return __mapChildren;
            }
        
        // Declared at the super level
        /**
         * Setter for property RequestTimeout.<p>
        * Transient property optionally used on the client to indicate the
        * (safe local) time after which this logical request should be
        * considered timed out.
        * 
        * Note that a single logical request message may result in multiple
        * physical request messages being sent to mulitple members; this
        * RequestTimeout value will be cloned to all resulting RequestMessage
        * instances.
        * 
        * This value is lazily calculated by #getRequestTimeout or
        * #calculateTimeoutRemaining.
         */
        public void setRequestTimeout(long ldtTimeout)
            {
            super.setRequestTimeout(ldtTimeout);
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$EventsHelper
    
    /**
     * Helper component for dispatching UEM events.
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class EventsHelper
            extends    com.tangosol.coherence.component.Util
            implements com.tangosol.net.events.EventInterceptor
        {
        // ---- Fields declarations ----
        
        /**
         * Property EventDispatcherRegistry
         *
         */
        private com.tangosol.net.events.EventDispatcherRegistry __m_EventDispatcherRegistry;
        
        /**
         * Property InterceptorCount
         *
         * A count of the number of service interceptors registered.
         */
        private transient java.util.concurrent.atomic.AtomicLong __m_InterceptorCount;
        
        /**
         * Property InterceptorManager
         *
         * InterceptorManager is responsible for creating EventInterceptors and
         * registering them with the  InterceptorRegistry.
         */
        private com.tangosol.net.events.internal.InterceptorManager __m_InterceptorManager;
        
        /**
         * Property ModifiedBinaryEntryFilter
         *
         * A Filter implementation that expects $EntryStatus objects and
         * evaluates to true if the associated BinaryEntry has been modified
         * ($BinaryEntry.isValueChanged()).
         */
        private com.tangosol.util.Filter __m_ModifiedBinaryEntryFilter;
        
        /**
         * Property ServiceDispatcher
         *
         * ServiceEventDispatcher for this service.
         */
        private com.tangosol.net.events.internal.ServiceDispatcher __m_ServiceDispatcher;
        private static com.tangosol.util.ListMap __mapChildren;
        
        // Static initializer
        static
            {
            __initStatic();
            }
        
        // Default static initializer
        private static void __initStatic()
            {
            // register child classes
            __mapChildren = new com.tangosol.util.ListMap();
            __mapChildren.put("BinaryEntryConverter", PartitionedCache.EventsHelper.BinaryEntryConverter.get_CLASS());
            __mapChildren.put("ModifiedBinaryEntryFilter", PartitionedCache.EventsHelper.ModifiedBinaryEntryFilter.get_CLASS());
            __mapChildren.put("StorageToEntriesConverter", PartitionedCache.EventsHelper.StorageToEntriesConverter.get_CLASS());
            }
        
        // Default constructor
        public EventsHelper()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public EventsHelper(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                setInterceptorCount(new java.util.concurrent.atomic.AtomicLong());
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // containment initialization: children
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.EventsHelper();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$EventsHelper".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        //++ getter for autogen property _ChildClasses
        /**
         * This is an auto-generated method that returns the map of design time
        * [static] children.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        protected java.util.Map get_ChildClasses()
            {
            return __mapChildren;
            }
        
        /**
         * Helper method for raising a RESTORED, RECOVERED, DEPARTED or ROLLBACK
        * event.
         */
        protected void fireTransferEvent(java.util.Map mapStorage, int iPartition, com.oracle.coherence.common.base.Continuation continuation, com.tangosol.net.events.partition.TransferEvent.Type evtType)
            {
            fireTransferEvent(mapStorage, iPartition, continuation, evtType, /*sSnapshot*/ null);
            }
        
        /**
         * Helper method for raising a RESTORED, RECOVERED, DEPARTED or ROLLBACK
        * event.
         */
        protected void fireTransferEvent(java.util.Map mapStorage, int iPartition, com.oracle.coherence.common.base.Continuation continuation, com.tangosol.net.events.partition.TransferEvent.Type evtType, String sSnapshotName)
            {
            // import com.oracle.coherence.common.base.Continuation;
            // import com.tangosol.net.events.internal.ServiceDispatcher as com.tangosol.net.events.internal.ServiceDispatcher;
            // import com.tangosol.net.Member;
            // import com.tangosol.net.events.partition.TransferEvent$Type as com.tangosol.net.events.partition.TransferEvent.Type;
            // import com.tangosol.util.Converter;
            // import com.tangosol.util.ConverterCollections;
            // import com.tangosol.util.NullImplementation;
            // import java.util.Collections;
            // import java.util.Map;
            
            com.tangosol.net.events.internal.ServiceDispatcher dispatcher = getServiceDispatcher();
            if (dispatcher != null && dispatcher.isSubscribed(evtType))
                {
                PartitionedCache        service     = getService();
                Member         memberLocal = service.getThisMember();
                PartitionedCache.Continuations contHelper  = (PartitionedCache.Continuations) service.getContinuations();
            
                PartitionedCache.EventsHelper.StorageToEntriesConverter convUp = new PartitionedCache.EventsHelper.StorageToEntriesConverter();
                convUp.setPartitionId(iPartition);
                _linkChild(convUp);
            
                Converter convNull  = NullImplementation.getConverter();
                Map       mapCaches = Collections.unmodifiableMap(ConverterCollections.getMap(
                            mapStorage, convNull, convNull, convUp, convNull));
            
                if (continuation != null)
                    {
                    continuation = contHelper.wrapAsMessage(continuation);
                    }
            
                Continuation contEvent = evtType == com.tangosol.net.events.partition.TransferEvent.Type.RECOVERED
                    ? dispatcher.getRecoveryTransferEventContinuation(iPartition, memberLocal,
                        memberLocal, mapCaches, sSnapshotName, continuation)
                    : dispatcher.getTransferEventContinuation(evtType, iPartition,
                        memberLocal, memberLocal, mapCaches, continuation);
            
                contHelper.wrapAsTask(contEvent).proceed(Boolean.TRUE);
                }
            else if (continuation != null)
                {
                continuation.proceed(Boolean.FALSE);
                }
            }
        
        /**
         * Create a BinaryEntry view for a collection of $EntryStatus objects.
        * This method is only called to create a UEM event information.
         */
        protected java.util.Set getBinaryEntries(java.util.Collection colStatus, boolean fPost)
            {
            // import com.tangosol.util.ConverterCollections$ConverterSet as com.tangosol.util.ConverterCollections.ConverterSet;
            // import com.tangosol.internal.util.ConversionHelper;
            // import com.tangosol.util.NullImplementation;
            // import java.util.HashSet;
            // import java.util.Iterator;
            // import java.util.Set;
            
            if (fPost)
                {
                // create the set of BinaryEntry objects immediately as it can be used 
                // asynchronously 
                Set setEntries = new HashSet(colStatus.size());
                for (Iterator iter = colStatus.iterator(); iter.hasNext(); )
                    {
                    Storage.EntryStatus status = (Storage.EntryStatus) iter.next();
                    if (status.isAnyAction() && !status.isExpiryOnly() && !status.isSuppressEvents())
                        {
                        setEntries.add(status.getReadOnlyEntry());
                        }
                    }
            
                return setEntries;
                }
            else
                {
                // at this time all status objects must have been locked via the
                // InvocationContext thus have a corresponding BinaryEntry
            
                // ensure only modified Storage.BinaryEntry objects are exposed
                colStatus = ConversionHelper.getFilterCollection(colStatus, getModifiedBinaryEntryFilter());
            
                //
                // Note: we call the constructor directly as opposed to the #getSet factory
                //       method as we have a "Collection" which we logically know is a "set"
                //       which is permitted by the constructor but not the static factory.
                //       See ConverterCollections#getSet/ConverterCollections$ConverterSet
                return new com.tangosol.util.ConverterCollections.ConverterSet(colStatus, getService().getBinaryEntryConverter(),
                    NullImplementation.getConverter());
                }
            }
        
        /**
         * Return a set of BinaryEntries from the specified cache.
         */
        public java.util.Set getBinaryEntries(Storage storage, java.util.Set setEntries)
            {
            // import com.tangosol.util.Converter;
            // import com.tangosol.util.ConverterCollections;
            // import com.tangosol.util.NullImplementation;
            
            Converter convUp   = storage.getEntryToBinaryEntryConverter();
            Converter convNull = NullImplementation.getConverter();
            
            return ConverterCollections.getSet(setEntries, convUp, convNull);
            }
        
        /**
         * Return a set of BinaryEntries from the specified cache, for the
        * entries contained within the specified transfer.
         */
        protected java.util.Set getBinaryEntries(Storage storage, PartitionedCache.TransferRequest msgTransfer)
            {
            // import com.tangosol.util.ImmutableArrayList;
            
            return getBinaryEntries(storage, new ImmutableArrayList(msgTransfer.getResource()).getSet());
            }
        
        // Accessor for the property "EventDispatcherRegistry"
        /**
         * Getter for property EventDispatcherRegistry.<p>
         */
        protected com.tangosol.net.events.EventDispatcherRegistry getEventDispatcherRegistry()
            {
            // import com.tangosol.net.events.EventDispatcherRegistry;
            // import com.tangosol.util.ResourceRegistry;
            
            EventDispatcherRegistry reg = __m_EventDispatcherRegistry;
            if (reg == null)
                {
                ResourceRegistry registry = ((PartitionedCache) get_Parent())
                        .getBackingMapManager().getCacheFactory().getResourceRegistry();
            
                setEventDispatcherRegistry(reg = (EventDispatcherRegistry) registry.getResource(EventDispatcherRegistry.class));
                }
            
            return reg;
            }
        
        // Accessor for the property "InterceptorCount"
        /**
         * Getter for property InterceptorCount.<p>
        * A count of the number of service interceptors registered.
         */
        protected java.util.concurrent.atomic.AtomicLong getInterceptorCount()
            {
            return __m_InterceptorCount;
            }
        
        // Accessor for the property "InterceptorManager"
        /**
         * Getter for property InterceptorManager.<p>
        * InterceptorManager is responsible for creating EventInterceptors and
        * registering them with the  InterceptorRegistry.
         */
        public com.tangosol.net.events.internal.InterceptorManager getInterceptorManager()
            {
            return __m_InterceptorManager;
            }
        
        // Accessor for the property "ModifiedBinaryEntryFilter"
        /**
         * Getter for property ModifiedBinaryEntryFilter.<p>
        * A Filter implementation that expects $EntryStatus objects and
        * evaluates to true if the associated BinaryEntry has been modified
        * ($BinaryEntry.isValueChanged()).
         */
        protected com.tangosol.util.Filter getModifiedBinaryEntryFilter()
            {
            return __m_ModifiedBinaryEntryFilter;
            }
        
        /**
         * Converts a list of $TransferMessage's to an array of maps indexed by
        * partition id. Each map comprises of cache name to a set of
        * BinaryEntry objects.
        * 
        * @param listTransfer  list of $TransferMessage's
        * 
        * @return an array, indexed by partition id, of maps referencing
        * $Storage entries
         */
        protected com.tangosol.util.LongArray getPartitionedMapEntries(java.util.List listTransfer)
            {
            // import com.tangosol.util.LongArray;
            // import com.tangosol.util.SparseArray;
            // import java.util.HashMap;
            // import java.util.Iterator;
            // import java.util.Map;
            
            PartitionedCache   service = getService();
            LongArray laParts = new SparseArray();
            
            for (Iterator iter = listTransfer.iterator(); iter.hasNext(); )
                {
                PartitionedCache.TransferRequest msg       = (PartitionedCache.TransferRequest) iter.next();
                Storage         storage   = service.getStorage(msg.getCacheId());
                int              iPart     = msg.getPartition();
                Map              mapCaches = (Map) laParts.get(iPart);
            
                // COH-8416: ensure that the cache-map exists for all partitions, even
                //           if there are no valid caches on the service
                if (mapCaches == null)
                    {
                    laParts.set(iPart, mapCaches = new HashMap());
                    }
            
                // Note: storage could be null for two reasons, either the service has no
                //       caches and this msg carries -1L as a "marker" cache-id, or the
                //       cache was concurrently destroyed
                if (storage != null)
                    {
                    mapCaches.put(storage.getCacheName(), getBinaryEntries(storage, msg));
                    }
                }
            
            return laParts;
            }
        
        // Accessor for the property "Service"
        /**
         * Getter for property Service.<p>
         */
        public PartitionedCache getService()
            {
            return (PartitionedCache) get_Module();
            }
        
        // Accessor for the property "ServiceDispatcher"
        /**
         * Getter for property ServiceDispatcher.<p>
        * ServiceEventDispatcher for this service.
         */
        public com.tangosol.net.events.internal.ServiceDispatcher getServiceDispatcher()
            {
            return __m_ServiceDispatcher;
            }
        
        /**
         * Return the $StorageDispatcher for the specified storage.
         */
        protected com.tangosol.net.events.internal.StorageDispatcher getStorageDispatcher(Storage storage)
            {
            // import com.tangosol.net.events.internal.StorageDispatcher;
            
            return (StorageDispatcher) storage.getEventDispatcher();
            }
        
        /**
         * Returns true iff any interceptors are subscribed to pre-commit
        * EntryEvent or TxnEvent event types for the provided Storage instance.
        * 
        * @param storage    the $Storage instance whose corresponding
        * dispatcher should be checked
         */
        public boolean hasPreCommitInterceptors(Storage storage)
            {
            // import com.tangosol.net.events.partition.TransactionEvent$Type as com.tangosol.net.events.partition.TransactionEvent.Type;
            // import com.tangosol.net.events.partition.cache.EntryEvent$Type as com.tangosol.net.events.partition.cache.EntryEvent.Type;
            // import com.tangosol.net.events.internal.StorageDispatcher as com.tangosol.net.events.internal.StorageDispatcher;
            
            com.tangosol.net.events.internal.StorageDispatcher dispatcher = getStorageDispatcher(storage);
            
            return getInterceptorCount().get() > 0 && hasServiceInterceptors(com.tangosol.net.events.partition.TransactionEvent.Type.COMMITTING) ||
                   storage.hasInterceptors() && dispatcher != null &&
                   (dispatcher.isSubscribed(com.tangosol.net.events.partition.cache.EntryEvent.Type.INSERTING) ||
                    dispatcher.isSubscribed(com.tangosol.net.events.partition.cache.EntryEvent.Type.UPDATING)  ||
                    dispatcher.isSubscribed(com.tangosol.net.events.partition.cache.EntryEvent.Type.REMOVING));
            }
        
        /**
         * Returns true iff any interceptors are registered with the
        * PartitionedServiceDispatcher.
         */
        public boolean hasServiceInterceptors()
            {
            // import com.tangosol.net.events.internal.ServiceDispatcher as com.tangosol.net.events.internal.ServiceDispatcher;
            
            com.tangosol.net.events.internal.ServiceDispatcher dispatcher = getServiceDispatcher();
            return dispatcher != null && !dispatcher.getInterceptorMap().isEmpty();
            }
        
        /**
         * Returns true iff any interceptors are subscribed to the specified
        * event type with the PartitionedServiceDispatcher.
        * 
        * @param evtType    the event type
         */
        public boolean hasServiceInterceptors(Enum evtType)
            {
            // import com.tangosol.net.events.internal.ServiceDispatcher as com.tangosol.net.events.internal.ServiceDispatcher;
            
            com.tangosol.net.events.internal.ServiceDispatcher dispatcher = getServiceDispatcher();
            return getInterceptorCount().get() > 0 &&
                dispatcher != null && dispatcher.isSubscribed(evtType);
            }
        
        /**
         * Returns true iff any interceptors are subscribed to the specified
        * event type with the StorageDispatcher.
        * 
        * @param storage    the $Storage instance whose corresponding
        * dispatcher should be checked
        * @param evtType    the event type
         */
        public boolean hasStorageInterceptors(Storage storage, Enum evtType)
            {
            // import com.tangosol.net.events.internal.StorageDispatcher as com.tangosol.net.events.internal.StorageDispatcher;
            
            com.tangosol.net.events.internal.StorageDispatcher dispatcher = getStorageDispatcher(storage);
            return dispatcher != null && dispatcher.isSubscribed(evtType);
            }
        
        /**
         * Create, register and return dispatcher for the provided cache.
         */
        public com.tangosol.net.events.internal.StorageDispatcher instantiateStorageDispatcher(String sCacheName)
            {
            // import com.tangosol.net.events.EventDispatcherRegistry;
            // import com.tangosol.net.events.internal.StorageDispatcher;
            
            StorageDispatcher dispatcher = new StorageDispatcher(sCacheName, getService());
            
            EventDispatcherRegistry registry = getEventDispatcherRegistry();
            if (registry != null)
                {
                registry.registerEventDispatcher(dispatcher);
                }
            
            return dispatcher;
            }
        
        /**
         * Create, register, and return a dispatcher for the provided $Storage
        * instance.
         */
        public com.tangosol.net.events.internal.StorageDispatcher instantiateStorageDispatcher(Storage storage)
            {
            // import com.tangosol.net.events.EventDispatcherRegistry;
            // import com.tangosol.net.events.EventDispatcher$InterceptorRegistrationEvent$Type as com.tangosol.net.events.EventDispatcher.InterceptorRegistrationEvent.Type;
            // import com.tangosol.net.events.internal.StorageDispatcher;
            // import com.tangosol.net.events.partition.TransactionEvent$Type as com.tangosol.net.events.partition.TransactionEvent.Type;
            // import com.tangosol.net.events.partition.UnsolicitedCommitEvent$Type as com.tangosol.net.events.partition.UnsolicitedCommitEvent.Type;
            // import com.tangosol.util.ImmutableArrayList;
            
            StorageDispatcher dispatcher = new StorageDispatcher(storage);
            
            dispatcher.addEventInterceptor(get_Name(), storage.getEventDispatcherInterceptor(),
                    new ImmutableArrayList(new Enum[] {com.tangosol.net.events.EventDispatcher.InterceptorRegistrationEvent.Type.INSERTED, com.tangosol.net.events.EventDispatcher.InterceptorRegistrationEvent.Type.REMOVED}),
                    false);
            
            EventDispatcherRegistry registry = getEventDispatcherRegistry();
            if (registry != null)
                {
                registry.registerEventDispatcher(dispatcher);
                }
            
            if (hasServiceInterceptors(com.tangosol.net.events.partition.TransactionEvent.Type.COMMITTED) ||
                hasServiceInterceptors(com.tangosol.net.events.partition.UnsolicitedCommitEvent.Type.COMMITTED))
                {
                storage.ensureOldValueRequired();
                }
            
            return dispatcher;
            }
        
        /**
         * Instantiate cache interceptors and storage dispatcher on the
        * storage-enabled nodes. 
        * 
        * Called on the service thread only.
         */
        public void onCacheConfigured(BinaryMap mapBinary)
            {
            // import com.tangosol.util.Base;
            
            String sCacheName = mapBinary.getCacheName();
            String sSvcName   = getService().getServiceName();
            try
                {
                getInterceptorManager().instantiateCacheInterceptors(
                    sCacheName, sSvcName);
                }
            catch (Exception e)
                {
                _trace("Failed to register event interceptors for cache " +
                    sCacheName + " service " + sSvcName + ": " + e + "\n" +
                    Base.getStackTrace(e), 1);
                }
            
            mapBinary.setDispatcher(
                instantiateStorageDispatcher(sCacheName));
            }
        
        /**
         * Instantiate cache interceptors and storage dispatcher on the
        * storage-enabled nodes. 
        * 
        * Called on the service thread only.
         */
        public void onCacheConfigured(Storage storage)
            {
            PartitionedCache service = getService();
            if (service.getStorageArray().get(storage.getCacheId()) == storage)
                {
                // Note: we do not instantiate interceptors if storage is being cloned (truncate)
                String sCacheName = storage.getCacheName();
                String sSvcName   = service.getServiceName();
                try
                    {
                    getInterceptorManager().instantiateCacheInterceptors(
                        sCacheName, sSvcName);
                    }
                catch (Exception e)
                    {
                    _trace("Failed to register event interceptors for cache " +
                        sCacheName + " service " + sSvcName + ": " + e, 1);
                    }
                }
            storage.setEventDispatcher(
                instantiateStorageDispatcher(storage));
            }
        
        /**
         * Raise an event (if necessary) signalling that the storage of the
        * specified partition set has been truncated, and complete the
        * specified continuation.
        * 
        * Called on service thread only.
         */
        public void onCacheLifecycle(com.tangosol.net.events.internal.StorageDispatcher dispatcher, com.tangosol.net.events.partition.cache.CacheLifecycleEvent.Type eventType)
            {
            // import java.util.Collections;
            
            if (dispatcher != null && dispatcher.isSubscribed(eventType))
                {
                // prepare a continuation to raise a special entry event indicating all entries are removed,
                // and wrap it as a task to run on the EventDispatcher thread
                getService().getContinuations().wrapAsTask(
                        dispatcher.getCacheLifecycleEventContinuation(eventType, null))
                    .proceed(Boolean.TRUE);
                }
            }
        
        /**
         * Raise an event (if necessary) signalling that the specified list of
        * transfers has arrived, and complete the specified continuation.
        * 
        * Called on the service thread only.
         */
        public void onEntriesArrived(java.util.List listTransfer, com.oracle.coherence.common.base.Continuation continuation)
            {
            // import com.tangosol.net.events.partition.TransferEvent$Type as com.tangosol.net.events.partition.TransferEvent.Type;
            // import com.tangosol.net.events.internal.ServiceDispatcher as com.tangosol.net.events.internal.ServiceDispatcher;
            // import com.tangosol.net.Member;
            // import com.tangosol.util.LongArray;
            // import com.tangosol.util.LongArray$Iterator as com.tangosol.util.LongArray.Iterator;
            // import java.util.Collections;
            // import java.util.Map;
            
            com.tangosol.net.events.internal.ServiceDispatcher dispatcher = getServiceDispatcher();
            if (dispatcher != null && dispatcher.isSubscribed(com.tangosol.net.events.partition.TransferEvent.Type.ARRIVED) &&
                !listTransfer.isEmpty())
                {
                PartitionedCache          service    = getService();
                PartitionedCache.Continuations   contHelper = (PartitionedCache.Continuations) service.getContinuations();
                PartitionedCache.TransferRequest msg        = (PartitionedCache.TransferRequest) listTransfer.iterator().next();
                LongArray        laPartMap  = getPartitionedMapEntries(listTransfer);
                Member           memberFrom = msg.getFromMember();
            
                for (com.tangosol.util.LongArray.Iterator iterPartMap = laPartMap.iterator(); iterPartMap.hasNext(); )
                    {
                    Map mapCaches = Collections.unmodifiableMap((Map) iterPartMap.next());
                    int iPart     = (int) iterPartMap.getIndex();
                    
                    // prepare a continuation to raise the transfer event, and wrap it in a task
                    // to run on the EventDispatcher thread. If this is the last transfer message,
                    // wrap the caller's continuation in a Message to post back to the service
                    // thread to run after completing the event has been dispatched
                    contHelper.wrapAsTask(
                        dispatcher.getTransferEventContinuation(
                            com.tangosol.net.events.partition.TransferEvent.Type.ARRIVED, iPart, service.getThisMember(), memberFrom,
                            mapCaches,
                            iterPartMap.hasNext() ? null : contHelper.wrapAsMessage(continuation)))
                        .proceed(Boolean.TRUE);
                    }
                }
            else if (continuation != null)
                {
                continuation.proceed(Boolean.FALSE);
                }
            }
        
        /**
         * Raise an event (if necessary) signalling that the specified transfer
        * is departing, and complete the specified continuation.
        * 
        * Called on the service thread only.
         */
        public void onEntriesDeparting(java.util.List listTransfer, com.oracle.coherence.common.base.Continuation continuation)
            {
            // import com.tangosol.net.events.partition.TransferEvent$Type as com.tangosol.net.events.partition.TransferEvent.Type;
            // import com.tangosol.net.events.internal.ServiceDispatcher as com.tangosol.net.events.internal.ServiceDispatcher;
            // import com.tangosol.net.Member;
            // import com.tangosol.util.LongArray;
            // import com.tangosol.util.LongArray$Iterator as com.tangosol.util.LongArray.Iterator;
            // import java.util.Collections;
            // import java.util.Map;
            
            com.tangosol.net.events.internal.ServiceDispatcher dispatcher = getServiceDispatcher();
            if (dispatcher != null && dispatcher.isSubscribed(com.tangosol.net.events.partition.TransferEvent.Type.DEPARTING) &&
                !listTransfer.isEmpty())
                {
                PartitionedCache          service    = getService();
                PartitionedCache.Continuations   contHelper = (PartitionedCache.Continuations) service.getContinuations();
                PartitionedCache.TransferRequest msg        = (PartitionedCache.TransferRequest) listTransfer.iterator().next();
                LongArray        laPartMap  = getPartitionedMapEntries(listTransfer);
                Member           memberTo   = msg.getRecipient();
            
                for (com.tangosol.util.LongArray.Iterator iterPartMap = laPartMap.iterator(); iterPartMap.hasNext(); )
                    {
                    Map mapCaches = Collections.unmodifiableMap((Map) iterPartMap.next());
                    int iPart     = (int) iterPartMap.getIndex();
            
                    // prepare a continuation to raise the transfer event, and wrap it in a task
                    // to run on the EventDispatcher thread.  If this is the last transfer message,
                    // wrap the caller's continuation in a Message to post back to the service
                    // thread to run after completing the event has been dispatched
                    contHelper.wrapAsTask(
                        dispatcher.getTransferEventContinuation(
                            com.tangosol.net.events.partition.TransferEvent.Type.DEPARTING, iPart, service.getThisMember(), memberTo,
                            mapCaches,
                            iterPartMap.hasNext() ? null : contHelper.wrapAsMessage(continuation)))
                        .proceed(Boolean.TRUE);
                    }
                }
            else if (continuation != null)
                {
                continuation.proceed(Boolean.FALSE);
                }
            }
        
        /**
         * Raise an event (if necessary) signalling that the entries for the
        * specified cache are being recovered from persistent storage, and
        * complete the specified continuation.
        * 
        * Called on the service thread only.
         */
        public void onEntriesRecovered(java.util.Map mapStorage, int iPartition, String sSnapshotName, com.oracle.coherence.common.base.Continuation continuation)
            {
            // import com.tangosol.net.events.partition.TransferEvent$Type as com.tangosol.net.events.partition.TransferEvent.Type;
            
            fireTransferEvent(mapStorage, iPartition, continuation, com.tangosol.net.events.partition.TransferEvent.Type.RECOVERED, sSnapshotName);
            }
        
        /**
         * Raise an event (if necessary) signalling that the entries for the
        * specified cache are being restored, and complete the specified
        * continuation.
        * 
        * Called on the service thread only.
         */
        public void onEntriesRestored(java.util.Map mapStorage, int iPartition, com.oracle.coherence.common.base.Continuation continuation)
            {
            // import com.tangosol.net.events.partition.TransferEvent$Type as com.tangosol.net.events.partition.TransferEvent.Type;
            
            fireTransferEvent(mapStorage, iPartition, continuation, com.tangosol.net.events.partition.TransferEvent.Type.ARRIVED);
            }
        
        /**
         * Raise an event (if necessary) signalling that the specified entry has
        * been changed, and complete the specified continuation.
        * 
        * Called on a worker or service thread.
         */
        public void onEntryChanged(com.tangosol.net.internal.EntryInfo entryInfo, com.oracle.coherence.common.base.Continuation continuation)
            {
            // import com.tangosol.net.cache.ReadWriteBackingMap;
            // import com.tangosol.net.events.partition.cache.EntryEvent$Type as com.tangosol.net.events.partition.cache.EntryEvent.Type;
            // import com.tangosol.net.events.internal.StorageDispatcher as com.tangosol.net.events.internal.StorageDispatcher;
            // import com.tangosol.util.BinaryEntry;
            // import java.util.Collections;
            
            PartitionedCache     service    = getService();
            BinaryEntry binEntry   = entryInfo.getBinaryEntry();
            Storage    storage    = service.getStorage(binEntry.getBackingMapContext().getCacheName());
            com.tangosol.net.events.partition.cache.EntryEvent.Type   eventType  = entryInfo.getEventType();
            com.tangosol.net.events.internal.StorageDispatcher  dispatcher = getStorageDispatcher(storage);
            boolean     fDispatch  = storage.hasInterceptors() && dispatcher != null;

            if (fDispatch && eventType == EntryEvent.Type.UPDATED &&
                ReadWriteBackingMap.BIN_ERASE_PENDING.equals(binEntry.getBinaryValue()))
                {
                eventType = EntryEvent.Type.REMOVED;
                }

            if (storage.hasInterceptors() && dispatcher != null && dispatcher.isSubscribed(eventType))
                {
                // prepare a continuation to raise the entry event, and wrap it as a task to
                // run on the EventDispatcher thread
                service.getContinuations().wrapAsTask(
                    dispatcher.getEntryEventContinuation(
                        eventType, Collections.singleton(binEntry), continuation)).proceed(Boolean.TRUE);
                }
            else if (continuation != null)
                {
                continuation.proceed(Boolean.FALSE);
                }
            }
        
        /**
         * Raise an event (if necessary) signalling that the specified entry is
        * being changed, and complete the specified continuation.
        * 
        * Called on a worker or service thread.
         */
        public void onEntryChanging(Storage.BinaryEntry binEntry, com.oracle.coherence.common.base.Continuation continuation)
            {
            // import com.tangosol.net.events.partition.cache.EntryEvent$Type as com.tangosol.net.events.partition.cache.EntryEvent.Type;
            // import com.tangosol.net.events.internal.StorageDispatcher as com.tangosol.net.events.internal.StorageDispatcher;
            // import java.util.Collections;
            
            com.tangosol.net.events.partition.cache.EntryEvent.Type  eventType  = null;
            com.tangosol.net.events.internal.StorageDispatcher dispatcher = getStorageDispatcher(binEntry.getStorage());
            if (dispatcher != null &&
                ((binEntry.isValueRemoved() || ReadWriteBackingMap.BIN_ERASE_PENDING.equals(binEntry.getBinaryValue()))
                    ? dispatcher.isSubscribed(eventType = com.tangosol.net.events.partition.cache.EntryEvent.Type.REMOVING)
                    : dispatcher.isSubscribed(com.tangosol.net.events.partition.cache.EntryEvent.Type.INSERTING) || dispatcher.isSubscribed(com.tangosol.net.events.partition.cache.EntryEvent.Type.UPDATING)))
                {
                if (eventType == null)
                    {
                    // defer the evaluation of isOriginalPresent until it is absolutely
                    // needed (INSERTING or UPDATING is subscribed), as it requires a
                    // backing-map lookup to answer
                    eventType = binEntry.isValueLoaded() || binEntry.getOriginalBinaryValue() == null
                            ? com.tangosol.net.events.partition.cache.EntryEvent.Type.INSERTING : com.tangosol.net.events.partition.cache.EntryEvent.Type.UPDATING;
                    }
            
                // raise pre-events synchronously on the worker thread
                dispatcher.getEntryEventContinuation(
                    eventType, Collections.singleton(binEntry), continuation).proceed(Boolean.TRUE);
                }
            else if (continuation != null)
                {
                continuation.proceed(Boolean.FALSE);
                }
            }
        
        // From interface: com.tangosol.net.events.EventInterceptor
        public void onEvent(com.tangosol.net.events.Event event)
            {
            // import com.tangosol.net.events.EventDispatcher$InterceptorRegistrationEvent as com.tangosol.net.events.EventDispatcher.InterceptorRegistrationEvent;
            // import com.tangosol.net.events.EventDispatcher$InterceptorRegistrationEvent$Type as com.tangosol.net.events.EventDispatcher.InterceptorRegistrationEvent.Type;
            // import com.tangosol.net.events.partition.TransactionEvent$Type as com.tangosol.net.events.partition.TransactionEvent.Type;
            // import com.tangosol.net.events.partition.UnsolicitedCommitEvent$Type as com.tangosol.net.events.partition.UnsolicitedCommitEvent.Type;
            // import java.util.Iterator;
            
            com.tangosol.net.events.EventDispatcher.InterceptorRegistrationEvent evtDisp = (com.tangosol.net.events.EventDispatcher.InterceptorRegistrationEvent) event;
            
            if (evtDisp.getInterceptor() != this && evtDisp.getType() == com.tangosol.net.events.EventDispatcher.InterceptorRegistrationEvent.Type.INSERTED)
                {
                if (evtDisp.getEventTypes().contains(com.tangosol.net.events.partition.TransactionEvent.Type.COMMITTED) ||
                    evtDisp.getEventTypes().contains(com.tangosol.net.events.partition.UnsolicitedCommitEvent.Type.COMMITTED))
                    {
                    // a service based interceptor has been added therefore notify all known
                    // Storage instances to ensure the old value is available
                    // Note: see registerStorage for new Storage instances
            
                    for (Iterator iter = getService().getStorageArray().iterator(); iter.hasNext(); )
                        {
                        ((Storage) iter.next()).ensureOldValueRequired();
                        }
                    }
                getInterceptorCount().incrementAndGet();
                }
            }
        
        // Declared at the super level
        /**
         * The "component has been initialized" method-notification called out
        * of setConstructed() for the topmost component and that in turn
        * notifies all the children.
        * 
        * This notification gets called before the control returns back to this
        * component instantiator (using <code>new Component.X()</code> or
        * <code>_newInstance(sName)</code>) and on the same thread. In
        * addition, visual components have a "posted" notification
        * <code>onInitUI</code> that is called after (or at the same time as)
        * the control returns back to the instantiator and possibly on a
        * different thread.
         */
        public void onInit()
            {
            super.onInit();
            
            setModifiedBinaryEntryFilter(new PartitionedCache.EventsHelper.ModifiedBinaryEntryFilter());
            }
        
        /**
         * Raise an event (if necessary) signalling that the specified
        * EntryProcessor has processed the specified set of entries, and
        * complete the specified continuation.
        * 
        * Called on a worker or service thread.
         */
        public void onInvoked(Storage storage, java.util.Set setEntries, com.tangosol.util.InvocableMap.EntryProcessor agent, com.oracle.coherence.common.base.Continuation continuation)
            {
            // import com.tangosol.net.events.partition.cache.EntryProcessorEvent$Type as com.tangosol.net.events.partition.cache.EntryProcessorEvent.Type;
            // import com.tangosol.net.events.internal.StorageDispatcher as com.tangosol.net.events.internal.StorageDispatcher;
            
            com.tangosol.net.events.internal.StorageDispatcher dispatcher = getStorageDispatcher(storage);
            if (dispatcher != null && dispatcher.isSubscribed(com.tangosol.net.events.partition.cache.EntryProcessorEvent.Type.EXECUTED))
                {
                // prepare a continuation to raise the entry event, and wrap it as a task to
                // run on the EventDispatcher thread
                getService().getContinuations().wrapAsTask(
                    dispatcher.getEntryProcessorEventContinuation(
                        com.tangosol.net.events.partition.cache.EntryProcessorEvent.Type.EXECUTED, agent, setEntries, continuation)).proceed(Boolean.TRUE);
                }
            else if (continuation != null)
                {
                // always proceed on this thread (service or worker)
                continuation.proceed(Boolean.FALSE);
                }
            }
        
        /**
         * Raise an event (if necessary) signalling that the specified
        * EntryProcessor is processing the specified set of entries, and
        * complete the specified continuation.
        * 
        * Called on a worker or service thread.
         */
        public void onInvoking(Storage storage, java.util.Set setEntries, com.tangosol.util.InvocableMap.EntryProcessor agent, com.oracle.coherence.common.base.Continuation continuation)
            {
            // import com.tangosol.net.events.partition.cache.EntryProcessorEvent$Type as com.tangosol.net.events.partition.cache.EntryProcessorEvent.Type;
            // import com.tangosol.net.events.internal.StorageDispatcher as com.tangosol.net.events.internal.StorageDispatcher;
            
            com.tangosol.net.events.internal.StorageDispatcher dispatcher = getStorageDispatcher(storage);
            if (dispatcher != null && dispatcher.isSubscribed(com.tangosol.net.events.partition.cache.EntryProcessorEvent.Type.EXECUTING))
                {
                // raise pre-events synchronously on the worker thread
                dispatcher.getEntryProcessorEventContinuation(
                    com.tangosol.net.events.partition.cache.EntryProcessorEvent.Type.EXECUTING, agent, setEntries, continuation).proceed(Boolean.TRUE);
                }
            else if (continuation != null)
                {
                // always proceed on this thread (service or worker)
                continuation.proceed(Boolean.FALSE);
                }
            }
        
        /**
         * Raise an event (if necessary) signalling that a number of entries
        * have been changed.
        * 
        * Called on a worker or service thread.
         */
        public final void onOutOfBandChanges(java.util.Set setEntries)
            {
            // import com.tangosol.net.events.partition.UnsolicitedCommitEvent$Type as com.tangosol.net.events.partition.UnsolicitedCommitEvent.Type;
            // import com.tangosol.net.events.internal.ServiceDispatcher as com.tangosol.net.events.internal.ServiceDispatcher;
            // import java.util.Set;
            
            com.tangosol.net.events.internal.ServiceDispatcher dispatcher = getServiceDispatcher();
            if (dispatcher != null && !setEntries.isEmpty()
                && dispatcher.isSubscribed(com.tangosol.net.events.partition.UnsolicitedCommitEvent.Type.COMMITTED))
                {
                // prepare a continuation to raise the entry event, and wrap it as a task to
                // run on the EventDispatcher thread
                getService().getContinuations().wrapAsTask(
                    dispatcher.getUnsolicitedCommitEventContinuation(com.tangosol.net.events.partition.UnsolicitedCommitEvent.Type.COMMITTED,
                        setEntries)).proceed(Boolean.TRUE);
                }
            }
        
        /**
         * Raise an event (if necessary) signalling that the entries for the
        * specified cache are being restored, and complete the specified
        * continuation.
        * 
        * Called on the service thread only.
         */
        public void onPartitionAssigned(java.util.Map mapStorage, int iPartition, com.oracle.coherence.common.base.Continuation continuation)
            {
            // import com.tangosol.net.events.partition.TransferEvent$Type as com.tangosol.net.events.partition.TransferEvent.Type;
            
            fireTransferEvent(mapStorage, iPartition, continuation, com.tangosol.net.events.partition.TransferEvent.Type.ASSIGNED);
            }
        
        /**
         * Raise an event (if necessary) signalling that the entries for the
        * specified cache are being restored, and complete the specified
        * continuation.
        * 
        * Called on the service thread only.
         */
        public void onPartitionLost(java.util.Map mapStorage, int iPartition, com.oracle.coherence.common.base.Continuation continuation)
            {
            // import com.tangosol.net.events.partition.TransferEvent$Type as com.tangosol.net.events.partition.TransferEvent.Type;
            
            fireTransferEvent(mapStorage, iPartition, continuation, com.tangosol.net.events.partition.TransferEvent.Type.LOST);
            }
        
        /**
         * Instantiate service interceptors and service dispatcher on the
        * storage-enabled nodes. 
        * 
        * Called on the service thread only.
         */
        public void onServiceStarted()
            {
            // import com.tangosol.net.events.internal.InterceptorManager;
            // import com.tangosol.util.Base;
            // import com.tangosol.util.ResourceRegistry;
            
            ResourceRegistry registry = ((PartitionedCache) get_Module())
                .getBackingMapManager().getCacheFactory().getResourceRegistry();
            
            InterceptorManager manager = (InterceptorManager)
                registry.getResource(InterceptorManager.class);
                   
            setInterceptorManager(manager);
            
            PartitionedCache service = (PartitionedCache) get_Module();
            
            if (service.isOwnershipEnabled())
                {
                String sSvcName = service.getServiceName();
                try
                    {
                    manager.instantiateServiceInterceptors(sSvcName);
                    }
                catch (Exception e)
                    {
                    _trace("Failed to register event interceptors for service " + sSvcName +
                        ": " + e + "\n" + Base.getStackTrace(e), 5);
                    }
            
                registerServiceDispatcher();
                }
            }
        
        /**
         * Raise an event (if necessary) signalling that a number of entries
        * have been changed.
        * 
        * Called on a worker or service thread.
         */
        public final void onTransactionPostCommit(java.util.Set setEntries)
            {
            // import com.tangosol.net.events.partition.TransactionEvent$Type as com.tangosol.net.events.partition.TransactionEvent.Type;
            // import com.tangosol.net.events.internal.ServiceDispatcher as com.tangosol.net.events.internal.ServiceDispatcher;
            // import java.util.Set;
            
            com.tangosol.net.events.internal.ServiceDispatcher dispatcher = getServiceDispatcher();
            if (getInterceptorCount().get() > 0 && dispatcher != null
                 && dispatcher.isSubscribed(com.tangosol.net.events.partition.TransactionEvent.Type.COMMITTED))
                {
                if (!setEntries.isEmpty())
                    {
                    // prepare a continuation to raise the entry event, and wrap it as a task to
                    // run on the EventDispatcher thread
                    getService().getContinuations().wrapAsTask(
                        dispatcher.getTransactionEventContinuation(com.tangosol.net.events.partition.TransactionEvent.Type.COMMITTED,
                            setEntries)).proceed(Boolean.TRUE);
                    }
                }
            }
        
        /**
         * Raise an event (if necessary) signalling that a number of entries are
        * being changed.
        * 
        * Called on a worker or service thread.
         */
        public final void onTransactionPreCommit(java.util.Collection colStatus)
            {
            // import com.tangosol.net.events.partition.TransactionEvent$Type as com.tangosol.net.events.partition.TransactionEvent.Type;
            // import com.tangosol.net.events.internal.ServiceDispatcher as com.tangosol.net.events.internal.ServiceDispatcher;
            // import java.util.Set;
            
            com.tangosol.net.events.internal.ServiceDispatcher dispatcher = getServiceDispatcher();
            if (dispatcher != null && !colStatus.isEmpty() &&
                getInterceptorCount().get() > 0 && dispatcher.isSubscribed(com.tangosol.net.events.partition.TransactionEvent.Type.COMMITTING))
                {
                // create a [lazy] set of entries, realizing the BinaryEntry from the 
                // Storage.EntryStatus upon access
                Set setEntries = getBinaryEntries(colStatus, /*fPost*/ false);
            
                if (!setEntries.isEmpty())
                    {
                    // raise pre-events synchronously on the worker thread
                    dispatcher.getTransactionEventContinuation(com.tangosol.net.events.partition.TransactionEvent.Type.COMMITTING,
                        setEntries).proceed(Boolean.TRUE);
                    }
                }
            }
        
        /**
         * Raise an event (if necessary) signalling that the entries for the
        * specified cache are being restored, and complete the specified
        * continuation.
        * 
        * Called on the service thread only.
         */
        public void onTransferCompleted(boolean fSuccess, int iPartition, com.oracle.coherence.common.base.Continuation continuation)
            {
            // import com.tangosol.net.events.partition.TransferEvent$Type as com.tangosol.net.events.partition.TransferEvent.Type;
            // import java.util.Collections;
            
            fireTransferEvent(getService().collectValidStorages(), iPartition, continuation,
                             fSuccess ? com.tangosol.net.events.partition.TransferEvent.Type.DEPARTED : com.tangosol.net.events.partition.TransferEvent.Type.ROLLBACK);
            }
        
        /**
         * Register a dispatcher for the service.
         */
        protected void registerServiceDispatcher()
            {
            // import com.tangosol.net.events.EventDispatcherRegistry;
            // import com.tangosol.net.events.EventDispatcher$InterceptorRegistrationEvent$Type as com.tangosol.net.events.EventDispatcher.InterceptorRegistrationEvent.Type;
            // import com.tangosol.net.events.internal.ServiceDispatcher;
            // import com.tangosol.util.ImmutableArrayList;
            
            ServiceDispatcher dispatcher = new ServiceDispatcher(getService());
            
            setServiceDispatcher(dispatcher);
            dispatcher.addEventInterceptor(get_Name(), this, new ImmutableArrayList(
                new Enum[] {com.tangosol.net.events.EventDispatcher.InterceptorRegistrationEvent.Type.INSERTED, com.tangosol.net.events.EventDispatcher.InterceptorRegistrationEvent.Type.REMOVED}), false);
            
            EventDispatcherRegistry registry = getEventDispatcherRegistry();
            if (registry != null)
                {
                registry.registerEventDispatcher(dispatcher);
                }
            }
        
        // Accessor for the property "EventDispatcherRegistry"
        /**
         * Setter for property EventDispatcherRegistry.<p>
         */
        protected void setEventDispatcherRegistry(com.tangosol.net.events.EventDispatcherRegistry registryInterceptor)
            {
            __m_EventDispatcherRegistry = registryInterceptor;
            }
        
        // Accessor for the property "InterceptorCount"
        /**
         * Setter for property InterceptorCount.<p>
        * A count of the number of service interceptors registered.
         */
        protected void setInterceptorCount(java.util.concurrent.atomic.AtomicLong atomicCount)
            {
            __m_InterceptorCount = atomicCount;
            }
        
        // Accessor for the property "InterceptorManager"
        /**
         * Setter for property InterceptorManager.<p>
        * InterceptorManager is responsible for creating EventInterceptors and
        * registering them with the  InterceptorRegistry.
         */
        public void setInterceptorManager(com.tangosol.net.events.internal.InterceptorManager manager)
            {
            __m_InterceptorManager = manager;
            }
        
        // Accessor for the property "ModifiedBinaryEntryFilter"
        /**
         * Setter for property ModifiedBinaryEntryFilter.<p>
        * A Filter implementation that expects $EntryStatus objects and
        * evaluates to true if the associated BinaryEntry has been modified
        * ($BinaryEntry.isValueChanged()).
         */
        protected void setModifiedBinaryEntryFilter(com.tangosol.util.Filter filter)
            {
            __m_ModifiedBinaryEntryFilter = filter;
            }
        
        // Accessor for the property "ServiceDispatcher"
        /**
         * Setter for property ServiceDispatcher.<p>
        * ServiceEventDispatcher for this service.
         */
        protected void setServiceDispatcher(com.tangosol.net.events.internal.ServiceDispatcher dispatcher)
            {
            __m_ServiceDispatcher = dispatcher;
            }
        
        /**
         * Unregister a dispatcher for the service.
         */
        public void unregisterServiceDispatcher()
            {
            // import com.tangosol.net.events.EventDispatcherRegistry;
            // import com.tangosol.net.events.internal.ServiceDispatcher;
            
            ServiceDispatcher dispatcher = getServiceDispatcher();
            if (dispatcher != null)
                {
                EventDispatcherRegistry registry = getEventDispatcherRegistry();
                if (registry != null)
                    {
                    registry.unregisterEventDispatcher(dispatcher);
                    }
            
                dispatcher.removeEventInterceptor(this);
                }
            }
        
        /**
         * Unegister the disptacher for the specified storage.
         */
        public void unregisterStorageDispatcher(Storage storage)
            {
            // import com.tangosol.net.events.EventDispatcherRegistry;
            // import com.tangosol.net.events.internal.StorageDispatcher;
            
            StorageDispatcher dispatcher = (StorageDispatcher) storage.getEventDispatcher();
            if (dispatcher != null)
                {
                EventDispatcherRegistry registry = getEventDispatcherRegistry();
                if (registry != null)
                    {
                    registry.unregisterEventDispatcher(dispatcher);
                    }
            
                dispatcher.removeEventInterceptor(storage.getEventDispatcherInterceptor());
                storage.setEventDispatcher(null);
                }
            }

        // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$EventsHelper$BinaryEntryConverter
        
        /**
         * Converts an $EntryStatus object to a BinaryEntry.
         */
        @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
        public static class BinaryEntryConverter
                extends    com.tangosol.coherence.component.Util
                implements com.tangosol.util.Converter
            {
            // ---- Fields declarations ----
            
            // Default constructor
            public BinaryEntryConverter()
                {
                this(null, null, true);
                }
            
            // Initializing constructor
            public BinaryEntryConverter(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                {
                super(sName, compParent, false);
                
                if (fInit)
                    {
                    __init();
                    }
                }
            
            // Main initializer
            public void __init()
                {
                // private initialization
                __initPrivate();
                
                
                // signal the end of the initialization
                set_Constructed(true);
                }
            
            // Private initializer
            protected void __initPrivate()
                {
                
                super.__initPrivate();
                }
            
            //++ getter for static property _Instance
            /**
             * Getter for property _Instance.<p>
            * Auto generated
             */
            public static com.tangosol.coherence.Component get_Instance()
                {
                return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.EventsHelper.BinaryEntryConverter();
                }
            
            //++ getter for static property _CLASS
            /**
             * Getter for property _CLASS.<p>
            * Property with auto-generated accessor that returns the Class
            * object for a given component.
             */
            public static Class get_CLASS()
                {
                Class clz;
                try
                    {
                    clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$EventsHelper$BinaryEntryConverter".replace('/', '.'));
                    }
                catch (ClassNotFoundException e)
                    {
                    throw new NoClassDefFoundError(e.getMessage());
                    }
                return clz;
                }
            
            //++ getter for autogen property _Module
            /**
             * This is an auto-generated method that returns the global [design
            * time] parent component.
            * 
            * Note: the class generator will ignore any custom implementation
            * for this behavior.
             */
            private com.tangosol.coherence.Component get_Module()
                {
                return this.get_Parent().get_Parent();
                }
            
            // From interface: com.tangosol.util.Converter
            /**
             * Converts the $EntryStatus object to a BinaryEntry.
             */
            public Object convert(Object o)
                {
                return ((Storage.EntryStatus) o).getBinaryEntry();
                }
            }

        // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$EventsHelper$ModifiedBinaryEntryFilter
        
        @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
        public static class ModifiedBinaryEntryFilter
                extends    com.tangosol.coherence.component.Util
                implements com.tangosol.util.Filter
            {
            // ---- Fields declarations ----
            
            // Default constructor
            public ModifiedBinaryEntryFilter()
                {
                this(null, null, true);
                }
            
            // Initializing constructor
            public ModifiedBinaryEntryFilter(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                {
                super(sName, compParent, false);
                
                if (fInit)
                    {
                    __init();
                    }
                }
            
            // Main initializer
            public void __init()
                {
                // private initialization
                __initPrivate();
                
                
                // signal the end of the initialization
                set_Constructed(true);
                }
            
            // Private initializer
            protected void __initPrivate()
                {
                
                super.__initPrivate();
                }
            
            //++ getter for static property _Instance
            /**
             * Getter for property _Instance.<p>
            * Auto generated
             */
            public static com.tangosol.coherence.Component get_Instance()
                {
                return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.EventsHelper.ModifiedBinaryEntryFilter();
                }
            
            //++ getter for static property _CLASS
            /**
             * Getter for property _CLASS.<p>
            * Property with auto-generated accessor that returns the Class
            * object for a given component.
             */
            public static Class get_CLASS()
                {
                Class clz;
                try
                    {
                    clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$EventsHelper$ModifiedBinaryEntryFilter".replace('/', '.'));
                    }
                catch (ClassNotFoundException e)
                    {
                    throw new NoClassDefFoundError(e.getMessage());
                    }
                return clz;
                }
            
            //++ getter for autogen property _Module
            /**
             * This is an auto-generated method that returns the global [design
            * time] parent component.
            * 
            * Note: the class generator will ignore any custom implementation
            * for this behavior.
             */
            private com.tangosol.coherence.Component get_Module()
                {
                return this.get_Parent().get_Parent();
                }
            
            // From interface: com.tangosol.util.Filter
            public boolean evaluate(Object oValue)
                {
                Storage.EntryStatus status   = (Storage.EntryStatus) oValue;
                Storage.BinaryEntry binEntry = status.getBinaryEntry();
                
                return binEntry != null && (binEntry.isValueChanged() || binEntry.isValueLoaded())
                    && !status.isSuppressEvents();
                }
            }

        // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$EventsHelper$StorageToEntriesConverter
        
        /**
         * Converts a $Storage instance to a set of BinaryEntry objects
         * currently stored in primary backing-map.
         */
        @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
        public static class StorageToEntriesConverter
                extends    com.tangosol.coherence.component.Util
                implements com.tangosol.util.Converter
            {
            // ---- Fields declarations ----
            
            /**
             * Property PartitionId
             *
             */
            private int __m_PartitionId;
            
            // Default constructor
            public StorageToEntriesConverter()
                {
                this(null, null, true);
                }
            
            // Initializing constructor
            public StorageToEntriesConverter(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                {
                super(sName, compParent, false);
                
                if (fInit)
                    {
                    __init();
                    }
                }
            
            // Main initializer
            public void __init()
                {
                // private initialization
                __initPrivate();
                
                
                // signal the end of the initialization
                set_Constructed(true);
                }
            
            // Private initializer
            protected void __initPrivate()
                {
                
                super.__initPrivate();
                }
            
            //++ getter for static property _Instance
            /**
             * Getter for property _Instance.<p>
            * Auto generated
             */
            public static com.tangosol.coherence.Component get_Instance()
                {
                return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.EventsHelper.StorageToEntriesConverter();
                }
            
            //++ getter for static property _CLASS
            /**
             * Getter for property _CLASS.<p>
            * Property with auto-generated accessor that returns the Class
            * object for a given component.
             */
            public static Class get_CLASS()
                {
                Class clz;
                try
                    {
                    clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$EventsHelper$StorageToEntriesConverter".replace('/', '.'));
                    }
                catch (ClassNotFoundException e)
                    {
                    throw new NoClassDefFoundError(e.getMessage());
                    }
                return clz;
                }
            
            //++ getter for autogen property _Module
            /**
             * This is an auto-generated method that returns the global [design
            * time] parent component.
            * 
            * Note: the class generator will ignore any custom implementation
            * for this behavior.
             */
            private com.tangosol.coherence.Component get_Module()
                {
                return this.get_Parent().get_Parent();
                }
            
            // From interface: com.tangosol.util.Converter
            /**
             * Converts the $EntryStatus object to a BinaryEntry.
             */
            public Object convert(Object o)
                {
                // import com.tangosol.net.partition.PartitionAwareBackingMap as com.tangosol.net.partition.PartitionAwareBackingMap;
                // import com.tangosol.util.Converter;
                // import com.tangosol.util.ConverterCollections;
                // import com.tangosol.util.NullImplementation;
                // import java.util.Collections;
                // import java.util.Map;
                // import java.util.Set;
                
                // null storage indicates a non-existent cache and is passed through as null
                if (o == null)
                    {
                    return null;
                    }
                
                Storage storage = (Storage) o;
                com.tangosol.net.partition.PartitionAwareBackingMap     mapPABM = storage.getPartitionAwareBackingMap();
                
                if (mapPABM != null)
                    {
                    // typical case (com.tangosol.net.partition.PartitionAwareBackingMap); drive off of the partition-map
                    Map mapPart = mapPABM.getPartitionMap(getPartitionId());
                
                    return getEventsHelper().getBinaryEntries(storage, mapPart.entrySet());
                    }
                
                Map map = storage.getBackingMap();
                if (map == null)
                    {
                    // degenerate case
                    return Collections.emptySet();
                    }
                else
                    {
                    // no com.tangosol.net.partition.PartitionAwareBackingMap; need to drive off of the partitioned-key index and do
                    // a BM-lookup for each key (see Storage.KeyToBinaryEntryConverter)
                
                    Converter convUp   = storage.getKeyToBinaryEntryConverter();
                    Converter convNull = NullImplementation.getConverter();
                
                    Set setKeys = storage.getPartitionedKeyIndex().getPartitionMap(getPartitionId()).keySet();
                
                    return ConverterCollections.getSet(setKeys, convUp, convNull);
                    }
                }
            
            // Accessor for the property "EventsHelper"
            /**
             * Getter for property EventsHelper.<p>
             */
            protected PartitionedCache.EventsHelper getEventsHelper()
                {
                return (PartitionedCache.EventsHelper) get_Parent();
                }
            
            // Accessor for the property "PartitionId"
            /**
             * Getter for property PartitionId.<p>
             */
            public int getPartitionId()
                {
                return __m_PartitionId;
                }
            
            // Accessor for the property "PartitionId"
            /**
             * Setter for property PartitionId.<p>
             */
            public void setPartitionId(int nId)
                {
                __m_PartitionId = nId;
                }
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$GetAllRequest
    
    /**
     * @see $BinaryMap#getAll
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class GetAllRequest
            extends    com.tangosol.coherence.component.net.message.requestMessage.distributedCacheRequest.KeySetRequest
        {
        // ---- Fields declarations ----
        
        /**
         * Property AllowBackupRead
         *
         * Whether reading from backups should be permitted.
         */
        private boolean __m_AllowBackupRead;
        
        /**
         * Property SizeThreshold
         *
         * A maximum number of bytes the caller is willing to accept as a
         * result of the getAll call. Used only for the entrySet()
         * optimization. If specified (positive), the null values must be
         * returned for non-existent (expired) entries.
         */
        private int __m_SizeThreshold;
        private static com.tangosol.util.ListMap __mapChildren;
        
        // Static initializer
        static
            {
            __initStatic();
            }
        
        // Default static initializer
        private static void __initStatic()
            {
            // register child classes
            __mapChildren = new com.tangosol.util.ListMap();
            __mapChildren.put("Poll", PartitionedCache.GetAllRequest.Poll.get_CLASS());
            }
        
        // Default constructor
        public GetAllRequest()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public GetAllRequest(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                setMessageType(58);
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // containment initialization: children
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.GetAllRequest();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$GetAllRequest".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        //++ getter for autogen property _ChildClasses
        /**
         * This is an auto-generated method that returns the map of design time
        * [static] children.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        protected java.util.Map get_ChildClasses()
            {
            return __mapChildren;
            }
        
        // Declared at the super level
        /**
         * Instantiate a copy of this message. This is quite different from the
        * standard "clone" since only the "transmittable" portion of the
        * message (and none of the internal) state should be cloned.
         */
        public com.tangosol.coherence.component.net.Message cloneMessage()
            {
            PartitionedCache.GetAllRequest msg = (PartitionedCache.GetAllRequest) super.cloneMessage();
            
            msg.setAllowBackupRead(isAllowBackupRead());
            
            return msg;
            }
        
        // Declared at the super level
        /**
         * Getter for property EstimatedByteSize.<p>
        * The estimated serialized size of this message.  A negative value
        * indicates that the size is unknown and that it is safe to estimate
        * the size via a double serialization.
         */
        public int getEstimatedByteSize()
            {
            return -1;
            }
        
        // Accessor for the property "SizeThreshold"
        /**
         * Getter for property SizeThreshold.<p>
        * A maximum number of bytes the caller is willing to accept as a result
        * of the getAll call. Used only for the entrySet() optimization. If
        * specified (positive), the null values must be returned for
        * non-existent (expired) entries.
         */
        public int getSizeThreshold()
            {
            return __m_SizeThreshold;
            }
        
        // Declared at the super level
        protected java.util.Set instantiateKeySet(int cKeys)
            {
            // import java.util.Collections;
            
            return ((PartitionedCache) get_Module()).isConcurrent()
                ? Collections.newSetFromMap(new NullableSortedMap())
                : super.instantiateKeySet(cKeys);
            }
        
        // Accessor for the property "AllowBackupRead"
        /**
         * Getter for property AllowBackupRead.<p>
        * Whether reading from backups should be permitted.
         */
        public boolean isAllowBackupRead()
            {
            return __m_AllowBackupRead;
            }
        
        // Declared at the super level
        /**
         * Getter for property CoherentResult.<p>
        * Return true if this message requires a coherence result thus must be
        * served by the primary.
         */
        public boolean isCoherentResult()
            {
            return !isAllowBackupRead();
            }
        
        // Declared at the super level
        public void read(com.tangosol.io.ReadBuffer.BufferInput input)
                throws java.io.IOException
            {
            // import com.tangosol.util.ExternalizableHelper;
            
            super.read(input);
            
            setSizeThreshold(ExternalizableHelper.readInt(input));
            
            readTracing(input);
            
            if (input.available() > 0)
                {
                setAllowBackupRead(input.readBoolean());
                }
            }
        
        // Declared at the super level
        public void run()
            {
            ((PartitionedCache) getService()).onGetAllRequest(this);
            }
        
        // Accessor for the property "AllowBackupRead"
        /**
         * Setter for property AllowBackupRead.<p>
        * Whether reading from backups should be permitted.
         */
        public void setAllowBackupRead(boolean fRead)
            {
            __m_AllowBackupRead = fRead;
            }
        
        // Declared at the super level
        /**
         * Setter for property RequestTimeout.<p>
        * Transient property optionally used on the client to indicate the
        * (safe local) time after which this logical request should be
        * considered timed out.
        * 
        * Note that a single logical request message may result in multiple
        * physical request messages being sent to mulitple members; this
        * RequestTimeout value will be cloned to all resulting RequestMessage
        * instances.
        * 
        * This value is lazily calculated by #getRequestTimeout or
        * #calculateTimeoutRemaining.
         */
        public void setRequestTimeout(long ldtTimeout)
            {
            super.setRequestTimeout(ldtTimeout);
            }
        
        // Accessor for the property "SizeThreshold"
        /**
         * Setter for property SizeThreshold.<p>
        * A maximum number of bytes the caller is willing to accept as a result
        * of the getAll call. Used only for the entrySet() optimization. If
        * specified (positive), the null values must be returned for
        * non-existent (expired) entries.
         */
        public void setSizeThreshold(int cbLimit)
            {
            __m_SizeThreshold = cbLimit;
            }
        
        // Declared at the super level
        public void write(com.tangosol.io.WriteBuffer.BufferOutput output)
                throws java.io.IOException
            {
            // import com.tangosol.util.ExternalizableHelper;
            
            super.write(output);
            
            ExternalizableHelper.writeInt(output, getSizeThreshold());
            
            writeTracing(output);
            
            output.writeBoolean(isAllowBackupRead());
            }

        // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$GetAllRequest$Poll
        
        /**
         * The Poll contains information regarding a request sent to one or
         * more Cluster Members that require responses. A Service may poll
         * other Members that are running the same Service, and the Poll is
         * used to wait for and assemble the responses from each of those
         * Members. A client thread may also use the Poll to block on a
         * response or set of responses, thus waiting for the completion of the
         * Poll. In its simplest form, which is a Poll that is sent to one
         * Member of the Cluster, the Poll actually represents the
         * request/response model.
         */
        @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
        public static class Poll
                extends    com.tangosol.coherence.component.net.message.requestMessage.distributedCacheRequest.KeySetRequest.Poll
            {
            // ---- Fields declarations ----
            
            // Default constructor
            public Poll()
                {
                this(null, null, true);
                }
            
            // Initializing constructor
            public Poll(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                {
                super(sName, compParent, false);
                
                if (fInit)
                    {
                    __init();
                    }
                }
            
            // Main initializer
            public void __init()
                {
                // private initialization
                __initPrivate();
                
                
                // signal the end of the initialization
                set_Constructed(true);
                }
            
            // Private initializer
            protected void __initPrivate()
                {
                
                super.__initPrivate();
                }
            
            // Getter for virtual constant Preprocessable
            public boolean isPreprocessable()
                {
                return true;
                }
            
            //++ getter for static property _Instance
            /**
             * Getter for property _Instance.<p>
            * Auto generated
             */
            public static com.tangosol.coherence.Component get_Instance()
                {
                return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.GetAllRequest.Poll();
                }
            
            //++ getter for static property _CLASS
            /**
             * Getter for property _CLASS.<p>
            * Property with auto-generated accessor that returns the Class
            * object for a given component.
             */
            public static Class get_CLASS()
                {
                Class clz;
                try
                    {
                    clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$GetAllRequest$Poll".replace('/', '.'));
                    }
                catch (ClassNotFoundException e)
                    {
                    throw new NoClassDefFoundError(e.getMessage());
                    }
                return clz;
                }
            
            //++ getter for autogen property _Module
            /**
             * This is an auto-generated method that returns the global [design
            * time] parent component.
            * 
            * Note: the class generator will ignore any custom implementation
            * for this behavior.
             */
            private com.tangosol.coherence.Component get_Module()
                {
                return this.get_Parent().get_Parent();
                }
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$GetRequest
    
    /**
     * @see $BinaryMap#get
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class GetRequest
            extends    com.tangosol.coherence.component.net.message.requestMessage.DistributedCacheKeyRequest
        {
        // ---- Fields declarations ----
        
        /**
         * Property AllowBackupRead
         *
         * Whether reading from backups should be permitted.
         */
        private boolean __m_AllowBackupRead;
        private static com.tangosol.util.ListMap __mapChildren;
        
        // Static initializer
        static
            {
            __initStatic();
            }
        
        // Default static initializer
        private static void __initStatic()
            {
            // register child classes
            __mapChildren = new com.tangosol.util.ListMap();
            __mapChildren.put("Poll", PartitionedCache.GetRequest.Poll.get_CLASS());
            }
        
        // Default constructor
        public GetRequest()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public GetRequest(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                setMessageType(59);
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // containment initialization: children
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.GetRequest();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$GetRequest".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        //++ getter for autogen property _ChildClasses
        /**
         * This is an auto-generated method that returns the map of design time
        * [static] children.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        protected java.util.Map get_ChildClasses()
            {
            return __mapChildren;
            }
        
        // Declared at the super level
        /**
         * Instantiate a copy of this message. This is quite different from the
        * standard "clone" since only the "transmittable" portion of the
        * message (and none of the internal) state should be cloned.
         */
        public com.tangosol.coherence.component.net.Message cloneMessage()
            {
            PartitionedCache.GetRequest msg = (PartitionedCache.GetRequest) super.cloneMessage();
            
            msg.setAllowBackupRead(isAllowBackupRead());
            
            return msg;
            }
        
        // Declared at the super level
        /**
         * Getter for property EstimatedByteSize.<p>
        * The estimated serialized size of this message.  A negative value
        * indicates that the size is unknown and that it is safe to estimate
        * the size via a double serialization.
         */
        public int getEstimatedByteSize()
            {
            return -1;
            }
        
        // Accessor for the property "AllowBackupRead"
        /**
         * Getter for property AllowBackupRead.<p>
        * Whether reading from backups should be permitted.
         */
        public boolean isAllowBackupRead()
            {
            return __m_AllowBackupRead;
            }
        
        // Declared at the super level
        /**
         * Getter for property CoherentResult.<p>
        * Return true if this message requires a coherence result thus must be
        * served by the primary.
         */
        public boolean isCoherentResult()
            {
            return !isAllowBackupRead();
            }
        
        // Declared at the super level
        public void read(com.tangosol.io.ReadBuffer.BufferInput input)
                throws java.io.IOException
            {
            super.read(input);
            
            if (input.available() > 0)
                {
                setAllowBackupRead(input.readBoolean());
                }
            }
        
        // Declared at the super level
        public void run()
            {
            ((PartitionedCache) getService()).onGetRequest(this);
            }
        
        // Accessor for the property "AllowBackupRead"
        /**
         * Setter for property AllowBackupRead.<p>
        * Whether reading from backups should be permitted.
         */
        public void setAllowBackupRead(boolean fRead)
            {
            __m_AllowBackupRead = fRead;
            }
        
        // Declared at the super level
        /**
         * Setter for property RequestTimeout.<p>
        * Transient property optionally used on the client to indicate the
        * (safe local) time after which this logical request should be
        * considered timed out.
        * 
        * Note that a single logical request message may result in multiple
        * physical request messages being sent to mulitple members; this
        * RequestTimeout value will be cloned to all resulting RequestMessage
        * instances.
        * 
        * This value is lazily calculated by #getRequestTimeout or
        * #calculateTimeoutRemaining.
         */
        public void setRequestTimeout(long ldtTimeout)
            {
            super.setRequestTimeout(ldtTimeout);
            }
        
        // Declared at the super level
        public void write(com.tangosol.io.WriteBuffer.BufferOutput output)
                throws java.io.IOException
            {
            super.write(output);
            
            output.writeBoolean(isAllowBackupRead());
            }

        // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$GetRequest$Poll
        
        /**
         * The Poll contains information regarding a request sent to one or
         * more Cluster Members that require responses. A Service may poll
         * other Members that are running the same Service, and the Poll is
         * used to wait for and assemble the responses from each of those
         * Members. A client thread may also use the Poll to block on a
         * response or set of responses, thus waiting for the completion of the
         * Poll. In its simplest form, which is a Poll that is sent to one
         * Member of the Cluster, the Poll actually represents the
         * request/response model.
         */
        @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
        public static class Poll
                extends    com.tangosol.coherence.component.net.message.requestMessage.DistributedCacheKeyRequest.Poll
            {
            // ---- Fields declarations ----
            
            // Default constructor
            public Poll()
                {
                this(null, null, true);
                }
            
            // Initializing constructor
            public Poll(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                {
                super(sName, compParent, false);
                
                if (fInit)
                    {
                    __init();
                    }
                }
            
            // Main initializer
            public void __init()
                {
                // private initialization
                __initPrivate();
                
                
                // signal the end of the initialization
                set_Constructed(true);
                }
            
            // Private initializer
            protected void __initPrivate()
                {
                
                super.__initPrivate();
                }
            
            // Getter for virtual constant Preprocessable
            public boolean isPreprocessable()
                {
                return true;
                }
            
            //++ getter for static property _Instance
            /**
             * Getter for property _Instance.<p>
            * Auto generated
             */
            public static com.tangosol.coherence.Component get_Instance()
                {
                return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.GetRequest.Poll();
                }
            
            //++ getter for static property _CLASS
            /**
             * Getter for property _CLASS.<p>
            * Property with auto-generated accessor that returns the Class
            * object for a given component.
             */
            public static Class get_CLASS()
                {
                Class clz;
                try
                    {
                    clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$GetRequest$Poll".replace('/', '.'));
                    }
                catch (ClassNotFoundException e)
                    {
                    throw new NoClassDefFoundError(e.getMessage());
                    }
                return clz;
                }
            
            //++ getter for autogen property _Module
            /**
             * This is an auto-generated method that returns the global [design
            * time] parent component.
            * 
            * Note: the class generator will ignore any custom implementation
            * for this behavior.
             */
            private com.tangosol.coherence.Component get_Module()
                {
                return this.get_Parent().get_Parent();
                }
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$IndexRequest
    
    /**
     * @see $BinaryMap#addIndex
     * @see $BinaryMap#removeIndex
     * 
     * As of Coherence 12.2.1.1, this request simply schedules the index
     * rebuild and is always processed on the service thread.
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class IndexRequest
            extends    com.tangosol.coherence.component.net.message.requestMessage.distributedCacheRequest.StorageRequest
        {
        // ---- Fields declarations ----
        
        /**
         * Property Add
         *
         * If true, add an index; otherwise remove it.
         */
        private boolean __m_Add;
        
        /**
         * Property Comparator
         *
         * Comparator to use for creating a sorted index, or null if the index
         * is unordered.
         */
        private java.util.Comparator __m_Comparator;
        
        /**
         * Property Extractor
         *
         * The extractor associated with this index request.
         */
        private com.tangosol.util.ValueExtractor __m_Extractor;
        
        /**
         * Property Ordered
         *
         * True iff the request is to add an ordered index.
         */
        private boolean __m_Ordered;
        private static com.tangosol.util.ListMap __mapChildren;
        
        // Static initializer
        static
            {
            __initStatic();
            }
        
        // Default static initializer
        private static void __initStatic()
            {
            // register child classes
            __mapChildren = new com.tangosol.util.ListMap();
            __mapChildren.put("Poll", PartitionedCache.IndexRequest.Poll.get_CLASS());
            }
        
        // Default constructor
        public IndexRequest()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public IndexRequest(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                setMessageType(60);
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // containment initialization: children
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        // Getter for virtual constant ReadOnly
        public boolean isReadOnly()
            {
            return false;
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.IndexRequest();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$IndexRequest".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        //++ getter for autogen property _ChildClasses
        /**
         * This is an auto-generated method that returns the map of design time
        * [static] children.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        protected java.util.Map get_ChildClasses()
            {
            return __mapChildren;
            }
        
        // Declared at the super level
        /**
         * Instantiate a copy of this message. This is quite different from the
        * standard "clone" since only the "transmittable" portion of the
        * message (and none of the internal) state should be cloned.
         */
        public com.tangosol.coherence.component.net.Message cloneMessage()
            {
            PartitionedCache.IndexRequest msg = (PartitionedCache.IndexRequest) super.cloneMessage();
            
            msg.setAdd(isAdd());
            msg.setOrdered(isOrdered());
            msg.setExtractor(getExtractor());
            msg.setComparator(getComparator());
            
            return msg;
            }
        
        // Accessor for the property "Comparator"
        /**
         * Getter for property Comparator.<p>
        * Comparator to use for creating a sorted index, or null if the index
        * is unordered.
         */
        public java.util.Comparator getComparator()
            {
            return __m_Comparator;
            }
        
        // Accessor for the property "Extractor"
        /**
         * Getter for property Extractor.<p>
        * The extractor associated with this index request.
         */
        public com.tangosol.util.ValueExtractor getExtractor()
            {
            return __m_Extractor;
            }
        
        // Accessor for the property "Add"
        /**
         * Getter for property Add.<p>
        * If true, add an index; otherwise remove it.
         */
        public boolean isAdd()
            {
            return __m_Add;
            }
        
        // Accessor for the property "Ordered"
        /**
         * Getter for property Ordered.<p>
        * True iff the request is to add an ordered index.
         */
        public boolean isOrdered()
            {
            return __m_Ordered;
            }
        
        // Declared at the super level
        /**
         * This is the event that is executed when a Message is received.
        * <p>
        * It is the main processing event of the Message called by the
        * <code>Service.onMessage()</code> event. With regards to the use of
        * Message components within clustered Services, Services are designed
        * by dragging Message components into them as static children. These
        * Messages are the components that a Service can send to other running
        * instances of the same Service within a cluster. When the onReceived
        * event is invoked by a Service, it means that the Message has been
        * received; the code in the onReceived event is therefore the Message
        * specific logic for processing a received Message. For example, when
        * onReceived is invoked on a Message named FindData, the onReceived
        * event should do the work to "find the data", because it is being
        * invoked by the Service that received the "find the data" Message.
         */
        public void onReceived()
            {
            ((PartitionedCache) getService()).onIndexRequest(this);
            }
        
        // Declared at the super level
        public void read(com.tangosol.io.ReadBuffer.BufferInput input)
                throws java.io.IOException
            {
            // import com.tangosol.util.Base;
            // import com.tangosol.util.ValueExtractor as com.tangosol.util.ValueExtractor;
            // import java.util.Comparator;
            
            super.read(input);
            
            setAdd(input.readBoolean());
            setOrdered(input.readBoolean());
            try
                {
                setExtractor ((com.tangosol.util.ValueExtractor)  readObject(input));
                setComparator((Comparator) readObject(input));
                }
            catch (Throwable t)
                {
                // see $Module#onIndexRequest
                setReadException(Base.ensureRuntimeException(t));
                }
            
            readTracing(input);
            }
        
        // Declared at the super level
        public void run()
            {
            // should not be called
            throw new IllegalStateException();
            }
        
        // Accessor for the property "Add"
        /**
         * Setter for property Add.<p>
        * If true, add an index; otherwise remove it.
         */
        public void setAdd(boolean fAdd)
            {
            __m_Add = fAdd;
            }
        
        // Accessor for the property "Comparator"
        /**
         * Setter for property Comparator.<p>
        * Comparator to use for creating a sorted index, or null if the index
        * is unordered.
         */
        public void setComparator(java.util.Comparator comparator)
            {
            __m_Comparator = comparator;
            }
        
        // Accessor for the property "Extractor"
        /**
         * Setter for property Extractor.<p>
        * The extractor associated with this index request.
         */
        public void setExtractor(com.tangosol.util.ValueExtractor extractor)
            {
            __m_Extractor = extractor;
            }
        
        // Accessor for the property "Ordered"
        /**
         * Setter for property Ordered.<p>
        * True iff the request is to add an ordered index.
         */
        public void setOrdered(boolean fOrdered)
            {
            __m_Ordered = fOrdered;
            }
        
        // Declared at the super level
        /**
         * Setter for property RequestTimeout.<p>
        * Transient property optionally used on the client to indicate the
        * (safe local) time after which this logical request should be
        * considered timed out.
        * 
        * Note that a single logical request message may result in multiple
        * physical request messages being sent to mulitple members; this
        * RequestTimeout value will be cloned to all resulting RequestMessage
        * instances.
        * 
        * This value is lazily calculated by #getRequestTimeout or
        * #calculateTimeoutRemaining.
         */
        public void setRequestTimeout(long ldtTimeout)
            {
            super.setRequestTimeout(ldtTimeout);
            }
        
        // Declared at the super level
        public void write(com.tangosol.io.WriteBuffer.BufferOutput output)
                throws java.io.IOException
            {
            // import java.io.IOException;
            
            super.write(output);
            
            output.writeBoolean(isAdd());
            output.writeBoolean(isOrdered());
            
            try
                {
                writeObject(output, getExtractor());
                }
            catch (IOException e)
                {
                _trace("Extractor is not serializable: " + getExtractor(), 1);
                throw e;
                }
            
            try
                {
                writeObject(output, getComparator());
                }
            catch (IOException e)
                {
                _trace("Comparator is not serializable: " + getComparator(), 1);
                throw e;
                }
            
            writeTracing(output);
            }

        // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$IndexRequest$Poll
        
        /**
         * The Poll contains information regarding a request sent to one or
         * more Cluster Members that require responses. A Service may poll
         * other Members that are running the same Service, and the Poll is
         * used to wait for and assemble the responses from each of those
         * Members. A client thread may also use the Poll to block on a
         * response or set of responses, thus waiting for the completion of the
         * Poll. In its simplest form, which is a Poll that is sent to one
         * Member of the Cluster, the Poll actually represents the
         * request/response model.
         */
        @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
        public static class Poll
                extends    com.tangosol.coherence.component.net.message.requestMessage.distributedCacheRequest.StorageRequest.Poll
            {
            // ---- Fields declarations ----
            
            // Default constructor
            public Poll()
                {
                this(null, null, true);
                }
            
            // Initializing constructor
            public Poll(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                {
                super(sName, compParent, false);
                
                if (fInit)
                    {
                    __init();
                    }
                }
            
            // Main initializer
            public void __init()
                {
                // private initialization
                __initPrivate();
                
                
                // signal the end of the initialization
                set_Constructed(true);
                }
            
            // Private initializer
            protected void __initPrivate()
                {
                
                super.__initPrivate();
                }
            
            //++ getter for static property _Instance
            /**
             * Getter for property _Instance.<p>
            * Auto generated
             */
            public static com.tangosol.coherence.Component get_Instance()
                {
                return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.IndexRequest.Poll();
                }
            
            //++ getter for static property _CLASS
            /**
             * Getter for property _CLASS.<p>
            * Property with auto-generated accessor that returns the Class
            * object for a given component.
             */
            public static Class get_CLASS()
                {
                Class clz;
                try
                    {
                    clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$IndexRequest$Poll".replace('/', '.'));
                    }
                catch (ClassNotFoundException e)
                    {
                    throw new NoClassDefFoundError(e.getMessage());
                    }
                return clz;
                }
            
            //++ getter for autogen property _Module
            /**
             * This is an auto-generated method that returns the global [design
            * time] parent component.
            * 
            * Note: the class generator will ignore any custom implementation
            * for this behavior.
             */
            private com.tangosol.coherence.Component get_Module()
                {
                return this.get_Parent().get_Parent();
                }
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$InvocationContext
    
    /**
     * The WrapperContext is a BackingMapManagerContext implementation that
     * routes all requests to the underlying Context and maintaining a map of
     * allocated $StorageContext (BackingMapContext) components.
     * 
     * This component is tightly bound to the PartitionedCache component
     * structure.
     * InvocationContext is used to hold metadata relating to a logical
     * invocation request.  The InvocationContext holds any keys that are
     * locked as well as any BinaryEntry objects that are associated with the
     * invocation.
     * 
     * The InvocationContext is also used as the  BackingMapManagerContext
     * exposed through any BinaryEntry objects that are associated with the
     * invocation.
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class InvocationContext
            extends    com.tangosol.coherence.component.util.WrapperContext
        {
        // ---- Fields declarations ----
        
        /**
         * Property AccessGranted
         *
         * One of the BinaryEntry ACCESS_* constants that represents the
         * already granted access.
         */
        private int __m_AccessGranted;
        
        /**
         * Property AccessReason
         *
         * One of the StorageAccessAuthorizer REASON_* constants.
         */
        private int __m_AccessReason;
        
        /**
         * Property AccessStorage
         *
         * The "primary" Storage for this context.
         */
        private Storage __m_AccessStorage;
        
        /**
         * Property AccessSubject
         *
         * Subject represeting the caller.
         */
        private javax.security.auth.Subject __m_AccessSubject;
        
        /**
         * Property Active
         *
         * Indicates whether this context is active.
         * 
         * @see $Module.ensureInvocationContext
         */
        private boolean __m_Active;
        
        /**
         * Property AllowReadThrough
         *
         * Whether to allow the backing map to perform a read-through via
         * provided BMC.getReadOnlyEntry()s.
         */
        private boolean __m_AllowReadThrough;
        
        /**
         * Property Attempt
         *
         * A counter on the number of attempts a request was executed. A
         * request is typically re-executed in the face of deadlock.
         */
        private transient int __m_Attempt;
        
        /**
         * Property Committed
         *
         * If true, the context was "transactional", but the transaction has
         * been committed and no further entry enlistment is allowed.
         */
        private boolean __m_Committed;
        
        /**
         * Property EnlistedStatuses
         *
         * A map of $Storage to a Set of statuses added via lockEntry.
         * 
         * Note: this "safety net" is used only during the lite txn prepare
         * phase to collect entries enlisted by interceptors.
         * 
         * @see lockEntry
         * @see processInterceptors
         */
        private java.util.Map __m_EnlistedStatuses;
        
        /**
         * Property LockedStorage
         *
         * A set of $Storage instances that have been globally locked.
         */
        private java.util.Set __m_LockedStorage;
        
        /**
         * Property MAX_ATTEMPTS
         *
         * The maximum number of attempts to re-execute a request.
         */
        protected static final int MAX_ATTEMPTS = 15;
        
        /**
         * Property PinnedPartitions
         *
         * The set of partitions "entered" on behalf of this InvocationContext.
         */
        private com.tangosol.net.partition.PartitionSet __m_PinnedPartitions;
        
        /**
         * Property ReadOnlyRequest
         *
         * True iff this context is associated with read only request, eg:
         * get/getAll/query/aggregate.
         */
        private boolean __m_ReadOnlyRequest;
        
        /**
         * Property StorageEntries
         *
         * A map of Storage to BinaryEntry objects for all enlisted entries.
         */
        private java.util.Map __m_StorageEntries;
        
        /**
         * Property StorageStatusMap
         *
         * A Map containing the $EntryStatus objects that have been locked by
         * this Invocation context.
         * 
         * Map<$Storage,Map<BinaryKey,$EntryStatus>>
         */
        private java.util.Map __m_StorageStatusMap;
        private static com.tangosol.util.ListMap __mapChildren;
        
        // Static initializer
        static
            {
            __initStatic();
            }
        
        // Default static initializer
        private static void __initStatic()
            {
            // register child classes
            __mapChildren = new com.tangosol.util.ListMap();
            __mapChildren.put("StorageContext", PartitionedCache.InvocationContext.StorageContext.get_CLASS());
            }
        
        // Default constructor
        public InvocationContext()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public InvocationContext(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                setAllowReadThrough(true);
                setLockedStorage(new com.tangosol.util.LiteSet());
                setStorageMap(new com.tangosol.util.LiteMap());
                setStorageStatusMap(new com.tangosol.util.LiteMap());
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // containment initialization: children
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.InvocationContext();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$InvocationContext".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        //++ getter for autogen property _ChildClasses
        /**
         * This is an auto-generated method that returns the map of design time
        * [static] children.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        protected java.util.Map get_ChildClasses()
            {
            return __mapChildren;
            }
        
        /**
         * Check if the expiry of the entry should be extended.
         */
        protected static void checkSlidingExpiry(Storage storage, Storage.EntryStatus status, Storage.BinaryEntry entry)
            {
            if (storage.isExpirySliding() && !entry.isValueChanged() && !entry.isReadOnly())
                {
                status.setPending(true);
                try
                    {
                    if (!status.isAnyAction())
                       {
                       entry.expire(storage.getBackingConfigurableCache().getExpiryDelay());
                       status.setExpiryOnly(true);
                       }
                   }
                finally
                    {
                    status.setPending(false);
                    }
                }
            }
        
        /**
         * Clear the $EntryStatuses enlisted with this InvocationContext and
        * unlock keys for $Storage instances that do not have a global lock.
         */
        protected void clearStatuses()
            {
            // import java.util.Iterator;
            // import java.util.Map;
            // import java.util.Map$Entry as java.util.Map.Entry;
            // import java.util.Set;
            
            PartitionedCache service          = getService();
            Set     setLockedStorage = getLockedStorage();
            Map     mapStorageStatus = getStorageStatusMap();
            
            for (Iterator iter = mapStorageStatus.entrySet().iterator(); iter.hasNext(); )
                {
                java.util.Map.Entry    entry        = (java.util.Map.Entry) iter.next();
                Storage storage      = (Storage) entry.getKey();
                Map      mapKeyStatus = (Map) entry.getValue();
            
                if (!setLockedStorage.contains(storage))
                    {
                    for (Iterator iterStatus = mapKeyStatus.values().iterator(); iterStatus.hasNext(); )
                        {
                        Storage.EntryStatus status = (Storage.EntryStatus) iterStatus.next();
            
                        // Note: always pass false here, as pinned partitions are tracked
                        //       separately and exited by release()
                        service.unlockKey(storage, status.getKey(), false);
                        }
                    }
                }
            mapStorageStatus.clear();
            }
        
        /**
         * Return a view on EnlistedStatuses converting the $EntryStatus value
        * to a corresponding $BinaryEntry.
         */
        protected java.util.Map createEntryView(java.util.Map mapStatuses)
            {
            // import com.tangosol.internal.util.ConversionHelper;
            // import com.tangosol.util.ConverterCollections;
            // import com.tangosol.util.Converter;
            // import com.tangosol.util.NullImplementation;
            
            // Map<Storage, Collection<EntryStatus>> -> Map<Storage, Collection<BinaryEntry>>
            
            Converter convNull = NullImplementation.getConverter();
            Converter convUp   = getService().getBinaryEntryConverter();
            
            return ConverterCollections.getMap(mapStatuses,
                convNull, convNull,
                ConversionHelper.getCollectionConverter(convUp, convNull), convNull);
            }
        
        /**
         * Enlist the corresponding entry for the provided key and $Storage
        * instance, returning the relevant $EntryStatus. The enlisted entry is
        * not detected as a new enlistment thus not added to EnlistedStatuses.
        * 
        * Note: this method assumes a sufficient lock has already been
        * acquired, i.e. the key or all keys are locked for the specified
        * $Storage instance.
        * 
        * @param storage   the storage to enlist the backing-map entry for
        * @param binKey    the binary key to enlist
         */
        public Storage.EntryStatus enlistSynthetic(Storage storage, com.tangosol.util.Binary binKey)
            {
            // import com.tangosol.util.LiteMap;
            // import java.util.Map;
            
            Map          mapStorage   = getStorageStatusMap(); // Map<Storage, Map<BinKey, $EntryStatus>>
            Map          mapKeyStatus = (Map) mapStorage.get(storage);
            Storage.EntryStatus status       = mapKeyStatus == null ? null : (Storage.EntryStatus) mapKeyStatus.get(binKey);
            
            if (status == null)
                {
                status = getService().getResourceCoordinator().ensureStatus(storage, binKey);
                status.setManaged(true);
            
                if (mapKeyStatus == null)
                    {
                    mapStorage.put(storage, mapKeyStatus = new LiteMap());
                    }
                mapKeyStatus.put(binKey, status);
            
                // we may be reusing an EntryStatus, however a previous BinaryEntry
                // can be safely dereferenced
                status.setBinaryEntry(storage.instantiateBinaryEntry(binKey, null, false));
                }
            
            return status;
            }
        
        // Accessor for the property "AccessGranted"
        /**
         * Getter for property AccessGranted.<p>
        * One of the BinaryEntry ACCESS_* constants that represents the already
        * granted access.
         */
        public int getAccessGranted()
            {
            return __m_AccessGranted;
            }
        
        // Accessor for the property "AccessReason"
        /**
         * Getter for property AccessReason.<p>
        * One of the StorageAccessAuthorizer REASON_* constants.
         */
        public int getAccessReason()
            {
            return __m_AccessReason;
            }
        
        // Accessor for the property "AccessStorage"
        /**
         * Getter for property AccessStorage.<p>
        * The "primary" Storage for this context.
         */
        public Storage getAccessStorage()
            {
            return __m_AccessStorage;
            }
        
        // Accessor for the property "AccessSubject"
        /**
         * Getter for property AccessSubject.<p>
        * Subject represeting the caller.
         */
        public javax.security.auth.Subject getAccessSubject()
            {
            return __m_AccessSubject;
            }
        
        // Accessor for the property "Attempt"
        /**
         * Getter for property Attempt.<p>
        * A counter on the number of attempts a request was executed. A request
        * is typically re-executed in the face of deadlock.
         */
        protected int getAttempt()
            {
            return __m_Attempt;
            }
        
        // Accessor for the property "EnlistedStatuses"
        /**
         * Getter for property EnlistedStatuses.<p>
        * A map of $Storage to a Set of statuses added via lockEntry.
        * 
        * Note: this "safety net" is used only during the lite txn prepare
        * phase to collect entries enlisted by interceptors.
        * 
        * @see lockEntry
        * @see processInterceptors
         */
        protected java.util.Map getEnlistedStatuses()
            {
            return __m_EnlistedStatuses;
            }
        
        /**
         * Return the EntryStatus for the provided $Storage instance and the
        * binary key, or null.
         */
        public Storage.EntryStatus getEntryStatus(Storage storage, com.tangosol.util.Binary binKey)
            {
            // import java.util.Map;
            
            Map mapStatuses = (Map) getStorageStatusMap().get(storage);
            
            return mapStatuses == null
                ? null
                : (Storage.EntryStatus) mapStatuses.get(binKey);
            }
        
        // Accessor for the property "EntryStatuses"
        /**
         * Getter for property EntryStatuses.<p>
        * A collection of statuses added by lockEntry or enlistEntry methods.
         */
        public java.util.Collection getEntryStatuses()
            {
            // import com.tangosol.internal.util.ConversionHelper;
            // import com.tangosol.util.ChainedCollection;
            // import com.tangosol.util.ConverterCollections;
            // import com.tangosol.util.NullImplementation;
            // import java.util.Collection;
            // import java.util.Map;
            
            // return a Collection<$EntryStatus> objects given the following
            // EntryStatusMap structure: Map<$Storage, Map<BinKey,$EntryStatus>>
            
            Collection collMaps = getStorageStatusMap().values();
            if (collMaps.size() == 1)
                {
                Map mapStatus = (Map) collMaps.iterator().next();
                return mapStatus.values();
                }
            else
                {
                return new ChainedCollection(
                    ConverterCollections.getCollection(collMaps,
                        ConversionHelper.getMapValuesConverter(),
                        NullImplementation.getConverter()));
                }
            }
        
        // Accessor for the property "LockedStorage"
        /**
         * Getter for property LockedStorage.<p>
        * A set of $Storage instances that have been globally locked.
         */
        protected java.util.Set getLockedStorage()
            {
            return __m_LockedStorage;
            }
        
        // Accessor for the property "PinnedPartitions"
        /**
         * Getter for property PinnedPartitions.<p>
        * The set of partitions "entered" on behalf of this InvocationContext.
         */
        public com.tangosol.net.partition.PartitionSet getPinnedPartitions()
            {
            // import com.tangosol.net.partition.PartitionSet;
            
            PartitionSet parts = __m_PinnedPartitions;
            if (parts == null)
                {
                parts = new PartitionSet(getService().getPartitionCount());
                setPinnedPartitions(parts);
                }
            
            return parts;
            }
        
        // Declared at the super level
        /**
         * Getter for property Service.<p>
         */
        public PartitionedCache getService()
            {
            return (PartitionedCache) get_Module();
            }
        
        // Declared at the super level
        public Storage getStorage(String sCacheName)
            {
            return ((PartitionedCache) get_Module()).getStorage(sCacheName);
            }
        
        // Accessor for the property "StorageEntries"
        /**
         * Getter for property StorageEntries.<p>
        * A map of Storage to BinaryEntry objects for all enlisted entries.
         */
        protected java.util.Map getStorageEntries()
            {
            return __m_StorageEntries;
            }
        
        // Accessor for the property "StorageStatusMap"
        /**
         * Getter for property StorageStatusMap.<p>
        * A Map containing the $EntryStatus objects that have been locked by
        * this Invocation context.
        * 
        * Map<$Storage,Map<BinaryKey,$EntryStatus>>
         */
        public java.util.Map getStorageStatusMap()
            {
            return __m_StorageStatusMap;
            }
        
        /**
         * Return true if there are any enlisted entries for the provided
        * $Storage instance.
         */
        public boolean hasEntriesEnlisted(Storage storage)
            {
            // import java.util.Map;
            
            Map mapStatuses = (Map) getStorageStatusMap().get(storage);
            
            return mapStatuses != null && !mapStatuses.isEmpty();
            }
        
        /**
         * Return true if there are any enlisted entries for the provided
        * $Storage instance and the binary key.
         */
        public boolean hasEntryEnlisted(Storage storage, com.tangosol.util.Binary binKey)
            {
            // import java.util.Map;
            
            Map mapStatuses = (Map) getStorageStatusMap().get(storage);
            
            return mapStatuses != null && mapStatuses.containsKey(binKey);
            }
        
        /**
         * Initialize this InvocationContext.
         */
        public void initialize()
            {
            // import com.tangosol.internal.util.ConversionHelper;
            // import com.tangosol.net.partition.PartitionSet;
            // import com.tangosol.util.Converter;
            // import com.tangosol.util.ConverterCollections;
            // import com.tangosol.util.NullImplementation;
            // import java.util.Map;
            
            // converts Map<Storage,Map<BinKey,$EntryStatus>> to Map<Storage,Collection<BinaryEntry>>
            
            Converter convNull = NullImplementation.getConverter();
            PartitionedCache   service  = getService();
            
            Map mapStorageEntries = ConverterCollections.getMap(getStorageStatusMap(),
                    convNull, convNull,
                    ConversionHelper.getMapValuesConverter(service.getBinaryEntryConverter(), convNull),
                    convNull);
            
            setStorageEntries(mapStorageEntries);
            setPrePinnedPartitions(new PartitionSet(service.getPartitionCount()));
            }
        
        // Declared at the super level
        /**
         * Factory method to avoid cost of virtual construction of
        * $StorageContext child component.
         */
        protected com.tangosol.coherence.component.util.WrapperContext.StorageContext instantiateStorageContext(Storage storage)
            {
            // this method could be called quite frequently; optimize _newChild()
            PartitionedCache.InvocationContext.StorageContext ctx = new PartitionedCache.InvocationContext.StorageContext();
            _linkChild(ctx);
            ctx.setStorage(storage);
            
            return ctx;
            }
        
        // Accessor for the property "Active"
        /**
         * Getter for property Active.<p>
        * Indicates whether this context is active.
        * 
        * @see $Module.ensureInvocationContext
         */
        public boolean isActive()
            {
            return __m_Active;
            }
        
        // Accessor for the property "AllowReadThrough"
        /**
         * Getter for property AllowReadThrough.<p>
        * Whether to allow the backing map to perform a read-through via
        * provided BMC.getReadOnlyEntry()s.
         */
        public boolean isAllowReadThrough()
            {
            return __m_AllowReadThrough;
            }
        
        // Accessor for the property "Committed"
        /**
         * Getter for property Committed.<p>
        * If true, the context was "transactional", but the transaction has
        * been committed and no further entry enlistment is allowed.
         */
        public boolean isCommitted()
            {
            return __m_Committed;
            }
        
        // Accessor for the property "ReadOnly"
        /**
         * Getter for property ReadOnly.<p>
        * True iff the context is associated with a ready only request or the
        * associated transaction is committed.
         */
        public boolean isReadOnly()
            {
            return isReadOnlyRequest() || isCommitted();
            }
        
        // Accessor for the property "ReadOnlyRequest"
        /**
         * Getter for property ReadOnlyRequest.<p>
        * True iff this context is associated with read only request, eg:
        * get/getAll/query/aggregate.
         */
        public boolean isReadOnlyRequest()
            {
            return __m_ReadOnlyRequest;
            }
        
        /**
         * Lock the entries for the specified keys from the specified $Storage,
        * returning the corresponding $EntryStatus. It doesnt check for any
        * registered listener because bulk locking is never called by triggers
        * or UEM interceptors.
        * 
        * @param storage    the storage to lock the backing-map entry for
        * @param aKeys       array of Binary keys to lock
         */
        public Storage.EntryStatus[] lockEntries(Storage storage, com.tangosol.util.Binary[] aKeys, int cSize)
            {
            // import com.tangosol.util.Binary;
            // import com.tangosol.util.LiteMap;
            // import java.util.Map;
            
            Map                  mapStorage   = getStorageStatusMap(); // <Storage, Map<BinKey, $EntryStatus>>
            Map                  mapKeyStatus = (Map) mapStorage.get(storage);
            PartitionedCache              service      = getService();
            PartitionedCache.ResourceCoordinator coordinator  = service.getResourceCoordinator();
            Storage.EntryStatus[]       aStatus      = new Storage.EntryStatus[cSize];
            
            if (mapKeyStatus == null)
                {
                mapStorage.put(storage, mapKeyStatus = new LiteMap());
                }
            
            for (int i = 0; i < cSize; i++)
                {
                Binary binKey = aKeys[i];
            
                service.lockKey(storage, binKey, false);
            
                Storage.EntryStatus status = coordinator.getStatus(storage, binKey);
                _assert(status != null && status.getBinaryEntry() == null);
            
                mapKeyStatus.put(binKey, status);
            
                status.setBinaryEntry(storage.instantiateBinaryEntry(binKey, null, false));
            
                aStatus[i] = status;
                }
            
            return aStatus;
            }
        
        /**
         * Lock the entry for the specified key from the specified $Storage,
        * returning the corresponding $EntryStatus.
        * 
        * @param storage   the storage to lock the backing-map entry for
        * @param binKey     the key to lock the entry for
        * @param fEnter      true iff the corresponding partition should be
        * entered
         */
        public Storage.EntryStatus lockEntry(Storage storage, com.tangosol.util.Binary binKey, boolean fEnter)
            {
            return lockEntry(storage, storage.instantiateBinaryEntry(binKey, null, false), fEnter);
            }
        
        /**
         * Lock the entry for the specified key from the specified $Storage,
        * returning the corresponding $EntryStatus.
        * 
        * @param storage    the storage to lock the backing-map entry for
        * @param binEntry   the $Storage$BinaryEntry to lock
        * @param fEnter       true iff the corresponding partition should be
        * entered
         */
        public Storage.EntryStatus lockEntry(Storage storage, Storage.BinaryEntry binEntry, boolean fEnter)
            {
            // import com.tangosol.net.partition.PartitionSet;
            // import com.tangosol.util.Binary;
            // import com.tangosol.util.LiteMap;
            // import com.tangosol.util.LiteSet;
            // import java.util.Map;
            // import java.util.Set;
            
            Map          mapStorage   = getStorageStatusMap(); // <Storage, Map<BinKey, $EntryStatus>>
            Map          mapKeyStatus = (Map) mapStorage.get(storage);
            Binary       binKey       = binEntry.getBinaryKey();
            PartitionedCache      service      = getService();
            PartitionSet partsPinned  = getPinnedPartitions();
            Storage.EntryStatus status       = mapKeyStatus == null ? null : (Storage.EntryStatus) mapKeyStatus.get(binKey);
            int          nPartition   = status == null ? getKeyPartition(binKey) : status.getPartition();
            
            fEnter = fEnter && !partsPinned.contains(nPartition); // only if not already entered
            if (status == null && service.lockKey(storage, binKey, fEnter))
                {
                if (fEnter || !service.isConcurrent())
                    {
                    // remember the partition as having been entered by the InvocationContext
                    partsPinned.add(nPartition);
                    }
            
                status = service.getResourceCoordinator().getStatus(storage, binKey);
                _assert(status != null && status.getBinaryEntry() == null);
            
                if (mapKeyStatus == null)
                    {
                    mapStorage.put(storage, mapKeyStatus = new LiteMap());
                    }
                mapKeyStatus.put(binKey, status);
            
                // we may be reusing an EntryStatus, however a previous BinaryEntry
                // can be safely dereferenced
                status.setBinaryEntry(binEntry);
            
                Map mapEnlisted = getEnlistedStatuses();
                if (mapEnlisted != null)
                    {
                    Set setStatus = (Set) mapEnlisted.get(storage);
                    if (setStatus == null)
                        {
                        mapEnlisted.put(storage, setStatus = new LiteSet());
                        }
                    setStatus.add(status);
                    }
                }
            
            return status;
            }
        
        /**
         * Attempt to lock all keys from the specified $Storage.
        * 
        * @param storage    the $Storage to lock all keys for
         */
        public void lockStorage(Storage storage)
            {
            getService().getResourceCoordinator().lockAll(storage, -1L);
            
            getLockedStorage().add(storage);
            }
        
        public void markCommitted()
            {
            setCommitted(true);
            }
        
        public void markReadOnlyRequest()
            {
            setReadOnlyRequest(true);
            }
        
        /**
         * Process any potential changes made to the BinaryEntry objects in the
        * specified invocation context and update the storage and status
        * accordingly.
         */
        public void postInvoke()
            {
            postInvokeAll(getEntryStatuses());
            }
        
        /**
         * Commit specified entries into the backing map.
        * 
        * @param colEntries  a collection of EntryStatus to be processed
         */
        public void postInvokeAll(java.util.Collection colEntries)
            {
            // import com.tangosol.net.cache.ConfigurableCacheMap as com.tangosol.net.cache.ConfigurableCacheMap;
            // import java.util.Iterator;
            // import java.util.HashMap;
            // import java.util.LinkedList;
            // import java.util.List;
            // import java.util.Map;
            // import java.util.Map$Entry as java.util.Map.Entry;
            
            int cEntries = colEntries.size();
            if (cEntries == 0)
                {
                return;
                }
            
            if (cEntries == 1)
                {
                Storage.EntryStatus status = (Storage.EntryStatus) colEntries.iterator().next();
                Storage.BinaryEntry entry  = status.getBinaryEntry();
            
                if (entry != null)
                    {
                    Storage storage = entry.getStorage();
            
                    checkSlidingExpiry(storage, status, entry);
            
                    storage.postInvoke(entry);
                    }
                return;
                }
            
            Map mapStorage = new HashMap(cEntries);
            
            for (Iterator iterEntries = colEntries.iterator(); iterEntries.hasNext(); )
                {
                Storage.EntryStatus status = (Storage.EntryStatus) iterEntries.next();
                Storage.BinaryEntry entry  = status.getBinaryEntry();
            
                if (entry != null)
                    {
                    Storage storage = entry.getStorage();
            
                    checkSlidingExpiry(storage, status, entry);
            
                    List listEntries = (List) mapStorage.get(storage);
                    if (listEntries == null)
                        {
                        mapStorage.put(storage, listEntries = new LinkedList());
                        }
                    listEntries.add(entry);
                    }
                }
            
            for (Iterator iter = mapStorage.entrySet().iterator(); iter.hasNext(); )
               {
               java.util.Map.Entry entry = (java.util.Map.Entry) iter.next();
            
               ((Storage) entry.getKey()).postInvokeAll((List) entry.getValue());
               }
            }
        
        /**
         * Prepare this context for StorageAccessAuthorizer-related checks.
        * 
        * @param nAccessRequired - ACCESS_READ_ANY, ACCESS_WRITE_ANY or zero
         */
        public void prepareAccess(com.tangosol.coherence.component.net.RequestContext context, Storage storage, int nAccessRequired, int nReason)
            {
            // import com.tangosol.net.security.StorageAccessAuthorizer as com.tangosol.net.security.StorageAccessAuthorizer;
            
            com.tangosol.net.security.StorageAccessAuthorizer authorizer = storage.getAccessAuthorizer();
            if (authorizer != null)
                {
                if (nAccessRequired != 0)
                    {
                    storage.checkAccess(context, nAccessRequired, nReason);
                    }
            
                setAccessSubject(context == null ? null : context.getSubject());
                setAccessStorage(storage);
                setAccessReason(nReason);
                setAccessGranted(nAccessRequired);
                }
            }
        
        /**
         * Calls triggers and UEM Interceptors on all the currently enlisted
        * entries in the Invocation Context and any new entry enlisted by
        * triggers and UEM interceptors.
        * 
        * @return Set of all newly enlisted EntryStatus
         */
        public java.util.Set processInterceptors()
            {
            return processInterceptors(getStorageEntries());
            }
        
        /**
         * Calls triggers and UEM Interceptors on all the entries in the
        * provided map, and any new entry enlisted by triggers and UEM
        * interceptors.
        * 
        * @param mapStorageEntries  a map of $Storage to a Collection of
        * BinaryEntry objects
        * 
        * @return Set of all newly enlisted EntryStatus
         */
        public java.util.Set processInterceptors(java.util.Map mapStorageEntries)
            {
            // import com.tangosol.util.LiteMap;
            // import com.tangosol.util.LiteSet;
            // import java.util.Collection;
            // import java.util.Collections;
            // import java.util.Iterator;
            // import java.util.Map;
            // import java.util.Map$Entry as java.util.Map.Entry;
            // import java.util.Set;
            
            PartitionedCache.EventsHelper evtHelper   = getService().getEventsHelper();
            Set           setEnlisted = null;
            try
                {
                boolean fPrecommit          = true;              // PreCommit is only fired once
                Map     mapEnlistedEntries  = mapStorageEntries; // <Storage, Set<$EntryStatus>>
                Map     mapEnlistedStatuses = null;
                Map     mapEnlistedExtra    = null;
                
                while (true)
                    {
                    // during the first iteration mapEnlistedEntries contains BinaryEntry objects;
                    // afterwards mapEnlistedEntries contains entries enlisted by interceptors.
                    // Since those are Storage.EntryStatus objects, we use a converting view
                    // (createEntryView()) instead
            
                    for (Iterator iterStorage = mapEnlistedEntries.entrySet().iterator(); iterStorage.hasNext(); )
                        {
                        java.util.Map.Entry      entry   = (java.util.Map.Entry) iterStorage.next();
                        Storage   storage = (Storage) entry.getKey();
            
                        if (storage.getTriggerSet() != null || evtHelper.hasPreCommitInterceptors(storage))
                            {
                            if (setEnlisted == null)
                                {
                                setEnlisted      = new LiteSet();
                                mapEnlistedExtra = new LiteMap();
            
                                // process known entries and collect newly enlisted entries
                                setEnlistedStatuses(mapEnlistedExtra); // used by lockEntry()
                                }
                            
                            Collection colEntry = (Collection) entry.getValue(); // <$BinaryEntry>
            
                            storage.processInterceptors(colEntry);
                            }
            
                        if (mapEnlistedStatuses != null)
                            {
                            // mapEnlistedStatuses contains EntryStatus objects added via lockEntry
                            setEnlisted.addAll((Collection) mapEnlistedStatuses.get(storage));
                            }   
                        }
            
                    if (mapEnlistedExtra == null)
                        {
                        // we didn't have neither triggers nor interceptors
                        break;
                        }
            
                    if (mapEnlistedExtra.isEmpty())
                        {
                        if (fPrecommit)
                            {
                            // we rely on the fact that EntryStatuses collection contains both original
                            // and newly enlisted entry statuses
                            evtHelper.onTransactionPreCommit(getEntryStatuses());
            
                           if (mapEnlistedExtra.isEmpty())
                                {
                                // transaction COMMITTING interceptor didn't add anything
                                break;
                                }
            
                            // any changes by the pre-commit trigger will not
                            // cause another pre-commit event; however additional
                            // entry-changing events could be fired
                            fPrecommit = false;
                            }
                        else
                            {
                            break;
                            }
                        }
            
                    mapEnlistedStatuses = mapEnlistedExtra;
                    mapEnlistedEntries  = createEntryView(mapEnlistedStatuses);
                    mapEnlistedExtra    = new LiteMap();
                    setEnlistedStatuses(mapEnlistedExtra); 
                    }
                }
            finally
                {
                setEnlistedStatuses(null);
                markCommitted();
                }
            
            return setEnlisted == null ? Collections.EMPTY_SET : setEnlisted;
            }
        
        /**
         * Release this InvocationContext resetting any state. If fUnpin is true
        * unpin partitions.
        * 
        * @param fUnpin  whether to unpin partitions
         */
        public void release(boolean fUnpin)
            {
            // import com.tangosol.internal.tracing.Span;
            // import com.tangosol.internal.tracing.TracingHelper;
            // import com.tangosol.net.partition.PartitionSet;
            // import java.util.Iterator;
            // import java.util.Set;
            
            setAttempt(0);
            clearStatuses();
            setActive(false);
            setReadOnlyRequest(false);
            setAllowReadThrough(true);
            setCommitted(false);
            getStorageMap().clear();
                
            PartitionedCache.ResourceCoordinator coordinator = getService().getResourceCoordinator();
            
            Set setLockedStorage = getLockedStorage();
            for (Iterator iter = setLockedStorage.iterator(); iter.hasNext(); )
                {
                coordinator.unlockAll((Storage) iter.next());
                }
            setLockedStorage.clear();
            
            PartitionSet partsPinned = getPinnedPartitions();
            if (fUnpin)
                {
                getService().unpinPartitions(partsPinned);
                }
            
            PartitionSet partsPinnedPre = getPrePinnedPartitions();
            
            Span span = TracingHelper.getActiveSpan();
            if (!TracingHelper.isNoop(span))
                {
                partsPinned.add(partsPinnedPre);
                span.setMetadata("partitions", partsPinned.toString(/*fVerbose*/ false));
                }
            
            partsPinned.clear();
            partsPinnedPre.clear();
            }
        
        /**
         * Reset the StorageAccessAuthorizer-spectfic data.
         */
        public void resetAccess()
            {
            setAccessSubject(null);
            setAccessStorage(null);
            setAccessGranted(0);
            setAccessReason(0);
            }
        
        /**
         * Rollback this InvocationContext whilst still under the allowed number
        * of attempts. If the number of attempts has exceeded the MAX_ATTEMPTS
        * the expection provided is thrown.
        * 
        * @param e                      the exception that was raised which
        * triggered this rollback
        * @param msgRequest  the request being processed when an exception was
        * encountered
        * 
        * @throws the provided RuntimeException if the attempts have been
        * exceeded
         */
        public void rollback(RuntimeException e, com.tangosol.coherence.component.net.message.RequestMessage msgRequest)
            {
            rollback(e, msgRequest, "");
            }
        
        /**
         * Rollback this InvocationContext whilst still under the allowed number
        * of attempts. If the number of attempts has exceeded the MAX_ATTEMPTS
        * the expection provided is thrown.
        * 
        * @param e                      the exception that was raised which
        * triggered this rollback
        * @param msgRequest  the request being processed when an exception was
        * encountered
        * @param sMsg               a message to append to the trace statement
        * made
        * 
        * @throws the provided RuntimeException if the attempts have been
        * exceeded
         */
        public void rollback(RuntimeException e, com.tangosol.coherence.component.net.message.RequestMessage msgRequest, String sMsg)
            {
            // import com.tangosol.net.GuardSupport;
            // import com.tangosol.util.Base;
            
            int     nAttempt = getAttempt() + 1;
            boolean fFail    = nAttempt == MAX_ATTEMPTS;
            String  sName    = msgRequest.get_Name();
            int     iRequest = sName.lastIndexOf("Request");
                    sName    = iRequest > 0 ? sName.substring(0, iRequest) : sName;
            
            setAttempt(nAttempt);
            
            _trace(String.format("%s %s %s request originating from member %d%s.",
                       new Object[] { e.getMessage(), fFail ? "Failed" : "Retrying",
                       sName, Integer.valueOf(msgRequest.getFromMember().getId()),
                       sMsg.isEmpty() ? sMsg : " (" + sMsg + ")"}),
                   fFail ? 1 : 2);
            
            if (fFail)
                {
                // at this point we will be throwing the exception and the call site
                // will release this context instance
                GuardSupport.logStackTraces();
            
                throw e;
                }
            
            // we hit some exception and will try to replay the operation however
            // yield to the winning thread giving it a headstart
            clearStatuses();
            
            Base.sleep(1);
            }
        
        // Accessor for the property "AccessGranted"
        /**
         * Setter for property AccessGranted.<p>
        * One of the BinaryEntry ACCESS_* constants that represents the already
        * granted access.
         */
        protected void setAccessGranted(int nReason)
            {
            __m_AccessGranted = nReason;
            }
        
        // Accessor for the property "AccessReason"
        /**
         * Setter for property AccessReason.<p>
        * One of the StorageAccessAuthorizer REASON_* constants.
         */
        protected void setAccessReason(int nReason)
            {
            __m_AccessReason = nReason;
            }
        
        // Accessor for the property "AccessStorage"
        /**
         * Setter for property AccessStorage.<p>
        * The "primary" Storage for this context.
         */
        protected void setAccessStorage(Storage storage)
            {
            __m_AccessStorage = storage;
            }
        
        // Accessor for the property "AccessSubject"
        /**
         * Setter for property AccessSubject.<p>
        * Subject represeting the caller.
         */
        protected void setAccessSubject(javax.security.auth.Subject subject)
            {
            __m_AccessSubject = subject;
            }
        
        // Accessor for the property "Active"
        /**
         * Setter for property Active.<p>
        * Indicates whether this context is active.
        * 
        * @see $Module.ensureInvocationContext
         */
        public void setActive(boolean fActive)
            {
            __m_Active = fActive;
            }
        
        // Accessor for the property "AllowReadThrough"
        /**
         * Setter for property AllowReadThrough.<p>
        * Whether to allow the backing map to perform a read-through via
        * provided BMC.getReadOnlyEntry()s.
         */
        public void setAllowReadThrough(boolean fThrough)
            {
            __m_AllowReadThrough = fThrough;
            }
        
        // Accessor for the property "Attempt"
        /**
         * Setter for property Attempt.<p>
        * A counter on the number of attempts a request was executed. A request
        * is typically re-executed in the face of deadlock.
         */
        protected void setAttempt(int nAttempt)
            {
            __m_Attempt = nAttempt;
            }
        
        // Accessor for the property "Committed"
        /**
         * Setter for property Committed.<p>
        * If true, the context was "transactional", but the transaction has
        * been committed and no further entry enlistment is allowed.
         */
        public void setCommitted(boolean fRequest)
            {
            __m_Committed = fRequest;
            }
        
        // Accessor for the property "EnlistedStatuses"
        /**
         * Setter for property EnlistedStatuses.<p>
        * A map of $Storage to a Set of statuses added via lockEntry.
        * 
        * Note: this "safety net" is used only during the lite txn prepare
        * phase to collect entries enlisted by interceptors.
        * 
        * @see lockEntry
        * @see processInterceptors
         */
        protected void setEnlistedStatuses(java.util.Map mapStatuses)
            {
            __m_EnlistedStatuses = mapStatuses;
            }
        
        // Accessor for the property "LockedStorage"
        /**
         * Setter for property LockedStorage.<p>
        * A set of $Storage instances that have been globally locked.
         */
        protected void setLockedStorage(java.util.Set setStorage)
            {
            __m_LockedStorage = setStorage;
            }
        
        // Accessor for the property "PinnedPartitions"
        /**
         * Setter for property PinnedPartitions.<p>
        * The set of partitions "entered" on behalf of this InvocationContext.
         */
        protected void setPinnedPartitions(com.tangosol.net.partition.PartitionSet parts)
            {
            __m_PinnedPartitions = parts;
            }
        
        // Accessor for the property "ReadOnlyRequest"
        /**
         * Setter for property ReadOnlyRequest.<p>
        * True iff this context is associated with read only request, eg:
        * get/getAll/query/aggregate.
         */
        protected void setReadOnlyRequest(boolean fReadOnly)
            {
            __m_ReadOnlyRequest = fReadOnly;
            }
        
        // Accessor for the property "StorageEntries"
        /**
         * Setter for property StorageEntries.<p>
        * A map of Storage to BinaryEntry objects for all enlisted entries.
         */
        protected void setStorageEntries(java.util.Map mapEntries)
            {
            __m_StorageEntries = mapEntries;
            }
        
        // Accessor for the property "StorageStatusMap"
        /**
         * Setter for property StorageStatusMap.<p>
        * A Map containing the $EntryStatus objects that have been locked by
        * this Invocation context.
        * 
        * Map<$Storage,Map<BinaryKey,$EntryStatus>>
         */
        protected void setStorageStatusMap(java.util.Map map)
            {
            __m_StorageStatusMap = map;
            }
        
        // Declared at the super level
        public String toString()
            {
            return get_Name() +
                " (Active=" + !isReadOnly() +
                " StorageMap=" + getStorageMap() +
                ')';
            }

        // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$InvocationContext$StorageContext
        
        /**
         * The StorageContext is an invocation context aware wrapper of the
         * corresponding $Storage.
         */
        @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
        public static class StorageContext
                extends    com.tangosol.coherence.component.util.WrapperContext.StorageContext
            {
            // ---- Fields declarations ----
            
            // Default constructor
            public StorageContext()
                {
                this(null, null, true);
                }
            
            // Initializing constructor
            public StorageContext(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                {
                super(sName, compParent, false);
                
                if (fInit)
                    {
                    __init();
                    }
                }
            
            // Main initializer
            public void __init()
                {
                // private initialization
                __initPrivate();
                
                
                // signal the end of the initialization
                set_Constructed(true);
                }
            
            // Private initializer
            protected void __initPrivate()
                {
                
                super.__initPrivate();
                }
            
            //++ getter for static property _Instance
            /**
             * Getter for property _Instance.<p>
            * Auto generated
             */
            public static com.tangosol.coherence.Component get_Instance()
                {
                return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.InvocationContext.StorageContext();
                }
            
            //++ getter for static property _CLASS
            /**
             * Getter for property _CLASS.<p>
            * Property with auto-generated accessor that returns the Class
            * object for a given component.
             */
            public static Class get_CLASS()
                {
                Class clz;
                try
                    {
                    clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$InvocationContext$StorageContext".replace('/', '.'));
                    }
                catch (ClassNotFoundException e)
                    {
                    throw new NoClassDefFoundError(e.getMessage());
                    }
                return clz;
                }
            
            //++ getter for autogen property _Module
            /**
             * This is an auto-generated method that returns the global [design
            * time] parent component.
            * 
            * Note: the class generator will ignore any custom implementation
            * for this behavior.
             */
            private com.tangosol.coherence.Component get_Module()
                {
                return this.get_Parent().get_Parent();
                }
            
            // Declared at the super level
            public com.tangosol.util.InvocableMap.Entry getBackingMapEntry(Object oKey)
                {
                // import com.tangosol.util.Binary;
                
                PartitionedCache.InvocationContext ctx    = (PartitionedCache.InvocationContext) get_Parent();
                Binary             binKey = (Binary) oKey;
                int                iPart  = ctx.getKeyPartition(binKey);
                
                if (ctx.isReadOnly())
                    {
                    throw new IllegalStateException("Context is read-only");
                    }
                
                if (ctx != ctx.getService().getInvocationContext())
                    {
                    throw new IllegalStateException("Context can only be used on the orginal invocation thread");
                    }
                
                // ensure that the partition has been pinned externally (as a single partition or as part
                // of a PartitionSet), or has already been pinned by this InvocationContext
                if (isPartitionEnlisted(iPart))
                    {
                    try
                        {
                        Storage.EntryStatus status = ctx.lockEntry(getStorage(), binKey, false);
                        return status == null ? null : status.getBinaryEntry();
                        }
                    catch (ClassCastException e)
                        {
                        throw new ClassCastException("This BackingMapManagerContext operates on "
                            + " keys and values in Binary format.");
                        }
                    }
                else
                    {
                    throw new IllegalArgumentException("Attempted to enlist an entry belonging to "
                        + "a partition outside of this transaction: " + iPart);
                    }
                }
            
            // Declared at the super level
            /**
             * Return the writable entry that is enlisted in the transaction
            * sandbox if any,   otherwise return a read-only entry from the
            * backing map if the associated partiton is enlisted.
             */
            public com.tangosol.util.InvocableMap.Entry getReadOnlyEntry(Object oKey)
                {
                // import com.tangosol.net.security.DoAsAction;
                // import com.tangosol.util.Binary;
                // import java.security.AccessController;
                // import java.util.Map;
                
                PartitionedCache.InvocationContext ctx = (PartitionedCache.InvocationContext) get_Parent();
                
                Storage storage   = getStorage();
                Map      mapStatus = (Map) ctx.getStorageStatusMap().get(storage);
                
                Map mapResource = System.getSecurityManager() == null
                        ? storage.getBackingMapInternal()
                        : (Map) AccessController.doPrivileged(new DoAsAction(storage.getBackingMapAction()));
                
                Storage.EntryStatus status = mapStatus == null ? null : (Storage.EntryStatus) mapStatus.get((Binary) oKey);
                
                if (status == null)
                    {
                    return ctx.isAllowReadThrough() || mapResource.containsKey(oKey)
                        ? super.getReadOnlyEntry(oKey) : null;
                    }
                
                return status.getBinaryEntry();
                }
            
            // Declared at the super level
            protected boolean isPartitionEnlisted(int iPart)
                {
                PartitionedCache.InvocationContext ctx = (PartitionedCache.InvocationContext) get_Parent();
                
                return super.isPartitionEnlisted(iPart)
                    || ctx.getPinnedPartitions().contains(iPart);
                }
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$InvokeAllRequest
    
    /**
     * @see $BinaryMap#invokeAll(Collection, EntryProcessor)
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class InvokeAllRequest
            extends    com.tangosol.coherence.component.net.message.requestMessage.distributedCacheRequest.KeySetRequest
        {
        // ---- Fields declarations ----
        
        /**
         * Property Processor
         *
         * (Transient) Cached processor reference. It becomes available only
         * after the processor is explicitly deserialized during server side
         * processing of this message.
         * 
         * @see #deserializeProcessor()
         */
        private transient com.tangosol.util.InvocableMap.EntryProcessor __m_Processor;
        
        /**
         * Property ProcessorBinary
         *
         * The binary representation of an  EntryProcessor.
         */
        private com.tangosol.util.Binary __m_ProcessorBinary;
        private static com.tangosol.util.ListMap __mapChildren;
        
        // Static initializer
        static
            {
            __initStatic();
            }
        
        // Default static initializer
        private static void __initStatic()
            {
            // register child classes
            __mapChildren = new com.tangosol.util.ListMap();
            __mapChildren.put("InvokeJob", PartitionedCache.InvokeAllRequest.InvokeJob.get_CLASS());
            __mapChildren.put("Poll", PartitionedCache.InvokeAllRequest.Poll.get_CLASS());
            }
        
        // Default constructor
        public InvokeAllRequest()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public InvokeAllRequest(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                setMessageType(61);
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // containment initialization: children
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        // Getter for virtual constant ReadOnly
        public boolean isReadOnly()
            {
            return false;
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.InvokeAllRequest();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$InvokeAllRequest".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        //++ getter for autogen property _ChildClasses
        /**
         * This is an auto-generated method that returns the map of design time
        * [static] children.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        protected java.util.Map get_ChildClasses()
            {
            return __mapChildren;
            }
        
        // Declared at the super level
        /**
         * Instantiate a copy of this message. This is quite different from the
        * standard "clone" since only the "transmittable" portion of the
        * message (and none of the internal) state should be cloned.
         */
        public com.tangosol.coherence.component.net.Message cloneMessage()
            {
            PartitionedCache.InvokeAllRequest msg = (PartitionedCache.InvokeAllRequest) super.cloneMessage();
            
            msg.setProcessorBinary(getProcessorBinary());
            msg.setOwnershipVersions(getOwnershipVersions());
            
            return msg;
            }
        
        public com.tangosol.util.InvocableMap.EntryProcessor deserializeProcessor()
            {
            // import com.tangosol.util.InvocableMap$EntryProcessor as com.tangosol.util.InvocableMap.EntryProcessor;
            // import com.tangosol.util.ExternalizableHelper as com.tangosol.util.ExternalizableHelper;
            
            com.tangosol.util.InvocableMap.EntryProcessor processor = getProcessor();
            if (processor == null)
                {
                processor = (com.tangosol.util.InvocableMap.EntryProcessor) com.tangosol.util.ExternalizableHelper.fromBinary(
                    getProcessorBinary(), getService().getSerializer());
                setProcessor(processor);
                }
            return processor;
            }
        
        // Declared at the super level
        /**
         * Getter for property EstimatedByteSize.<p>
        * The estimated serialized size of this message.  A negative value
        * indicates that the size is unknown and that it is safe to estimate
        * the size via a double serialization.
         */
        public int getEstimatedByteSize()
            {
            return -1;
            }
        
        // Accessor for the property "Processor"
        /**
         * Getter for property Processor.<p>
        * (Transient) Cached processor reference. It becomes available only
        * after the processor is explicitly deserialized during server side
        * processing of this message.
        * 
        * @see #deserializeProcessor()
         */
        public com.tangosol.util.InvocableMap.EntryProcessor getProcessor()
            {
            return __m_Processor;
            }
        
        // Accessor for the property "ProcessorBinary"
        /**
         * Getter for property ProcessorBinary.<p>
        * The binary representation of an  EntryProcessor.
         */
        public com.tangosol.util.Binary getProcessorBinary()
            {
            return __m_ProcessorBinary;
            }
        
        // Declared at the super level
        protected java.util.Set instantiateKeySet(int cKeys)
            {
            // import java.util.Collections;
            
            PartitionedCache service = (PartitionedCache) get_Module();
            
            // see comments in PutAllRequest.instantiateEntryMap
            return service.isConcurrent() && !isTaskSplitWorthy(cKeys)
                ? Collections.newSetFromMap(new NullableSortedMap())
                : super.instantiateKeySet(cKeys);
            }
        
        /**
         * Return true iff this request should be split into sub-tasks.
        * 
        * @param cEntries the number of entries this request will operate upon.
         */
        protected boolean isTaskSplitWorthy(int cKeys)
            {
            // Until COH-10615 is addressed, async requests should not be split worthy
            return !isAsyncOperation() && ((PartitionedCache) getService()).isTaskSplitWorthy(cKeys);
            }
        
        // Declared at the super level
        /**
         * This is the event that is executed when a Message is received.
        * <p>
        * It is the main processing event of the Message called by the
        * <code>Service.onMessage()</code> event. With regards to the use of
        * Message components within clustered Services, Services are designed
        * by dragging Message components into them as static children. These
        * Messages are the components that a Service can send to other running
        * instances of the same Service within a cluster. When the onReceived
        * event is invoked by a Service, it means that the Message has been
        * received; the code in the onReceived event is therefore the Message
        * specific logic for processing a received Message. For example, when
        * onReceived is invoked on a Message named FindData, the onReceived
        * event should do the work to "find the data", because it is being
        * invoked by the Service that received the "find the data" Message.
         */
        public void onReceived()
            {
            PartitionedCache service = (PartitionedCache) getService();
            if (isTaskSplitWorthy(getKeySet().size()))
                {
                scheduleJobs();
                }
            else
                {
                service.getDaemonPool().add(this);
                }
            }
        
        // Declared at the super level
        public void read(com.tangosol.io.ReadBuffer.BufferInput input)
                throws java.io.IOException
            {
            // import com.tangosol.net.internal.PartitionVersions;
            // import com.tangosol.util.Binary;
            
            super.read(input);
            
            setProcessorBinary((Binary) readObject(input));
            
            if (isAsyncOperation())
                {
                PartitionVersions versions = new PartitionVersions();
                versions.readExternal(input);
                setOwnershipVersions(versions);
                }
            
            readTracing(input);
            }
        
        // Declared at the super level
        public void run()
            {
            ((PartitionedCache) get_Module()).onInvokeAllRequest(this);
            }
        
        /**
         * Split this task into jobs and schedule them with the daemon pool.
         */
        protected void scheduleJobs()
            {
            // import Component.Net.RequestContext as com.tangosol.coherence.component.net.RequestContext;
            // import Component.Util.DaemonPool as com.tangosol.coherence.component.util.DaemonPool;
            // import com.tangosol.util.Binary;
            // import com.tangosol.util.InvocableMap$EntryProcessor as com.tangosol.util.InvocableMap.EntryProcessor;
            // import com.tangosol.util.LongArray;
            // import com.tangosol.util.SparseArray;
            // import java.util.Iterator;
            // import java.util.Map;
            // import java.util.Set;
            
            PartitionedCache    service  = (PartitionedCache) getService();
            com.tangosol.coherence.component.util.DaemonPool pool     = service.getDaemonPool();
            Set        setKeys  = getKeySet();
            int        cEntries = setKeys.size();
            
            PartitionedCache.PartialMapResponse msgResponse = (PartitionedCache.PartialMapResponse)
                service.instantiateMessage("PartialMapResponse");
            msgResponse.respondTo(this);
            
            if (getReadException() != null)
                {
                msgResponse.setException(service.tagException(getReadException()));
                service.post(msgResponse);
                return;
                }
            
            // we need to prepare result arrays up-front
            // since the jobs will put invocation results into pre-assigned spots
            Object[] aoKey = new Object[cEntries];
            Object[] aoVal = new Object[cEntries];
            msgResponse.setKey(aoKey);
            msgResponse.setValue(aoVal);
            msgResponse.setSize(cEntries);
            
            // Note 1: job processing MUST not modify the state of this InvokeAllRequest
            //         message and the safest way is to new the PartitionedCache.InvokeAllRequest.InvokeJob object explicitly
            // Note 2: job processors MUST synchronize on the msgResponse for any modifications
            
            Binary        binProcessor = getProcessorBinary();
            com.tangosol.coherence.component.net.RequestContext       context      = getRequestContext();
            PartitionedCache.BatchContext ctxBatch     = service.instantiateBatchContext(msgResponse);
            
            // split up into individual jobs; one job per partition
            LongArray laJob = new SparseArray();
            
            for (Iterator iter = setKeys.iterator(); iter.hasNext();)
                {
                Binary     binKey     = (Binary) iter.next();
                int        iPartition = service.getKeyPartition(binKey);
                PartitionedCache.InvokeAllRequest.InvokeJob job        = (PartitionedCache.InvokeAllRequest.InvokeJob) laJob.get(iPartition);
                if (job == null)
                    {
                    job = new PartitionedCache.InvokeAllRequest.InvokeJob();
                    job.setRequest(this);
                    job.setService(service);
                    job.setBatchContext(ctxBatch);
                    job.setPartition(iPartition);
                    job.setProcessorBinary(binProcessor);
                    job.setRequestContext(context);
            
                    laJob.set(iPartition, job);
                    }
            
                job.getMap().put(binKey, null);
                }
            
            ctxBatch.getOutstandingOperationCounter().set(laJob.getSize());
            
            int iEntry = 0;
            for (Iterator iter = laJob.iterator(); iter.hasNext();)
                {
                PartitionedCache.InvokeAllRequest.InvokeJob job = (PartitionedCache.InvokeAllRequest.InvokeJob) iter.next();
            
                job.setResultIndex(iEntry);
                iEntry += job.getMap().size();
            
                pool.add(job);
                }
            }
        
        // Accessor for the property "Processor"
        /**
         * Setter for property Processor.<p>
        * (Transient) Cached processor reference. It becomes available only
        * after the processor is explicitly deserialized during server side
        * processing of this message.
        * 
        * @see #deserializeProcessor()
         */
        public void setProcessor(com.tangosol.util.InvocableMap.EntryProcessor processor)
            {
            __m_Processor = processor;
            }
        
        // Accessor for the property "ProcessorBinary"
        /**
         * Setter for property ProcessorBinary.<p>
        * The binary representation of an  EntryProcessor.
         */
        public void setProcessorBinary(com.tangosol.util.Binary binProcessor)
            {
            __m_ProcessorBinary = binProcessor;
            }
        
        // Declared at the super level
        /**
         * Setter for property RequestTimeout.<p>
        * Transient property optionally used on the client to indicate the
        * (safe local) time after which this logical request should be
        * considered timed out.
        * 
        * Note that a single logical request message may result in multiple
        * physical request messages being sent to mulitple members; this
        * RequestTimeout value will be cloned to all resulting RequestMessage
        * instances.
        * 
        * This value is lazily calculated by #getRequestTimeout or
        * #calculateTimeoutRemaining.
         */
        public void setRequestTimeout(long ldtTimeout)
            {
            super.setRequestTimeout(ldtTimeout);
            }
        
        // Declared at the super level
        public void write(com.tangosol.io.WriteBuffer.BufferOutput output)
                throws java.io.IOException
            {
            super.write(output);
            
            writeObject(output, getProcessorBinary());
            
            if (isAsyncOperation())
                {
                getOwnershipVersions().writeExternal(output);
                }
            
            writeTracing(output);
            }

        // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$InvokeAllRequest$InvokeJob
        
        /**
         * PartialJob represents a segment of a DistributedCacheRequest that
         * contains keys (entries) that belong to the same partition (bucket).
         * It assumes to belong to (contained by) a DistributedRequestMessage.
         * 
         * InvokeJob represents a segment of invokeAll request that contains
         * keys that belong to the same bucket.
         */
        @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
        public static class InvokeJob
                extends    com.tangosol.coherence.component.util.PartialJob
            {
            // ---- Fields declarations ----
            
            /**
             * Property Map
             *
             * The placeholder map for results of the job invocation. Map's key
             * set contains Binary keys to be processed by this job. Used
             * instead of a Set to eliminate an extra Map instantiation during
             * processing.
             * 
             * @see $Module#onInvokeAllRequest($InvokeJob)
             */
            private transient java.util.Map __m_Map;
            
            /**
             * Property Processor
             *
             * (Transient) Cached processor reference. It becomes available
             * only after the processor is explicitly deserialized during
             * server side processing of this message.
             * 
             * @see #deserializeProcessor()
             */
            private transient com.tangosol.util.InvocableMap.EntryProcessor __m_Processor;
            
            /**
             * Property ProcessorBinary
             *
             * The binary representation of an  EntryProcessor.
             */
            private com.tangosol.util.Binary __m_ProcessorBinary;
            
            /**
             * Property ResultIndex
             *
             * A starting index to the PartialMapResponse#Key,Value arrays that
             * this job will put the invocation results at.
             */
            private transient int __m_ResultIndex;
            
            /**
             * Property Service
             *
             * The Service.
             */
            private transient com.tangosol.coherence.component.util.daemon.queueProcessor.service.Grid __m_Service;
            
            // Default constructor
            public InvokeJob()
                {
                this(null, null, true);
                }
            
            // Initializing constructor
            public InvokeJob(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                {
                super(sName, compParent, false);
                
                if (fInit)
                    {
                    __init();
                    }
                }
            
            // Main initializer
            public void __init()
                {
                // private initialization
                __initPrivate();
                
                // state initialization: public and protected properties
                try
                    {
                    setMap(new NullableSortedMap());
                    }
                catch (java.lang.Exception e)
                    {
                    // re-throw as a runtime exception
                    throw new com.tangosol.util.WrapperException(e);
                    }
                
                // signal the end of the initialization
                set_Constructed(true);
                }
            
            // Private initializer
            protected void __initPrivate()
                {
                
                super.__initPrivate();
                }
            
            //++ getter for static property _Instance
            /**
             * Getter for property _Instance.<p>
            * Auto generated
             */
            public static com.tangosol.coherence.Component get_Instance()
                {
                return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.InvokeAllRequest.InvokeJob();
                }
            
            //++ getter for static property _CLASS
            /**
             * Getter for property _CLASS.<p>
            * Property with auto-generated accessor that returns the Class
            * object for a given component.
             */
            public static Class get_CLASS()
                {
                Class clz;
                try
                    {
                    clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$InvokeAllRequest$InvokeJob".replace('/', '.'));
                    }
                catch (ClassNotFoundException e)
                    {
                    throw new NoClassDefFoundError(e.getMessage());
                    }
                return clz;
                }
            
            //++ getter for autogen property _Module
            /**
             * This is an auto-generated method that returns the global [design
            * time] parent component.
            * 
            * Note: the class generator will ignore any custom implementation
            * for this behavior.
             */
            private com.tangosol.coherence.Component get_Module()
                {
                return this.get_Parent().get_Parent();
                }
            
            public com.tangosol.util.InvocableMap.EntryProcessor deserializeProcessor()
                {
                // import com.tangosol.util.InvocableMap$EntryProcessor as com.tangosol.util.InvocableMap.EntryProcessor;
                // import com.tangosol.util.ExternalizableHelper as com.tangosol.util.ExternalizableHelper;
                
                com.tangosol.util.InvocableMap.EntryProcessor processor = getProcessor();
                if (processor == null)
                    {
                    processor = (com.tangosol.util.InvocableMap.EntryProcessor) com.tangosol.util.ExternalizableHelper.fromBinary(
                        getProcessorBinary(), getService().getSerializer());
                    setProcessor(processor);
                    }
                return processor;
                }
            
            // Declared at the super level
            /**
             * Getter for property Description.<p>
            * Used for debugging purposes (from toString). Create a
            * human-readable description of the specific job data.
             */
            public String getDescription()
                {
                String sCacheName = ((PartitionedCache) get_Module()).getCacheName(getCacheId());
                
                if (sCacheName == null)
                    {
                    sCacheName = "<unknown>";
                    }
                
                return super.getDescription()
                    + ", Agent="  + getProcessor() + ", CacheName=" + sCacheName;
                }
            
            // Accessor for the property "Map"
            /**
             * Getter for property Map.<p>
            * The placeholder map for results of the job invocation. Map's key
            * set contains Binary keys to be processed by this job. Used
            * instead of a Set to eliminate an extra Map instantiation during
            * processing.
            * 
            * @see $Module#onInvokeAllRequest($InvokeJob)
             */
            public java.util.Map getMap()
                {
                return __m_Map;
                }
            
            // Accessor for the property "OwnershipVersion"
            /**
             * Getter for property OwnershipVersion.<p>
            * The ownership version of the partition that this job represents
            * (if async), or -1.
             */
            public int getOwnershipVersion()
                {
                // import com.tangosol.net.internal.PartitionVersions;
                
                PartitionVersions versions = ((PartitionedCache.InvokeAllRequest) getRequest()).getOwnershipVersions();
                return versions == null ? -1 : versions.getVersion(getPartition());
                }
            
            // Accessor for the property "Processor"
            /**
             * Getter for property Processor.<p>
            * (Transient) Cached processor reference. It becomes available only
            * after the processor is explicitly deserialized during server side
            * processing of this message.
            * 
            * @see #deserializeProcessor()
             */
            public com.tangosol.util.InvocableMap.EntryProcessor getProcessor()
                {
                return __m_Processor;
                }
            
            // Accessor for the property "ProcessorBinary"
            /**
             * Getter for property ProcessorBinary.<p>
            * The binary representation of an  EntryProcessor.
             */
            public com.tangosol.util.Binary getProcessorBinary()
                {
                return __m_ProcessorBinary;
                }
            
            // Accessor for the property "ResultIndex"
            /**
             * Getter for property ResultIndex.<p>
            * A starting index to the PartialMapResponse#Key,Value arrays that
            * this job will put the invocation results at.
             */
            public int getResultIndex()
                {
                return __m_ResultIndex;
                }
            
            // Accessor for the property "Service"
            /**
             * Getter for property Service.<p>
            * The Service.
             */
            public com.tangosol.coherence.component.util.daemon.queueProcessor.service.Grid getService()
                {
                return __m_Service;
                }
            
            // Declared at the super level
            public void run()
                {
                ((PartitionedCache) getResponse().getService()).onInvokeAllRequest(this);
                }
            
            // Accessor for the property "Map"
            /**
             * Setter for property Map.<p>
            * The placeholder map for results of the job invocation. Map's key
            * set contains Binary keys to be processed by this job. Used
            * instead of a Set to eliminate an extra Map instantiation during
            * processing.
            * 
            * @see $Module#onInvokeAllRequest($InvokeJob)
             */
            protected void setMap(java.util.Map set)
                {
                __m_Map = set;
                }
            
            // Accessor for the property "Processor"
            /**
             * Setter for property Processor.<p>
            * (Transient) Cached processor reference. It becomes available only
            * after the processor is explicitly deserialized during server side
            * processing of this message.
            * 
            * @see #deserializeProcessor()
             */
            public void setProcessor(com.tangosol.util.InvocableMap.EntryProcessor processor)
                {
                __m_Processor = processor;
                }
            
            // Accessor for the property "ProcessorBinary"
            /**
             * Setter for property ProcessorBinary.<p>
            * The binary representation of an  EntryProcessor.
             */
            public void setProcessorBinary(com.tangosol.util.Binary binProcessor)
                {
                __m_ProcessorBinary = binProcessor;
                }
            
            // Accessor for the property "ResultIndex"
            /**
             * Setter for property ResultIndex.<p>
            * A starting index to the PartialMapResponse#Key,Value arrays that
            * this job will put the invocation results at.
             */
            public void setResultIndex(int iStart)
                {
                __m_ResultIndex = iStart;
                }
            
            // Accessor for the property "Service"
            /**
             * Setter for property Service.<p>
            * The Service.
             */
            public void setService(com.tangosol.coherence.component.util.daemon.queueProcessor.service.Grid service)
                {
                __m_Service = service;
                }
            }

        // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$InvokeAllRequest$Poll
        
        /**
         * The Poll contains information regarding a request sent to one or
         * more Cluster Members that require responses. A Service may poll
         * other Members that are running the same Service, and the Poll is
         * used to wait for and assemble the responses from each of those
         * Members. A client thread may also use the Poll to block on a
         * response or set of responses, thus waiting for the completion of the
         * Poll. In its simplest form, which is a Poll that is sent to one
         * Member of the Cluster, the Poll actually represents the
         * request/response model.
         */
        @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
        public static class Poll
                extends    com.tangosol.coherence.component.net.message.requestMessage.distributedCacheRequest.KeySetRequest.Poll
            {
            // ---- Fields declarations ----
            
            // Default constructor
            public Poll()
                {
                this(null, null, true);
                }
            
            // Initializing constructor
            public Poll(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                {
                super(sName, compParent, false);
                
                if (fInit)
                    {
                    __init();
                    }
                }
            
            // Main initializer
            public void __init()
                {
                // private initialization
                __initPrivate();
                
                
                // signal the end of the initialization
                set_Constructed(true);
                }
            
            // Private initializer
            protected void __initPrivate()
                {
                
                super.__initPrivate();
                }
            
            // Getter for virtual constant Preprocessable
            public boolean isPreprocessable()
                {
                return true;
                }
            
            //++ getter for static property _Instance
            /**
             * Getter for property _Instance.<p>
            * Auto generated
             */
            public static com.tangosol.coherence.Component get_Instance()
                {
                return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.InvokeAllRequest.Poll();
                }
            
            //++ getter for static property _CLASS
            /**
             * Getter for property _CLASS.<p>
            * Property with auto-generated accessor that returns the Class
            * object for a given component.
             */
            public static Class get_CLASS()
                {
                Class clz;
                try
                    {
                    clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$InvokeAllRequest$Poll".replace('/', '.'));
                    }
                catch (ClassNotFoundException e)
                    {
                    throw new NoClassDefFoundError(e.getMessage());
                    }
                return clz;
                }
            
            //++ getter for autogen property _Module
            /**
             * This is an auto-generated method that returns the global [design
            * time] parent component.
            * 
            * Note: the class generator will ignore any custom implementation
            * for this behavior.
             */
            private com.tangosol.coherence.Component get_Module()
                {
                return this.get_Parent().get_Parent();
                }
            
            // Declared at the super level
            protected void processAsyncResponse(com.tangosol.coherence.component.net.Message msg)
                {
                // import Component.Net.RequestContext.AsyncContext.AsyncProcessorContext;
                // import com.tangosol.net.RequestIncompleteException;
                // import com.tangosol.util.Binary;
                // import com.tangosol.util.ConverterCollections$ConverterSet as com.tangosol.util.ConverterCollections.ConverterSet;
                // import com.tangosol.util.NullImplementation;
                // import java.util.Collection;
                // import java.util.Collections;
                
                PartitionedCache.InvokeAllRequest     msgRequest  = (PartitionedCache.InvokeAllRequest) get_Parent();
                AsyncProcessorContext context     = (AsyncProcessorContext) msgRequest.getRequestContext();
                PartitionedCache.PartialMapResponse   msgResponse = (PartitionedCache.PartialMapResponse) msg;
                
                Throwable t = msgResponse.getException();
                if (t == null)
                    {
                    int      cSize = msgResponse.getSize();
                    Object[] aoKey = msgResponse.getKey();
                    Object[] aoVal = msgResponse.getValue();
                
                    for (int i = 0; i < cSize; i++)
                        {
                        Binary binKey = (Binary) aoKey[i];
                        Binary binVal = (Binary) aoVal[i];
                    
                        if (binKey != null && binVal != null)
                            {
                            context.processPartialResult(binKey, binVal);
                            }
                        }
                    }
                else
                    {
                    RequestIncompleteException e = new RequestIncompleteException("Partial failure", t);
                
                    Collection colFailedKeys = msgResponse.getFailedKeys();
                    if (colFailedKeys == null)
                        {
                        colFailedKeys = Collections.emptyList();
                        }
                    
                    com.tangosol.util.ConverterCollections.ConverterSet setFailedKeys = new com.tangosol.util.ConverterCollections.ConverterSet(colFailedKeys,
                            context.getValueConverter(), NullImplementation.getConverter());
                
                    e.setPartialResult(setFailedKeys);
                
                    context.processPartialResult(null, e);
                    }
                }
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$InvokeFilterRequest
    
    /**
     * @see $BinaryMap#invokeAll(Filter, EntryProcessor)
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class InvokeFilterRequest
            extends    com.tangosol.coherence.component.net.message.requestMessage.distributedCacheRequest.partialRequest.FilterRequest
        {
        // ---- Fields declarations ----
        
        /**
         * Property Processor
         *
         * (Transient) Cached processor reference. It becomes available only
         * after the processor is explicitly deserialized during server side
         * processing of this message.
         * 
         * @see #deserializeProcessor()
         */
        private transient com.tangosol.util.InvocableMap.EntryProcessor __m_Processor;
        
        /**
         * Property ProcessorBinary
         *
         * The binary representation of an EntryProcessor.
         */
        private com.tangosol.util.Binary __m_ProcessorBinary;
        private static com.tangosol.util.ListMap __mapChildren;
        
        // Static initializer
        static
            {
            __initStatic();
            }
        
        // Default static initializer
        private static void __initStatic()
            {
            // register child classes
            __mapChildren = new com.tangosol.util.ListMap();
            __mapChildren.put("Poll", PartitionedCache.InvokeFilterRequest.Poll.get_CLASS());
            }
        
        // Default constructor
        public InvokeFilterRequest()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public InvokeFilterRequest(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                setMessageType(62);
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // containment initialization: children
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        // Getter for virtual constant ReadOnly
        public boolean isReadOnly()
            {
            return false;
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.InvokeFilterRequest();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$InvokeFilterRequest".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        //++ getter for autogen property _ChildClasses
        /**
         * This is an auto-generated method that returns the map of design time
        * [static] children.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        protected java.util.Map get_ChildClasses()
            {
            return __mapChildren;
            }
        
        // Declared at the super level
        /**
         * Instantiate a copy of this message. This is quite different from the
        * standard "clone" since only the "transmittable" portion of the
        * message (and none of the internal) state should be cloned.
         */
        public com.tangosol.coherence.component.net.Message cloneMessage()
            {
            PartitionedCache.InvokeFilterRequest msg = (PartitionedCache.InvokeFilterRequest) super.cloneMessage();
            
            msg.setProcessorBinary(getProcessorBinary());
            msg.setOwnershipVersions(getOwnershipVersions());
            
            return msg;
            }
        
        public com.tangosol.util.InvocableMap.EntryProcessor deserializeProcessor()
            {
            // import com.tangosol.util.InvocableMap$EntryProcessor as com.tangosol.util.InvocableMap.EntryProcessor;
            // import com.tangosol.util.ExternalizableHelper as com.tangosol.util.ExternalizableHelper;
            
            com.tangosol.util.InvocableMap.EntryProcessor processor = getProcessor();
            if (processor == null)
                {
                processor = (com.tangosol.util.InvocableMap.EntryProcessor) com.tangosol.util.ExternalizableHelper.fromBinary(
                    getProcessorBinary(), getService().getSerializer());
                setProcessor(processor);
                }
            return processor;
            }
        
        // Declared at the super level
        /**
         * Getter for property Description.<p>
        * Used for debugging purposes (from toString). Create a human-readable
        * description of the specific Message data.
         */
        public String getDescription()
            {
            return super.getDescription()
                + ", Agent=" + getProcessor() + ", Filter=" + getFilter();
            }
        
        // Accessor for the property "Processor"
        /**
         * Getter for property Processor.<p>
        * (Transient) Cached processor reference. It becomes available only
        * after the processor is explicitly deserialized during server side
        * processing of this message.
        * 
        * @see #deserializeProcessor()
         */
        public com.tangosol.util.InvocableMap.EntryProcessor getProcessor()
            {
            return __m_Processor;
            }
        
        // Accessor for the property "ProcessorBinary"
        /**
         * Getter for property ProcessorBinary.<p>
        * The binary representation of an EntryProcessor.
         */
        public com.tangosol.util.Binary getProcessorBinary()
            {
            return __m_ProcessorBinary;
            }
        
        // Declared at the super level
        public void read(com.tangosol.io.ReadBuffer.BufferInput input)
                throws java.io.IOException
            {
            // import com.tangosol.net.internal.PartitionVersions;
            // import com.tangosol.util.Binary;
            
            super.read(input);
            
            if (getReadException() == null)
                {
                setProcessorBinary((Binary) readObject(input));
            
                if (isAsyncOperation())
                    {
                    PartitionVersions versions = new PartitionVersions();
                    versions.readExternal(input);
                    setOwnershipVersions(versions);
                    }
                }
            
            readTracing(input);
            }
        
        // Declared at the super level
        public void run()
            {
            ((PartitionedCache) getService()).onInvokeFilterRequest(this);
            }
        
        // Accessor for the property "Processor"
        /**
         * Setter for property Processor.<p>
        * (Transient) Cached processor reference. It becomes available only
        * after the processor is explicitly deserialized during server side
        * processing of this message.
        * 
        * @see #deserializeProcessor()
         */
        public void setProcessor(com.tangosol.util.InvocableMap.EntryProcessor processor)
            {
            __m_Processor = processor;
            }
        
        // Accessor for the property "ProcessorBinary"
        /**
         * Setter for property ProcessorBinary.<p>
        * The binary representation of an EntryProcessor.
         */
        public void setProcessorBinary(com.tangosol.util.Binary binProcessor)
            {
            __m_ProcessorBinary = binProcessor;
            }
        
        // Declared at the super level
        /**
         * Setter for property RequestTimeout.<p>
        * Transient property optionally used on the client to indicate the
        * (safe local) time after which this logical request should be
        * considered timed out.
        * 
        * Note that a single logical request message may result in multiple
        * physical request messages being sent to mulitple members; this
        * RequestTimeout value will be cloned to all resulting RequestMessage
        * instances.
        * 
        * This value is lazily calculated by #getRequestTimeout or
        * #calculateTimeoutRemaining.
         */
        public void setRequestTimeout(long ldtTimeout)
            {
            super.setRequestTimeout(ldtTimeout);
            }
        
        // Declared at the super level
        public void write(com.tangosol.io.WriteBuffer.BufferOutput output)
                throws java.io.IOException
            {
            super.write(output);
            
            writeObject(output, getProcessorBinary());
            
            if (isAsyncOperation())
                {
                getOwnershipVersions().writeExternal(output);
                }
            
            writeTracing(output);
            }

        // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$InvokeFilterRequest$Poll
        
        /**
         * The Poll contains information regarding a request sent to one or
         * more Cluster Members that require responses. A Service may poll
         * other Members that are running the same Service, and the Poll is
         * used to wait for and assemble the responses from each of those
         * Members. A client thread may also use the Poll to block on a
         * response or set of responses, thus waiting for the completion of the
         * Poll. In its simplest form, which is a Poll that is sent to one
         * Member of the Cluster, the Poll actually represents the
         * request/response model.
         */
        @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
        public static class Poll
                extends    com.tangosol.coherence.component.net.message.requestMessage.distributedCacheRequest.PartialRequest.Poll
            {
            // ---- Fields declarations ----
            
            // Default constructor
            public Poll()
                {
                this(null, null, true);
                }
            
            // Initializing constructor
            public Poll(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                {
                super(sName, compParent, false);
                
                if (fInit)
                    {
                    __init();
                    }
                }
            
            // Main initializer
            public void __init()
                {
                // private initialization
                __initPrivate();
                
                
                // signal the end of the initialization
                set_Constructed(true);
                }
            
            // Private initializer
            protected void __initPrivate()
                {
                
                super.__initPrivate();
                }
            
            // Getter for virtual constant Preprocessable
            public boolean isPreprocessable()
                {
                return true;
                }
            
            //++ getter for static property _Instance
            /**
             * Getter for property _Instance.<p>
            * Auto generated
             */
            public static com.tangosol.coherence.Component get_Instance()
                {
                return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.InvokeFilterRequest.Poll();
                }
            
            //++ getter for static property _CLASS
            /**
             * Getter for property _CLASS.<p>
            * Property with auto-generated accessor that returns the Class
            * object for a given component.
             */
            public static Class get_CLASS()
                {
                Class clz;
                try
                    {
                    clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$InvokeFilterRequest$Poll".replace('/', '.'));
                    }
                catch (ClassNotFoundException e)
                    {
                    throw new NoClassDefFoundError(e.getMessage());
                    }
                return clz;
                }
            
            //++ getter for autogen property _Module
            /**
             * This is an auto-generated method that returns the global [design
            * time] parent component.
            * 
            * Note: the class generator will ignore any custom implementation
            * for this behavior.
             */
            private com.tangosol.coherence.Component get_Module()
                {
                return this.get_Parent().get_Parent();
                }
            
            // Declared at the super level
            public void processAsyncResponse(com.tangosol.coherence.component.net.Message msg)
                {
                // import Component.Net.RequestContext.AsyncContext.AsyncProcessorContext;
                // import com.tangosol.util.Binary;
                // import java.util.Collection;
                // import java.util.Iterator;
                // import java.util.Map$Entry as java.util.Map.Entry;
                
                PartitionedCache.InvokeFilterRequest  msgRequest  = (PartitionedCache.InvokeFilterRequest) get_Parent();
                AsyncProcessorContext context     = (AsyncProcessorContext) msgRequest.getRequestContext();
                PartitionedCache.QueryResponse        msgResponse = (PartitionedCache.QueryResponse) msg;
                
                if (msgResponse.getException() == null)
                    {
                    int      cSize    = msgResponse.getSize();
                    Object[] aoResult = msgResponse.getResult();
                
                    for (int i = 0; i < cSize; i++)
                        {
                        java.util.Map.Entry entry = (java.util.Map.Entry) aoResult[i];
                
                        context.processPartialResult((Binary) entry.getKey(), (Binary) entry.getValue());
                        }
                    }
                else
                    {
                    context.processPartialResult(null, msgResponse.getException());
                    }
                }
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$InvokeRequest
    
    /**
     * @see $BinaryMap#invoke(Object, EntryProcessor)
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class InvokeRequest
            extends    com.tangosol.coherence.component.net.message.requestMessage.DistributedCacheKeyRequest
        {
        // ---- Fields declarations ----
        
        /**
         * Property OrderId
         *
         * Unit-of-order id for asynchronous agents. This value is zero for
         * synchronous requests.
         * 
         * @see com.tangosol.util.processor.AsynchronousProcessor,
         * com.tangosol.util.aggregator.AsynchronousAggregator
         */
        private long __m_OrderId;
        
        /**
         * Property OwnershipVersion
         *
         * The ownership version of the partition associated with this
         * InvokeRequest (from the client's point of view).
         * 
         * Used for AsyncOperations only.
         */
        private int __m_OwnershipVersion;
        
        /**
         * Property Processor
         *
         * (Transient) Cached processor reference. It becomes available only
         * after the processor is explicitly deserialized during server side
         * processing of this message.
         * 
         * @see #deserializeProcessor()
         */
        private transient com.tangosol.util.InvocableMap.EntryProcessor __m_Processor;
        
        /**
         * Property ProcessorBinary
         *
         * The binary representation of an  EntryProcessor.
         */
        private com.tangosol.util.Binary __m_ProcessorBinary;
        
        /**
         * Property ReadException
         *
         * An Exception that occured during the read() and had to be deferred
         * to be processed during onReceived() and possibly reported back to
         * the client (requestor).
         */
        private transient Exception __m_ReadException;
        private static com.tangosol.util.ListMap __mapChildren;
        
        // Static initializer
        static
            {
            __initStatic();
            }
        
        // Default static initializer
        private static void __initStatic()
            {
            // register child classes
            __mapChildren = new com.tangosol.util.ListMap();
            __mapChildren.put("Poll", PartitionedCache.InvokeRequest.Poll.get_CLASS());
            }
        
        // Default constructor
        public InvokeRequest()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public InvokeRequest(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                setMessageType(63);
                setOwnershipVersion(-1);
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // containment initialization: children
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        // Getter for virtual constant ReadOnly
        public boolean isReadOnly()
            {
            return false;
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.InvokeRequest();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$InvokeRequest".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        //++ getter for autogen property _ChildClasses
        /**
         * This is an auto-generated method that returns the map of design time
        * [static] children.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        protected java.util.Map get_ChildClasses()
            {
            return __mapChildren;
            }
        
        // Declared at the super level
        /**
         * Instantiate a copy of this message. This is quite different from the
        * standard "clone" since only the "transmittable" portion of the
        * message (and none of the internal) state should be cloned.
         */
        public com.tangosol.coherence.component.net.Message cloneMessage()
            {
            PartitionedCache.InvokeRequest msg = (PartitionedCache.InvokeRequest) super.cloneMessage();
            
            msg.setProcessorBinary(getProcessorBinary());
            msg.setOrderId(getOrderId());
            msg.setOwnershipVersion(getOwnershipVersion());
            
            return msg;
            }
        
        public com.tangosol.util.InvocableMap.EntryProcessor deserializeProcessor()
            {
            // import com.tangosol.util.InvocableMap$EntryProcessor as com.tangosol.util.InvocableMap.EntryProcessor;
            // import com.tangosol.util.ExternalizableHelper as com.tangosol.util.ExternalizableHelper;
            
            com.tangosol.util.InvocableMap.EntryProcessor processor = getProcessor();
            if (processor == null)
                {
                processor = (com.tangosol.util.InvocableMap.EntryProcessor) com.tangosol.util.ExternalizableHelper.fromBinary(
                    getProcessorBinary(), getService().getSerializer());
                setProcessor(processor);
                }
            return processor;
            }
        
        // Declared at the super level
        public Object getAssociatedKey()
            {
            long lOrderId = getOrderId();
            
            return lOrderId == 0L ? super.getAssociatedKey() : Long.valueOf(lOrderId);
            }
        
        // Declared at the super level
        /**
         * Getter for property Description.<p>
        * Used for debugging purposes (from toString). Create a human-readable
        * description of the specific Message data.
         */
        public String getDescription()
            {
            return super.getDescription() + ", Agent=" + getProcessor();
            }
        
        // Declared at the super level
        /**
         * Getter for property EstimatedByteSize.<p>
        * The estimated serialized size of this message.  A negative value
        * indicates that the size is unknown and that it is safe to estimate
        * the size via a double serialization.
         */
        public int getEstimatedByteSize()
            {
            return -1;
            }
        
        // Accessor for the property "OrderId"
        /**
         * Getter for property OrderId.<p>
        * Unit-of-order id for asynchronous agents. This value is zero for
        * synchronous requests.
        * 
        * @see com.tangosol.util.processor.AsynchronousProcessor,
        * com.tangosol.util.aggregator.AsynchronousAggregator
         */
        public long getOrderId()
            {
            return __m_OrderId;
            }
        
        // Accessor for the property "OwnershipVersion"
        /**
         * Getter for property OwnershipVersion.<p>
        * The ownership version of the partition associated with this
        * InvokeRequest (from the client's point of view).
        * 
        * Used for AsyncOperations only.
         */
        public int getOwnershipVersion()
            {
            return __m_OwnershipVersion;
            }
        
        // Accessor for the property "Processor"
        /**
         * Getter for property Processor.<p>
        * (Transient) Cached processor reference. It becomes available only
        * after the processor is explicitly deserialized during server side
        * processing of this message.
        * 
        * @see #deserializeProcessor()
         */
        public com.tangosol.util.InvocableMap.EntryProcessor getProcessor()
            {
            return __m_Processor;
            }
        
        // Accessor for the property "ProcessorBinary"
        /**
         * Getter for property ProcessorBinary.<p>
        * The binary representation of an  EntryProcessor.
         */
        public com.tangosol.util.Binary getProcessorBinary()
            {
            return __m_ProcessorBinary;
            }
        
        // Accessor for the property "ReadException"
        /**
         * Getter for property ReadException.<p>
        * An Exception that occured during the read() and had to be deferred to
        * be processed during onReceived() and possibly reported back to the
        * client (requestor).
         */
        public Exception getReadException()
            {
            return __m_ReadException;
            }
        
        // Accessor for the property "AsyncOperation"
        /**
         * Getter for property AsyncOperation.<p>
        * Calculated property inidicating whether or not this message
        * represents an asycnhronous operation.
         */
        public boolean isAsyncOperation()
            {
            return getOrderId() != 0;
            }
        
        // Declared at the super level
        /**
         * Asynchronously send this message.  The actual transmission of the
        * message may be deferred due to the send queue batching.
        * This method should not be called directly; see Grid#post(Message).
         */
        public void post()
            {
            if (isAsyncOperation())
                {
                // stamp async requests with the client's view of the ownership version
                PartitionedCache service = (PartitionedCache) getService();
                setOwnershipVersion(service.getOwnershipVersion(service.getKeyPartition(getKey())));
                }
            
            super.post();
            }
        
        // Declared at the super level
        public void read(com.tangosol.io.ReadBuffer.BufferInput input)
                throws java.io.IOException
            {
            // import com.tangosol.util.Binary;
            // import com.tangosol.util.ExternalizableHelper;
            
            super.read(input);
            
            setProcessorBinary((Binary) readObject(input));
            setOrderId(ExternalizableHelper.readLong(input));
            
            if (isAsyncOperation())
                {
                setOwnershipVersion(ExternalizableHelper.readInt(input));
                }
            
            readTracing(input);
            }
        
        // Declared at the super level
        public void run()
            {
            ((PartitionedCache) getService()).onInvokeRequest(this);
            }
        
        // Accessor for the property "OrderId"
        /**
         * Setter for property OrderId.<p>
        * Unit-of-order id for asynchronous agents. This value is zero for
        * synchronous requests.
        * 
        * @see com.tangosol.util.processor.AsynchronousProcessor,
        * com.tangosol.util.aggregator.AsynchronousAggregator
         */
        public void setOrderId(long lId)
            {
            __m_OrderId = lId;
            }
        
        // Accessor for the property "OwnershipVersion"
        /**
         * Setter for property OwnershipVersion.<p>
        * The ownership version of the partition associated with this
        * InvokeRequest (from the client's point of view).
        * 
        * Used for AsyncOperations only.
         */
        public void setOwnershipVersion(int nVersion)
            {
            __m_OwnershipVersion = nVersion;
            }
        
        // Accessor for the property "Processor"
        /**
         * Setter for property Processor.<p>
        * (Transient) Cached processor reference. It becomes available only
        * after the processor is explicitly deserialized during server side
        * processing of this message.
        * 
        * @see #deserializeProcessor()
         */
        public void setProcessor(com.tangosol.util.InvocableMap.EntryProcessor agent)
            {
            __m_Processor = agent;
            }
        
        // Accessor for the property "ProcessorBinary"
        /**
         * Setter for property ProcessorBinary.<p>
        * The binary representation of an  EntryProcessor.
         */
        public void setProcessorBinary(com.tangosol.util.Binary binProcessor)
            {
            __m_ProcessorBinary = binProcessor;
            }
        
        // Accessor for the property "ReadException"
        /**
         * Setter for property ReadException.<p>
        * An Exception that occured during the read() and had to be deferred to
        * be processed during onReceived() and possibly reported back to the
        * client (requestor).
         */
        public void setReadException(Exception exception)
            {
            __m_ReadException = exception;
            }
        
        // Declared at the super level
        /**
         * Setter for property RequestTimeout.<p>
        * Transient property optionally used on the client to indicate the
        * (safe local) time after which this logical request should be
        * considered timed out.
        * 
        * Note that a single logical request message may result in multiple
        * physical request messages being sent to mulitple members; this
        * RequestTimeout value will be cloned to all resulting RequestMessage
        * instances.
        * 
        * This value is lazily calculated by #getRequestTimeout or
        * #calculateTimeoutRemaining.
         */
        public void setRequestTimeout(long ldtTimeout)
            {
            super.setRequestTimeout(ldtTimeout);
            }
        
        // Declared at the super level
        public void write(com.tangosol.io.WriteBuffer.BufferOutput output)
                throws java.io.IOException
            {
            // import com.tangosol.util.ExternalizableHelper;
            
            super.write(output);
            
            writeObject(output, getProcessorBinary());
            ExternalizableHelper.writeLong(output, getOrderId());
            
            if (isAsyncOperation())
                {
                ExternalizableHelper.writeInt(output, getOwnershipVersion());
                }
            
            writeTracing(output);
            }

        // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$InvokeRequest$Poll
        
        /**
         * The Poll contains information regarding a request sent to one or
         * more Cluster Members that require responses. A Service may poll
         * other Members that are running the same Service, and the Poll is
         * used to wait for and assemble the responses from each of those
         * Members. A client thread may also use the Poll to block on a
         * response or set of responses, thus waiting for the completion of the
         * Poll. In its simplest form, which is a Poll that is sent to one
         * Member of the Cluster, the Poll actually represents the
         * request/response model.
         */
        @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
        public static class Poll
                extends    com.tangosol.coherence.component.net.message.requestMessage.DistributedCacheKeyRequest.Poll
            {
            // ---- Fields declarations ----
            
            // Default constructor
            public Poll()
                {
                this(null, null, true);
                }
            
            // Initializing constructor
            public Poll(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                {
                super(sName, compParent, false);
                
                if (fInit)
                    {
                    __init();
                    }
                }
            
            // Main initializer
            public void __init()
                {
                // private initialization
                __initPrivate();
                
                
                // signal the end of the initialization
                set_Constructed(true);
                }
            
            // Private initializer
            protected void __initPrivate()
                {
                
                super.__initPrivate();
                }
            
            // Getter for virtual constant Preprocessable
            public boolean isPreprocessable()
                {
                return true;
                }
            
            //++ getter for static property _Instance
            /**
             * Getter for property _Instance.<p>
            * Auto generated
             */
            public static com.tangosol.coherence.Component get_Instance()
                {
                return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.InvokeRequest.Poll();
                }
            
            //++ getter for static property _CLASS
            /**
             * Getter for property _CLASS.<p>
            * Property with auto-generated accessor that returns the Class
            * object for a given component.
             */
            public static Class get_CLASS()
                {
                Class clz;
                try
                    {
                    clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$InvokeRequest$Poll".replace('/', '.'));
                    }
                catch (ClassNotFoundException e)
                    {
                    throw new NoClassDefFoundError(e.getMessage());
                    }
                return clz;
                }
            
            //++ getter for autogen property _Module
            /**
             * This is an auto-generated method that returns the global [design
            * time] parent component.
            * 
            * Note: the class generator will ignore any custom implementation
            * for this behavior.
             */
            private com.tangosol.coherence.Component get_Module()
                {
                return this.get_Parent().get_Parent();
                }
            
            // Declared at the super level
            /**
             * This is the event that is executed when all the Members that were
            * polled have responded or have left the Service.
             */
            protected void onCompletion()
                {
                // import Component.Net.RequestContext.AsyncContext.AsyncProcessorContext;
                // import com.tangosol.util.Binary;
                
                super.onCompletion();
                
                PartitionedCache.InvokeRequest msgRequest = (PartitionedCache.InvokeRequest) get_Parent();
                
                if (msgRequest.isAsyncOperation())
                    {
                    // this is an async processor request
                    PartitionedCache service = (PartitionedCache) getService();
                
                    PartitionedCache.RequestCoordinator coordinator = service.getRequestCoordinator();
                    Binary              binKey      = msgRequest.getKey();
                    int                 nPartition  = service.getKeyPartition(binKey);
                
                    Object oResult = getResult();
                    if (oResult == PartitionedCache.InvokeRequest.RESPONSE_UNKNOWN)
                        {
                        // Note1: we must run this logic (to create a new message and call submit()
                        //        even if the service has stopped, as it is our only mechanism to
                        //        unblock a potentially waiting client
                        // Note2: resubmit may not throw; any exceptions are reported via the context
                        // Note3: account for responded partitions to avoid "missing" a resend

                        MemberSet setMembers = getRespondedMemberSet();
                        if (!coordinator.resubmitRequest((PartitionedCache.InvokeRequest) msgRequest.cloneMessage(),
                                nPartition, /*fUpdatePart*/!setMembers.isEmpty() &&
                                                           !setMembers.contains(service.getPrimaryOwner(nPartition))))
                            {
                            // an exception has already been raised;
                            ((AsyncProcessorContext) msgRequest.getRequestContext()).processCompletion();
                            }
                        // this is either the service or a transport thread; no need to flush
                        }
                    else
                        {
                        ((AsyncProcessorContext) msgRequest.getRequestContext()).processSingleResult(binKey, oResult);
                        }
                
                    // finalize the response only after resubmitting a rejected request (COH-10351)
                    coordinator.finalizeResponse(nPartition);
                    }
                }
            
            // Declared at the super level
            /**
             * This is the event that occurs when the RequestMessage associated
            * with this poll failed in post()
             */
            public void onException(Throwable eReason)
                {
                // import Component.Net.RequestContext.AsyncContext.AsyncProcessorContext;
                
                PartitionedCache.InvokeRequest msgRequest = (PartitionedCache.InvokeRequest) get_Parent();
                if (msgRequest.isAsyncOperation())
                    {
                    AsyncProcessorContext context = (AsyncProcessorContext) msgRequest.getRequestContext();
                    context.processException(eReason);
                    }
                }
            
            // Declared at the super level
            /**
             * Preprocess the response to this Poll.
            * 
            * @return true iff the response message has been fully processed
            * (onMessage was called)
             */
            public boolean preprocessResponse(com.tangosol.coherence.component.net.Message msgResponse)
                {
                PartitionedCache.InvokeRequest msgRequest = (PartitionedCache.InvokeRequest) get_Parent();
                
                // for asynchronous operations, onCompletion() logic may call into user's methods
                // and is not a good fit for preprocessing
                return !msgRequest.isAsyncOperation()
                    && super.preprocessResponse(msgResponse);
                }
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$KeyIteratorRequest
    
    /**
     * @see $BinaryMap$KeySet$Iterator#instantiateMemberIterator
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class KeyIteratorRequest
            extends    com.tangosol.coherence.component.net.message.requestMessage.distributedCacheRequest.PartialRequest
        {
        // ---- Fields declarations ----
        private static com.tangosol.util.ListMap __mapChildren;
        
        // Static initializer
        static
            {
            __initStatic();
            }
        
        // Default static initializer
        private static void __initStatic()
            {
            // register child classes
            __mapChildren = new com.tangosol.util.ListMap();
            __mapChildren.put("Poll", PartitionedCache.KeyIteratorRequest.Poll.get_CLASS());
            }
        
        // Default constructor
        public KeyIteratorRequest()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public KeyIteratorRequest(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                setMessageType(64);
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // containment initialization: children
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.KeyIteratorRequest();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$KeyIteratorRequest".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        //++ getter for autogen property _ChildClasses
        /**
         * This is an auto-generated method that returns the map of design time
        * [static] children.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        protected java.util.Map get_ChildClasses()
            {
            return __mapChildren;
            }
        
        // Declared at the super level
        public void run()
            {
            ((PartitionedCache) getService()).onKeyIteratorRequest(this);
            }
        
        // Declared at the super level
        /**
         * Setter for property RequestTimeout.<p>
        * Transient property optionally used on the client to indicate the
        * (safe local) time after which this logical request should be
        * considered timed out.
        * 
        * Note that a single logical request message may result in multiple
        * physical request messages being sent to mulitple members; this
        * RequestTimeout value will be cloned to all resulting RequestMessage
        * instances.
        * 
        * This value is lazily calculated by #getRequestTimeout or
        * #calculateTimeoutRemaining.
         */
        public void setRequestTimeout(long ldtTimeout)
            {
            super.setRequestTimeout(ldtTimeout);
            }

        // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$KeyIteratorRequest$Poll
        
        /**
         * The Poll contains information regarding a request sent to one or
         * more Cluster Members that require responses. A Service may poll
         * other Members that are running the same Service, and the Poll is
         * used to wait for and assemble the responses from each of those
         * Members. A client thread may also use the Poll to block on a
         * response or set of responses, thus waiting for the completion of the
         * Poll. In its simplest form, which is a Poll that is sent to one
         * Member of the Cluster, the Poll actually represents the
         * request/response model.
         */
        @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
        public static class Poll
                extends    com.tangosol.coherence.component.net.message.requestMessage.distributedCacheRequest.PartialRequest.Poll
            {
            // ---- Fields declarations ----
            
            // Default constructor
            public Poll()
                {
                this(null, null, true);
                }
            
            // Initializing constructor
            public Poll(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                {
                super(sName, compParent, false);
                
                if (fInit)
                    {
                    __init();
                    }
                }
            
            // Main initializer
            public void __init()
                {
                // private initialization
                __initPrivate();
                
                
                // signal the end of the initialization
                set_Constructed(true);
                }
            
            // Private initializer
            protected void __initPrivate()
                {
                
                super.__initPrivate();
                }
            
            // Getter for virtual constant Preprocessable
            public boolean isPreprocessable()
                {
                return true;
                }
            
            //++ getter for static property _Instance
            /**
             * Getter for property _Instance.<p>
            * Auto generated
             */
            public static com.tangosol.coherence.Component get_Instance()
                {
                return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.KeyIteratorRequest.Poll();
                }
            
            //++ getter for static property _CLASS
            /**
             * Getter for property _CLASS.<p>
            * Property with auto-generated accessor that returns the Class
            * object for a given component.
             */
            public static Class get_CLASS()
                {
                Class clz;
                try
                    {
                    clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$KeyIteratorRequest$Poll".replace('/', '.'));
                    }
                catch (ClassNotFoundException e)
                    {
                    throw new NoClassDefFoundError(e.getMessage());
                    }
                return clz;
                }
            
            //++ getter for autogen property _Module
            /**
             * This is an auto-generated method that returns the global [design
            * time] parent component.
            * 
            * Note: the class generator will ignore any custom implementation
            * for this behavior.
             */
            private com.tangosol.coherence.Component get_Module()
                {
                return this.get_Parent().get_Parent();
                }
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$KeyListenerAllRequest
    
    /**
     * DistributeCacheRequest is a base component for RequestMessage(s) used by
     * the partitioned cache service that are key set or filter based. Quite
     * often a collection of similar requests are sent in parallel and a client
     * thread has to wait for all of them to return.
     * 
     * KeySetRequest is a DistributeCacheRequest that is sent to one storage
     * enabled Member that presumably owns the specified keys.
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class KeyListenerAllRequest
            extends    com.tangosol.coherence.component.net.message.requestMessage.distributedCacheRequest.KeySetRequest
        {
        // ---- Fields declarations ----
        
        /**
         * Property Add
         *
         */
        private boolean __m_Add;
        
        /**
         * Property Lite
         *
         */
        private boolean __m_Lite;
        
        /**
         * Property MemberId
         *
         */
        private int __m_MemberId;
        
        /**
         * Property PartitionVersions
         *
         */
        private com.tangosol.net.partition.VersionedPartitions __m_PartitionVersions;
        
        /**
         * Property Priming
         *
         */
        private boolean __m_Priming;
        private static com.tangosol.util.ListMap __mapChildren;
        
        // Static initializer
        static
            {
            __initStatic();
            }
        
        // Default static initializer
        private static void __initStatic()
            {
            // register child classes
            __mapChildren = new com.tangosol.util.ListMap();
            __mapChildren.put("KeyListenerJob", PartitionedCache.KeyListenerAllRequest.KeyListenerJob.get_CLASS());
            __mapChildren.put("Poll", PartitionedCache.KeyListenerAllRequest.Poll.get_CLASS());
            }
        
        // Default constructor
        public KeyListenerAllRequest()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public KeyListenerAllRequest(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                setMessageType(85);
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // containment initialization: children
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.KeyListenerAllRequest();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$KeyListenerAllRequest".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        //++ getter for autogen property _ChildClasses
        /**
         * This is an auto-generated method that returns the map of design time
        * [static] children.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        protected java.util.Map get_ChildClasses()
            {
            return __mapChildren;
            }
        
        // Declared at the super level
        /**
         * Instantiate a copy of this message. This is quite different from the
        * standard "clone" since only the "transmittable" portion of the
        * message (and none of the internal) state should be cloned.
         */
        public com.tangosol.coherence.component.net.Message cloneMessage()
            {
            PartitionedCache.KeyListenerAllRequest msg = (PartitionedCache.KeyListenerAllRequest) super.cloneMessage();
            
            msg.setAdd(isAdd());
            msg.setLite(isLite());
            msg.setPriming(isPriming());
            msg.setMemberId(getMemberId());
            
            return msg;
            }
        
        // Accessor for the property "MemberId"
        /**
         * Getter for property MemberId.<p>
         */
        public int getMemberId()
            {
            return __m_MemberId;
            }
        
        // Accessor for the property "PartitionVersions"
        /**
         * Getter for property PartitionVersions.<p>
         */
        public com.tangosol.net.partition.VersionedPartitions getPartitionVersions()
            {
            return __m_PartitionVersions;
            }
        
        // Declared at the super level
        protected java.util.Set instantiateKeySet(int cKeys)
            {
            // import java.util.Collections;
            
            return ((PartitionedCache) get_Module()).isConcurrent()
                ? Collections.newSetFromMap(new NullableSortedMap())
                : super.instantiateKeySet(cKeys);
            }
        
        // Accessor for the property "Add"
        /**
         * Getter for property Add.<p>
         */
        public boolean isAdd()
            {
            return __m_Add;
            }
        
        // Accessor for the property "Lite"
        /**
         * Getter for property Lite.<p>
         */
        public boolean isLite()
            {
            return __m_Lite;
            }
        
        // Accessor for the property "Priming"
        /**
         * Getter for property Priming.<p>
         */
        public boolean isPriming()
            {
            return __m_Priming;
            }
        
        // Declared at the super level
        /**
         * This is the event that is executed when a Message is received.
        * <p>
        * It is the main processing event of the Message called by the
        * <code>Service.onMessage()</code> event. With regards to the use of
        * Message components within clustered Services, Services are designed
        * by dragging Message components into them as static children. These
        * Messages are the components that a Service can send to other running
        * instances of the same Service within a cluster. When the onReceived
        * event is invoked by a Service, it means that the Message has been
        * received; the code in the onReceived event is therefore the Message
        * specific logic for processing a received Message. For example, when
        * onReceived is invoked on a Message named FindData, the onReceived
        * event should do the work to "find the data", because it is being
        * invoked by the Service that received the "find the data" Message.
         */
        public void onReceived()
            {
            // in 12.2.1, we do not support async KeyListenerAllRequests
            if (((PartitionedCache) getService()).getDaemonPool().getDaemonCount() > 0)
                {
                scheduleJobs();
                }
            else
                {
                super.onReceived();
                }
            }
        
        // Declared at the super level
        public void read(com.tangosol.io.ReadBuffer.BufferInput input)
                throws java.io.IOException
            {
            // import com.tangosol.net.partition.VersionedPartitions;
            
            super.read(input);
            
            setAdd(input.readBoolean());
            setLite(input.readBoolean());
            setPriming(input.readBoolean());
            setMemberId(input.readUnsignedShort());
            
            readTracing(input);
            
            if (input.available() > 0)
                {
                // if we still have more bytes to read it must be PartitionVersions
                setPartitionVersions((VersionedPartitions) readObject(input));
                }
            }
        
        // Declared at the super level
        public void run()
            {
            ((PartitionedCache) getService()).onKeyListenerAllRequest(this);
            }
        
        public void scheduleJobs()
            {
            // import Component.Net.Member as com.tangosol.coherence.component.net.Member;
            // import Component.Net.RequestContext as com.tangosol.coherence.component.net.RequestContext;
            // import Component.Util.DaemonPool as com.tangosol.coherence.component.util.DaemonPool;
            // import com.tangosol.net.partition.VersionAwareMapListener;
            // import com.tangosol.net.partition.VersionedPartitions;
            // import com.tangosol.util.Binary;
            // import com.tangosol.util.LongArray;
            // import com.tangosol.util.SparseArray;
            // import java.util.Iterator;
            // import java.util.Map;
            // import java.util.Set;
            
            PartitionedCache    service = (PartitionedCache) getService();
            com.tangosol.coherence.component.util.DaemonPool pool    = service.getDaemonPool();
            Set        setKeys = getKeySetSafe();
            int        cKeys   = setKeys.size();
            
            PartitionedCache.PartialMapResponse msgResponse = (PartitionedCache.PartialMapResponse)
                service.instantiateMessage("PartialMapResponse");
            msgResponse.respondTo(this);
            
            // Note 1: job processing MUST not modify the state of this RemoveAllRequest 
            //         message and the safest way is to new the PartitionedCache.KeyListenerAllRequest.KeyListenerJob object explicitly
            // Note 2: job processors MUST synchronize on the msgResponse for any modifications
            
            long          lCacheId = getCacheId();
            PartitionedCache.BatchContext ctxBatch = service.instantiateBatchContext(msgResponse);
            com.tangosol.coherence.component.net.RequestContext       context  = getRequestContext();
            boolean       fAdd     = isAdd();
            boolean       fLite    = isLite();
            boolean       fPriming = isPriming();
            boolean       fAsync   = isAsyncOperation();
            com.tangosol.coherence.component.net.Member        member   = getFromMember();
            
            VersionedPartitions versions = getPartitionVersions();
            
            // split up into individual jobs; one job per partition
            LongArray laJob = new SparseArray();
            for (Iterator iter = setKeys.iterator(); iter.hasNext();)
                {
                Binary          binKey     = (Binary) iter.next();
                int             iPartition = service.getKeyPartition(binKey);
                PartitionedCache.KeyListenerAllRequest.KeyListenerJob job        = (PartitionedCache.KeyListenerAllRequest.KeyListenerJob) laJob.get(iPartition);
            
                if (job == null)
                    {
                    job = new PartitionedCache.KeyListenerAllRequest.KeyListenerJob();
                    job.setBatchContext(ctxBatch);
                    job.setRequest(this);
                    job.setPartition(iPartition);
                    job.setService(service);
                    job.setRequestContext(context);
                    job.setAdd(fAdd);
                    job.setLite(fLite);
                    job.setFromMember(member);
                    job.setPriming(fPriming);
            
                    if (versions != null)
                        {
                        job.setPartitionVersion(versions.getVersion(iPartition));
                        }
            
                    laJob.set(iPartition, job);
                    }
            
                job.getMap().put(binKey, null);
                }
            
            ctxBatch.getOutstandingOperationCounter().set(laJob.getSize());
            
            for (Iterator iter = laJob.iterator(); iter.hasNext();)
                {
                pool.add((Runnable) iter.next());
                }
            }
        
        // Accessor for the property "Add"
        /**
         * Setter for property Add.<p>
         */
        public void setAdd(boolean fAdd)
            {
            __m_Add = fAdd;
            }
        
        // Accessor for the property "Lite"
        /**
         * Setter for property Lite.<p>
         */
        public void setLite(boolean fLite)
            {
            __m_Lite = fLite;
            }
        
        // Accessor for the property "MemberId"
        /**
         * Setter for property MemberId.<p>
         */
        public void setMemberId(int nId)
            {
            __m_MemberId = nId;
            }
        
        // Accessor for the property "PartitionVersions"
        /**
         * Setter for property PartitionVersions.<p>
         */
        public void setPartitionVersions(com.tangosol.net.partition.VersionedPartitions version)
            {
            __m_PartitionVersions = version;
            }
        
        // Accessor for the property "Priming"
        /**
         * Setter for property Priming.<p>
         */
        public void setPriming(boolean fPriming)
            {
            __m_Priming = fPriming;
            }
        
        // Declared at the super level
        public void write(com.tangosol.io.WriteBuffer.BufferOutput output)
                throws java.io.IOException
            {
            super.write(output);
            
            output.writeBoolean(isAdd());
            output.writeBoolean(isLite());
            output.writeBoolean(isPriming());
            output.writeShort(getMemberId());
            
            writeTracing(output);
            
            writeObject(output, getPartitionVersions());
            }

        // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$KeyListenerAllRequest$KeyListenerJob
        
        /**
         * PartialJob represents a segment of a DistributedCacheRequest that
         * contains keys (entries) that belong to the same partition (bucket).
         * It assumes to belong to (contained by) a DistributedRequestMessage.
         */
        @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
        public static class KeyListenerJob
                extends    com.tangosol.coherence.component.util.PartialJob
            {
            // ---- Fields declarations ----
            
            /**
             * Property Add
             *
             */
            private boolean __m_Add;
            
            /**
             * Property AsyncOperation
             *
             */
            private boolean __m_AsyncOperation;
            
            /**
             * Property FromMember
             *
             */
            private com.tangosol.coherence.component.net.Member __m_FromMember;
            
            /**
             * Property Lite
             *
             */
            private boolean __m_Lite;
            
            /**
             * Property Map
             *
             */
            private java.util.Map __m_Map;
            
            /**
             * Property MemberId
             *
             */
            private int __m_MemberId;
            
            /**
             * Property PartitionVersion
             *
             * The partition version this listener request events from.
             * 
             * Defaults to Long.MIN_VALUE.
             */
            private long __m_PartitionVersion;
            
            /**
             * Property Priming
             *
             */
            private boolean __m_Priming;
            
            /**
             * Property Service
             *
             */
            private com.tangosol.coherence.component.util.daemon.queueProcessor.service.Grid __m_Service;
            
            // Default constructor
            public KeyListenerJob()
                {
                this(null, null, true);
                }
            
            // Initializing constructor
            public KeyListenerJob(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                {
                super(sName, compParent, false);
                
                if (fInit)
                    {
                    __init();
                    }
                }
            
            // Main initializer
            public void __init()
                {
                // private initialization
                __initPrivate();
                
                // state initialization: public and protected properties
                try
                    {
                    setMap(new NullableSortedMap());
                    setPartitionVersion(-9223372036854775808L);
                    }
                catch (java.lang.Exception e)
                    {
                    // re-throw as a runtime exception
                    throw new com.tangosol.util.WrapperException(e);
                    }
                
                // signal the end of the initialization
                set_Constructed(true);
                }
            
            // Private initializer
            protected void __initPrivate()
                {
                
                super.__initPrivate();
                }
            
            //++ getter for static property _Instance
            /**
             * Getter for property _Instance.<p>
            * Auto generated
             */
            public static com.tangosol.coherence.Component get_Instance()
                {
                return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.KeyListenerAllRequest.KeyListenerJob();
                }
            
            //++ getter for static property _CLASS
            /**
             * Getter for property _CLASS.<p>
            * Property with auto-generated accessor that returns the Class
            * object for a given component.
             */
            public static Class get_CLASS()
                {
                Class clz;
                try
                    {
                    clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$KeyListenerAllRequest$KeyListenerJob".replace('/', '.'));
                    }
                catch (ClassNotFoundException e)
                    {
                    throw new NoClassDefFoundError(e.getMessage());
                    }
                return clz;
                }
            
            //++ getter for autogen property _Module
            /**
             * This is an auto-generated method that returns the global [design
            * time] parent component.
            * 
            * Note: the class generator will ignore any custom implementation
            * for this behavior.
             */
            private com.tangosol.coherence.Component get_Module()
                {
                return this.get_Parent().get_Parent();
                }
            
            // Declared at the super level
            public boolean equals(Object obj)
                {
                // import Component.Util.Daemon.QueueProcessor.Service.Grid;
                // import com.tangosol.util.Base;
                
                // this implementation is used to associate non-commutative requests;
                // it is intentionally agnostic about the request specifics
                // (see comments to getAssociatedKey() implementation)
                
                // Note: we associate by cache and partition to ensure ordering of KeyListener
                //       and KeyListenerAll requests emanating from the same client
                
                Grid service    = null;
                long lCacheId   = 0L;
                int  nPartition = -1;
                
                if (obj instanceof PartitionedCache.KeyListenerRequest)
                    {
                    PartitionedCache.KeyListenerRequest that = (PartitionedCache.KeyListenerRequest) obj;
                
                    service    = that.getService();
                    lCacheId   = that.getCacheId();
                    nPartition = that.getPartition();
                    }
                else if (obj instanceof PartitionedCache.KeyListenerAllRequest.KeyListenerJob)
                    {
                    PartitionedCache.KeyListenerAllRequest.KeyListenerJob that = (PartitionedCache.KeyListenerAllRequest.KeyListenerJob) obj;
                
                    service    = that.getService();
                    lCacheId   = that.getCacheId();
                    nPartition = that.getPartition();
                    }
                
                return this.getService()   == service
                    && this.getCacheId()   == lCacheId
                    && this.getPartition() == nPartition;
                }
            
            // Declared at the super level
            public Object getAssociatedKey()
                {
                return this;
                }
            
            // Accessor for the property "FromMember"
            /**
             * Getter for property FromMember.<p>
             */
            public com.tangosol.coherence.component.net.Member getFromMember()
                {
                return __m_FromMember;
                }
            
            // Accessor for the property "Map"
            /**
             * Getter for property Map.<p>
             */
            public java.util.Map getMap()
                {
                return __m_Map;
                }
            
            // Accessor for the property "MemberId"
            /**
             * Getter for property MemberId.<p>
             */
            public int getMemberId()
                {
                return __m_MemberId;
                }
            
            // Accessor for the property "PartitionVersion"
            /**
             * Getter for property PartitionVersion.<p>
            * The partition version this listener request events from.
            * 
            * Defaults to Long.MIN_VALUE.
             */
            public long getPartitionVersion()
                {
                return __m_PartitionVersion;
                }
            
            // Accessor for the property "Service"
            /**
             * Getter for property Service.<p>
             */
            public com.tangosol.coherence.component.util.daemon.queueProcessor.service.Grid getService()
                {
                return __m_Service;
                }
            
            // Declared at the super level
            public int hashCode()
                {
                // import com.tangosol.util.HashHelper;
                
                // this implementation is used to associate non-commutative requests;
                // it is intentionally agnostic about the request specifics
                // (see comments to getAssociatedKey() implementation)
                
                // Note: we associate by cache and partition to ensure ordering of KeyListener
                //       and KeyListenerAll requests emanating from the same client
                
                return HashHelper.hash(getCacheId(), getPartition());
                }
            
            // Accessor for the property "Add"
            /**
             * Getter for property Add.<p>
             */
            public boolean isAdd()
                {
                return __m_Add;
                }
            
            // Accessor for the property "AsyncOperation"
            /**
             * Getter for property AsyncOperation.<p>
             */
            public boolean isAsyncOperation()
                {
                return __m_AsyncOperation;
                }
            
            // Accessor for the property "Lite"
            /**
             * Getter for property Lite.<p>
             */
            public boolean isLite()
                {
                return __m_Lite;
                }
            
            // Accessor for the property "Priming"
            /**
             * Getter for property Priming.<p>
             */
            public boolean isPriming()
                {
                return __m_Priming;
                }
            
            // Accessor for the property "Versioned"
            /**
             * Getter for property Versioned.<p>
             */
            public boolean isVersioned()
                {
                return getPartitionVersion() != PartitionedCache.KeyListenerRequest.NOT_VERSIONED;
                }
            
            // Declared at the super level
            public void run()
                {
                ((PartitionedCache) getResponse().getService()).onKeyListenerAllRequest(this);
                }
            
            // Accessor for the property "Add"
            /**
             * Setter for property Add.<p>
             */
            public void setAdd(boolean fAdd)
                {
                __m_Add = fAdd;
                }
            
            // Accessor for the property "AsyncOperation"
            /**
             * Setter for property AsyncOperation.<p>
             */
            public void setAsyncOperation(boolean fOperation)
                {
                __m_AsyncOperation = fOperation;
                }
            
            // Accessor for the property "FromMember"
            /**
             * Setter for property FromMember.<p>
             */
            public void setFromMember(com.tangosol.coherence.component.net.Member memberFrom)
                {
                __m_FromMember = memberFrom;
                }
            
            // Accessor for the property "Lite"
            /**
             * Setter for property Lite.<p>
             */
            public void setLite(boolean fLite)
                {
                __m_Lite = fLite;
                }
            
            // Accessor for the property "Map"
            /**
             * Setter for property Map.<p>
             */
            public void setMap(java.util.Map map)
                {
                __m_Map = map;
                }
            
            // Accessor for the property "MemberId"
            /**
             * Setter for property MemberId.<p>
             */
            public void setMemberId(int nId)
                {
                __m_MemberId = nId;
                }
            
            // Accessor for the property "PartitionVersion"
            /**
             * Setter for property PartitionVersion.<p>
            * The partition version this listener request events from.
            * 
            * Defaults to Long.MIN_VALUE.
             */
            public void setPartitionVersion(long lVersion)
                {
                __m_PartitionVersion = lVersion;
                }
            
            // Accessor for the property "Priming"
            /**
             * Setter for property Priming.<p>
             */
            public void setPriming(boolean fPriming)
                {
                __m_Priming = fPriming;
                }
            
            // Accessor for the property "Service"
            /**
             * Setter for property Service.<p>
             */
            public void setService(com.tangosol.coherence.component.util.daemon.queueProcessor.service.Grid gridService)
                {
                __m_Service = gridService;
                }
            }

        // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$KeyListenerAllRequest$Poll
        
        /**
         * The Poll contains information regarding a request sent to one or
         * more Cluster Members that require responses. A Service may poll
         * other Members that are running the same Service, and the Poll is
         * used to wait for and assemble the responses from each of those
         * Members. A client thread may also use the Poll to block on a
         * response or set of responses, thus waiting for the completion of the
         * Poll. In its simplest form, which is a Poll that is sent to one
         * Member of the Cluster, the Poll actually represents the
         * request/response model.
         */
        @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
        public static class Poll
                extends    com.tangosol.coherence.component.net.message.requestMessage.distributedCacheRequest.KeySetRequest.Poll
            {
            // ---- Fields declarations ----
            
            // Default constructor
            public Poll()
                {
                this(null, null, true);
                }
            
            // Initializing constructor
            public Poll(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                {
                super(sName, compParent, false);
                
                if (fInit)
                    {
                    __init();
                    }
                }
            
            // Main initializer
            public void __init()
                {
                // private initialization
                __initPrivate();
                
                
                // signal the end of the initialization
                set_Constructed(true);
                }
            
            // Private initializer
            protected void __initPrivate()
                {
                
                super.__initPrivate();
                }
            
            //++ getter for static property _Instance
            /**
             * Getter for property _Instance.<p>
            * Auto generated
             */
            public static com.tangosol.coherence.Component get_Instance()
                {
                return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.KeyListenerAllRequest.Poll();
                }
            
            //++ getter for static property _CLASS
            /**
             * Getter for property _CLASS.<p>
            * Property with auto-generated accessor that returns the Class
            * object for a given component.
             */
            public static Class get_CLASS()
                {
                Class clz;
                try
                    {
                    clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$KeyListenerAllRequest$Poll".replace('/', '.'));
                    }
                catch (ClassNotFoundException e)
                    {
                    throw new NoClassDefFoundError(e.getMessage());
                    }
                return clz;
                }
            
            //++ getter for autogen property _Module
            /**
             * This is an auto-generated method that returns the global [design
            * time] parent component.
            * 
            * Note: the class generator will ignore any custom implementation
            * for this behavior.
             */
            private com.tangosol.coherence.Component get_Module()
                {
                return this.get_Parent().get_Parent();
                }
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$KeyListenerRequest
    
    /**
     * Key based listener request.
     * 
     * @see $BinaryMap#addMapListener
     * @see $BinaryMap#removeMapListener
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class KeyListenerRequest
            extends    com.tangosol.coherence.component.net.message.requestMessage.DistributedCacheKeyRequest
        {
        // ---- Fields declarations ----
        
        /**
         * Property Add
         *
         * @see $BinaryMap.addMapListener
         * @see $BinaryMap.removeMapListener
         */
        private boolean __m_Add;
        
        /**
         * Property Lite
         *
         * @see $BinaryMap.addMapListener
         */
        private boolean __m_Lite;
        
        /**
         * Property MemberId
         *
         * The id of the listening member. For Primary requests this must be
         * equal to FromMember.Id
         */
        private int __m_MemberId;
        
        /**
         * Property NOT_VERSIONED
         *
         * A constant that can be used against PartitionVersion to see if the
         * request is versioned.
         */
        public static final long NOT_VERSIONED = -9223372036854775808L;
        
        /**
         * Property Partition
         *
         */
        private int __m_Partition;
        
        /**
         * Property PartitionVersion
         *
         * The partition version this listener request events from.
         * 
         * Defaults to Long.MIN_VALUE.
         */
        private long __m_PartitionVersion;
        
        /**
         * Property Priming
         *
         * Support for the NearCache priming listener. The value of true
         * indicates that the listener registration should force a synthetic
         * event containing the current value to the requesting client.
         * 
         * @see $BinaryMap.addMapListener
         */
        private boolean __m_Priming;
        private static com.tangosol.util.ListMap __mapChildren;
        
        // Static initializer
        static
            {
            __initStatic();
            }
        
        // Default static initializer
        private static void __initStatic()
            {
            // register child classes
            __mapChildren = new com.tangosol.util.ListMap();
            __mapChildren.put("Poll", PartitionedCache.KeyListenerRequest.Poll.get_CLASS());
            }
        
        // Default constructor
        public KeyListenerRequest()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public KeyListenerRequest(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                setMessageType(65);
                setPartitionVersion(-9223372036854775808L);
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // containment initialization: children
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        // Getter for virtual constant ReadOnly
        public boolean isReadOnly()
            {
            return false;
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.KeyListenerRequest();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$KeyListenerRequest".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        //++ getter for autogen property _ChildClasses
        /**
         * This is an auto-generated method that returns the map of design time
        * [static] children.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        protected java.util.Map get_ChildClasses()
            {
            return __mapChildren;
            }
        
        // Declared at the super level
        /**
         * Instantiate a copy of this message. This is quite different from the
        * standard "clone" since only the "transmittable" portion of the
        * message (and none of the internal) state should be cloned.
         */
        public com.tangosol.coherence.component.net.Message cloneMessage()
            {
            PartitionedCache.KeyListenerRequest msg = (PartitionedCache.KeyListenerRequest) super.cloneMessage();
            
            msg.setAdd(isAdd());
            msg.setLite(isLite());
            msg.setPriming(isPriming());
            msg.setMemberId(getMemberId());
            msg.setPartitionVersion(getPartitionVersion());
            
            return msg;
            }
        
        // Declared at the super level
        public boolean equals(Object obj)
            {
            // import Component.Util.Daemon.QueueProcessor.Service.Grid;
            // import com.tangosol.util.Base;
            
            // this implementation is used to associate non-commutative requests;
            // it is intentionally agnostic about the request specifics
            // (see comments to getAssociatedKey() implementation)
            
            // Note: we associate by cache and partition to ensure ordering of KeyListener
            //       and KeyListenerAll requests emanating from the same client
            
            Grid service    = null;
            long lCacheId   = 0L;
            int  nPartition = -1;
            
            if (obj instanceof PartitionedCache.KeyListenerRequest)
                {
                PartitionedCache.KeyListenerRequest that = (PartitionedCache.KeyListenerRequest) obj;
            
                service    = that.getService();
                lCacheId   = that.getCacheId();
                nPartition = that.getPartition();
                }
            else if (obj instanceof PartitionedCache.KeyListenerAllRequest.KeyListenerJob)
                {
                PartitionedCache.KeyListenerAllRequest.KeyListenerJob that = (PartitionedCache.KeyListenerAllRequest.KeyListenerJob) obj;
            
                service    = that.getService();
                lCacheId   = that.getCacheId();
                nPartition = that.getPartition();
                }
            
            return this.getService()   == service
                && this.getCacheId()   == lCacheId
                && this.getPartition() == nPartition;
            }
        
        // Declared at the super level
        /**
         * Getter for property EstimatedByteSize.<p>
        * The estimated serialized size of this message.  A negative value
        * indicates that the size is unknown and that it is safe to estimate
        * the size via a double serialization.
         */
        public int getEstimatedByteSize()
            {
            return -1;
            }
        
        // Accessor for the property "MemberId"
        /**
         * Getter for property MemberId.<p>
        * The id of the listening member. For Primary requests this must be
        * equal to FromMember.Id
         */
        public int getMemberId()
            {
            return __m_MemberId;
            }
        
        // Accessor for the property "Partition"
        /**
         * Getter for property Partition.<p>
         */
        public int getPartition()
            {
            return __m_Partition;
            }
        
        // Accessor for the property "PartitionVersion"
        /**
         * Getter for property PartitionVersion.<p>
        * The partition version this listener request events from.
        * 
        * Defaults to Long.MIN_VALUE.
         */
        public long getPartitionVersion()
            {
            return __m_PartitionVersion;
            }
        
        // Declared at the super level
        public int hashCode()
            {
            // import com.tangosol.util.HashHelper;
            
            // this implementation is used to associate non-commutative requests;
            // it is intentionally agnostic about the request specifics
            // (see comments to getAssociatedKey() implementation)
            
            // Note: we associate by cache and partition to ensure ordering of KeyListener
            //       and KeyListenerAll requests emanating from the same client
            
            return HashHelper.hash(getCacheId(), getPartition());
            }
        
        // Accessor for the property "Add"
        /**
         * Getter for property Add.<p>
        * @see $BinaryMap.addMapListener
        * @see $BinaryMap.removeMapListener
         */
        public boolean isAdd()
            {
            return __m_Add;
            }
        
        // Accessor for the property "Lite"
        /**
         * Getter for property Lite.<p>
        * @see $BinaryMap.addMapListener
         */
        public boolean isLite()
            {
            return __m_Lite;
            }
        
        // Accessor for the property "Priming"
        /**
         * Getter for property Priming.<p>
        * Support for the NearCache priming listener. The value of true
        * indicates that the listener registration should force a synthetic
        * event containing the current value to the requesting client.
        * 
        * @see $BinaryMap.addMapListener
         */
        public boolean isPriming()
            {
            return __m_Priming;
            }
        
        // Accessor for the property "Versioned"
        /**
         * Getter for property Versioned.<p>
        * True if the request is versioned.
         */
        public boolean isVersioned()
            {
            return getPartitionVersion() != NOT_VERSIONED;
            }
        
        // Declared at the super level
        public void read(com.tangosol.io.ReadBuffer.BufferInput input)
                throws java.io.IOException
            {
            // import com.tangosol.util.ExternalizableHelper as com.tangosol.util.ExternalizableHelper;
            
            super.read(input);
            
            setAdd(input.readBoolean());
            setLite(input.readBoolean());
            setPriming(input.readBoolean());
            setMemberId(input.readUnsignedShort());
            
            readTracing(input);
            
            if (input.available() > 0)
                {
                setPartitionVersion(com.tangosol.util.ExternalizableHelper.readLong(input));
                }
            }
        
        // Declared at the super level
        public void run()
            {
            ((PartitionedCache) getService()).onKeyListenerRequest(this);
            }
        
        // Accessor for the property "Add"
        /**
         * Setter for property Add.<p>
        * @see $BinaryMap.addMapListener
        * @see $BinaryMap.removeMapListener
         */
        public void setAdd(boolean fAdd)
            {
            __m_Add = fAdd;
            }
        
        // Accessor for the property "Lite"
        /**
         * Setter for property Lite.<p>
        * @see $BinaryMap.addMapListener
         */
        public void setLite(boolean fLite)
            {
            __m_Lite = fLite;
            }
        
        // Accessor for the property "MemberId"
        /**
         * Setter for property MemberId.<p>
        * The id of the listening member. For Primary requests this must be
        * equal to FromMember.Id
         */
        public void setMemberId(int nMemberId)
            {
            __m_MemberId = nMemberId;
            }
        
        // Accessor for the property "Partition"
        /**
         * Setter for property Partition.<p>
         */
        public void setPartition(int nPartition)
            {
            __m_Partition = nPartition;
            }
        
        // Accessor for the property "PartitionVersion"
        /**
         * Setter for property PartitionVersion.<p>
        * The partition version this listener request events from.
        * 
        * Defaults to Long.MIN_VALUE.
         */
        public void setPartitionVersion(long lVersion)
            {
            __m_PartitionVersion = lVersion;
            }
        
        // Accessor for the property "Priming"
        /**
         * Setter for property Priming.<p>
        * Support for the NearCache priming listener. The value of true
        * indicates that the listener registration should force a synthetic
        * event containing the current value to the requesting client.
        * 
        * @see $BinaryMap.addMapListener
         */
        public void setPriming(boolean fLite)
            {
            __m_Priming = fLite;
            }
        
        // Declared at the super level
        /**
         * Setter for property RequestTimeout.<p>
        * Transient property optionally used on the client to indicate the
        * (safe local) time after which this logical request should be
        * considered timed out.
        * 
        * Note that a single logical request message may result in multiple
        * physical request messages being sent to mulitple members; this
        * RequestTimeout value will be cloned to all resulting RequestMessage
        * instances.
        * 
        * This value is lazily calculated by #getRequestTimeout or
        * #calculateTimeoutRemaining.
         */
        public void setRequestTimeout(long ldtTimeout)
            {
            super.setRequestTimeout(ldtTimeout);
            }
        
        // Declared at the super level
        public void write(com.tangosol.io.WriteBuffer.BufferOutput output)
                throws java.io.IOException
            {
            // import com.tangosol.util.ExternalizableHelper as com.tangosol.util.ExternalizableHelper;
            
            super.write(output);
            
            output.writeBoolean(isAdd());
            output.writeBoolean(isLite());
            output.writeBoolean(isPriming());
            output.writeShort(getMemberId());
            
            writeTracing(output);
            
            com.tangosol.util.ExternalizableHelper.writeLong(output, getPartitionVersion());
            }

        // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$KeyListenerRequest$Poll
        
        /**
         * The Poll contains information regarding a request sent to one or
         * more Cluster Members that require responses. A Service may poll
         * other Members that are running the same Service, and the Poll is
         * used to wait for and assemble the responses from each of those
         * Members. A client thread may also use the Poll to block on a
         * response or set of responses, thus waiting for the completion of the
         * Poll. In its simplest form, which is a Poll that is sent to one
         * Member of the Cluster, the Poll actually represents the
         * request/response model.
         */
        @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
        public static class Poll
                extends    com.tangosol.coherence.component.net.message.requestMessage.DistributedCacheKeyRequest.Poll
            {
            // ---- Fields declarations ----
            
            // Default constructor
            public Poll()
                {
                this(null, null, true);
                }
            
            // Initializing constructor
            public Poll(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                {
                super(sName, compParent, false);
                
                if (fInit)
                    {
                    __init();
                    }
                }
            
            // Main initializer
            public void __init()
                {
                // private initialization
                __initPrivate();
                
                
                // signal the end of the initialization
                set_Constructed(true);
                }
            
            // Private initializer
            protected void __initPrivate()
                {
                
                super.__initPrivate();
                }
            
            //++ getter for static property _Instance
            /**
             * Getter for property _Instance.<p>
            * Auto generated
             */
            public static com.tangosol.coherence.Component get_Instance()
                {
                return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.KeyListenerRequest.Poll();
                }
            
            //++ getter for static property _CLASS
            /**
             * Getter for property _CLASS.<p>
            * Property with auto-generated accessor that returns the Class
            * object for a given component.
             */
            public static Class get_CLASS()
                {
                Class clz;
                try
                    {
                    clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$KeyListenerRequest$Poll".replace('/', '.'));
                    }
                catch (ClassNotFoundException e)
                    {
                    throw new NoClassDefFoundError(e.getMessage());
                    }
                return clz;
                }
            
            //++ getter for autogen property _Module
            /**
             * This is an auto-generated method that returns the global [design
            * time] parent component.
            * 
            * Note: the class generator will ignore any custom implementation
            * for this behavior.
             */
            private com.tangosol.coherence.Component get_Module()
                {
                return this.get_Parent().get_Parent();
                }
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$LazyLookup
    
    /**
     * LazyLookup is a very specialized ReadBuffer wrapper that allows a
     * ReadBuffer (Binary) lookup to be evaluated lazily.
     * 
     * Note: this class is extremely specialized in nature, and would ideally
     * be implemented as an anonymous inner class.
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class LazyLookup
            extends    com.tangosol.coherence.Component
            implements com.tangosol.io.ReadBuffer
        {
        // ---- Fields declarations ----
        
        /**
         * Property Binary
         *
         */
        private com.tangosol.util.Binary __m_Binary;
        
        /**
         * Property LookupKey
         *
         */
        private Object __m_LookupKey;
        
        /**
         * Property LookupMap
         *
         */
        private java.util.Map __m_LookupMap;
        
        // Default constructor
        public LazyLookup()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public LazyLookup(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.LazyLookup();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$LazyLookup".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        // From interface: com.tangosol.io.ReadBuffer
        public byte byteAt(int of)
            {
            return getBinary().byteAt(of);
            }
        
        // From interface: com.tangosol.io.ReadBuffer
        // Declared at the super level
        public Object clone()
            {
            try
                {
                return super.clone();
                }
            catch (java.lang.CloneNotSupportedException e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            }
        
        // From interface: com.tangosol.io.ReadBuffer
        public void copyBytes(int ofBegin, int ofEnd, byte[] abDest, int ofDest)
            {
            getBinary().copyBytes(ofBegin, ofEnd, abDest, ofDest);
            }
        
        // Accessor for the property "Binary"
        /**
         * Getter for property Binary.<p>
         */
        public com.tangosol.util.Binary getBinary()
            {
            // import com.tangosol.util.Binary;
            // import java.util.Map;
            
            Binary bin = __m_Binary;
            if (bin == null)
                {
                Map mapLookup = getLookupMap();
                if (mapLookup != null)
                    {
                    setBinary(bin = (Binary) mapLookup.get(getLookupKey()));
                    }
                }
            return bin;
            }
        
        // From interface: com.tangosol.io.ReadBuffer
        public com.tangosol.io.ReadBuffer.BufferInput getBufferInput()
            {
            return getBinary().getBufferInput();
            }
        
        // Accessor for the property "LookupKey"
        /**
         * Getter for property LookupKey.<p>
         */
        public Object getLookupKey()
            {
            return __m_LookupKey;
            }
        
        // Accessor for the property "LookupMap"
        /**
         * Getter for property LookupMap.<p>
         */
        public java.util.Map getLookupMap()
            {
            return __m_LookupMap;
            }
        
        // From interface: com.tangosol.io.ReadBuffer
        public com.tangosol.io.ReadBuffer getReadBuffer(int of, int cb)
            {
            return getBinary().getReadBuffer(of, cb);
            }
        
        // From interface: com.tangosol.io.ReadBuffer
        public int length()
            {
            // import com.tangosol.util.Binary;
            
            // protect against the NPE if the underlying value is missing from
            // the LookupMap.  This is an imperfect solution to COH-5544 as this
            // LazyLookup ReadBuffer could be used to represent a deferred Binary
            // which could in actuality be null.
            
            Binary bin = getBinary();
            return bin == null ? 0 : bin.length();
            }
        
        public void reset()
            {
            setBinary   (null);
            setLookupKey(null);
            setLookupMap(null);
            }
        
        // Accessor for the property "Binary"
        /**
         * Setter for property Binary.<p>
         */
        protected void setBinary(com.tangosol.util.Binary bin)
            {
            __m_Binary = bin;
            }
        
        // Accessor for the property "LookupKey"
        /**
         * Setter for property LookupKey.<p>
         */
        public void setLookupKey(Object oKey)
            {
            __m_LookupKey = oKey;
            }
        
        // Accessor for the property "LookupMap"
        /**
         * Setter for property LookupMap.<p>
         */
        public void setLookupMap(java.util.Map mapLookup)
            {
            __m_LookupMap = mapLookup;
            }
        
        // From interface: com.tangosol.io.ReadBuffer
        public com.tangosol.util.ByteSequence subSequence(int ofStart, int ofEnd)
            {
            return getBinary().subSequence(ofStart, ofEnd);
            }
        
        // From interface: com.tangosol.io.ReadBuffer
        public com.tangosol.util.Binary toBinary()
            {
            return getBinary();
            }
        
        // From interface: com.tangosol.io.ReadBuffer
        public com.tangosol.util.Binary toBinary(int of, int cb)
            {
            return getBinary().toBinary(of, cb);
            }
        
        // From interface: com.tangosol.io.ReadBuffer
        public byte[] toByteArray()
            {
            return getBinary().toByteArray();
            }
        
        // From interface: com.tangosol.io.ReadBuffer
        public byte[] toByteArray(int of, int cb)
            {
            return getBinary().toByteArray(of, cb);
            }
        
        // From interface: com.tangosol.io.ReadBuffer
        public java.nio.ByteBuffer toByteBuffer()
            {
            return getBinary().toByteBuffer();
            }
        
        // From interface: com.tangosol.io.ReadBuffer
        public java.nio.ByteBuffer toByteBuffer(int of, int cb)
            {
            return getBinary().toByteBuffer(of, cb);
            }
        
        // Declared at the super level
        public String toString()
            {
            return String.valueOf(getBinary());
            }
        
        // From interface: com.tangosol.io.ReadBuffer
        public void writeTo(java.io.DataOutput out)
                throws java.io.IOException
            {
            getBinary().writeTo(out);
            }
        
        // From interface: com.tangosol.io.ReadBuffer
        public void writeTo(java.io.DataOutput out, int of, int cb)
                throws java.io.IOException
            {
            getBinary().writeTo(out, of, cb);
            }
        
        // From interface: com.tangosol.io.ReadBuffer
        public void writeTo(java.io.OutputStream out)
                throws java.io.IOException
            {
            getBinary().writeTo(out);
            }
        
        // From interface: com.tangosol.io.ReadBuffer
        public void writeTo(java.io.OutputStream out, int of, int cb)
                throws java.io.IOException
            {
            getBinary().writeTo(out, of, cb);
            }
        
        // From interface: com.tangosol.io.ReadBuffer
        public void writeTo(java.nio.ByteBuffer buf)
            {
            getBinary().writeTo(buf);
            }
        
        // From interface: com.tangosol.io.ReadBuffer
        public void writeTo(java.nio.ByteBuffer buf, int of, int cb)
                throws java.io.IOException
            {
            getBinary().writeTo(buf, of, cb);
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$ListenerRequest
    
    /**
     * Filter based listener request.
     * 
     * @see $BinaryMap#addMapListener
     * @see $BinaryMap#removeMapListener
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class ListenerRequest
            extends    com.tangosol.coherence.component.net.message.requestMessage.distributedCacheRequest.StorageRequest
        {
        // ---- Fields declarations ----
        
        /**
         * Property Add
         *
         * If true, add a listener; otherwise remove it.
         */
        private boolean __m_Add;
        
        /**
         * Property Filter
         *
         * @see $BinaryMap#addMapListener
         */
        private com.tangosol.util.Filter __m_Filter;
        
        /**
         * Property FilterId
         *
         * @see $BinaryMap#addMapListener
         */
        private long __m_FilterId;
        
        /**
         * Property Lite
         *
         * @see $BinaryMap#addMapListener
         */
        private boolean __m_Lite;
        
        /**
         * Property MemberId
         *
         * The id of the listening member.
         * 
         * Note: this is not always the same as the FromMember (see
         * $MemberWelcomeRequest#populateWelcomeRequest)
         */
        private int __m_MemberId;
        
        /**
         * Property Partitions
         *
         * The set of partitions to be processed. 
         */
        private com.tangosol.net.partition.PartitionSet __m_Partitions;
        
        /**
         * Property PartitionVersions
         *
         * Partition versions
         */
        private com.tangosol.net.partition.VersionedPartitions __m_PartitionVersions;
        
        /**
         * Property Trigger
         *
         * An optional MapTrigger object associated with this request.
         * 
         * @see $BinaryMap#addMapListener
         */
        private com.tangosol.util.MapTrigger __m_Trigger;
        private static com.tangosol.util.ListMap __mapChildren;
        
        // Static initializer
        static
            {
            __initStatic();
            }
        
        // Default static initializer
        private static void __initStatic()
            {
            // register child classes
            __mapChildren = new com.tangosol.util.ListMap();
            __mapChildren.put("Poll", PartitionedCache.ListenerRequest.Poll.get_CLASS());
            }
        
        // Default constructor
        public ListenerRequest()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public ListenerRequest(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                setMessageType(66);
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // containment initialization: children
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        // Getter for virtual constant ReadOnly
        public boolean isReadOnly()
            {
            return false;
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.ListenerRequest();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$ListenerRequest".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        //++ getter for autogen property _ChildClasses
        /**
         * This is an auto-generated method that returns the map of design time
        * [static] children.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        protected java.util.Map get_ChildClasses()
            {
            return __mapChildren;
            }
        
        // Declared at the super level
        /**
         * Instantiate a copy of this message. This is quite different from the
        * standard "clone" since only the "transmittable" portion of the
        * message (and none of the internal) state should be cloned.
         */
        public com.tangosol.coherence.component.net.Message cloneMessage()
            {
            PartitionedCache.ListenerRequest msg = (PartitionedCache.ListenerRequest) super.cloneMessage();
            
            msg.setFilter(getFilter());
            msg.setTrigger(getTrigger());
            msg.setFilterId(getFilterId());
            msg.setAdd(isAdd());
            msg.setLite(isLite());
            msg.setMemberId(getMemberId());
            msg.setPartitionVersions(getPartitionVersions());
            msg.setPartitions(getPartitions());
            msg.setRequestContext(getRequestContext());
            
            return msg;
            }
        
        // Declared at the super level
        public Object getAssociatedKey()
            {
            return Long.valueOf(getCacheId());
            }
        
        // Accessor for the property "Filter"
        /**
         * Getter for property Filter.<p>
        * @see $BinaryMap#addMapListener
         */
        public com.tangosol.util.Filter getFilter()
            {
            return __m_Filter;
            }
        
        // Accessor for the property "FilterId"
        /**
         * Getter for property FilterId.<p>
        * @see $BinaryMap#addMapListener
         */
        public long getFilterId()
            {
            return __m_FilterId;
            }
        
        // Accessor for the property "MemberId"
        /**
         * Getter for property MemberId.<p>
        * The id of the listening member.
        * 
        * Note: this is not always the same as the FromMember (see
        * $MemberWelcomeRequest#populateWelcomeRequest)
         */
        public int getMemberId()
            {
            return __m_MemberId;
            }
        
        // Accessor for the property "Partitions"
        /**
         * Getter for property Partitions.<p>
        * The set of partitions to be processed. 
         */
        public com.tangosol.net.partition.PartitionSet getPartitions()
            {
            return __m_Partitions;
            }
        
        // Accessor for the property "PartitionVersions"
        /**
         * Getter for property PartitionVersions.<p>
        * Partition versions
         */
        public com.tangosol.net.partition.VersionedPartitions getPartitionVersions()
            {
            return __m_PartitionVersions;
            }
        
        // Declared at the super level
        /**
         * Getter for property RequestPartitions.<p>
        * (Calculated) Set of partitions that need to be processed for this
        * request. This value is never null for asynchronous requests.
         */
        public com.tangosol.net.partition.PartitionSet getRequestPartitions()
            {
            return getPartitions();
            }
        
        // Accessor for the property "Trigger"
        /**
         * Getter for property Trigger.<p>
        * An optional MapTrigger object associated with this request.
        * 
        * @see $BinaryMap#addMapListener
         */
        public com.tangosol.util.MapTrigger getTrigger()
            {
            return __m_Trigger;
            }
        
        // Accessor for the property "Add"
        /**
         * Getter for property Add.<p>
        * If true, add a listener; otherwise remove it.
         */
        public boolean isAdd()
            {
            return __m_Add;
            }
        
        // Accessor for the property "Lite"
        /**
         * Getter for property Lite.<p>
        * @see $BinaryMap#addMapListener
         */
        public boolean isLite()
            {
            return __m_Lite;
            }
        
        // Declared at the super level
        public void read(com.tangosol.io.ReadBuffer.BufferInput input)
                throws java.io.IOException
            {
            // import com.tangosol.net.partition.PartitionSet;
            // import com.tangosol.net.partition.VersionedPartitions;
            // import com.tangosol.util.Base;
            // import com.tangosol.util.ExternalizableHelper;
            // import com.tangosol.util.Filter;
            // import com.tangosol.util.MapTrigger;
            
            super.read(input);
            
            try
                {
                setFilter((Filter) readObject(input));
                setTrigger((MapTrigger) readObject(input));
                }
            catch (Throwable t)
                {
                setReadException(Base.ensureRuntimeException(t));
                }
            
            setFilterId(ExternalizableHelper.readLong(input));
            setAdd(input.readBoolean());
            setLite(input.readBoolean());
            setMemberId(input.readInt());
            
            readTracing(input);
            
            if (input.available() > 0)
                {
                // if we still have more bytes to read it must be PartitionVersions and Partitions
                setPartitionVersions((VersionedPartitions) readObject(input));
            
                setPartitions((PartitionSet) readObject(input));
                }
            }
        
        // Declared at the super level
        public void run()
            {
            ((PartitionedCache) getService()).onListenerRequest(this);
            }
        
        // Accessor for the property "Add"
        /**
         * Setter for property Add.<p>
        * If true, add a listener; otherwise remove it.
         */
        public void setAdd(boolean fAdd)
            {
            __m_Add = fAdd;
            }
        
        // Accessor for the property "Filter"
        /**
         * Setter for property Filter.<p>
        * @see $BinaryMap#addMapListener
         */
        public void setFilter(com.tangosol.util.Filter filter)
            {
            __m_Filter = filter;
            }
        
        // Accessor for the property "FilterId"
        /**
         * Setter for property FilterId.<p>
        * @see $BinaryMap#addMapListener
         */
        public void setFilterId(long lFilterId)
            {
            __m_FilterId = lFilterId;
            }
        
        // Accessor for the property "Lite"
        /**
         * Setter for property Lite.<p>
        * @see $BinaryMap#addMapListener
         */
        public void setLite(boolean fLite)
            {
            __m_Lite = fLite;
            }
        
        // Accessor for the property "MemberId"
        /**
         * Setter for property MemberId.<p>
        * The id of the listening member.
        * 
        * Note: this is not always the same as the FromMember (see
        * $MemberWelcomeRequest#populateWelcomeRequest)
         */
        public void setMemberId(int nMember)
            {
            __m_MemberId = nMember;
            }
        
        // Accessor for the property "Partitions"
        /**
         * Setter for property Partitions.<p>
        * The set of partitions to be processed. 
         */
        public void setPartitions(com.tangosol.net.partition.PartitionSet parts)
            {
            __m_Partitions = parts;
            }
        
        // Accessor for the property "PartitionVersions"
        /**
         * Setter for property PartitionVersions.<p>
        * Partition versions
         */
        public void setPartitionVersions(com.tangosol.net.partition.VersionedPartitions partitionsVersions)
            {
            __m_PartitionVersions = partitionsVersions;
            }
        
        // Declared at the super level
        /**
         * Setter for property RequestTimeout.<p>
        * Transient property optionally used on the client to indicate the
        * (safe local) time after which this logical request should be
        * considered timed out.
        * 
        * Note that a single logical request message may result in multiple
        * physical request messages being sent to mulitple members; this
        * RequestTimeout value will be cloned to all resulting RequestMessage
        * instances.
        * 
        * This value is lazily calculated by #getRequestTimeout or
        * #calculateTimeoutRemaining.
         */
        public void setRequestTimeout(long ldtTimeout)
            {
            super.setRequestTimeout(ldtTimeout);
            }
        
        // Declared at the super level
        /**
         * Setter for property Response.<p>
        * Response message to be sent to the requestor upon poll completion.
         */
        public void setResponse(com.tangosol.coherence.component.net.message.responseMessage.SimpleResponse msgResponse)
            {
            super.setResponse(msgResponse);
            }
        
        // Accessor for the property "Trigger"
        /**
         * Setter for property Trigger.<p>
        * An optional MapTrigger object associated with this request.
        * 
        * @see $BinaryMap#addMapListener
         */
        public void setTrigger(com.tangosol.util.MapTrigger trigger)
            {
            __m_Trigger = trigger;
            }
        
        // Declared at the super level
        public void write(com.tangosol.io.WriteBuffer.BufferOutput output)
                throws java.io.IOException
            {
            // import com.tangosol.net.partition.PartitionSet;
            // import com.tangosol.util.ExternalizableHelper;
            // import java.io.IOException;
            
            super.write(output);
            
            try
                {
                writeObject(output, getFilter());
                }
            catch (IOException e)
                {
                _trace("Filter is not serializable: " + getFilter(), 1);
                throw e;
                }
            
            try
                {
                writeObject(output, getTrigger());
                }
            catch (IOException e)
                {
                _trace("MapTrigger is not serializable: " + getTrigger(), 1);
                throw e;
                }
            
            ExternalizableHelper.writeLong(output, getFilterId());
            output.writeBoolean(isAdd());
            output.writeBoolean(isLite());
            output.writeInt(getMemberId());
            
            writeTracing(output);
            
            writeObject(output, getPartitionVersions());
            
            writeObject(output, getPartitions());
            }

        // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$ListenerRequest$Poll
        
        /**
         * The Poll contains information regarding a request sent to one or
         * more Cluster Members that require responses. A Service may poll
         * other Members that are running the same Service, and the Poll is
         * used to wait for and assemble the responses from each of those
         * Members. A client thread may also use the Poll to block on a
         * response or set of responses, thus waiting for the completion of the
         * Poll. In its simplest form, which is a Poll that is sent to one
         * Member of the Cluster, the Poll actually represents the
         * request/response model.
         */
        @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
        public static class Poll
                extends    com.tangosol.coherence.component.net.message.requestMessage.distributedCacheRequest.StorageRequest.Poll
            {
            // ---- Fields declarations ----
            
            // Default constructor
            public Poll()
                {
                this(null, null, true);
                }
            
            // Initializing constructor
            public Poll(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                {
                super(sName, compParent, false);
                
                if (fInit)
                    {
                    __init();
                    }
                }
            
            // Main initializer
            public void __init()
                {
                // private initialization
                __initPrivate();
                
                
                // signal the end of the initialization
                set_Constructed(true);
                }
            
            // Private initializer
            protected void __initPrivate()
                {
                
                super.__initPrivate();
                }
            
            //++ getter for static property _Instance
            /**
             * Getter for property _Instance.<p>
            * Auto generated
             */
            public static com.tangosol.coherence.Component get_Instance()
                {
                return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.ListenerRequest.Poll();
                }
            
            //++ getter for static property _CLASS
            /**
             * Getter for property _CLASS.<p>
            * Property with auto-generated accessor that returns the Class
            * object for a given component.
             */
            public static Class get_CLASS()
                {
                Class clz;
                try
                    {
                    clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$ListenerRequest$Poll".replace('/', '.'));
                    }
                catch (ClassNotFoundException e)
                    {
                    throw new NoClassDefFoundError(e.getMessage());
                    }
                return clz;
                }
            
            //++ getter for autogen property _Module
            /**
             * This is an auto-generated method that returns the global [design
            * time] parent component.
            * 
            * Note: the class generator will ignore any custom implementation
            * for this behavior.
             */
            private com.tangosol.coherence.Component get_Module()
                {
                return this.get_Parent().get_Parent();
                }
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$LockRequest
    
    /**
     * @see $BinaryMap#put
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class LockRequest
            extends    com.tangosol.coherence.component.net.message.requestMessage.DistributedCacheKeyRequest
        {
        // ---- Fields declarations ----
        
        /**
         * Property LeaseExpiration
         *
         * Cluster time that the Lease should expire at. This value is
         * calculated based on the LeaseWaitMillis value and cached upon the
         * very first access.
         */
        private transient long __m_LeaseExpiration;
        
        /**
         * Property LeaseHolderId
         *
         * The member id for the for this Lease holder. If Primary is true this
         * value must be equal to getFromMember().getId().
         */
        private int __m_LeaseHolderId;
        
        /**
         * Property LeaseMillis
         *
         * The LeaseMillis is a duration of the Lease in milliseconds starting
         * immediately after the lock is acquired; 0 means indefinite lease
         * duration.
         */
        private long __m_LeaseMillis;
        
        /**
         * Property LeaseThreadId
         *
         * Unique (within the requestor's VM) id of the Thread which requests a
         * lock for this Lease.
         */
        private long __m_LeaseThreadId;
        
        /**
         * Property LeaseWaitMillis
         *
         * The LeaseWaitMillis value is the time interval by which this
         * LockRequest must be replied to.
         */
        private long __m_LeaseWaitMillis;
        
        /**
         * Property LeaseWaitTimeout
         *
         * The LeaseWaitTimeout value is the Cluster time by which this
         * LockRequest must be replied to. This value is calculated based on
         * the LeaseWaitMillis value and cached upon the very first access.
         */
        private transient long __m_LeaseWaitTimeout;
        private static com.tangosol.util.ListMap __mapChildren;
        
        // Static initializer
        static
            {
            __initStatic();
            }
        
        // Default static initializer
        private static void __initStatic()
            {
            // register child classes
            __mapChildren = new com.tangosol.util.ListMap();
            __mapChildren.put("Poll", PartitionedCache.LockRequest.Poll.get_CLASS());
            }
        
        // Default constructor
        public LockRequest()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public LockRequest(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                setMessageType(67);
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // containment initialization: children
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        // Getter for virtual constant ReadOnly
        public boolean isReadOnly()
            {
            return false;
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.LockRequest();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$LockRequest".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        //++ getter for autogen property _ChildClasses
        /**
         * This is an auto-generated method that returns the map of design time
        * [static] children.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        protected java.util.Map get_ChildClasses()
            {
            return __mapChildren;
            }
        
        // Declared at the super level
        /**
         * Instantiate a copy of this message. This is quite different from the
        * standard "clone" since only the "transmittable" portion of the
        * message (and none of the internal) state should be cloned.
         */
        public com.tangosol.coherence.component.net.Message cloneMessage()
            {
            PartitionedCache.LockRequest msg = (PartitionedCache.LockRequest) super.cloneMessage();
            
            msg.fromLease(toLease());
            msg.setLeaseWaitMillis(getRequestTimeoutMillis());
            
            return msg;
            }
        
        /**
         * Set the request's info based on the specified Lease object.
         */
        public void fromLease(com.tangosol.coherence.component.net.Lease lease)
            {
            // import com.tangosol.util.Binary;
            
            setKey((Binary) lease.getResourceKey());
            setLeaseHolderId(lease.getHolderId());
            setLeaseThreadId(lease.getHolderThreadId());
            
            long ldtExpiry = lease.getExpirationTime();
            if (ldtExpiry > 0L)
                {
                setLeaseMillis(Math.max(0L, ldtExpiry - ((PartitionedCache) get_Module()).getClusterTime()));
                }
            }
        
        // Declared at the super level
        /**
         * Getter for property Description.<p>
        * Used for debugging purposes (from toString). Create a human-readable
        * description of the specific Message data.
         */
        public String getDescription()
            {
            return super.getDescription() +
                "\nWaitTimeout=" + getLeaseWaitTimeout() +
                ", LeaseExpiration=" + getLeaseExpiration();
            }
        
        // Declared at the super level
        /**
         * Getter for property EstimatedByteSize.<p>
        * The estimated serialized size of this message.  A negative value
        * indicates that the size is unknown and that it is safe to estimate
        * the size via a double serialization.
         */
        public int getEstimatedByteSize()
            {
            return -1;
            }
        
        // Accessor for the property "LeaseExpiration"
        /**
         * Getter for property LeaseExpiration.<p>
        * Cluster time that the Lease should expire at. This value is
        * calculated based on the LeaseWaitMillis value and cached upon the
        * very first access.
         */
        public long getLeaseExpiration()
            {
            long ldtExpiry = __m_LeaseExpiration;
            if (ldtExpiry == 0L)
                {
                PartitionedCache service = (PartitionedCache) getService();
            
                // (LeaseMillis == 0) means indefinite lease duration
                ldtExpiry = service.adjustWaitTime(getLeaseMillis() - 1L, PartitionedCache.TIME_CLUSTER);
                setLeaseExpiration(ldtExpiry);
                }
            return ldtExpiry;
            }
        
        // Accessor for the property "LeaseHolderId"
        /**
         * Getter for property LeaseHolderId.<p>
        * The member id for the for this Lease holder. If Primary is true this
        * value must be equal to getFromMember().getId().
         */
        public int getLeaseHolderId()
            {
            return __m_LeaseHolderId;
            }
        
        // Accessor for the property "LeaseMillis"
        /**
         * Getter for property LeaseMillis.<p>
        * The LeaseMillis is a duration of the Lease in milliseconds starting
        * immediately after the lock is acquired; 0 means indefinite lease
        * duration.
         */
        public long getLeaseMillis()
            {
            return __m_LeaseMillis;
            }
        
        // Accessor for the property "LeaseThreadId"
        /**
         * Getter for property LeaseThreadId.<p>
        * Unique (within the requestor's VM) id of the Thread which requests a
        * lock for this Lease.
         */
        public long getLeaseThreadId()
            {
            return __m_LeaseThreadId;
            }
        
        // Accessor for the property "LeaseWaitMillis"
        /**
         * Getter for property LeaseWaitMillis.<p>
        * The LeaseWaitMillis value is the time interval by which this
        * LockRequest must be replied to.
         */
        public long getLeaseWaitMillis()
            {
            return __m_LeaseWaitMillis;
            }
        
        // Accessor for the property "LeaseWaitTimeout"
        /**
         * Getter for property LeaseWaitTimeout.<p>
        * The LeaseWaitTimeout value is the Cluster time by which this
        * LockRequest must be replied to. This value is calculated based on the
        * LeaseWaitMillis value and cached upon the very first access.
         */
        public long getLeaseWaitTimeout()
            {
            long ldtTimeout = __m_LeaseWaitTimeout;
            if (ldtTimeout == 0L)
                {
                PartitionedCache service = (PartitionedCache) getService();
            
                ldtTimeout = service.adjustWaitTime(getLeaseWaitMillis(), PartitionedCache.TIME_CLUSTER);
                setLeaseWaitTimeout(ldtTimeout);
                }
            return ldtTimeout;
            }
        
        // Declared at the super level
        /**
         * Getter for property RequestTimeoutMillis.<p>
        * From PriorityTask interface.
         */
        public long getRequestTimeoutMillis()
            {
            // 1) negative wait timeout (WAIT_FOREVER) should override any default request timeout
            // 2) non-positive request timeout should override non-positive wait timeout
            // 3) wait timeout less then a positive request timeout should be ignored
            // 4) wait timeout greater then a positive request timeout should be adjusted
            //    (by the request timeout)
            
            long cWait = getLeaseWaitMillis();
            if (cWait < 0)
                {
                return cWait;
                }
            long cDefault = getService().getRequestTimeout();
            
            if (cDefault <= 0)
                {
                return cDefault;
                }
            
            if (cWait < cDefault)
                {
                return cDefault;
                }
            
            // watch for an overrun)
            return Math.min(cWait, Long.MAX_VALUE - cDefault) + cDefault;
            }
        
        // Declared at the super level
        public void read(com.tangosol.io.ReadBuffer.BufferInput input)
                throws java.io.IOException
            {
            // import com.tangosol.util.ExternalizableHelper;
            
            super.read(input);
            
            setLeaseHolderId(input.readUnsignedShort());
            setLeaseThreadId(ExternalizableHelper.readLong(input));
            setLeaseMillis(ExternalizableHelper.readLong(input));
            setLeaseWaitMillis(ExternalizableHelper.readLong(input));
            
            readTracing(input);
            }
        
        // Declared at the super level
        public void run()
            {
            ((PartitionedCache) getService()).onLockRequest(this);
            }
        
        // Accessor for the property "LeaseExpiration"
        /**
         * Setter for property LeaseExpiration.<p>
        * Cluster time that the Lease should expire at. This value is
        * calculated based on the LeaseWaitMillis value and cached upon the
        * very first access.
         */
        protected void setLeaseExpiration(long ltExpiration)
            {
            __m_LeaseExpiration = ltExpiration;
            }
        
        // Accessor for the property "LeaseHolderId"
        /**
         * Setter for property LeaseHolderId.<p>
        * The member id for the for this Lease holder. If Primary is true this
        * value must be equal to getFromMember().getId().
         */
        public void setLeaseHolderId(int nHolderId)
            {
            __m_LeaseHolderId = nHolderId;
            }
        
        // Accessor for the property "LeaseMillis"
        /**
         * Setter for property LeaseMillis.<p>
        * The LeaseMillis is a duration of the Lease in milliseconds starting
        * immediately after the lock is acquired; 0 means indefinite lease
        * duration.
         */
        public void setLeaseMillis(long cMillis)
            {
            __m_LeaseMillis = (cMillis);
            setLeaseExpiration(0L); // clear a cached value
            }
        
        // Accessor for the property "LeaseThreadId"
        /**
         * Setter for property LeaseThreadId.<p>
        * Unique (within the requestor's VM) id of the Thread which requests a
        * lock for this Lease.
         */
        public void setLeaseThreadId(long lThreadId)
            {
            __m_LeaseThreadId = lThreadId;
            }
        
        // Accessor for the property "LeaseWaitMillis"
        /**
         * Setter for property LeaseWaitMillis.<p>
        * The LeaseWaitMillis value is the time interval by which this
        * LockRequest must be replied to.
         */
        public void setLeaseWaitMillis(long cMillis)
            {
            __m_LeaseWaitMillis = (cMillis);
            setLeaseWaitTimeout(0L); // clear a cached value
            }
        
        // Accessor for the property "LeaseWaitTimeout"
        /**
         * Setter for property LeaseWaitTimeout.<p>
        * The LeaseWaitTimeout value is the Cluster time by which this
        * LockRequest must be replied to. This value is calculated based on the
        * LeaseWaitMillis value and cached upon the very first access.
         */
        protected void setLeaseWaitTimeout(long ldtTimeout)
            {
            __m_LeaseWaitTimeout = ldtTimeout;
            }
        
        // Declared at the super level
        /**
         * Setter for property RequestTimeout.<p>
        * Transient property optionally used on the client to indicate the
        * (safe local) time after which this logical request should be
        * considered timed out.
        * 
        * Note that a single logical request message may result in multiple
        * physical request messages being sent to mulitple members; this
        * RequestTimeout value will be cloned to all resulting RequestMessage
        * instances.
        * 
        * This value is lazily calculated by #getRequestTimeout or
        * #calculateTimeoutRemaining.
         */
        public void setRequestTimeout(long ldtTimeout)
            {
            super.setRequestTimeout(ldtTimeout);
            }
        
        /**
         * Calculate a Lease object based on the request's info.
         */
        public com.tangosol.coherence.component.net.Lease toLease()
            {
            // import Component.Net.Lease;
            
            Lease lease = Lease.instantiate(0, getKey(), getService());
            
            lease.setHolderId(getLeaseHolderId());
            lease.setHolderThreadId(getLeaseThreadId());
            lease.setExpirationTime(getLeaseExpiration());
            
            return lease;
            }
        
        // Declared at the super level
        public void write(com.tangosol.io.WriteBuffer.BufferOutput output)
                throws java.io.IOException
            {
            // import com.tangosol.util.ExternalizableHelper;
            
            super.write(output);
            
            output.writeShort(getLeaseHolderId());
            ExternalizableHelper.writeLong(output, getLeaseThreadId());
            ExternalizableHelper.writeLong(output, getLeaseMillis());
            ExternalizableHelper.writeLong(output, getLeaseWaitMillis());
            
            writeTracing(output);
            }

        // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$LockRequest$Poll
        
        /**
         * The Poll contains information regarding a request sent to one or
         * more Cluster Members that require responses. A Service may poll
         * other Members that are running the same Service, and the Poll is
         * used to wait for and assemble the responses from each of those
         * Members. A client thread may also use the Poll to block on a
         * response or set of responses, thus waiting for the completion of the
         * Poll. In its simplest form, which is a Poll that is sent to one
         * Member of the Cluster, the Poll actually represents the
         * request/response model.
         */
        @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
        public static class Poll
                extends    com.tangosol.coherence.component.net.message.requestMessage.DistributedCacheKeyRequest.Poll
            {
            // ---- Fields declarations ----
            
            // Default constructor
            public Poll()
                {
                this(null, null, true);
                }
            
            // Initializing constructor
            public Poll(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                {
                super(sName, compParent, false);
                
                if (fInit)
                    {
                    __init();
                    }
                }
            
            // Main initializer
            public void __init()
                {
                // private initialization
                __initPrivate();
                
                
                // signal the end of the initialization
                set_Constructed(true);
                }
            
            // Private initializer
            protected void __initPrivate()
                {
                
                super.__initPrivate();
                }
            
            //++ getter for static property _Instance
            /**
             * Getter for property _Instance.<p>
            * Auto generated
             */
            public static com.tangosol.coherence.Component get_Instance()
                {
                return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.LockRequest.Poll();
                }
            
            //++ getter for static property _CLASS
            /**
             * Getter for property _CLASS.<p>
            * Property with auto-generated accessor that returns the Class
            * object for a given component.
             */
            public static Class get_CLASS()
                {
                Class clz;
                try
                    {
                    clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$LockRequest$Poll".replace('/', '.'));
                    }
                catch (ClassNotFoundException e)
                    {
                    throw new NoClassDefFoundError(e.getMessage());
                    }
                return clz;
                }
            
            //++ getter for autogen property _Module
            /**
             * This is an auto-generated method that returns the global [design
            * time] parent component.
            * 
            * Note: the class generator will ignore any custom implementation
            * for this behavior.
             */
            private com.tangosol.coherence.Component get_Module()
                {
                return this.get_Parent().get_Parent();
                }
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$MapEvent
    
    /**
     * Remote MapEvent notification.
     * 
     * @see $Storage#dispatch
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class MapEvent
            extends    com.tangosol.coherence.component.net.message.MapEventMessage
        {
        // ---- Fields declarations ----
        
        // Default constructor
        public MapEvent()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public MapEvent(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                setMessageType(68);
                setNotifyDelivery(true);
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.MapEvent();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$MapEvent".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        // Declared at the super level
        /**
         * Getter for property CacheName.<p>
        * (Calculated) The corresponding cache name.
         */
        public String getCacheName()
            {
            PartitionedCache    service   = (PartitionedCache) getService();
            BinaryMap mapBinary = (BinaryMap) service.getBinaryMapArray().get(getCacheId());
            return mapBinary == null ? super.getCacheName() : mapBinary.getCacheName();
            }
        
        // Declared at the super level
        /**
         * Getter for property DeltaCompressor.<p>
        * The DeltaCompressor to use for compressing the NewValue for standard
        * events.
         */
        public com.tangosol.io.DeltaCompressor getDeltaCompressor()
            {
            return ((PartitionedCache) getService()).getEventDeltaCompressor();
            }
        
        // Declared at the super level
        /**
         * Getter for property EstimatedByteSize.<p>
        * The estimated serialized size of this message.  A negative value
        * indicates that the size is unknown and that it is safe to estimate
        * the size via a double serialization.
         */
        public int getEstimatedByteSize()
            {
            return -1;
            }

        // Declared at the super level
        /**
         * This is the event that occurs when a Message with NotifySent set to
        * true and the Message is sent and fully acknowledged. Note that this
        * event does not mean that all Members received the Message; it just
        * means that those Members that are still alive and that the Message
        * was addressed to have acknowledged the Message, as well as all older
        * messages from this member.
         */
        public void onDelivery()
            {
            ((PartitionedCache) getService()).unregisterEvent(this);
            
            super.onDelivery();
            }
        
        // Declared at the super level
        /**
         * This is the event that is executed when a Message is received.
        * <p>
        * It is the main processing event of the Message called by the
        * <code>Service.onMessage()</code> event. With regards to the use of
        * Message components within clustered Services, Services are designed
        * by dragging Message components into them as static children. These
        * Messages are the components that a Service can send to other running
        * instances of the same Service within a cluster. When the onReceived
        * event is invoked by a Service, it means that the Message has been
        * received; the code in the onReceived event is therefore the Message
        * specific logic for processing a received Message. For example, when
        * onReceived is invoked on a Message named FindData, the onReceived
        * event should do the work to "find the data", because it is being
        * invoked by the Service that received the "find the data" Message.
         */
        public void onReceived()
            {
            super.onReceived();
            
            ((PartitionedCache) getService()).onMapEvent(this);
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$MemberWelcome
    
    /**
     * This Message is used to welcome a new member into this Service.
     * 
     * Attributes:
     *     MemberConfigMap
     *     ServiceConfigMap  (optional)
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class MemberWelcome
            extends    com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.MemberWelcome
        {
        // ---- Fields declarations ----
        
        /**
         * Property PostWelcomeRequests
         *
         * A list of requests (e.g. IndexRequest, ListenerRequest) to be
         * processed by the new member before it starts accepting client
         * requests (AcceptingClients).
         * 
         * This list is gathered during the MemberWelcomeRequest handshake
         * sequence and transmitted to the new member as a part of the payload
         * on the MemberWelcome message (as opposed to being sent explicitly).
         */
        private java.util.List __m_PostWelcomeRequests;
        
        // Default constructor
        public MemberWelcome()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public MemberWelcome(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                setMessageType(-2);
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.MemberWelcome();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$MemberWelcome".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        // Declared at the super level
        /**
         * Getter for property Description.<p>
        * Used for debugging purposes (from toString). Create a human-readable
        * description of the specific Message data.
         */
        public String getDescription()
            {
            return super.getDescription() + ", PostWelcomeRequests=" + getPostWelcomeRequests();
            }
        
        // Accessor for the property "PostWelcomeRequests"
        /**
         * Getter for property PostWelcomeRequests.<p>
        * A list of requests (e.g. IndexRequest, ListenerRequest) to be
        * processed by the new member before it starts accepting client
        * requests (AcceptingClients).
        * 
        * This list is gathered during the MemberWelcomeRequest handshake
        * sequence and transmitted to the new member as a part of the payload
        * on the MemberWelcome message (as opposed to being sent explicitly).
         */
        public java.util.List getPostWelcomeRequests()
            {
            return __m_PostWelcomeRequests;
            }
        
        // Declared at the super level
        public void read(com.tangosol.io.ReadBuffer.BufferInput input)
                throws java.io.IOException
            {
            // import Component.Net.Member as com.tangosol.coherence.component.net.Member;
            // import Component.Net.Message;
            // import com.tangosol.util.Binary;
            // import java.util.LinkedList;
            // import java.util.List;
            
            super.read(input);
            
            if (isRejected())
                {
                return;
                }
            
            PartitionedCache service    = (PartitionedCache) getService();
            com.tangosol.coherence.component.net.Member  memberThis = service.getThisMember();
            
            // the post-welcome requests
            int cRequests = input.readInt();
            if (cRequests > 0)
                {
                List listRequests = new LinkedList();
                for (int i = 0; i < cRequests; i++)
                    {
                    int     nMsgType    = input.readInt();
                    Message msgRegister = service.instantiateMessage(nMsgType);
            
                    // Note: msg is serialized and written as a Binary (see #write)
                    Binary binMsg = new Binary();
                    binMsg.readExternal(input);
                    msgRegister.read(binMsg.getBufferInput());
            
                    msgRegister.addToMember(memberThis);
                    listRequests.add(msgRegister);
                    }
            
                setPostWelcomeRequests(listRequests);
                }
            }
        
        // Accessor for the property "PostWelcomeRequests"
        /**
         * Setter for property PostWelcomeRequests.<p>
        * A list of requests (e.g. IndexRequest, ListenerRequest) to be
        * processed by the new member before it starts accepting client
        * requests (AcceptingClients).
        * 
        * This list is gathered during the MemberWelcomeRequest handshake
        * sequence and transmitted to the new member as a part of the payload
        * on the MemberWelcome message (as opposed to being sent explicitly).
         */
        public void setPostWelcomeRequests(java.util.List listRequests)
            {
            __m_PostWelcomeRequests = listRequests;
            }
        
        // Declared at the super level
        public void write(com.tangosol.io.WriteBuffer.BufferOutput output)
                throws java.io.IOException
            {
            // import Component.Net.Message;
            // import com.tangosol.util.BinaryWriteBuffer as com.tangosol.util.BinaryWriteBuffer;
            // import java.util.Iterator;
            // import java.util.List;
            
            super.write(output);
            
            if (isRejected())
                {
                return;
                }
            
            // write the post-welcome requests
            List listRequests = getPostWelcomeRequests();
            if (listRequests == null)
                {
                output.writeInt(0);
                }
            else
                {
                output.writeInt(listRequests.size());
                for (Iterator iter = listRequests.iterator(); iter.hasNext(); )
                    {
                    // serialize the request messages
            
                    Message msgRequest = (Message) iter.next();
                    output.writeInt(msgRequest.getMessageType());
            
                    // Note: since we could be serializing user data, we must
                    //       serialize a Binary in order to be able to recover
                    //       from deserialization errors without corrupting the
                    //       input stream.
                    com.tangosol.util.BinaryWriteBuffer bufTemp = new com.tangosol.util.BinaryWriteBuffer(1024);
                    msgRequest.write(bufTemp.getBufferOutput());
                    bufTemp.toBinary().writeExternal(output);
                    }
                }
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$MemberWelcomeRequest
    
    /**
     * This Message is sent to all other Members running this service to
     * request their up-to-date Member ConfigMap for this Service.
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class MemberWelcomeRequest
            extends    com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.MemberWelcomeRequest
        {
        // ---- Fields declarations ----
        private static com.tangosol.util.ListMap __mapChildren;
        
        // Static initializer
        static
            {
            __initStatic();
            }
        
        // Default static initializer
        private static void __initStatic()
            {
            // register child classes
            __mapChildren = new com.tangosol.util.ListMap();
            __mapChildren.put("Poll", PartitionedCache.MemberWelcomeRequest.Poll.get_CLASS());
            }
        
        // Default constructor
        public MemberWelcomeRequest()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public MemberWelcomeRequest(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                setMessageType(-1);
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // containment initialization: children
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.MemberWelcomeRequest();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$MemberWelcomeRequest".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        //++ getter for autogen property _ChildClasses
        /**
         * This is an auto-generated method that returns the map of design time
        * [static] children.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        protected java.util.Map get_ChildClasses()
            {
            return __mapChildren;
            }
        
        // Declared at the super level
        /**
         * This is the event that is executed when a Message is received.
        * <p>
        * It is the main processing event of the Message called by the
        * <code>Service.onMessage()</code> event. With regards to the use of
        * Message components within clustered Services, Services are designed
        * by dragging Message components into them as static children. These
        * Messages are the components that a Service can send to other running
        * instances of the same Service within a cluster. When the onReceived
        * event is invoked by a Service, it means that the Message has been
        * received; the code in the onReceived event is therefore the Message
        * specific logic for processing a received Message. For example, when
        * onReceived is invoked on a Message named FindData, the onReceived
        * event should do the work to "find the data", because it is being
        * invoked by the Service that received the "find the data" Message.
         */
        public void onReceived()
            {
            super.onReceived();
            
            // clear the ProcessedEvents array for that member id
            PartitionedCache service = (PartitionedCache) getService();
            service.removeSUIDRange(service.getProcessedEvents(), getFromMember().getId(), false);
            }
        
        // Declared at the super level
        /**
         * Populate and return the WelcomeMember message to respond to this
        * welcome request with.
         */
        protected com.tangosol.coherence.component.util.daemon.queueProcessor.service.Grid.MemberWelcome populateWelcomeMessage()
            {
            PartitionedCache.MemberWelcome msgWelcome = (PartitionedCache.MemberWelcome) super.populateWelcomeMessage();
            
            if (!msgWelcome.isRejected())
                {
                // add any post-welcome requests that may be required
                msgWelcome.setPostWelcomeRequests(
                        ((PartitionedCache) getService()).createWelcomeRequests(getFromMember()));
                }
            
            return msgWelcome;
            }

        // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$MemberWelcomeRequest$Poll
        
        /**
         * The Poll contains information regarding a request sent to one or
         * more Cluster Members that require responses. A Service may poll
         * other Members that are running the same Service, and the Poll is
         * used to wait for and assemble the responses from each of those
         * Members. A client thread may also use the Poll to block on a
         * response or set of responses, thus waiting for the completion of the
         * Poll. In its simplest form, which is a Poll that is sent to one
         * Member of the Cluster, the Poll actually represents the
         * request/response model.
         */
        @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
        public static class Poll
                extends    com.tangosol.coherence.component.util.daemon.queueProcessor.service.Grid.MemberWelcomeRequest.Poll
            {
            // ---- Fields declarations ----
            
            // Default constructor
            public Poll()
                {
                this(null, null, true);
                }
            
            // Initializing constructor
            public Poll(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                {
                super(sName, compParent, false);
                
                if (fInit)
                    {
                    __init();
                    }
                }
            
            // Main initializer
            public void __init()
                {
                // private initialization
                __initPrivate();
                
                
                // signal the end of the initialization
                set_Constructed(true);
                }
            
            // Private initializer
            protected void __initPrivate()
                {
                
                super.__initPrivate();
                }
            
            //++ getter for static property _Instance
            /**
             * Getter for property _Instance.<p>
            * Auto generated
             */
            public static com.tangosol.coherence.Component get_Instance()
                {
                return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.MemberWelcomeRequest.Poll();
                }
            
            //++ getter for static property _CLASS
            /**
             * Getter for property _CLASS.<p>
            * Property with auto-generated accessor that returns the Class
            * object for a given component.
             */
            public static Class get_CLASS()
                {
                Class clz;
                try
                    {
                    clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$MemberWelcomeRequest$Poll".replace('/', '.'));
                    }
                catch (ClassNotFoundException e)
                    {
                    throw new NoClassDefFoundError(e.getMessage());
                    }
                return clz;
                }
            
            //++ getter for autogen property _Module
            /**
             * This is an auto-generated method that returns the global [design
            * time] parent component.
            * 
            * Note: the class generator will ignore any custom implementation
            * for this behavior.
             */
            private com.tangosol.coherence.Component get_Module()
                {
                return this.get_Parent().get_Parent();
                }
            
            // Declared at the super level
            /**
             * This event occurs for each response Message from each polled
            * Member.
             */
            public void onResponse(com.tangosol.coherence.component.net.Message msg)
                {
                // import Component.Net.Member;
                // import Component.Net.MemberSet;
                // import Component.Net.MemberSet.SingleMemberSet;
                // import Component.Net.Message;
                // import java.util.Iterator;
                // import java.util.List;
                
                // process any post-welcome requests included in an accepted PartitionedCache.MemberWelcome
                PartitionedCache.MemberWelcome msgWelcome = (PartitionedCache.MemberWelcome) msg;
                if (!msgWelcome.isRejected())
                    {
                    List listRequests = msgWelcome.getPostWelcomeRequests();
                    if (listRequests != null)
                        {
                        // send the post-welcome requests
                        PartitionedCache   service = (PartitionedCache) getService();
                        MemberSet setThis = SingleMemberSet.instantiate(service.getThisMember());
                
                        for (Iterator iter = listRequests.iterator(); iter.hasNext(); )
                            {
                            Message msgRequest = (Message) iter.next();
                
                            msgRequest.setToMemberSet(setThis);
                            service.post(msgRequest);
                            }
                        }
                    }
                
                super.onResponse(msg);
                }
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$OwnershipRequest
    
    /**
     * Poll message that requests an ownership info. This poll can only come
     * from the ownership senior member.
     * 
     * First, the senior issues this request with Query flag set to true.
     * Recipients respond to this message with the local copy of the partition
     * assignment array.  Any response that is showing discrepancies in
     * understanding what orphan partitions are will force another poll.
     * 
     * When everyone agrees on what the orphaned partitions are (or timeout
     * occurs), the senior member issues another request with Query flag set
     * false, at which point everyone 
     * assumes the ownership for all the backed up partitions. The senior then
     * takes over all the partitions that are still orphaned.
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class OwnershipRequest
            extends    com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.OwnershipRequest
        {
        // ---- Fields declarations ----
        private static com.tangosol.util.ListMap __mapChildren;
        
        // Static initializer
        static
            {
            __initStatic();
            }
        
        // Default static initializer
        private static void __initStatic()
            {
            // register child classes
            __mapChildren = new com.tangosol.util.ListMap();
            __mapChildren.put("Poll", com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.OwnershipRequest.Poll.get_CLASS());
            }
        
        // Default constructor
        public OwnershipRequest()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public OwnershipRequest(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                setMessageType(33);
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // containment initialization: children
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.OwnershipRequest();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$OwnershipRequest".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        //++ getter for autogen property _ChildClasses
        /**
         * This is an auto-generated method that returns the map of design time
        * [static] children.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        protected java.util.Map get_ChildClasses()
            {
            return __mapChildren;
            }
        
        // Declared at the super level
        /**
         * Setter for property RequestTimeout.<p>
        * Transient property optionally used on the client to indicate the
        * (safe local) time after which this logical request should be
        * considered timed out.
        * 
        * Note that a single logical request message may result in multiple
        * physical request messages being sent to mulitple members; this
        * RequestTimeout value will be cloned to all resulting RequestMessage
        * instances.
        * 
        * This value is lazily calculated by #getRequestTimeout or
        * #calculateTimeoutRemaining.
         */
        public void setRequestTimeout(long ldtTimeout)
            {
            super.setRequestTimeout(ldtTimeout);
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$PartialMapResponse
    
    /**
     * Response to DistributedCacheRequest messages (e.g GetAllRequest,
     * InvokeAllRequest) that returns a map of partial result entries along
     * with a set of partitions that have been rejected.
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class PartialMapResponse
            extends    com.tangosol.coherence.component.net.message.responseMessage.DistributedPartialResponse
        {
        // ---- Fields declarations ----
        
        /**
         * Property FailedKeys
         *
         * Collection of keys that failed to be processed while executing the
         * request.
         * 
         * This could only be assigned if there is an Exception.
         */
        private java.util.Collection __m_FailedKeys;
        
        /**
         * Property Key
         *
         * An array of [Binary] keys. The length of this array could exceed the
         * Size property value. In that case, the array will contain nulls that
         * should be skipped along with the corresponding elements in the Value
         * array. Note that the type is Object and not Binary.  This was done
         * so that the array could be reused in onInvokeAllRequest() to hold
         * objects of a different type, saving the cost of allocating an
         * additional array.  Type safety was intentionally sacrificed for the
         * performance gain.
         */
        private Object[] __m_Key;
        
        /**
         * Property Size
         *
         * The length of both Key and Value arrays.
         */
        private int __m_Size;
        
        /**
         * Property Value
         *
         * An array of Binary values. Note that the type is Object and not
         * Binary. This was done so that the array could be reused in
         * onInvokeAllRequest() to hold objects of a different type, saving the
         * cost of allocating an additional array.  Type safety was
         * intentionally sacrificed for the performance gain.
         */
        private Object[] __m_Value;
        
        // Default constructor
        public PartialMapResponse()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public PartialMapResponse(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                setMessageType(69);
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.PartialMapResponse();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$PartialMapResponse".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        // Declared at the super level
        /**
         * Getter for property EstimatedByteSize.<p>
        * The estimated serialized size of this message.  A negative value
        * indicates that the size is unknown and that it is safe to estimate
        * the size via a double serialization.
         */
        public int getEstimatedByteSize()
            {
            // import com.tangosol.util.Binary;
            
            return getValue() instanceof Binary[] ? -1 : 0;
            }
        
        // Accessor for the property "FailedKeys"
        /**
         * Getter for property FailedKeys.<p>
        * Collection of keys that failed to be processed while executing the
        * request.
        * 
        * This could only be assigned if there is an Exception.
         */
        public java.util.Collection getFailedKeys()
            {
            return __m_FailedKeys;
            }
        
        // Accessor for the property "Key"
        /**
         * Getter for property Key.<p>
        * An array of [Binary] keys. The length of this array could exceed the
        * Size property value. In that case, the array will contain nulls that
        * should be skipped along with the corresponding elements in the Value
        * array. Note that the type is Object and not Binary.  This was done so
        * that the array could be reused in onInvokeAllRequest() to hold
        * objects of a different type, saving the cost of allocating an
        * additional array.  Type safety was intentionally sacrificed for the
        * performance gain.
         */
        public Object[] getKey()
            {
            return __m_Key;
            }
        
        // Accessor for the property "Size"
        /**
         * Getter for property Size.<p>
        * The length of both Key and Value arrays.
         */
        public int getSize()
            {
            return __m_Size;
            }
        
        // Accessor for the property "Value"
        /**
         * Getter for property Value.<p>
        * An array of Binary values. Note that the type is Object and not
        * Binary. This was done so that the array could be reused in
        * onInvokeAllRequest() to hold objects of a different type, saving the
        * cost of allocating an additional array.  Type safety was
        * intentionally sacrificed for the performance gain.
         */
        public Object[] getValue()
            {
            return __m_Value;
            }
        
        // Declared at the super level
        public void read(com.tangosol.io.ReadBuffer.BufferInput input)
                throws java.io.IOException
            {
            // import com.tangosol.util.Binary;
            // import com.tangosol.util.ExternalizableHelper;
            // import java.util.ArrayList;
            // import java.util.List;
            
            super.read(input);
            
            if (getException() == null)
                {
                int      cSize = ExternalizableHelper.readInt(input);
                Object[] aoKey = new Object[cSize];
                Object[] aoVal = new Object[cSize];
            
                for (int i = 0; i < cSize; i++)
                    {
                    aoKey[i] = (Binary) readObject(input);
                    aoVal[i] = (Binary) readObject(input);
                    }
                setSize(cSize);
                setKey(aoKey);
                setValue(aoVal);
                }
            else
                {
                int cColSize = input.readPackedInt();
                if (cColSize > 0)
                    {
                    List list = new ArrayList(cColSize);
            
                    for (int i = 0; i < cColSize; i++)
                        {
                        list.add(readObject(input));
                        }
            
                    setFailedKeys(list);
                    }
                }
            }
        
        // Accessor for the property "FailedKeys"
        /**
         * Setter for property FailedKeys.<p>
        * Collection of keys that failed to be processed while executing the
        * request.
        * 
        * This could only be assigned if there is an Exception.
         */
        public void setFailedKeys(java.util.Collection colKeys)
            {
            __m_FailedKeys = colKeys;
            }
        
        // Accessor for the property "Key"
        /**
         * Setter for property Key.<p>
        * An array of [Binary] keys. The length of this array could exceed the
        * Size property value. In that case, the array will contain nulls that
        * should be skipped along with the corresponding elements in the Value
        * array. Note that the type is Object and not Binary.  This was done so
        * that the array could be reused in onInvokeAllRequest() to hold
        * objects of a different type, saving the cost of allocating an
        * additional array.  Type safety was intentionally sacrificed for the
        * performance gain.
         */
        public void setKey(Object[] abin)
            {
            __m_Key = abin;
            }
        
        // Accessor for the property "Size"
        /**
         * Setter for property Size.<p>
        * The length of both Key and Value arrays.
         */
        public void setSize(int c)
            {
            __m_Size = c;
            }
        
        // Accessor for the property "Value"
        /**
         * Setter for property Value.<p>
        * An array of Binary values. Note that the type is Object and not
        * Binary. This was done so that the array could be reused in
        * onInvokeAllRequest() to hold objects of a different type, saving the
        * cost of allocating an additional array.  Type safety was
        * intentionally sacrificed for the performance gain.
         */
        public void setValue(Object[] abin)
            {
            __m_Value = abin;
            }
        
        // Declared at the super level
        public void write(com.tangosol.io.WriteBuffer.BufferOutput output)
                throws java.io.IOException
            {
            // import com.tangosol.util.Binary;
            // import com.tangosol.util.ExternalizableHelper;
            // import java.util.Collection;
            // import java.util.Iterator;
            
            super.write(output);
            
            if (getException() == null)
                {
                int      cSize   = getSize();
                Object[] aoKey   = getKey();
                Object[] aoVal   = getValue();
                int      cKeys   = aoKey == null ? 0 : aoKey.length;
                int      cValues = aoVal == null ? 0 : aoVal.length;
            
                // the array of keys could be large than the effective size
                // and it could have "holes" (null values) in it
                _assert(cKeys == cValues && cSize <= cKeys);
            
                ExternalizableHelper.writeInt(output, cSize);
            
                int cActualSize = 0;
                for (int i = 0; i < cKeys; i++)
                    {
                    Binary binKey = (Binary) aoKey[i];
                    if (binKey != null)
                        {
                        writeObject(output, binKey);
                        writeObject(output, aoVal[i]);
                        cActualSize++;
                        }
                    }
            
                if (cActualSize != cSize)
                    {
                    // soft assert
                    _trace("Invalid response size: expected=" + cSize +
                           ", actual=" + cActualSize, 1);
                    }
                }
            else
                {
                Collection colResult = getFailedKeys();
                if (colResult == null)
                    {
                    output.writePackedInt(-1);
                    }
                else
                    {
                    output.writePackedInt(colResult.size());
                    for (Iterator iter = colResult.iterator(); iter.hasNext(); )
                        {
                        writeObject(output, iter.next());
                        }
                    }
                }
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$PartialValueResponse
    
    /**
     * Response to DistributedCacheRequests messages that returns a partial
     * result along with a set of partitions that have been rejected.
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class PartialValueResponse
            extends    com.tangosol.coherence.component.net.message.responseMessage.DistributedPartialResponse
        {
        // ---- Fields declarations ----
        
        /**
         * Property Collection
         *
         * True if the Result is a Collection.
         */
        private boolean __m_Collection;
        
        /**
         * Property FailedKeys
         *
         * Collection of keys that failed to be processed while executing the
         * request.
         * 
         * This could only be assigned if there is an Exception.
         */
        private java.util.Collection __m_FailedKeys;
        
        /**
         * Property Result
         *
         * Partial execution Binary result.
         * 
         * This could only be null if there is no partial result at all.
         */
        private Object __m_Result;
        
        // Default constructor
        public PartialValueResponse()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public PartialValueResponse(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                setCollection(false);
                setMessageType(70);
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.PartialValueResponse();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$PartialValueResponse".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        // Declared at the super level
        /**
         * Getter for property EstimatedByteSize.<p>
        * The estimated serialized size of this message.  A negative value
        * indicates that the size is unknown and that it is safe to estimate
        * the size via a double serialization.
         */
        public int getEstimatedByteSize()
            {
            return -1;
            }
        
        // Accessor for the property "FailedKeys"
        /**
         * Getter for property FailedKeys.<p>
        * Collection of keys that failed to be processed while executing the
        * request.
        * 
        * This could only be assigned if there is an Exception.
         */
        public java.util.Collection getFailedKeys()
            {
            return __m_FailedKeys;
            }
        
        // Accessor for the property "Result"
        /**
         * Getter for property Result.<p>
        * Partial execution Binary result.
        * 
        * This could only be null if there is no partial result at all.
         */
        public Object getResult()
            {
            return __m_Result;
            }
        
        // Accessor for the property "Collection"
        /**
         * Getter for property Collection.<p>
        * True if the Result is a Collection.
         */
        public boolean isCollection()
            {
            return __m_Collection;
            }
        
        // Declared at the super level
        public void read(com.tangosol.io.ReadBuffer.BufferInput input)
                throws java.io.IOException
            {
            // import java.util.ArrayList;
            // import java.util.List;
            
            super.read(input);
            
            if (getException() == null)
                {
                int cSize = input.readPackedInt();
                if (cSize >= 0)
                    {
                    List list = new ArrayList(cSize);
            
                    for (int i = 0; i < cSize; i++)
                        {
                        list.add(readObject(input));
                        }
            
                    setCollectionResult(list);
                    }
                else
                    {   
                    setResult(readObject(input));
                    }
                }
            else
                {
                int cSize = input.readPackedInt();
                if (cSize >= 0)
                    {
                    List list = new ArrayList(cSize);
            
                    for (int i = 0; i < cSize; i++)
                        {
                        list.add(readObject(input));
                        }
            
                    setFailedKeys(list);
                    }
                }
            }
        
        // Accessor for the property "Collection"
        /**
         * Setter for property Collection.<p>
        * True if the Result is a Collection.
         */
        protected void setCollection(boolean fCollection)
            {
            __m_Collection = fCollection;
            }
        
        /**
         * Helper method.
         */
        public void setCollectionResult(java.util.Collection colResult)
            {
            setCollection(true);
            setResult(colResult);
            }
        
        // Accessor for the property "FailedKeys"
        /**
         * Setter for property FailedKeys.<p>
        * Collection of keys that failed to be processed while executing the
        * request.
        * 
        * This could only be assigned if there is an Exception.
         */
        public void setFailedKeys(java.util.Collection colKeys)
            {
            __m_FailedKeys = colKeys;
            }
        
        // Accessor for the property "Result"
        /**
         * Setter for property Result.<p>
        * Partial execution Binary result.
        * 
        * This could only be null if there is no partial result at all.
         */
        public void setResult(Object oResult)
            {
            __m_Result = oResult;
            }
        
        // Declared at the super level
        public void write(com.tangosol.io.WriteBuffer.BufferOutput output)
                throws java.io.IOException
            {
            // import java.util.Collection;
            // import java.util.Iterator;
            
            super.write(output);
            
            if (getException() == null)
                {
                if (isCollection())
                    {
                    Collection col = (Collection) getResult();
            
                    output.writePackedInt(col.size());
                    for (Iterator iter = col.iterator(); iter.hasNext(); )
                        {
                        writeObject(output, iter.next());
                        }
                    }
                else
                    {
                    output.writePackedInt(-1);
                    writeObject(output, getResult());
                    }
                }
            else
                {
                Collection col = getFailedKeys();
                if (col == null)
                    {
                    output.writePackedInt(-1);
                    }
                else
                    {
                    output.writePackedInt(col.size());
            
                    for (Iterator iter = col.iterator(); iter.hasNext(); )
                        {
                        writeObject(output, iter.next());
                        }
                    }   
                }
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$PartitionAbandonRequest
    
    /**
     * PartitionAbandonRequest is sent to the ownership "chain" of members to
     * "abandon" or intentionally "orphan" one or more partitions.  The request
     * is sent as a ChainedRequest to all owners of this partition set, in the
     * order of storage index (e.g. Primary, backup1, backup2, ...)
     * 
     * Note: This message is currenlty not used but is retained for future use.
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class PartitionAbandonRequest
            extends    com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.PartitionAbandonRequest
        {
        // ---- Fields declarations ----
        private static com.tangosol.util.ListMap __mapChildren;
        
        // Static initializer
        static
            {
            __initStatic();
            }
        
        // Default static initializer
        private static void __initStatic()
            {
            // register child classes
            __mapChildren = new com.tangosol.util.ListMap();
            __mapChildren.put("Poll", com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.PartitionAbandonRequest.Poll.get_CLASS());
            }
        
        // Default constructor
        public PartitionAbandonRequest()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public PartitionAbandonRequest(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                setMessageType(46);
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // containment initialization: children
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.PartitionAbandonRequest();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$PartitionAbandonRequest".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        //++ getter for autogen property _ChildClasses
        /**
         * This is an auto-generated method that returns the map of design time
        * [static] children.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        protected java.util.Map get_ChildClasses()
            {
            return __mapChildren;
            }
        
        // Declared at the super level
        /**
         * Setter for property RequestTimeout.<p>
        * Transient property optionally used on the client to indicate the
        * (safe local) time after which this logical request should be
        * considered timed out.
        * 
        * Note that a single logical request message may result in multiple
        * physical request messages being sent to mulitple members; this
        * RequestTimeout value will be cloned to all resulting RequestMessage
        * instances.
        * 
        * This value is lazily calculated by #getRequestTimeout or
        * #calculateTimeoutRemaining.
         */
        public void setRequestTimeout(long ldtTimeout)
            {
            super.setRequestTimeout(ldtTimeout);
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$PartitionControl
    
    /**
     * PartitionControl provides the means to control access to a partition's
     * contents across multiple threads.
     * 
     * Note: Since a PartitionControl component is created for each partition,
     * we are using the _Feed and _Sink properties to hold partition state as a
     * storage optimization.
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class PartitionControl
            extends    com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.PartitionControl
        {
        // ---- Fields declarations ----
        private static com.tangosol.util.ListMap __mapChildren;
        
        // Static initializer
        static
            {
            __initStatic();
            }
        
        // Default static initializer
        private static void __initStatic()
            {
            // register child classes
            __mapChildren = new com.tangosol.util.ListMap();
            __mapChildren.put("GuardContinuation", com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.PartitionControl.GuardContinuation.get_CLASS());
            }
        
        // Default constructor
        public PartitionControl()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public PartitionControl(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                setDeferredBackups(new com.tangosol.util.CircularArrayList());
                setPersistentBackupExtents(new com.tangosol.net.internal.CopyOnWriteLongList());
                setPersistentExtents(new com.tangosol.net.internal.CopyOnWriteLongList());
                setVersionCounter(new java.util.concurrent.atomic.AtomicLong());
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // containment initialization: children
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.PartitionControl();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$PartitionControl".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        //++ getter for autogen property _ChildClasses
        /**
         * This is an auto-generated method that returns the map of design time
        * [static] children.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        protected java.util.Map get_ChildClasses()
            {
            return __mapChildren;
            }
        
        // Declared at the super level
        /**
         * Delete the persistent information for the provided cache id.
        * 
        * @param lExtentId  the extent to delete
        * @param laCaches  the caches (id -> name) to store in the
        * PersistentStore
         */
        public void deletePersistentExtent(long lExtentId, com.tangosol.util.LongArray laCaches)
            {
            // import com.oracle.coherence.persistence.PersistentStore;
            // import com.tangosol.persistence.CachePersistenceHelper as com.tangosol.persistence.CachePersistenceHelper;
            
            // deleteExtent should always propagate down to the store for two reasons:
            //   i) some meta extents (indexes, locks, key listeners) may have been created
            //   ii) deleting an extent that was not ensured is a no-op
            
            PersistentStore[] aStore = new PersistentStore[] {getPersistentStore(), getPersistentEventsStore()};
            
            for (int i = 0, c = aStore.length; i < c; ++i)
                {
                PersistentStore store = aStore[i];
            
                if (store != null)
                    {
                    com.tangosol.persistence.CachePersistenceHelper.deleteExtents(store, lExtentId);
                    com.tangosol.persistence.CachePersistenceHelper.storeCacheNames(store, laCaches);
                    }
                }
            }
        
        /**
         * Ensure a persistent extent is created in the PersistentStore
        * associated with this PartitionControl.
        * 
        * @param lExtentId  the extent to ensure is createad
        * 
        * @see persistChanges
         */
        public boolean ensureBackupPersistentExtent(long lExtentId)
            {
            // import com.oracle.coherence.persistence.PersistentStore;
            // import com.tangosol.net.internal.CopyOnWriteLongList;
            // import com.tangosol.persistence.CachePersistenceHelper as com.tangosol.persistence.CachePersistenceHelper;
            // import com.tangosol.util.LongArray;
            // import java.util.Map;
            
            CopyOnWriteLongList listExtents  = getPersistentBackupExtents();
            Map                 mapGraveyard = ((PartitionedCache) get_Module()).getStorageGraveyard();
            
            if (mapGraveyard.containsKey(Long.valueOf(lExtentId)))
                {
                return false;
                }
            
            // backup partition recovery not relevant
            if (listExtents.contains(lExtentId))
                {
                boolean         fCreatedExtent = false;
                synchronized (this)
                    {
                    if (fCreatedExtent = listExtents.contains(lExtentId))
                        {
                        LongArray         laCaches = null;
            
                        PersistentStore store = ensureOpenPersistentStore(null, true, true);
                        if (store != null && store.ensureExtent(lExtentId))
                            {
                            if (laCaches == null)
                                {
                                laCaches = ((PartitionedCache) get_Module()).getPersistentCacheIds();
                                }
            
                            com.tangosol.persistence.CachePersistenceHelper.storeCacheNames(store, laCaches);
                            }
            
                        listExtents.remove(lExtentId);
                        }
                    }
            
                if (fCreatedExtent && mapGraveyard.containsKey(Long.valueOf(lExtentId)))
                    {
                    // as we ensured the extent the cache was concurrently destroyed; the
                    // destroy (service thread) does delete the extent however it may have
                    // happened-before the ensureExtent above therefore re-execute a deleteExtent
                    // to ensure the final state is a non-existent extent with the understanding
                    // that the second deleteExtent may be a no-op
            
                    com.tangosol.persistence.CachePersistenceHelper.deleteExtents(ensurePersistentStore(null, /*fEventsStore*/ false, /*fBackupStore*/ true), lExtentId);
            
                    return false;
                    }
                }
            return true;
            }
        
        // Declared at the super level
        /**
         * Ensure a persistent extent is created in the PersistentStore
        * associated with this PartitionControl.
        * 
        * @param lExtentId  the extent to ensure is createad
        * 
        * @see persistChanges
         */
        public boolean ensurePersistentExtent(long lExtentId)
            {
            // import com.oracle.coherence.persistence.PersistentStore;
            // import com.tangosol.net.internal.CopyOnWriteLongList;
            // import com.tangosol.persistence.CachePersistenceHelper as com.tangosol.persistence.CachePersistenceHelper;
            // import com.tangosol.util.LongArray;
            // import java.util.Map;
            
            CopyOnWriteLongList listExtents  = getPersistentExtents();
            Map                 mapGraveyard = ((PartitionedCache) get_Module()).getStorageGraveyard();
            
            if (mapGraveyard.containsKey(Long.valueOf(lExtentId)))
                {
                return false;
                }
            
            if (listExtents.contains(lExtentId) && !isRecovering())
                {
                PersistentStore storeEvents    = getPersistentEventsStore();
                boolean         fCreatedExtent = false;
                synchronized (this)
                    {
                    if (fCreatedExtent = listExtents.contains(lExtentId))
                        {
                        LongArray         laCaches = null;
                        PersistentStore[] aStore   = new PersistentStore[] {ensureOpenPersistentStore(), storeEvents};
            
                        for (int i = 0, c = aStore.length; i < c; ++i)
                            {
                            PersistentStore store = aStore[i];
                            if (store != null && store.ensureExtent(lExtentId))
                                {
                                if (laCaches == null)
                                    {
                                    laCaches = ((PartitionedCache) get_Module()).getPersistentCacheIds();
                                    }
            
                                com.tangosol.persistence.CachePersistenceHelper.storeCacheNames(aStore[i], laCaches);
                                }
                            }
            
                        listExtents.remove(lExtentId);
                        }
                    }
            
                if (fCreatedExtent && mapGraveyard.containsKey(Long.valueOf(lExtentId)))
                    {
                    // as we ensured the extent the cache was concurrently destroyed; the
                    // destroy (service thread) does delete the extent however it may have
                    // happened-before the ensureExtent above therefore re-execute a deleteExtent
                    // to ensure the final state is a non-existent extent with the understanding
                    // that the second deleteExtent may be a no-op
            
                    com.tangosol.persistence.CachePersistenceHelper.deleteExtents(ensureOpenPersistentStore(), lExtentId);

                    if (storeEvents != null)
                        {
                        storeEvents.deleteExtent(lExtentId);
                        }
            
                    return false;
                    }
                }
            return true;
            }
        
        // Declared at the super level
        /**
         * All deferred actions for this partition have been processed
         */
        public void onProcessedActions()
            {
            super.onProcessedActions();
            
            ((PartitionedCache) getService()).processChanges();
            }
        
        /**
         * Prepare (register or ensure) all known storage cache ids (extents)
        * with this PartitionControl.
        * 
        * In the case of registration the first mutating operation (or adding
        * of a key listener) on an extent will ensure the persistent extent on
        * the associated PersistentStore (see ensurePersistentExtent).
         */
        public void preparePersistentBackupExtents()
            {
            // import com.tangosol.net.internal.CopyOnWriteLongList;
            // import com.tangosol.util.LongArray;
            // import com.tangosol.util.LongArray$Iterator as com.tangosol.util.LongArray.Iterator;

            LongArray           laCaches    = ((PartitionedCache) get_Module()).getPersistentCacheIds();
            CopyOnWriteLongList listExtents = getPersistentBackupExtents();
            
            // need to "ensure" all of the cache-ids
            for (com.tangosol.util.LongArray.Iterator iter = laCaches.iterator(); iter.hasNext(); )
                {
                iter.next();
            
                long lCacheId = iter.getIndex();

                listExtents.add(lCacheId);
                }
            }
        
        // Declared at the super level
        /**
         * Prepare (register or ensure) the provided persistent extent with this
        * PartitionControl.
        * 
        * In the case of registeration the first mutating operation (or adding
        * of a key listener) on an extent will ensure the persistent extent on
        * the associated PersistentStore (see ensurePersistentExtent).
        * 
        * @param lExtentId   the extent to register
        * @param laCaches  the caches (id -> name) to store in the
        * PersistentStore
         */
        public void preparePersistentExtent(long lExtentId, com.tangosol.util.LongArray laCaches, boolean fBackup)
            {
            if (fBackup)
                {
                getPersistentBackupExtents().add(lExtentId);
                }
            else
                {
                getPersistentExtents().add(lExtentId);
                }
            }
        
        // Declared at the super level
        /**
         * Prepare (register or ensure) all known storage cache ids (extents)
        * with this PartitionControl.
        * 
        * In the case of registeration the first mutating operation (or adding
        * of a key listener) on an extent will ensure the persistent extent on
        * the associated PersistentStore (see ensurePersistentExtent).
         */
        public void preparePersistentExtents()
            {
            preparePersistentExtents(/*laExtentsExclude*/ null);
            }
        
        // Declared at the super level
        /**
         * Prepare (register or ensure) all known storage cache ids (extents)
        * with this PartitionControl.
        * 
        * In the case of registeration the first mutating operation (or adding
        * of a key listener) on an extent will ensure the persistent extent on
        * the associated PersistentStore (see ensurePersistentExtent).
         */
        public void preparePersistentExtents(com.tangosol.util.LongArray laExtentsExclude)
            {
            // import com.tangosol.net.internal.CopyOnWriteLongList;
            // import com.tangosol.util.LongArray;
            // import com.tangosol.util.LongArray$Iterator as com.tangosol.util.LongArray.Iterator;
            
            LongArray           laCaches    = ((PartitionedCache) get_Module()).getPersistentCacheIds();
            CopyOnWriteLongList listExtents = getPersistentExtents();
            
            // need to "ensure" all of the cache-ids outside of the excludes
            for (com.tangosol.util.LongArray.Iterator iter = laCaches.iterator(); iter.hasNext(); )
                {
                iter.next();
            
                long lCacheId = iter.getIndex();
            
                if (laExtentsExclude == null ||
                    !laExtentsExclude.exists(lCacheId))
                    {
                    listExtents.add(lCacheId);
                    }
                }
            }
        
        // Declared at the super level
        /**
         * Truncate the provided extent if it has been ensured.
        * 
        * @param lExtentId  the extent to ensure
         */
        public void truncatePersistentExtent(long lExtentId)
            {
            // import com.oracle.coherence.persistence.PersistentStore;
            
            if (!getPersistentExtents().contains(lExtentId))
                {
                getPersistentStore().truncateExtent(lExtentId);
            
                PersistentStore storeEvents = getPersistentEventsStore();
                if (storeEvents != null)
                    {
                    storeEvents.truncateExtent(lExtentId);
                    }
                }
            // else extent has not been created
            }
        
        // Declared at the super level
        /**
         * There are two ways the partition storage statistics are calculated.
        * If the backing map is a PartitionAwareBackingMap and also
        * a ConfigurableCacheMap with BinaryCalculator, then the storage size
        * is retrieved directly using getUnits. Otherwise,  the statistics are
        * updated as changes occur - see
        * PartitionedCache$Storage#onBackingMapEvent().
         */
        public com.tangosol.net.partition.PartitionStatistics updateDirectStorageSize()
            {
            // import com.tangosol.net.cache.ConfigurableCacheMap as com.tangosol.net.cache.ConfigurableCacheMap;
            // import com.tangosol.net.partition.PartitionAwareBackingMap as com.tangosol.net.partition.PartitionAwareBackingMap;
            // import java.util.Iterator;
            
            PartitionedCache service   = (PartitionedCache) get_Module();
            long    cbStorage = 0;
            int     nPart     = getPartitionId();
            
            for (Iterator iterStore = service.getStorageArray().iterator(); iterStore.hasNext();)
                {
                Storage storage = (Storage) iterStore.next();
                if (!storage.isAdjustPartitionSize())
                    {
                    com.tangosol.net.partition.PartitionAwareBackingMap mapPABM = storage.getPartitionAwareBackingMap();
                    if (mapPABM != null)
                        {
                        com.tangosol.net.cache.ConfigurableCacheMap mapCCM = (com.tangosol.net.cache.ConfigurableCacheMap) mapPABM.getPartitionMap(nPart);
                        cbStorage += mapCCM.getUnits() * mapCCM.getUnitFactor();
                        }
                    }
                }
            
            return getStatistics().setDirectStorageSize(cbStorage);
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$PartitionRecoverRequest
    
    /**
     * Sent to a member to request it to recover a partition from persistent
     * storage.
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class PartitionRecoverRequest
            extends    com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.PartitionRecoverRequest
        {
        // ---- Fields declarations ----
        private static com.tangosol.util.ListMap __mapChildren;
        
        // Static initializer
        static
            {
            __initStatic();
            }
        
        // Default static initializer
        private static void __initStatic()
            {
            // register child classes
            __mapChildren = new com.tangosol.util.ListMap();
            __mapChildren.put("Poll", com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.PartitionRecoverRequest.Poll.get_CLASS());
            __mapChildren.put("RecoverJob", com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.PartitionRecoverRequest.RecoverJob.get_CLASS());
            }
        
        // Default constructor
        public PartitionRecoverRequest()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public PartitionRecoverRequest(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                setMessageType(43);
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // containment initialization: children
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.PartitionRecoverRequest();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$PartitionRecoverRequest".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        //++ getter for autogen property _ChildClasses
        /**
         * This is an auto-generated method that returns the map of design time
        * [static] children.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        protected java.util.Map get_ChildClasses()
            {
            return __mapChildren;
            }
        
        // Declared at the super level
        /**
         * Setter for property RequestTimeout.<p>
        * Transient property optionally used on the client to indicate the
        * (safe local) time after which this logical request should be
        * considered timed out.
        * 
        * Note that a single logical request message may result in multiple
        * physical request messages being sent to mulitple members; this
        * RequestTimeout value will be cloned to all resulting RequestMessage
        * instances.
        * 
        * This value is lazily calculated by #getRequestTimeout or
        * #calculateTimeoutRemaining.
         */
        public void setRequestTimeout(long ldtTimeout)
            {
            super.setRequestTimeout(ldtTimeout);
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$PartitionSwapRequest
    
    /**
     * PartitionSwapRequest is sent by the primary partition owner to backup
     * owners to swap storage indices.  While this message is logically
     * directed at 2 members (the members that will be "swapping" backup
     * ownership), it will be delivered and chained through each of the
     * preceding backup owners.
     * 
     * For example, suppose a partition ownership: (M1,M2,M3,M4)
     * 
     * If the primary owner M1 wishes to swap the backup ownership for M3,M4
     * making the desired ownership (M1,M2,M4,M3), it will send a
     * PartitionSwapRequest to the MemberList: [M2,M4,M3].
     * 
     * The PartitionSwapRequest may only be used to swap "adjacent" backup
     * owners.  (i.e. in the prior example of (M1,M2,M3,M4), swap of M3 and M4
     * is allowed, swap of M2 and M3 is allowed, but a direct swap of M2 and M4
     * is disallowed and must be accomplished by a composite of 2 swap
     * operations).
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class PartitionSwapRequest
            extends    com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.PartitionSwapRequest
        {
        // ---- Fields declarations ----
        private static com.tangosol.util.ListMap __mapChildren;
        
        // Static initializer
        static
            {
            __initStatic();
            }
        
        // Default static initializer
        private static void __initStatic()
            {
            // register child classes
            __mapChildren = new com.tangosol.util.ListMap();
            __mapChildren.put("Poll", com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.PartitionSwapRequest.Poll.get_CLASS());
            }
        
        // Default constructor
        public PartitionSwapRequest()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public PartitionSwapRequest(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                setMessageType(39);
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // containment initialization: children
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.PartitionSwapRequest();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$PartitionSwapRequest".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        //++ getter for autogen property _ChildClasses
        /**
         * This is an auto-generated method that returns the map of design time
        * [static] children.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        protected java.util.Map get_ChildClasses()
            {
            return __mapChildren;
            }
        
        // Declared at the super level
        /**
         * Setter for property RequestTimeout.<p>
        * Transient property optionally used on the client to indicate the
        * (safe local) time after which this logical request should be
        * considered timed out.
        * 
        * Note that a single logical request message may result in multiple
        * physical request messages being sent to mulitple members; this
        * RequestTimeout value will be cloned to all resulting RequestMessage
        * instances.
        * 
        * This value is lazily calculated by #getRequestTimeout or
        * #calculateTimeoutRemaining.
         */
        public void setRequestTimeout(long ldtTimeout)
            {
            super.setRequestTimeout(ldtTimeout);
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$PartitionVersionSyncRequest
    
    /**
     * A PartitionVersionSyncRequest is sent from the primary partition owner
     * to all of its backups in order to synchronize the current partition
     * version.
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class PartitionVersionSyncRequest
            extends    com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.PartitionVersionSyncRequest
        {
        // ---- Fields declarations ----
        private static com.tangosol.util.ListMap __mapChildren;
        
        // Static initializer
        static
            {
            __initStatic();
            }
        
        // Default static initializer
        private static void __initStatic()
            {
            // register child classes
            __mapChildren = new com.tangosol.util.ListMap();
            __mapChildren.put("Poll", com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.PartitionVersionSyncRequest.Poll.get_CLASS());
            }
        
        // Default constructor
        public PartitionVersionSyncRequest()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public PartitionVersionSyncRequest(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                setMessageType(41);
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // containment initialization: children
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.PartitionVersionSyncRequest();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$PartitionVersionSyncRequest".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        //++ getter for autogen property _ChildClasses
        /**
         * This is an auto-generated method that returns the map of design time
        * [static] children.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        protected java.util.Map get_ChildClasses()
            {
            return __mapChildren;
            }
        
        // Declared at the super level
        /**
         * Setter for property RequestTimeout.<p>
        * Transient property optionally used on the client to indicate the
        * (safe local) time after which this logical request should be
        * considered timed out.
        * 
        * Note that a single logical request message may result in multiple
        * physical request messages being sent to mulitple members; this
        * RequestTimeout value will be cloned to all resulting RequestMessage
        * instances.
        * 
        * This value is lazily calculated by #getRequestTimeout or
        * #calculateTimeoutRemaining.
         */
        public void setRequestTimeout(long ldtTimeout)
            {
            super.setRequestTimeout(ldtTimeout);
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$PersistenceControl
    
    /**
     * The PersistenceControl manages the persistence-related state and
     * functionality.
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class PersistenceControl
            extends    com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.PersistenceControl
        {
        // ---- Fields declarations ----
        private static com.tangosol.util.ListMap __mapChildren;
        
        // Static initializer
        static
            {
            __initStatic();
            }
        
        // Default static initializer
        private static void __initStatic()
            {
            // register child classes
            __mapChildren = new com.tangosol.util.ListMap();
            __mapChildren.put("EventsVisitor", PartitionedCache.PersistenceControl.EventsVisitor.get_CLASS());
            __mapChildren.put("RecoveryVisitor", PartitionedCache.PersistenceControl.RecoveryVisitor.get_CLASS());
            __mapChildren.put("SnapshotBuilder", PartitionedCache.PersistenceControl.SnapshotBuilder.get_CLASS());
            __mapChildren.put("SnapshotController", com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.PersistenceControl.SnapshotController.get_CLASS());
            }
        
        // Default constructor
        public PersistenceControl()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public PersistenceControl(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                setActiveRecoveryRequests(new java.util.concurrent.atomic.AtomicInteger());
                setPartitionVersionExclusionList(new com.tangosol.net.internal.PartitionVersionExclusionList());
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // containment initialization: children
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.PersistenceControl();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$PersistenceControl".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        //++ getter for autogen property _ChildClasses
        /**
         * This is an auto-generated method that returns the map of design time
        * [static] children.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        protected java.util.Map get_ChildClasses()
            {
            return __mapChildren;
            }
        
        /**
         * Instantiate and return a RecoveryVisitor.
        * 
        * @param listRequests  a list of requests that will be posted to the
        * service after recovery is complete
         */
        public PartitionedCache.PersistenceControl.RecoveryVisitor instantiateRecoveryVisitor(java.util.List listRequests)
            {
            PartitionedCache.PersistenceControl.RecoveryVisitor visitor = (PartitionedCache.PersistenceControl.RecoveryVisitor) _newChild("RecoveryVisitor");
            visitor.setRequestList(listRequests);
            
            return visitor;
            }

        // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$PersistenceControl$EventsVisitor
        
        /**
         * PersistentStore.Visitor that is used to recovered persisted data
         * during partition recovery.
         */
        @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
        public static class EventsVisitor
                extends    com.tangosol.coherence.component.Util
                implements com.oracle.coherence.persistence.PersistentStore.Visitor
            {
            // ---- Fields declarations ----
            
            /**
             * Property Partition
             *
             * The partition being recovered.
             */
            private int __m_Partition;
            
            /**
             * Property RequestList
             *
             * An optional list of requests that will be posted to the service
             * after recovery is complete.
             */
            private java.util.List __m_RequestList;
            
            /**
             * Property StatsEntriesRecovered
             *
             */
            private transient int __m_StatsEntriesRecovered;
            
            /**
             * Property StorageArray
             *
             * A LongArray of $Storage instances, indexed by the cache IDs as
             * they are persisted in the recovery source PersistentStore.
             */
            private com.tangosol.util.LongArray __m_StorageArray;
            
            /**
             * Property StorageArrayPrev
             *
             * A LongArray of $Storage instances, indexed by the cache IDs as
             * they are persisted in the recovery source PersistentStore.
             */
            private com.tangosol.util.LongArray __m_StorageArrayPrev;
            
            // Default constructor
            public EventsVisitor()
                {
                this(null, null, true);
                }
            
            // Initializing constructor
            public EventsVisitor(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                {
                super(sName, compParent, false);
                
                if (fInit)
                    {
                    __init();
                    }
                }
            
            // Main initializer
            public void __init()
                {
                // private initialization
                __initPrivate();
                
                
                // signal the end of the initialization
                set_Constructed(true);
                }
            
            // Private initializer
            protected void __initPrivate()
                {
                
                super.__initPrivate();
                }
            
            //++ getter for static property _Instance
            /**
             * Getter for property _Instance.<p>
            * Auto generated
             */
            public static com.tangosol.coherence.Component get_Instance()
                {
                return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.PersistenceControl.EventsVisitor();
                }
            
            //++ getter for static property _CLASS
            /**
             * Getter for property _CLASS.<p>
            * Property with auto-generated accessor that returns the Class
            * object for a given component.
             */
            public static Class get_CLASS()
                {
                Class clz;
                try
                    {
                    clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$PersistenceControl$EventsVisitor".replace('/', '.'));
                    }
                catch (ClassNotFoundException e)
                    {
                    throw new NoClassDefFoundError(e.getMessage());
                    }
                return clz;
                }
            
            //++ getter for autogen property _Module
            /**
             * This is an auto-generated method that returns the global [design
            * time] parent component.
            * 
            * Note: the class generator will ignore any custom implementation
            * for this behavior.
             */
            private com.tangosol.coherence.Component get_Module()
                {
                return this.get_Parent().get_Parent();
                }
            
            /**
             * Return the Member which joined this PartitionedCache service with
            * the specified join time, or null if no such member exists (or
            * remains).
             */
            protected com.tangosol.coherence.component.net.Member getJoinedMember(long ldtJoined)
                {
                PartitionedCache service = (PartitionedCache) get_Module();
                
                return service.getServiceMemberSet().getJoinedMember(ldtJoined);
                }
            
            // Accessor for the property "Partition"
            /**
             * Getter for property Partition.<p>
            * The partition being recovered.
             */
            public int getPartition()
                {
                return __m_Partition;
                }
            
            // Accessor for the property "PartitionControl"
            /**
             * Getter for property PartitionControl.<p>
            * Return the PartitionControl for this recovery op.
             */
            public com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.PartitionControl getPartitionControl()
                {
                return ((PartitionedCache) get_Module()).getPartitionControl(getPartition());
                }
            
            // Accessor for the property "RequestList"
            /**
             * Getter for property RequestList.<p>
            * An optional list of requests that will be posted to the service
            * after recovery is complete.
             */
            public java.util.List getRequestList()
                {
                return __m_RequestList;
                }
            
            // Accessor for the property "StatsEntriesRecovered"
            /**
             * Getter for property StatsEntriesRecovered.<p>
             */
            public int getStatsEntriesRecovered()
                {
                return __m_StatsEntriesRecovered;
                }
            
            protected Storage getStorage(long lOldCacheId)
                {
                return (Storage) getStorageArray().get(lOldCacheId);
                }
            
            // Accessor for the property "StorageArray"
            /**
             * Getter for property StorageArray.<p>
            * A LongArray of $Storage instances, indexed by the cache IDs as
            * they are persisted in the recovery source PersistentStore.
             */
            public com.tangosol.util.LongArray getStorageArray()
                {
                return __m_StorageArray;
                }
            
            // Accessor for the property "StorageArrayPrev"
            /**
             * Getter for property StorageArrayPrev.<p>
            * A LongArray of $Storage instances, indexed by the cache IDs as
            * they are persisted in the recovery source PersistentStore.
             */
            public com.tangosol.util.LongArray getStorageArrayPrev()
                {
                return __m_StorageArrayPrev;
                }
            
            // Accessor for the property "Partition"
            /**
             * Setter for property Partition.<p>
            * The partition being recovered.
             */
            public void setPartition(int nPartition)
                {
                __m_Partition = nPartition;
                }
            
            // Accessor for the property "RequestList"
            /**
             * Setter for property RequestList.<p>
            * An optional list of requests that will be posted to the service
            * after recovery is complete.
             */
            public void setRequestList(java.util.List listRequest)
                {
                __m_RequestList = listRequest;
                }
            
            // Accessor for the property "StatsEntriesRecovered"
            /**
             * Setter for property StatsEntriesRecovered.<p>
             */
            public void setStatsEntriesRecovered(int sProperty)
                {
                __m_StatsEntriesRecovered = sProperty;
                }
            
            // Accessor for the property "StorageArray"
            /**
             * Setter for property StorageArray.<p>
            * A LongArray of $Storage instances, indexed by the cache IDs as
            * they are persisted in the recovery source PersistentStore.
             */
            public void setStorageArray(com.tangosol.util.LongArray laStorage)
                {
                __m_StorageArray = laStorage;
                }
            
            // Accessor for the property "StorageArrayPrev"
            /**
             * Setter for property StorageArrayPrev.<p>
            * A LongArray of $Storage instances, indexed by the cache IDs as
            * they are persisted in the recovery source PersistentStore.
             */
            public void setStorageArrayPrev(com.tangosol.util.LongArray laStorage)
                {
                __m_StorageArrayPrev = laStorage;
                }
            
            // From interface: com.oracle.coherence.persistence.PersistentStore$Visitor
            public boolean visit(long Param_1, Object Param_2, Object Param_3)
                {
                return false;
                }
            }

        // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$PersistenceControl$RecoveryVisitor
        
        /**
         * PersistentStore.Visitor that is used to recovered persisted data
         * during partition recovery.
         */
        @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
        public static class RecoveryVisitor
                extends    com.tangosol.coherence.component.Util
                implements com.tangosol.persistence.CachePersistenceHelper.Visitor
            {
            // ---- Fields declarations ----
            
            /**
             * Property Partition
             *
             * The partition being recovered.
             */
            private int __m_Partition;
            
            /**
             * Property RequestList
             *
             * An optional list of requests that will be posted to the service
             * after recovery is complete.
             */
            private java.util.List __m_RequestList;
            
            /**
             * Property StatsEntriesRecovered
             *
             */
            private transient int __m_StatsEntriesRecovered;
            
            /**
             * Property StorageArray
             *
             * A LongArray of $Storage instances, indexed by the cache IDs as
             * they are persisted in the recovery source PersistentStore.
             */
            private com.tangosol.util.LongArray __m_StorageArray;
            
            /**
             * Property StorageArrayPrev
             *
             * A LongArray of $Storage instances, indexed by the cache IDs as
             * they are persisted in the recovery source PersistentStore.
             */
            private com.tangosol.util.LongArray __m_StorageArrayPrev;
            
            // Default constructor
            public RecoveryVisitor()
                {
                this(null, null, true);
                }
            
            // Initializing constructor
            public RecoveryVisitor(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                {
                super(sName, compParent, false);
                
                if (fInit)
                    {
                    __init();
                    }
                }
            
            // Main initializer
            public void __init()
                {
                // private initialization
                __initPrivate();
                
                
                // signal the end of the initialization
                set_Constructed(true);
                }
            
            // Private initializer
            protected void __initPrivate()
                {
                
                super.__initPrivate();
                }
            
            //++ getter for static property _Instance
            /**
             * Getter for property _Instance.<p>
            * Auto generated
             */
            public static com.tangosol.coherence.Component get_Instance()
                {
                return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.PersistenceControl.RecoveryVisitor();
                }
            
            //++ getter for static property _CLASS
            /**
             * Getter for property _CLASS.<p>
            * Property with auto-generated accessor that returns the Class
            * object for a given component.
             */
            public static Class get_CLASS()
                {
                Class clz;
                try
                    {
                    clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$PersistenceControl$RecoveryVisitor".replace('/', '.'));
                    }
                catch (ClassNotFoundException e)
                    {
                    throw new NoClassDefFoundError(e.getMessage());
                    }
                return clz;
                }
            
            //++ getter for autogen property _Module
            /**
             * This is an auto-generated method that returns the global [design
            * time] parent component.
            * 
            * Note: the class generator will ignore any custom implementation
            * for this behavior.
             */
            private com.tangosol.coherence.Component get_Module()
                {
                return this.get_Parent().get_Parent();
                }
            
            /**
             * Return the Member which joined this PartitionedCache service with
            * the specified join time, or null if no such member exists (or
            * remains).
             */
            protected com.tangosol.coherence.component.net.Member getJoinedMember(long ldtJoined)
                {
                PartitionedCache service = (PartitionedCache) get_Module();
                
                return service.getServiceMemberSet().getJoinedMember(ldtJoined);
                }
            
            // Accessor for the property "Partition"
            /**
             * Getter for property Partition.<p>
            * The partition being recovered.
             */
            public int getPartition()
                {
                return __m_Partition;
                }
            
            // Accessor for the property "PartitionControl"
            /**
             * Getter for property PartitionControl.<p>
            * Return the PartitionControl for this recovery op.
             */
            public com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.PartitionControl getPartitionControl()
                {
                return ((PartitionedCache) get_Module()).getPartitionControl(getPartition());
                }
            
            // Accessor for the property "RequestList"
            /**
             * Getter for property RequestList.<p>
            * An optional list of requests that will be posted to the service
            * after recovery is complete.
             */
            public java.util.List getRequestList()
                {
                return __m_RequestList;
                }
            
            // Accessor for the property "StatsEntriesRecovered"
            /**
             * Getter for property StatsEntriesRecovered.<p>
             */
            public int getStatsEntriesRecovered()
                {
                return __m_StatsEntriesRecovered;
                }
            
            protected Storage getStorage(long lOldCacheId)
                {
                return (Storage) getStorageArray().get(lOldCacheId);
                }
            
            // Accessor for the property "StorageArray"
            /**
             * Getter for property StorageArray.<p>
            * A LongArray of $Storage instances, indexed by the cache IDs as
            * they are persisted in the recovery source PersistentStore.
             */
            public com.tangosol.util.LongArray getStorageArray()
                {
                return __m_StorageArray;
                }
            
            // Accessor for the property "StorageArrayPrev"
            /**
             * Getter for property StorageArrayPrev.<p>
            * A LongArray of $Storage instances, indexed by the cache IDs as
            * they are persisted in the recovery source PersistentStore.
             */
            public com.tangosol.util.LongArray getStorageArrayPrev()
                {
                return __m_StorageArrayPrev;
                }
            
            // Accessor for the property "Partition"
            /**
             * Setter for property Partition.<p>
            * The partition being recovered.
             */
            public void setPartition(int nPartition)
                {
                __m_Partition = nPartition;
                }
            
            // Accessor for the property "RequestList"
            /**
             * Setter for property RequestList.<p>
            * An optional list of requests that will be posted to the service
            * after recovery is complete.
             */
            public void setRequestList(java.util.List listRequest)
                {
                __m_RequestList = listRequest;
                }
            
            // Accessor for the property "StatsEntriesRecovered"
            /**
             * Setter for property StatsEntriesRecovered.<p>
             */
            public void setStatsEntriesRecovered(int sProperty)
                {
                __m_StatsEntriesRecovered = sProperty;
                }
            
            // Accessor for the property "StorageArray"
            /**
             * Setter for property StorageArray.<p>
            * A LongArray of $Storage instances, indexed by the cache IDs as
            * they are persisted in the recovery source PersistentStore.
             */
            public void setStorageArray(com.tangosol.util.LongArray laStorage)
                {
                __m_StorageArray = laStorage;
                }
            
            // Accessor for the property "StorageArrayPrev"
            /**
             * Setter for property StorageArrayPrev.<p>
            * A LongArray of $Storage instances, indexed by the cache IDs as
            * they are persisted in the recovery source PersistentStore.
             */
            public void setStorageArrayPrev(com.tangosol.util.LongArray laStorage)
                {
                __m_StorageArrayPrev = laStorage;
                }
            
            // From interface: com.tangosol.persistence.CachePersistenceHelper$Visitor
            public boolean visitCacheEntry(long lOldCacheId, com.tangosol.util.Binary binKey, com.tangosol.util.Binary binValue)
                {
                Storage storage = getStorage(lOldCacheId);
                if (storage != null)
                    {
                    getPartitionControl().ensurePersistentExtent(storage.getCacheId());
                    // recover to primary storage
                    storage.putPrimaryResource(binKey, binValue);
                
                    setStatsEntriesRecovered(getStatsEntriesRecovered() + 1);
                    }
                else
                    {
                    PartitionedCache service = (PartitionedCache) get_Module();
                    Object  oValue  = getStorageArrayPrev().get(lOldCacheId);
                
                    if (!(oValue instanceof Boolean))
                        {
                        // either String or null
                        String  sCacheName = (String) oValue;
                        boolean fDestroyed = sCacheName != null && service.getStorageGraveyard().containsValue(sCacheName);
                
                        _trace("Unable to locate Storage instance for cache '" + sCacheName +
                                "'; old-cache-ids: " + getStorageArrayPrev() +
                                ", new-cache-ids: " + getStorageArray() +
                                ", cache-destroyed: " +  fDestroyed,  2);
                
                        getStorageArrayPrev().set(lOldCacheId, Boolean.valueOf(true));
                        }
                    }
                //else: only possible if storage was destroyed and the store was not updated
                
                return true;
                }
            
            // From interface: com.tangosol.persistence.CachePersistenceHelper$Visitor
            public boolean visitIndex(long lOldCacheId, com.tangosol.util.Binary binExtractor, com.tangosol.util.Binary binComparator)
                {
                // import com.tangosol.io.Serializer;
                // import com.tangosol.persistence.CachePersistenceHelper as com.tangosol.persistence.CachePersistenceHelper;
                // import com.tangosol.util.ExternalizableHelper as com.tangosol.util.ExternalizableHelper;
                // import com.tangosol.util.ValueExtractor as com.tangosol.util.ValueExtractor;
                // import java.util.Comparator;
                // import java.util.List;
                
                Storage storage = getStorage(lOldCacheId);
                if (storage == null)
                    {
                    // TODO: this shouldn't happen; it probably means that the cache
                    //       was concurrently destroyed during the restore
                    }
                else
                    {
                    PartitionedCache    service    = (PartitionedCache) get_Module();
                    Serializer serializer = service.getSerializer();
                    com.tangosol.util.ValueExtractor  extractor  = (com.tangosol.util.ValueExtractor)  com.tangosol.util.ExternalizableHelper.fromBinary(binExtractor, serializer);
                    Comparator comparator = (Comparator) com.tangosol.util.ExternalizableHelper.fromBinary(binComparator, serializer);
                    long       lCacheId   = storage.getCacheId();  // the "new" cache-id
                
                    // As we currently rely on some subset of partitions to store "global"
                    // metadata (such as index registrations), recovery of the metadata cannot
                    // be applied "locally" on each storage member; it must be done globally
                    // by sending an IndexRequest (as is done at join-time by #createWelcomeRequests)
                    //
                    // See also CPH#isGlobalPartitioningSchemePID
                    List listRequests = getRequestList();
                    if (listRequests != null)
                        {
                        PartitionedCache.IndexRequest msgRequest = (PartitionedCache.IndexRequest) service.instantiateMessage("IndexRequest");
                        msgRequest.setCacheId   (lCacheId);
                        msgRequest.setAdd       (true);
                        msgRequest.setExtractor (extractor);
                        msgRequest.setOrdered   (comparator != null);
                        msgRequest.setComparator(comparator);
                        msgRequest.addToMember(service.getOwnershipSenior(true));
                        listRequests.add(msgRequest);
                        }
                    }
                
                return true;
                }
            
            // From interface: com.tangosol.persistence.CachePersistenceHelper$Visitor
            public boolean visitListener(long lOldCacheId, com.tangosol.util.Binary binKey, long lMemberId, boolean fLite)
                {
                // import Component.Net.Member as com.tangosol.coherence.component.net.Member;
                
                Storage storage = getStorage(lOldCacheId);
                if (storage == null)
                    {
                    // TODO: this shouldn't happen; it probably means that the cache
                    //       was concurrently destroyed during the restore
                    }
                else
                    {
                    com.tangosol.coherence.component.net.Member memberListener = getJoinedMember(lMemberId);
                    if (memberListener != null)
                        {
                        // similar to persistListenerRegistration the persistent extent
                        // is ensured when adding a key listener
                        getPartitionControl().ensurePersistentExtent(storage.getCacheId());
                
                        // recover to primary storage (will also write to persistent store)
                        storage.addKeyListener(memberListener, binKey, fLite, true);
                        }
                    }
                
                return true;
                }
            
            // From interface: com.tangosol.persistence.CachePersistenceHelper$Visitor
            public boolean visitLock(long lOldCacheId, com.tangosol.util.Binary binKey, long lHolderId, long lHolderThreadId)
                {
                // import Component.Net.Lease;
                // import Component.Net.Member;
                
                Storage storage = getStorage(lOldCacheId);
                if (storage == null)
                    {
                    // TODO: this shouldn't happen; it probably means that the cache
                    //       was concurrently destroyed during the restore
                    }
                else
                    {
                    Member memberHolder = getJoinedMember(lHolderId);
                    if (memberHolder != null)
                        {
                        // recover to primary storage (will also write to persistent store)
                        Lease lease = Lease.instantiate(0, binKey, storage.getService());
                
                        lease.setHolderId      (memberHolder.getId());
                        lease.setHolderThreadId(lHolderThreadId);
                
                        if (!storage.lock(lease))
                            {
                            // shouldn't be possible at this point to fail to lock...
                            }
                        }
                    }
                
                return true;
                }
            
            // From interface: com.tangosol.persistence.CachePersistenceHelper$Visitor
            public boolean visitTrigger(long lOldCacheId, com.tangosol.util.Binary binTrigger)
                {
                // import com.tangosol.io.Serializer;
                // import com.tangosol.persistence.CachePersistenceHelper as com.tangosol.persistence.CachePersistenceHelper;
                // import com.tangosol.util.ExternalizableHelper as com.tangosol.util.ExternalizableHelper;
                // import com.tangosol.util.MapTrigger;
                // import java.util.List;
                
                Storage storage = getStorage(lOldCacheId);
                if (storage == null)
                    {
                    // TODO: this shouldn't happen; it probably means that the cache
                    //       was concurrently destroyed during the restore
                    }
                else
                    {
                    PartitionedCache    service    = (PartitionedCache) get_Module();
                    Serializer serializer = service.getSerializer();
                    MapTrigger trigger    = (MapTrigger) com.tangosol.util.ExternalizableHelper.fromBinary(binTrigger, serializer);
                    long       lCacheId   = storage.getCacheId();  // the "new" cache-id
                
                    // As we currently rely on some subset of partitions to store "global"
                    // metadata (such as trigger registrations), recovery of the metadata cannot
                    // be applied "locally" on each storage member; it must be done globally
                    // by sending an ListenerRequest (as is done at join-time by #createWelcomeRequests)
                    //
                    // See also CPH#isGlobalPartitioningSchemePID
                    List listRequests = getRequestList();
                    if (listRequests != null)
                        {
                        PartitionedCache.ListenerRequest msgRequest = (PartitionedCache.ListenerRequest) service.instantiateMessage("ListenerRequest");
                        msgRequest.setCacheId(lCacheId);
                        msgRequest.setAdd(true);
                        msgRequest.setTrigger(trigger);
                        msgRequest.addToMember(service.getOwnershipSenior(true));
                        listRequests.add(msgRequest);
                        }
                    }
                
                return true;
                }
            }

        // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$PersistenceControl$SnapshotBuilder
        
        /**
         * SnapshotBuilder encapsulates the state associated with a request to
         * build a persistent snapshot (which may be carried out
         * asynchronously).
         */
        @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
        public static class SnapshotBuilder
                extends    com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.PersistenceControl.SnapshotBuilder
            {
            // ---- Fields declarations ----
            
            // Default constructor
            public SnapshotBuilder()
                {
                this(null, null, true);
                }
            
            // Initializing constructor
            public SnapshotBuilder(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                {
                super(sName, compParent, false);
                
                if (fInit)
                    {
                    __init();
                    }
                }
            
            // Main initializer
            public void __init()
                {
                // private initialization
                __initPrivate();
                
                // state initialization: public and protected properties
                try
                    {
                    setPartition(-1);
                    }
                catch (java.lang.Exception e)
                    {
                    // re-throw as a runtime exception
                    throw new com.tangosol.util.WrapperException(e);
                    }
                
                // signal the end of the initialization
                set_Constructed(true);
                }
            
            // Private initializer
            protected void __initPrivate()
                {
                
                super.__initPrivate();
                }
            
            //++ getter for static property _Instance
            /**
             * Getter for property _Instance.<p>
            * Auto generated
             */
            public static com.tangosol.coherence.Component get_Instance()
                {
                return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.PersistenceControl.SnapshotBuilder();
                }
            
            //++ getter for static property _CLASS
            /**
             * Getter for property _CLASS.<p>
            * Property with auto-generated accessor that returns the Class
            * object for a given component.
             */
            public static Class get_CLASS()
                {
                Class clz;
                try
                    {
                    clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$PersistenceControl$SnapshotBuilder".replace('/', '.'));
                    }
                catch (ClassNotFoundException e)
                    {
                    throw new NoClassDefFoundError(e.getMessage());
                    }
                return clz;
                }
            
            //++ getter for autogen property _Module
            /**
             * This is an auto-generated method that returns the global [design
            * time] parent component.
            * 
            * Note: the class generator will ignore any custom implementation
            * for this behavior.
             */
            private com.tangosol.coherence.Component get_Module()
                {
                return this.get_Parent().get_Parent();
                }
            
            // Declared at the super level
            /**
             * Remove the caches that are not intented to be snapshotted from
            * the copied store.
             */
            public void removeTransientCaches(com.oracle.coherence.persistence.PersistentStore store)
                {
                // import com.tangosol.net.BackingMapManager;
                // import com.tangosol.persistence.CachePersistenceHelper as com.tangosol.persistence.CachePersistenceHelper;
                // import com.tangosol.util.LongArray;
                
                PartitionedCache           service         = (PartitionedCache) getService();
                BackingMapManager manager         = service.getBackingMapManager();
                long[]            alCacheId       = store.extents();
                LongArray         laCaches        = com.tangosol.persistence.CachePersistenceHelper.getCacheNames(store);
                boolean           fWriteCacheName = false;
                
                for (int i = 0, c = alCacheId.length; i < c; i++)
                    {
                    long   lCacheId = alCacheId[i];
                    String sName    = (String) laCaches.get(lCacheId);
                    if (sName != null && !manager.isBackingMapPersistent(sName, true))
                        {
                        com.tangosol.persistence.CachePersistenceHelper.deleteExtents(store, lCacheId);
                        laCaches.remove(lCacheId);
                        fWriteCacheName = true;
                        }
                    }
                
                if (fWriteCacheName)
                    {
                    com.tangosol.persistence.CachePersistenceHelper.storeCacheNames(store, laCaches);
                    }
                }
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$PinningIterator
    
    /**
     * A specialized iterator that iterates through the underlying Set of
     * Binary keys or Entries and read-locks (pins) all necessary partitions.
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class PinningIterator
            extends    com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.PinningIterator
        {
        // ---- Fields declarations ----
        
        // Default constructor
        public PinningIterator()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public PinningIterator(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.PinningIterator();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$PinningIterator".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        // Declared at the super level
        /**
         * Enter the partition.
        * 
        * This method is overridden by the PartitionCache to ensure that the
        * index can be used for that partition.
        * 
        * @return true iff the partition is successfully entered
         */
        protected boolean enterPartition(int nPartition)
            {
            boolean fEntered = super.enterPartition(nPartition);
            
            if (fEntered)
                {
                ((PartitionedCache) get_Module()).ensureIndexReady(nPartition);
                }
            
            return fEntered;
            }
        
        // Declared at the super level
        /**
         * Setter for property RejectedPartitions.<p>
        * Partitions that could not be locked; could be null.
         */
        public void setRejectedPartitions(com.tangosol.net.partition.PartitionSet partitions)
            {
            super.setRejectedPartitions(partitions);
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$PutAllRequest
    
    /**
     * @see $BinaryMap#putAll
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class PutAllRequest
            extends    com.tangosol.coherence.component.net.message.requestMessage.distributedCacheRequest.MapRequest
        {
        // ---- Fields declarations ----
        private static com.tangosol.util.ListMap __mapChildren;
        
        // Static initializer
        static
            {
            __initStatic();
            }
        
        // Default static initializer
        private static void __initStatic()
            {
            // register child classes
            __mapChildren = new com.tangosol.util.ListMap();
            __mapChildren.put("Poll", PartitionedCache.PutAllRequest.Poll.get_CLASS());
            }
        
        // Default constructor
        public PutAllRequest()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public PutAllRequest(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                setMessageType(71);
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // containment initialization: children
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        // Getter for virtual constant ReadOnly
        public boolean isReadOnly()
            {
            return false;
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.PutAllRequest();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$PutAllRequest".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        //++ getter for autogen property _ChildClasses
        /**
         * This is an auto-generated method that returns the map of design time
        * [static] children.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        protected java.util.Map get_ChildClasses()
            {
            return __mapChildren;
            }
        
        // Declared at the super level
        /**
         * Instantiate and return a Map to hold the entries for this request.
        * 
        * @param cEntries  the size of the map
         */
        protected java.util.Map instantiateEntryMap(int cEntries)
            {
            PartitionedCache service = (PartitionedCache) get_Module();
            
            // no need to sort now if we are single threaded
            return service.isConcurrent()
                ? new NullableSortedMap()
                : super.instantiateEntryMap(cEntries);
            }
        
        // Declared at the super level
        /**
         * This is the event that is executed when a Message is received.
        * <p>
        * It is the main processing event of the Message called by the
        * <code>Service.onMessage()</code> event. With regards to the use of
        * Message components within clustered Services, Services are designed
        * by dragging Message components into them as static children. These
        * Messages are the components that a Service can send to other running
        * instances of the same Service within a cluster. When the onReceived
        * event is invoked by a Service, it means that the Message has been
        * received; the code in the onReceived event is therefore the Message
        * specific logic for processing a received Message. For example, when
        * onReceived is invoked on a Message named FindData, the onReceived
        * event should do the work to "find the data", because it is being
        * invoked by the Service that received the "find the data" Message.
         */
        public void onReceived()
            {
            PartitionedCache service = (PartitionedCache) getService();
            service.getDaemonPool().add(this);
            }
        
        // Declared at the super level
        public void run()
            {
            ((PartitionedCache) get_Module()).onPutAllRequest(this);
            }
        
        // Declared at the super level
        /**
         * Setter for property RequestTimeout.<p>
        * Transient property optionally used on the client to indicate the
        * (safe local) time after which this logical request should be
        * considered timed out.
        * 
        * Note that a single logical request message may result in multiple
        * physical request messages being sent to mulitple members; this
        * RequestTimeout value will be cloned to all resulting RequestMessage
        * instances.
        * 
        * This value is lazily calculated by #getRequestTimeout or
        * #calculateTimeoutRemaining.
         */
        public void setRequestTimeout(long ldtTimeout)
            {
            super.setRequestTimeout(ldtTimeout);
            }

        // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$PutAllRequest$Poll
        
        /**
         * The Poll contains information regarding a request sent to one or
         * more Cluster Members that require responses. A Service may poll
         * other Members that are running the same Service, and the Poll is
         * used to wait for and assemble the responses from each of those
         * Members. A client thread may also use the Poll to block on a
         * response or set of responses, thus waiting for the completion of the
         * Poll. In its simplest form, which is a Poll that is sent to one
         * Member of the Cluster, the Poll actually represents the
         * request/response model.
         */
        @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
        public static class Poll
                extends    com.tangosol.coherence.component.net.message.requestMessage.distributedCacheRequest.MapRequest.Poll
            {
            // ---- Fields declarations ----
            
            // Default constructor
            public Poll()
                {
                this(null, null, true);
                }
            
            // Initializing constructor
            public Poll(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                {
                super(sName, compParent, false);
                
                if (fInit)
                    {
                    __init();
                    }
                }
            
            // Main initializer
            public void __init()
                {
                // private initialization
                __initPrivate();
                
                
                // signal the end of the initialization
                set_Constructed(true);
                }
            
            // Private initializer
            protected void __initPrivate()
                {
                
                super.__initPrivate();
                }
            
            // Getter for virtual constant Preprocessable
            public boolean isPreprocessable()
                {
                return true;
                }
            
            //++ getter for static property _Instance
            /**
             * Getter for property _Instance.<p>
            * Auto generated
             */
            public static com.tangosol.coherence.Component get_Instance()
                {
                return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.PutAllRequest.Poll();
                }
            
            //++ getter for static property _CLASS
            /**
             * Getter for property _CLASS.<p>
            * Property with auto-generated accessor that returns the Class
            * object for a given component.
             */
            public static Class get_CLASS()
                {
                Class clz;
                try
                    {
                    clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$PutAllRequest$Poll".replace('/', '.'));
                    }
                catch (ClassNotFoundException e)
                    {
                    throw new NoClassDefFoundError(e.getMessage());
                    }
                return clz;
                }
            
            //++ getter for autogen property _Module
            /**
             * This is an auto-generated method that returns the global [design
            * time] parent component.
            * 
            * Note: the class generator will ignore any custom implementation
            * for this behavior.
             */
            private com.tangosol.coherence.Component get_Module()
                {
                return this.get_Parent().get_Parent();
                }
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$PutRequest
    
    /**
     * @see $BinaryMap#put
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class PutRequest
            extends    com.tangosol.coherence.component.net.message.requestMessage.DistributedCacheKeyRequest
        {
        // ---- Fields declarations ----
        
        /**
         * Property ExpiryDelay
         *
         * The resource expiration value.
         */
        private long __m_ExpiryDelay;
        
        /**
         * Property ReturnRequired
         *
         * If true, the caller expects this Request to return the old value;
         * otherwise the return value will be ignored.
         */
        private boolean __m_ReturnRequired;
        
        /**
         * Property Value
         *
         * The resource value.
         */
        private com.tangosol.util.Binary __m_Value;
        private static com.tangosol.util.ListMap __mapChildren;
        
        // Static initializer
        static
            {
            __initStatic();
            }
        
        // Default static initializer
        private static void __initStatic()
            {
            // register child classes
            __mapChildren = new com.tangosol.util.ListMap();
            __mapChildren.put("Poll", PartitionedCache.PutRequest.Poll.get_CLASS());
            }
        
        // Default constructor
        public PutRequest()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public PutRequest(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                setMessageType(72);
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // containment initialization: children
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        // Getter for virtual constant ReadOnly
        public boolean isReadOnly()
            {
            return false;
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.PutRequest();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$PutRequest".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        //++ getter for autogen property _ChildClasses
        /**
         * This is an auto-generated method that returns the map of design time
        * [static] children.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        protected java.util.Map get_ChildClasses()
            {
            return __mapChildren;
            }
        
        // Declared at the super level
        /**
         * Instantiate a copy of this message. This is quite different from the
        * standard "clone" since only the "transmittable" portion of the
        * message (and none of the internal) state should be cloned.
         */
        public com.tangosol.coherence.component.net.Message cloneMessage()
            {
            PartitionedCache.PutRequest msg = (PartitionedCache.PutRequest) super.cloneMessage();
            
            msg.setReturnRequired(isReturnRequired());
            msg.setExpiryDelay(getExpiryDelay());
            msg.setValue(getValue());
            
            return msg;
            }
        
        // Declared at the super level
        /**
         * Getter for property EstimatedByteSize.<p>
        * The estimated serialized size of this message.  A negative value
        * indicates that the size is unknown and that it is safe to estimate
        * the size via a double serialization.
         */
        public int getEstimatedByteSize()
            {
            return -1;
            }
        
        // Accessor for the property "ExpiryDelay"
        /**
         * Getter for property ExpiryDelay.<p>
        * The resource expiration value.
         */
        public long getExpiryDelay()
            {
            return __m_ExpiryDelay;
            }
        
        // Accessor for the property "Value"
        /**
         * Getter for property Value.<p>
        * The resource value.
         */
        public com.tangosol.util.Binary getValue()
            {
            return __m_Value;
            }
        
        // Accessor for the property "ReturnRequired"
        /**
         * Getter for property ReturnRequired.<p>
        * If true, the caller expects this Request to return the old value;
        * otherwise the return value will be ignored.
         */
        public boolean isReturnRequired()
            {
            return __m_ReturnRequired;
            }
        
        // Declared at the super level
        public void read(com.tangosol.io.ReadBuffer.BufferInput input)
                throws java.io.IOException
            {
            // import com.tangosol.util.Binary;
            // import com.tangosol.util.ExternalizableHelper as com.tangosol.util.ExternalizableHelper;
            
            super.read(input);
            
            setReturnRequired(input.readBoolean());
            setValue((Binary) readObject(input));
            setExpiryDelay(com.tangosol.util.ExternalizableHelper.readLong(input));
            
            readTracing(input);
            }
        
        // Declared at the super level
        public void run()
            {
            ((PartitionedCache) getService()).onPutRequest(this);
            }
        
        // Accessor for the property "ExpiryDelay"
        /**
         * Setter for property ExpiryDelay.<p>
        * The resource expiration value.
         */
        public void setExpiryDelay(long cMillis)
            {
            __m_ExpiryDelay = cMillis;
            }
        
        // Declared at the super level
        /**
         * Setter for property RequestTimeout.<p>
        * Transient property optionally used on the client to indicate the
        * (safe local) time after which this logical request should be
        * considered timed out.
        * 
        * Note that a single logical request message may result in multiple
        * physical request messages being sent to mulitple members; this
        * RequestTimeout value will be cloned to all resulting RequestMessage
        * instances.
        * 
        * This value is lazily calculated by #getRequestTimeout or
        * #calculateTimeoutRemaining.
         */
        public void setRequestTimeout(long ldtTimeout)
            {
            super.setRequestTimeout(ldtTimeout);
            }
        
        // Accessor for the property "ReturnRequired"
        /**
         * Setter for property ReturnRequired.<p>
        * If true, the caller expects this Request to return the old value;
        * otherwise the return value will be ignored.
         */
        public void setReturnRequired(boolean fRequired)
            {
            __m_ReturnRequired = fRequired;
            }
        
        // Accessor for the property "Value"
        /**
         * Setter for property Value.<p>
        * The resource value.
         */
        public void setValue(com.tangosol.util.Binary binValue)
            {
            __m_Value = binValue;
            }
        
        // Declared at the super level
        public void write(com.tangosol.io.WriteBuffer.BufferOutput output)
                throws java.io.IOException
            {
            // import com.tangosol.util.ExternalizableHelper as com.tangosol.util.ExternalizableHelper;
            
            super.write(output);
            
            output.writeBoolean(isReturnRequired());
            writeObject(output, getValue());
            com.tangosol.util.ExternalizableHelper.writeLong(output, getExpiryDelay());
            
            writeTracing(output);
            }

        // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$PutRequest$Poll
        
        /**
         * The Poll contains information regarding a request sent to one or
         * more Cluster Members that require responses. A Service may poll
         * other Members that are running the same Service, and the Poll is
         * used to wait for and assemble the responses from each of those
         * Members. A client thread may also use the Poll to block on a
         * response or set of responses, thus waiting for the completion of the
         * Poll. In its simplest form, which is a Poll that is sent to one
         * Member of the Cluster, the Poll actually represents the
         * request/response model.
         */
        @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
        public static class Poll
                extends    com.tangosol.coherence.component.net.message.requestMessage.DistributedCacheKeyRequest.Poll
            {
            // ---- Fields declarations ----
            
            // Default constructor
            public Poll()
                {
                this(null, null, true);
                }
            
            // Initializing constructor
            public Poll(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                {
                super(sName, compParent, false);
                
                if (fInit)
                    {
                    __init();
                    }
                }
            
            // Main initializer
            public void __init()
                {
                // private initialization
                __initPrivate();
                
                
                // signal the end of the initialization
                set_Constructed(true);
                }
            
            // Private initializer
            protected void __initPrivate()
                {
                
                super.__initPrivate();
                }
            
            // Getter for virtual constant Preprocessable
            public boolean isPreprocessable()
                {
                return true;
                }
            
            //++ getter for static property _Instance
            /**
             * Getter for property _Instance.<p>
            * Auto generated
             */
            public static com.tangosol.coherence.Component get_Instance()
                {
                return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.PutRequest.Poll();
                }
            
            //++ getter for static property _CLASS
            /**
             * Getter for property _CLASS.<p>
            * Property with auto-generated accessor that returns the Class
            * object for a given component.
             */
            public static Class get_CLASS()
                {
                Class clz;
                try
                    {
                    clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$PutRequest$Poll".replace('/', '.'));
                    }
                catch (ClassNotFoundException e)
                    {
                    throw new NoClassDefFoundError(e.getMessage());
                    }
                return clz;
                }
            
            //++ getter for autogen property _Module
            /**
             * This is an auto-generated method that returns the global [design
            * time] parent component.
            * 
            * Note: the class generator will ignore any custom implementation
            * for this behavior.
             */
            private com.tangosol.coherence.Component get_Module()
                {
                return this.get_Parent().get_Parent();
                }
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$QueryRequest
    
    /**
     * @see $BinaryMap#keySet(Filter)
     * @see $BinaryMap#entrySet(Filter)
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class QueryRequest
            extends    com.tangosol.coherence.component.net.message.requestMessage.distributedCacheRequest.partialRequest.FilterRequest
        {
        // ---- Fields declarations ----
        
        /**
         * Property KeysOnly
         *
         * Specifies what kind of response is required: if true, a keySet is
         * sent back; otherwise an entrySet.
         */
        private boolean __m_KeysOnly;
        private static com.tangosol.util.ListMap __mapChildren;
        
        // Static initializer
        static
            {
            __initStatic();
            }
        
        // Default static initializer
        private static void __initStatic()
            {
            // register child classes
            __mapChildren = new com.tangosol.util.ListMap();
            __mapChildren.put("Poll", PartitionedCache.QueryRequest.Poll.get_CLASS());
            }
        
        // Default constructor
        public QueryRequest()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public QueryRequest(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                setMessageType(73);
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // containment initialization: children
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.QueryRequest();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$QueryRequest".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        //++ getter for autogen property _ChildClasses
        /**
         * This is an auto-generated method that returns the map of design time
        * [static] children.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        protected java.util.Map get_ChildClasses()
            {
            return __mapChildren;
            }
        
        // Declared at the super level
        /**
         * Instantiate a copy of this message. This is quite different from the
        * standard "clone" since only the "transmittable" portion of the
        * message (and none of the internal) state should be cloned.
         */
        public com.tangosol.coherence.component.net.Message cloneMessage()
            {
            PartitionedCache.QueryRequest msg = (PartitionedCache.QueryRequest) super.cloneMessage();
            
            msg.setKeysOnly(isKeysOnly());
            
            return msg;
            }
        
        // Accessor for the property "KeysOnly"
        /**
         * Getter for property KeysOnly.<p>
        * Specifies what kind of response is required: if true, a keySet is
        * sent back; otherwise an entrySet.
         */
        public boolean isKeysOnly()
            {
            return __m_KeysOnly;
            }
        
        // Declared at the super level
        public void read(com.tangosol.io.ReadBuffer.BufferInput input)
                throws java.io.IOException
            {
            super.read(input);
            
            setKeysOnly(input.readBoolean());
            
            readTracing(input);
            }
        
        // Declared at the super level
        public void run()
            {
            ((PartitionedCache) getService()).onQueryRequest(this);
            }
        
        // Accessor for the property "KeysOnly"
        /**
         * Setter for property KeysOnly.<p>
        * Specifies what kind of response is required: if true, a keySet is
        * sent back; otherwise an entrySet.
         */
        public void setKeysOnly(boolean fKeysOnly)
            {
            __m_KeysOnly = fKeysOnly;
            }
        
        // Declared at the super level
        /**
         * Setter for property RequestTimeout.<p>
        * Transient property optionally used on the client to indicate the
        * (safe local) time after which this logical request should be
        * considered timed out.
        * 
        * Note that a single logical request message may result in multiple
        * physical request messages being sent to mulitple members; this
        * RequestTimeout value will be cloned to all resulting RequestMessage
        * instances.
        * 
        * This value is lazily calculated by #getRequestTimeout or
        * #calculateTimeoutRemaining.
         */
        public void setRequestTimeout(long ldtTimeout)
            {
            super.setRequestTimeout(ldtTimeout);
            }
        
        // Declared at the super level
        public void write(com.tangosol.io.WriteBuffer.BufferOutput output)
                throws java.io.IOException
            {
            super.write(output);
            
            output.writeBoolean(isKeysOnly());
            
            writeTracing(output);
            }

        // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$QueryRequest$Poll
        
        /**
         * The Poll contains information regarding a request sent to one or
         * more Cluster Members that require responses. A Service may poll
         * other Members that are running the same Service, and the Poll is
         * used to wait for and assemble the responses from each of those
         * Members. A client thread may also use the Poll to block on a
         * response or set of responses, thus waiting for the completion of the
         * Poll. In its simplest form, which is a Poll that is sent to one
         * Member of the Cluster, the Poll actually represents the
         * request/response model.
         */
        @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
        public static class Poll
                extends    com.tangosol.coherence.component.net.message.requestMessage.distributedCacheRequest.PartialRequest.Poll
            {
            // ---- Fields declarations ----
            
            // Default constructor
            public Poll()
                {
                this(null, null, true);
                }
            
            // Initializing constructor
            public Poll(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                {
                super(sName, compParent, false);
                
                if (fInit)
                    {
                    __init();
                    }
                }
            
            // Main initializer
            public void __init()
                {
                // private initialization
                __initPrivate();
                
                
                // signal the end of the initialization
                set_Constructed(true);
                }
            
            // Private initializer
            protected void __initPrivate()
                {
                
                super.__initPrivate();
                }
            
            // Getter for virtual constant Preprocessable
            public boolean isPreprocessable()
                {
                return true;
                }
            
            //++ getter for static property _Instance
            /**
             * Getter for property _Instance.<p>
            * Auto generated
             */
            public static com.tangosol.coherence.Component get_Instance()
                {
                return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.QueryRequest.Poll();
                }
            
            //++ getter for static property _CLASS
            /**
             * Getter for property _CLASS.<p>
            * Property with auto-generated accessor that returns the Class
            * object for a given component.
             */
            public static Class get_CLASS()
                {
                Class clz;
                try
                    {
                    clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$QueryRequest$Poll".replace('/', '.'));
                    }
                catch (ClassNotFoundException e)
                    {
                    throw new NoClassDefFoundError(e.getMessage());
                    }
                return clz;
                }
            
            //++ getter for autogen property _Module
            /**
             * This is an auto-generated method that returns the global [design
            * time] parent component.
            * 
            * Note: the class generator will ignore any custom implementation
            * for this behavior.
             */
            private com.tangosol.coherence.Component get_Module()
                {
                return this.get_Parent().get_Parent();
                }
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$PartitionedQueryRequest

    /**
     * @see $BinaryMap#keySet(Filter)
     * @see $BinaryMap#entrySet(Filter)
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class PartitionedQueryRequest
            extends    QueryRequest
        {
        // ---- Fields declarations ----

        private static com.tangosol.util.ListMap __mapChildren;

        // Static initializer
        static
            {
            __initStatic();
            }

        // Default static initializer
        private static void __initStatic()
            {
            // register child classes
            __mapChildren = new com.tangosol.util.ListMap();
            __mapChildren.put("Poll", PartitionedCache.PartitionedQueryRequest.Poll.get_CLASS());
            }

        // Default constructor
        public PartitionedQueryRequest()
            {
            this(null, null, true);
            }

        // Initializing constructor
        public PartitionedQueryRequest(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);

            if (fInit)
                {
                __init();
                }
            }

        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();

            // state initialization: public and protected properties
            try
                {
                setMessageType(87);
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }

            // containment initialization: children

            // signal the end of the initialization
            set_Constructed(true);
            }

        // Private initializer
        protected void __initPrivate()
            {
            super.__initPrivate();
            }

        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
         * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.PartitionedQueryRequest();
            }

        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
         * Property with auto-generated accessor that returns the Class object
         * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$PartitionedQueryRequest".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }

        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
         * time] parent component.
         *
         * Note: the class generator will ignore any custom implementation for
         * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }

        //++ getter for autogen property _ChildClasses
        /**
         * This is an auto-generated method that returns the map of design time
         * [static] children.
         *
         * Note: the class generator will ignore any custom implementation for
         * this behavior.
         */
        protected java.util.Map get_ChildClasses()
            {
            return __mapChildren;
            }

        // Declared at the super level
        /**
         * Instantiate a copy of this message. This is quite different from the
         * standard "clone" since only the "transmittable" portion of the
         * message (and none of the internal) state should be cloned.
         */
        public com.tangosol.coherence.component.net.Message cloneMessage()
            {
            PartitionedCache.PartitionedQueryRequest msg = (PartitionedCache.PartitionedQueryRequest) super.cloneMessage();

            return msg;
            }

        // Declared at the super level
        public void read(com.tangosol.io.ReadBuffer.BufferInput input)
                throws java.io.IOException
            {
            super.read(input);

            readTracing(input);
            }

        // Declared at the super level
        public void run()
            {
            ((PartitionedCache) getService()).onQueryRequest(this);
            }

        // Declared at the super level
        /**
         * Setter for property RequestTimeout.<p>
         * Transient property optionally used on the client to indicate the
         * (safe local) time after which this logical request should be
         * considered timed out.
         *
         * Note that a single logical request message may result in multiple
         * physical request messages being sent to mulitple members; this
         * RequestTimeout value will be cloned to all resulting RequestMessage
         * instances.
         *
         * This value is lazily calculated by #getRequestTimeout or
         * #calculateTimeoutRemaining.
         */
        public void setRequestTimeout(long ldtTimeout)
            {
            super.setRequestTimeout(ldtTimeout);
            }

        // Declared at the super level
        public void write(com.tangosol.io.WriteBuffer.BufferOutput output)
                throws java.io.IOException
            {
            super.write(output);

            writeTracing(output);
            }

        // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$QueryRequest$Poll

        /**
         * The Poll contains information regarding a request sent to one or
         * more Cluster Members that require responses. A Service may poll
         * other Members that are running the same Service, and the Poll is
         * used to wait for and assemble the responses from each of those
         * Members. A client thread may also use the Poll to block on a
         * response or set of responses, thus waiting for the completion of the
         * Poll. In its simplest form, which is a Poll that is sent to one
         * Member of the Cluster, the Poll actually represents the
         * request/response model.
         */
        @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
        public static class Poll
                extends    com.tangosol.coherence.component.net.message.requestMessage.distributedCacheRequest.PartialRequest.Poll
            {
            // ---- Fields declarations ----

            // Default constructor
            public Poll()
                {
                this(null, null, true);
                }

            // Initializing constructor
            public Poll(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                {
                super(sName, compParent, false);

                if (fInit)
                    {
                    __init();
                    }
                }

            // Main initializer
            public void __init()
                {
                // private initialization
                __initPrivate();


                // signal the end of the initialization
                set_Constructed(true);
                }

            // Private initializer
            protected void __initPrivate()
                {

                super.__initPrivate();
                }

            // Getter for virtual constant Preprocessable
            public boolean isPreprocessable()
                {
                return true;
                }

            //++ getter for static property _Instance
            /**
             * Getter for property _Instance.<p>
             * Auto generated
             */
            public static com.tangosol.coherence.Component get_Instance()
                {
                return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.QueryRequest.Poll();
                }

            //++ getter for static property _CLASS
            /**
             * Getter for property _CLASS.<p>
             * Property with auto-generated accessor that returns the Class
             * object for a given component.
             */
            public static Class get_CLASS()
                {
                Class clz;
                try
                    {
                    clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$PartitionedQueryRequest$Poll".replace('/', '.'));
                    }
                catch (ClassNotFoundException e)
                    {
                    throw new NoClassDefFoundError(e.getMessage());
                    }
                return clz;
                }

            //++ getter for autogen property _Module
            /**
             * This is an auto-generated method that returns the global [design
             * time] parent component.
             *
             * Note: the class generator will ignore any custom implementation
             * for this behavior.
             */
            private com.tangosol.coherence.Component get_Module()
                {
                return this.get_Parent().get_Parent();
                }
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$QueryResponse
    
    /**
     * Response to DistributedCacheRequest messages (e.g QueryRequest,
     * InvokeFilterRequest) that returns an array of partial results (keys or
     * entries) along with a set of partitions that have been rejected.
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class QueryResponse
            extends    com.tangosol.coherence.component.net.message.responseMessage.DistributedPartialResponse
        {
        // ---- Fields declarations ----
        
        /**
         * Property Available
         *
         * Count of entries actually available (meaningful only when a query
         * uses a LimitFilter)
         */
        private int __m_Available;
        
        /**
         * Property BinarySize
         *
         * The binary size of the Result array.
         */
        private long __m_BinarySize;
        
        /**
         * Property KeysOnly
         *
         * Specifies the kind of response: if true, a keySet; otherwise an
         * entrySet.
         */
        private boolean __m_KeysOnly;
        
        /**
         * Property Result
         *
         * An array of [Binary] keys or entries returned as a result of a
         * query.
         * 
         * The entries can be Binary keys, $BinaryEntry components or
         * SimpleMapEntry objects on the back-end depending on a request type.
         * On the front-end deserialization always produces either Binary keys
         * or SimpleMapEntry entries, so the entries can be $BinaryEntry
         * components only if the front-end is co-located with the back-end and
         * no serialization occurs.
         * 
         * The length of this array could exceed the Size property value. In
         * that case, the array will contain trailing nulls that should be
         * ignored.
         */
        private Object[] __m_Result;
        
        /**
         * Property Size
         *
         * The effective length of the Result array.
         */
        private int __m_Size;
        
        // Default constructor
        public QueryResponse()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public QueryResponse(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                setMessageType(74);
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.QueryResponse();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$QueryResponse".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        /**
         * Ensure a SimpleMapEntry is returned converting from a BinaryEntry if
        * necessary.
         */
        public static java.util.Map.Entry ensureSimpleEntry(java.util.Map.Entry entry)
            {
            // import com.tangosol.util.BinaryEntry;
            // import com.tangosol.util.SimpleMapEntry;
            
            if (entry instanceof BinaryEntry)
                {
                BinaryEntry binEntry = (BinaryEntry) entry;
                entry = new SimpleMapEntry(binEntry.getBinaryKey(),
                        binEntry.getBinaryValue());
                }
            
            return entry;
            }
        
        /**
         * Extract a binary key from the map entry.
         */
        public static Object extractBinaryKey(java.util.Map.Entry entry)
            {
            // import com.tangosol.util.BinaryEntry;
            
            return entry instanceof BinaryEntry
                    ? ((BinaryEntry) entry).getBinaryKey()
                    : entry.getKey();
            }
        
        /**
         * Extract a binary value from the map entry.
         */
        public static Object extractBinaryValue(java.util.Map.Entry entry)
            {
            // import com.tangosol.util.BinaryEntry;
            
            return entry instanceof BinaryEntry
                    ? ((BinaryEntry) entry).getBinaryValue()
                    : entry.getValue();
            }
        
        // Accessor for the property "Available"
        /**
         * Getter for property Available.<p>
        * Count of entries actually available (meaningful only when a query
        * uses a LimitFilter)
         */
        public int getAvailable()
            {
            return __m_Available;
            }
        
        // Accessor for the property "BinarySize"
        /**
         * Getter for property BinarySize.<p>
        * The binary size of the Result array.
         */
        public long getBinarySize()
            {
            return __m_BinarySize;
            }
        
        // Declared at the super level
        /**
         * Getter for property EstimatedByteSize.<p>
        * The estimated serialized size of this message.  A negative value
        * indicates that the size is unknown and that it is safe to estimate
        * the size via a double serialization.
         */
        public int getEstimatedByteSize()
            {
            return -1;
            }
        
        // Accessor for the property "Result"
        /**
         * Getter for property Result.<p>
        * An array of [Binary] keys or entries returned as a result of a query.
        * 
        * The entries can be Binary keys, $BinaryEntry components or
        * SimpleMapEntry objects on the back-end depending on a request type.
        * On the front-end deserialization always produces either Binary keys
        * or SimpleMapEntry entries, so the entries can be $BinaryEntry
        * components only if the front-end is co-located with the back-end and
        * no serialization occurs.
        * 
        * The length of this array could exceed the Size property value. In
        * that case, the array will contain trailing nulls that should be
        * ignored.
         */
        public Object[] getResult()
            {
            return __m_Result;
            }
        
        // Accessor for the property "Size"
        /**
         * Getter for property Size.<p>
        * The effective length of the Result array.
         */
        public int getSize()
            {
            return __m_Size;
            }
        
        // Accessor for the property "KeysOnly"
        /**
         * Getter for property KeysOnly.<p>
        * Specifies the kind of response: if true, a keySet; otherwise an
        * entrySet.
         */
        public boolean isKeysOnly()
            {
            return __m_KeysOnly;
            }
        
        // Declared at the super level
        public void read(com.tangosol.io.ReadBuffer.BufferInput input)
                throws java.io.IOException
            {
            // import com.tangosol.util.Binary;
            // import com.tangosol.util.ExternalizableHelper;
            // import com.tangosol.util.SimpleMapEntry;
            
            super.read(input);
            
            if (getException() == null)
                {
                int      cEntries  = ExternalizableHelper.readInt(input);
                boolean  fKeysOnly = input.readBoolean();
                Object[] aoResult  = new Object[cEntries];
                long     cb        = 0;
                for (int i = 0; i < cEntries; i++)
                    {
                    if (fKeysOnly)
                       {
                       aoResult[i] = readObject(input);
                       }
                   else
                       {
                       Binary binKey = (Binary) readObject(input);
                       Binary binVal = (Binary) readObject(input);
                       cb = cb + binKey.length() + (binVal == null ? 0 : binVal.length());
                       aoResult[i] = new SimpleMapEntry(binKey, binVal);
                       }
                    }
                setSize(cEntries);
                setBinarySize(cb);
                setKeysOnly(fKeysOnly);
                setResult(aoResult);
                setAvailable(ExternalizableHelper.readInt(input));
                }
            }
        
        // Accessor for the property "Available"
        /**
         * Setter for property Available.<p>
        * Count of entries actually available (meaningful only when a query
        * uses a LimitFilter)
         */
        public void setAvailable(int cAvailable)
            {
            __m_Available = cAvailable;
            }
        
        // Accessor for the property "BinarySize"
        /**
         * Setter for property BinarySize.<p>
        * The binary size of the Result array.
         */
        public void setBinarySize(long lSize)
            {
            __m_BinarySize = lSize;
            }
        
        // Accessor for the property "KeysOnly"
        /**
         * Setter for property KeysOnly.<p>
        * Specifies the kind of response: if true, a keySet; otherwise an
        * entrySet.
         */
        public void setKeysOnly(boolean fKeysOnly)
            {
            __m_KeysOnly = fKeysOnly;
            }
        
        // Accessor for the property "Result"
        /**
         * Setter for property Result.<p>
        * An array of [Binary] keys or entries returned as a result of a query.
        * 
        * The entries can be Binary keys, $BinaryEntry components or
        * SimpleMapEntry objects on the back-end depending on a request type.
        * On the front-end deserialization always produces either Binary keys
        * or SimpleMapEntry entries, so the entries can be $BinaryEntry
        * components only if the front-end is co-located with the back-end and
        * no serialization occurs.
        * 
        * The length of this array could exceed the Size property value. In
        * that case, the array will contain trailing nulls that should be
        * ignored.
         */
        public void setResult(Object[] ao)
            {
            __m_Result = ao;
            }
        
        // Accessor for the property "Size"
        /**
         * Setter for property Size.<p>
        * The effective length of the Result array.
         */
        public void setSize(int c)
            {
            __m_Size = c;
            }
        
        // Declared at the super level
        public void write(com.tangosol.io.WriteBuffer.BufferOutput output)
                throws java.io.IOException
            {
            // import com.tangosol.util.BinaryEntry;
            // import com.tangosol.util.ExternalizableHelper;
            // import java.util.Map$Entry as java.util.Map.Entry;
            
            super.write(output);
            
            if (getException() == null)
                {
                Object[] aoResult = getResult();
                int      cEntries = getSize();
            
                ExternalizableHelper.writeInt(output, cEntries);
                boolean fKeysOnly = isKeysOnly();
                output.writeBoolean(fKeysOnly);
            
                for (int i = 0; i < cEntries; i++)
                    {
                    if (fKeysOnly)
                        {
                        writeObject(output, aoResult[i]); // binKey
                        }
                    else
                        {
                        java.util.Map.Entry entry = (java.util.Map.Entry) aoResult[i];
            
                        writeObject(output, extractBinaryKey(entry));   // binKey
                        writeObject(output, extractBinaryValue(entry)); // binValue
                        }
                    }
                ExternalizableHelper.writeInt(output, getAvailable());
                }
            }
        }

    /**
     * Response to DistributedCacheRequest messages (e.g QueryRequest,
     * InvokeFilterRequest) that returns an array of partial results (keys or
     * entries) along with a set of partitions that have been rejected.
     * This versions enables streaming of large responses.
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class PartitionedQueryResponse
            extends    QueryResponse
        {
        // ---- Fields declarations ----

        // Default constructor
        public PartitionedQueryResponse()
            {
            this(null, null, true);
            }

        // Initializing constructor
        public PartitionedQueryResponse(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);

            if (fInit)
                {
                __init();
                }
            }

        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();

            // state initialization: public and protected properties
            try
                {
                setMessageType(88);
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }

            // signal the end of the initialization
            set_Constructed(true);
            }

        // Private initializer
        protected void __initPrivate()
            {

            super.__initPrivate();
            }

        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
         * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.PartitionedQueryResponse();
            }

        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
         * Property with auto-generated accessor that returns the Class object
         * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$PartitionedQueryResponse".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }

        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
         * time] parent component.
         *
         * Note: the class generator will ignore any custom implementation for
         * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }

        // Declared at the super level
        public void read(com.tangosol.io.ReadBuffer.BufferInput input)
                throws java.io.IOException
            {
            super.read(input);

            if (input.readBoolean())
                {
                PartitionSet partsResponse = new PartitionSet();
                partsResponse.readExternal(input);
                setResponsePartitions(partsResponse);
                }
            }

        // Declared at the super level
        public void write(com.tangosol.io.WriteBuffer.BufferOutput output)
                throws java.io.IOException
            {
            super.write(output);

            PartitionSet partsResponse = getResponsePartitions();
            if (partsResponse == null)
                {
                output.writeBoolean(false);
                }
            else
                {
                output.writeBoolean(true);
                partsResponse.writeExternal(output);
                }
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$RemoveAllRequest
    
    /**
     * @see $BinaryMap#removeAll
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class RemoveAllRequest
            extends    com.tangosol.coherence.component.net.message.requestMessage.distributedCacheRequest.KeySetRequest
        {
        // ---- Fields declarations ----
        private static com.tangosol.util.ListMap __mapChildren;
        
        // Static initializer
        static
            {
            __initStatic();
            }
        
        // Default static initializer
        private static void __initStatic()
            {
            // register child classes
            __mapChildren = new com.tangosol.util.ListMap();
            __mapChildren.put("Poll", PartitionedCache.RemoveAllRequest.Poll.get_CLASS());
            __mapChildren.put("RemoveJob", PartitionedCache.RemoveAllRequest.RemoveJob.get_CLASS());
            }
        
        // Default constructor
        public RemoveAllRequest()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public RemoveAllRequest(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                setMessageType(75);
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // containment initialization: children
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        // Getter for virtual constant ReadOnly
        public boolean isReadOnly()
            {
            return false;
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.RemoveAllRequest();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$RemoveAllRequest".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        //++ getter for autogen property _ChildClasses
        /**
         * This is an auto-generated method that returns the map of design time
        * [static] children.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        protected java.util.Map get_ChildClasses()
            {
            return __mapChildren;
            }
        
        // Declared at the super level
        /**
         * Getter for property EstimatedByteSize.<p>
        * The estimated serialized size of this message.  A negative value
        * indicates that the size is unknown and that it is safe to estimate
        * the size via a double serialization.
         */
        public int getEstimatedByteSize()
            {
            return -1;
            }
        
        // Declared at the super level
        protected java.util.Set instantiateKeySet(int cKeys)
            {
            // import java.util.Collections;
            
            PartitionedCache service = (PartitionedCache) get_Module();
            
            // see comments in PutAllRequest.instantiateKeySet
            return service.isConcurrent() && !service.isTaskSplitWorthy(cKeys)
                ? Collections.newSetFromMap(new NullableSortedMap())
                : super.instantiateKeySet(cKeys);
            }
        
        // Declared at the super level
        /**
         * This is the event that is executed when a Message is received.
        * <p>
        * It is the main processing event of the Message called by the
        * <code>Service.onMessage()</code> event. With regards to the use of
        * Message components within clustered Services, Services are designed
        * by dragging Message components into them as static children. These
        * Messages are the components that a Service can send to other running
        * instances of the same Service within a cluster. When the onReceived
        * event is invoked by a Service, it means that the Message has been
        * received; the code in the onReceived event is therefore the Message
        * specific logic for processing a received Message. For example, when
        * onReceived is invoked on a Message named FindData, the onReceived
        * event should do the work to "find the data", because it is being
        * invoked by the Service that received the "find the data" Message.
         */
        public void onReceived()
            {
            PartitionedCache service = (PartitionedCache) getService();
            if (service.isTaskSplitWorthy(getKeySet().size()))
                {
                scheduleJobs();
                }
            else
                {
                service.getDaemonPool().add(this);
                }
            }
        
        // Declared at the super level
        public void run()
            {
            ((PartitionedCache) get_Module()).onRemoveAllRequest(this);
            }
        
        /**
         * Split this task into jobs and schedule with the daemon pool.
         */
        protected void scheduleJobs()
            {
            // import Component.Util.DaemonPool as com.tangosol.coherence.component.util.DaemonPool;
            // import com.tangosol.util.Binary;
            // import com.tangosol.util.LongArray;
            // import com.tangosol.util.SparseArray;
            // import java.util.Iterator;
            // import java.util.Map;
            // import java.util.Map$Entry as java.util.Map.Entry;
            // import java.util.Set;
            
            PartitionedCache    service = (PartitionedCache) getService();
            com.tangosol.coherence.component.util.DaemonPool pool    = service.getDaemonPool();
            Set        setKeys = getKeySet();
            int        cKeys   = setKeys.size();
            
            PartitionedCache.PartialValueResponse msgResponse =
                (PartitionedCache.PartialValueResponse) service.instantiateMessage("PartialValueResponse");
            msgResponse.respondTo(this);
            
            // Note 1: job processing MUST not modify the state of this RemoveAllRequest 
            //         message and the safest way is to new the PartitionedCache.RemoveAllRequest.RemoveJob object explicitly
            // Note 2: job processors MUST synchronize on the msgResponse for any modifications
            
            long          lCacheId = getCacheId();
            PartitionedCache.BatchContext ctxBatch = service.instantiateBatchContext(msgResponse);
            
            // split up into individual jobs; one job per partition
            LongArray laJob = new SparseArray();
            for (Iterator iter = setKeys.iterator(); iter.hasNext();)
                {
                Binary     binKey     = (Binary) iter.next();
                int        iPartition = service.getKeyPartition(binKey);
                PartitionedCache.RemoveAllRequest.RemoveJob job        = (PartitionedCache.RemoveAllRequest.RemoveJob) laJob.get(iPartition);
                if (job == null)
                    {
                    job = new PartitionedCache.RemoveAllRequest.RemoveJob();
                    job.setBatchContext(ctxBatch);
                    job.setRequest(this);
                    job.setPartition(iPartition);
            
                    laJob.set(iPartition, job);
                    }
            
                job.getMap().put(binKey, null);
                }
            
            ctxBatch.getOutstandingOperationCounter().set(laJob.getSize());
            
            for (Iterator iter = laJob.iterator(); iter.hasNext();)
                {
                pool.add((Runnable) iter.next());
                }
            }
        
        // Declared at the super level
        /**
         * Setter for property RequestTimeout.<p>
        * Transient property optionally used on the client to indicate the
        * (safe local) time after which this logical request should be
        * considered timed out.
        * 
        * Note that a single logical request message may result in multiple
        * physical request messages being sent to mulitple members; this
        * RequestTimeout value will be cloned to all resulting RequestMessage
        * instances.
        * 
        * This value is lazily calculated by #getRequestTimeout or
        * #calculateTimeoutRemaining.
         */
        public void setRequestTimeout(long ldtTimeout)
            {
            super.setRequestTimeout(ldtTimeout);
            }

        // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$RemoveAllRequest$Poll
        
        /**
         * The Poll contains information regarding a request sent to one or
         * more Cluster Members that require responses. A Service may poll
         * other Members that are running the same Service, and the Poll is
         * used to wait for and assemble the responses from each of those
         * Members. A client thread may also use the Poll to block on a
         * response or set of responses, thus waiting for the completion of the
         * Poll. In its simplest form, which is a Poll that is sent to one
         * Member of the Cluster, the Poll actually represents the
         * request/response model.
         */
        @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
        public static class Poll
                extends    com.tangosol.coherence.component.net.message.requestMessage.distributedCacheRequest.KeySetRequest.Poll
            {
            // ---- Fields declarations ----
            
            // Default constructor
            public Poll()
                {
                this(null, null, true);
                }
            
            // Initializing constructor
            public Poll(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                {
                super(sName, compParent, false);
                
                if (fInit)
                    {
                    __init();
                    }
                }
            
            // Main initializer
            public void __init()
                {
                // private initialization
                __initPrivate();
                
                
                // signal the end of the initialization
                set_Constructed(true);
                }
            
            // Private initializer
            protected void __initPrivate()
                {
                
                super.__initPrivate();
                }
            
            // Getter for virtual constant Preprocessable
            public boolean isPreprocessable()
                {
                return true;
                }
            
            //++ getter for static property _Instance
            /**
             * Getter for property _Instance.<p>
            * Auto generated
             */
            public static com.tangosol.coherence.Component get_Instance()
                {
                return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.RemoveAllRequest.Poll();
                }
            
            //++ getter for static property _CLASS
            /**
             * Getter for property _CLASS.<p>
            * Property with auto-generated accessor that returns the Class
            * object for a given component.
             */
            public static Class get_CLASS()
                {
                Class clz;
                try
                    {
                    clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$RemoveAllRequest$Poll".replace('/', '.'));
                    }
                catch (ClassNotFoundException e)
                    {
                    throw new NoClassDefFoundError(e.getMessage());
                    }
                return clz;
                }
            
            //++ getter for autogen property _Module
            /**
             * This is an auto-generated method that returns the global [design
            * time] parent component.
            * 
            * Note: the class generator will ignore any custom implementation
            * for this behavior.
             */
            private com.tangosol.coherence.Component get_Module()
                {
                return this.get_Parent().get_Parent();
                }
            }

        // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$RemoveAllRequest$RemoveJob
        
        /**
         * PartialJob represents a segment of a DistributedCacheRequest that
         * contains keys (entries) that belong to the same partition (bucket).
         * It assumes to belong to (contained by) a DistributedRequestMessage.
         * 
         * $RemoveJob represents a segment of removeAll request that contains
         * keys that belong to the same bucket.
         */
        @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
        public static class RemoveJob
                extends    com.tangosol.coherence.component.util.PartialJob
            {
            // ---- Fields declarations ----
            
            /**
             * Property Map
             *
             * The map containing binary keys to be removed by this job. The
             * values are all nulls initially and used for holding
             * corresponding processing status.
             */
            private transient java.util.Map __m_Map;
            
            // Default constructor
            public RemoveJob()
                {
                this(null, null, true);
                }
            
            // Initializing constructor
            public RemoveJob(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                {
                super(sName, compParent, false);
                
                if (fInit)
                    {
                    __init();
                    }
                }
            
            // Main initializer
            public void __init()
                {
                // private initialization
                __initPrivate();
                
                // state initialization: public and protected properties
                try
                    {
                    setMap(new NullableSortedMap());
                    }
                catch (java.lang.Exception e)
                    {
                    // re-throw as a runtime exception
                    throw new com.tangosol.util.WrapperException(e);
                    }
                
                // signal the end of the initialization
                set_Constructed(true);
                }
            
            // Private initializer
            protected void __initPrivate()
                {
                
                super.__initPrivate();
                }
            
            //++ getter for static property _Instance
            /**
             * Getter for property _Instance.<p>
            * Auto generated
             */
            public static com.tangosol.coherence.Component get_Instance()
                {
                return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.RemoveAllRequest.RemoveJob();
                }
            
            //++ getter for static property _CLASS
            /**
             * Getter for property _CLASS.<p>
            * Property with auto-generated accessor that returns the Class
            * object for a given component.
             */
            public static Class get_CLASS()
                {
                Class clz;
                try
                    {
                    clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$RemoveAllRequest$RemoveJob".replace('/', '.'));
                    }
                catch (ClassNotFoundException e)
                    {
                    throw new NoClassDefFoundError(e.getMessage());
                    }
                return clz;
                }
            
            //++ getter for autogen property _Module
            /**
             * This is an auto-generated method that returns the global [design
            * time] parent component.
            * 
            * Note: the class generator will ignore any custom implementation
            * for this behavior.
             */
            private com.tangosol.coherence.Component get_Module()
                {
                return this.get_Parent().get_Parent();
                }
            
            // Declared at the super level
            /**
             * Getter for property Description.<p>
            * Used for debugging purposes (from toString). Create a
            * human-readable description of the specific job data.
             */
            public String getDescription()
                {
                String sCacheName = ((PartitionedCache) get_Module()).getCacheName(getCacheId());
                    
                if (sCacheName == null)
                    {
                    sCacheName = "<unknown>";
                    }
                    
                return super.getDescription() + ", CacheName=" + sCacheName;
                }
            
            // Accessor for the property "Map"
            /**
             * Getter for property Map.<p>
            * The map containing binary keys to be removed by this job. The
            * values are all nulls initially and used for holding corresponding
            * processing status.
             */
            public java.util.Map getMap()
                {
                return __m_Map;
                }
            
            // Declared at the super level
            public void run()
                {
                ((PartitionedCache) getResponse().getService()).onRemoveAllRequest(this);
                }
            
            // Accessor for the property "Map"
            /**
             * Setter for property Map.<p>
            * The map containing binary keys to be removed by this job. The
            * values are all nulls initially and used for holding corresponding
            * processing status.
             */
            protected void setMap(java.util.Map map)
                {
                __m_Map = map;
                }
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$RemoveRequest
    
    /**
     * @see $BinaryMap#remove
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class RemoveRequest
            extends    com.tangosol.coherence.component.net.message.requestMessage.DistributedCacheKeyRequest
        {
        // ---- Fields declarations ----
        
        /**
         * Property ReturnRequired
         *
         * If true, the caller expects this Request to return the old value;
         * otherwise the return value will be ignored.
         */
        private boolean __m_ReturnRequired;
        private static com.tangosol.util.ListMap __mapChildren;
        
        // Static initializer
        static
            {
            __initStatic();
            }
        
        // Default static initializer
        private static void __initStatic()
            {
            // register child classes
            __mapChildren = new com.tangosol.util.ListMap();
            __mapChildren.put("Poll", PartitionedCache.RemoveRequest.Poll.get_CLASS());
            }
        
        // Default constructor
        public RemoveRequest()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public RemoveRequest(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                setMessageType(76);
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // containment initialization: children
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        // Getter for virtual constant ReadOnly
        public boolean isReadOnly()
            {
            return false;
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.RemoveRequest();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$RemoveRequest".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        //++ getter for autogen property _ChildClasses
        /**
         * This is an auto-generated method that returns the map of design time
        * [static] children.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        protected java.util.Map get_ChildClasses()
            {
            return __mapChildren;
            }
        
        // Declared at the super level
        /**
         * Instantiate a copy of this message. This is quite different from the
        * standard "clone" since only the "transmittable" portion of the
        * message (and none of the internal) state should be cloned.
         */
        public com.tangosol.coherence.component.net.Message cloneMessage()
            {
            PartitionedCache.RemoveRequest msg = (PartitionedCache.RemoveRequest) super.cloneMessage();
            
            msg.setReturnRequired(isReturnRequired());
            
            return msg;
            }
        
        // Declared at the super level
        /**
         * Getter for property EstimatedByteSize.<p>
        * The estimated serialized size of this message.  A negative value
        * indicates that the size is unknown and that it is safe to estimate
        * the size via a double serialization.
         */
        public int getEstimatedByteSize()
            {
            return -1;
            }
        
        // Accessor for the property "ReturnRequired"
        /**
         * Getter for property ReturnRequired.<p>
        * If true, the caller expects this Request to return the old value;
        * otherwise the return value will be ignored.
         */
        public boolean isReturnRequired()
            {
            return __m_ReturnRequired;
            }
        
        // Declared at the super level
        public void read(com.tangosol.io.ReadBuffer.BufferInput input)
                throws java.io.IOException
            {
            super.read(input);
            
            setReturnRequired(input.readBoolean());
            
            readTracing(input);
            }
        
        // Declared at the super level
        public void run()
            {
            ((PartitionedCache) getService()).onRemoveRequest(this);
            }
        
        // Declared at the super level
        /**
         * Setter for property RequestTimeout.<p>
        * Transient property optionally used on the client to indicate the
        * (safe local) time after which this logical request should be
        * considered timed out.
        * 
        * Note that a single logical request message may result in multiple
        * physical request messages being sent to mulitple members; this
        * RequestTimeout value will be cloned to all resulting RequestMessage
        * instances.
        * 
        * This value is lazily calculated by #getRequestTimeout or
        * #calculateTimeoutRemaining.
         */
        public void setRequestTimeout(long ldtTimeout)
            {
            super.setRequestTimeout(ldtTimeout);
            }
        
        // Accessor for the property "ReturnRequired"
        /**
         * Setter for property ReturnRequired.<p>
        * If true, the caller expects this Request to return the old value;
        * otherwise the return value will be ignored.
         */
        public void setReturnRequired(boolean fRequired)
            {
            __m_ReturnRequired = fRequired;
            }
        
        // Declared at the super level
        public void write(com.tangosol.io.WriteBuffer.BufferOutput output)
                throws java.io.IOException
            {
            super.write(output);
            
            output.writeBoolean(isReturnRequired());
            
            writeTracing(output);
            }

        // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$RemoveRequest$Poll
        
        /**
         * The Poll contains information regarding a request sent to one or
         * more Cluster Members that require responses. A Service may poll
         * other Members that are running the same Service, and the Poll is
         * used to wait for and assemble the responses from each of those
         * Members. A client thread may also use the Poll to block on a
         * response or set of responses, thus waiting for the completion of the
         * Poll. In its simplest form, which is a Poll that is sent to one
         * Member of the Cluster, the Poll actually represents the
         * request/response model.
         */
        @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
        public static class Poll
                extends    com.tangosol.coherence.component.net.message.requestMessage.DistributedCacheKeyRequest.Poll
            {
            // ---- Fields declarations ----
            
            // Default constructor
            public Poll()
                {
                this(null, null, true);
                }
            
            // Initializing constructor
            public Poll(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                {
                super(sName, compParent, false);
                
                if (fInit)
                    {
                    __init();
                    }
                }
            
            // Main initializer
            public void __init()
                {
                // private initialization
                __initPrivate();
                
                
                // signal the end of the initialization
                set_Constructed(true);
                }
            
            // Private initializer
            protected void __initPrivate()
                {
                
                super.__initPrivate();
                }
            
            // Getter for virtual constant Preprocessable
            public boolean isPreprocessable()
                {
                return true;
                }
            
            //++ getter for static property _Instance
            /**
             * Getter for property _Instance.<p>
            * Auto generated
             */
            public static com.tangosol.coherence.Component get_Instance()
                {
                return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.RemoveRequest.Poll();
                }
            
            //++ getter for static property _CLASS
            /**
             * Getter for property _CLASS.<p>
            * Property with auto-generated accessor that returns the Class
            * object for a given component.
             */
            public static Class get_CLASS()
                {
                Class clz;
                try
                    {
                    clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$RemoveRequest$Poll".replace('/', '.'));
                    }
                catch (ClassNotFoundException e)
                    {
                    throw new NoClassDefFoundError(e.getMessage());
                    }
                return clz;
                }
            
            //++ getter for autogen property _Module
            /**
             * This is an auto-generated method that returns the global [design
            * time] parent component.
            * 
            * Note: the class generator will ignore any custom implementation
            * for this behavior.
             */
            private com.tangosol.coherence.Component get_Module()
                {
                return this.get_Parent().get_Parent();
                }
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$RequestCoordinator

    /**
     * RequestCoordinator is used to manage the ordering and retry logic for
     * asynchronous invocation and aggregation operations.
     *
     * The coordinator maintains a (volatile) array of PartitionInfo objects,
     * indexed by the partition id.
     *
     * The possible transitions for the RequestCoordinator state are as
     * follows:
     *
     * 1) PartitionInfo is initialized and the "target" member is set to the
     * partition owner;
     *
     * 2) when corresponding request messages are sent, the outstanding request
     * counter is incremented unless it is -1, in which case we re-fetch the
     * new PartitionInfo (see 4a below);
     *
     * 3) when response messages are received, the outstanding request counter
     * is decremented.  If the request counter reaches zero, and a
     * DeferredRequests array exists, the same actions as in 4 below are taken;
     *
     * 4) when a partition-config update is received, we set the
     * DeferredRequests array and try to CAS the Counter from 0 to -1
     * ("deactivating" it):
     *     a) if the counter is successfully CAS'd to -1, we know there are not
     * any outstanding requests.  We replace the PartitionInfo (held in a
     * volatile array) with a new PartitionInfo;
     *     b) if the counter cannot be CAS'd, it must be due to an outstanding
     * request.  In that case, we know that when the request returns (either
     * successfully or with a RETRY), it will see the non-null DeferredRequest
     * array, and migrate to a new PartitionInfo.
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class RequestCoordinator
            extends    com.tangosol.coherence.component.Util
        {
        // ---- Fields declarations ----

        /**
         * Property BacklogNormalCount
         *
         * The number of pending messages that is considered to be "back to
         * normal" after backlog has been announced.
         */
        private int __m_BacklogNormalCount;

        /**
         * Property CloggedCount
         *
         * The maximum number of pending asynchronous requests before
         * determining that the service is clogged.
         */
        private int __m_CloggedCount;

        /**
         * Property DeferredRequestCounter
         *
         * Atomic counter of number of async requests that are currently
         * deferred by this RequestCoordinator (across all partitions).
         */
        private java.util.concurrent.atomic.AtomicInteger __m_DeferredRequestCounter;

        /**
         * Property MemberInfoMap
         *
         * A Map of MemberInfo objects keyed by the corresponding
         * (ownership-enabled) Member. Additionally, this map will always have
         * a MemberInfo keyed by null, representing the messages that are
         * deferred due to an unknown target member.
         */
        private java.util.Map __m_MemberInfoMap;

        /**
         * Property PartitionInfoArray
         *
         * The (atomic/volatile) array of $PartitionInfo objects, indexed by
         * partition-id.
         */
        private java.util.concurrent.atomic.AtomicReferenceArray __m_PartitionInfoArray;
        private static com.tangosol.util.ListMap __mapChildren;

        // Static initializer
        static
            {
            __initStatic();
            }

        // Default static initializer
        private static void __initStatic()
            {
            // register child classes
            __mapChildren = new com.tangosol.util.ListMap();
            __mapChildren.put("BacklogContinuation", PartitionedCache.RequestCoordinator.BacklogContinuation.get_CLASS());
            }

        // Default constructor
        public RequestCoordinator()
            {
            this(null, null, true);
            }

        // Initializing constructor
        public RequestCoordinator(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);

            if (fInit)
                {
                __init();
                }
            }

        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();

            // state initialization: public and protected properties
            try
                {
                setDeferredRequestCounter(new java.util.concurrent.atomic.AtomicInteger());
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }

            // containment initialization: children

            // signal the end of the initialization
            set_Constructed(true);
            }

        // Private initializer
        protected void __initPrivate()
            {

            super.__initPrivate();
            }

        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.RequestCoordinator();
            }

        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$RequestCoordinator".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }

        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        *
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }

        //++ getter for autogen property _ChildClasses
        /**
         * This is an auto-generated method that returns the map of design time
        * [static] children.
        *
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        protected java.util.Map get_ChildClasses()
            {
            return __mapChildren;
            }

        /**
         * Check for the backlog associated with the specified partition.
        *
        * @see com.tangosol.net.FlowControl for the semantics of the
        * Continuation
         */
        public boolean checkBacklog(int nPartition, com.oracle.coherence.common.base.Continuation continuation)
            {
            // import com.tangosol.net.internal.MemberInfo;
            // import com.tangosol.net.internal.PartitionInfo;
            // import com.tangosol.util.SafeLinkedList;

            PartitionedCache       service    = getService();
            PartitionInfo infoPart   = getPartitionInfo(nPartition);
            MemberInfo    infoMember = (MemberInfo) getMemberInfoMap().get(infoPart.getTarget());

            if (infoMember.getCounter().get() >= getCloggedCount())
                {
                if (continuation != null)
                    {
                    SafeLinkedList list = infoMember.ensureBacklogContinuations();
                    list.add(continuation);

                    // check is the service is still running (volatile)
                    // *after* crossing the write-barrier on the continuation list;
                    // the logic in onExit() checks those same barriers in the inverse order

                    if (infoMember.getCounter().get() <= getBacklogNormalCount() ||
                        service.getServiceState() == PartitionedCache.SERVICE_STOPPED)
                        {
                        // no need to add it, but it could have been aready called
                        // by the notifyBacklogNormal()

                        return !list.remove(continuation);
                        }
                    }
                return true;
                }

            // check the event dispatcher queue
            return service.ensureEventDispatcher().checkBacklog(continuation);
            }

        /**
         * Check for the backlog associated with any of the specified
        * partitions.
        *
        * @see com.tangosol.net.FlowControl for the semantics of the
        * Continuation
         */
        public boolean checkBacklog(com.tangosol.net.partition.PartitionSet partitions, com.oracle.coherence.common.base.Continuation continuation)
            {
            for (int iPart = partitions.next(0); iPart >= 0; iPart = partitions.next(iPart + 1))
                {
                if (checkBacklog(iPart, continuation))
                    {
                    return true;
                    }
                }

            return false;
            }

        /**
         * Check the deferred asynchronous requests for any requests that have
        * exceeded their timeouts.
         */
        protected void checkDeferred()
            {
            // import Component.Net.Message.RequestMessage;
            // import Component.Net.RequestContext.AsyncContext;
            // import com.tangosol.util.LongArray;
            // import java.util.Iterator;

            if (getDeferredRequestCounter().get() > 0)
                {
                for (int i = 0, c = getService().getPartitionCount(); i < c; ++i)
                    {
                    LongArray laDeferred = getPartitionInfo(i).getDeferredRequests();

                    if (laDeferred != null)
                        {
                        synchronized (laDeferred)
                            {
                            for (Iterator iter = laDeferred.iterator(); iter.hasNext(); )
                                {
                                RequestMessage msgRequest = (RequestMessage) iter.next();
                                try
                                    {
                                    validateRequest(msgRequest);
                                    }
                                catch (Throwable e)
                                    {
                                    // the deferred request can not be submitted either due to timeout,
                                    // the service has stopped or the cache is inactive; therefore fulfill
                                    // the contract by calling processException & processCompletion
                                    // and removing the deferred request

                                    AsyncContext ctx = (AsyncContext) msgRequest.getRequestContext();

                                    ctx.processException(e);
                                    ctx.processCompletion();

                                    // Note: we must not remove the deferred array, even if it
                                    //       becomes empty, as its presence is meaningful
                                    iter.remove();
                                    getDeferredRequestCounter().decrementAndGet();
                                    }
                                }
                            }
                        }
                    }
                }
            }

        /**
         * Clear all backlog continuations. Called during service stop.
         */
        public void clearBacklog()
            {
            // import com.tangosol.net.internal.MemberInfo;
            // import java.util.Iterator;
            // import java.util.Map;

            // could be null if the service has not yet finished starting/joining
            Map mapMemberInfo = getMemberInfoMap();
            if (mapMemberInfo != null)
                {
                for (Iterator iter = mapMemberInfo.values().iterator(); iter.hasNext();)
                    {
                    MemberInfo info = (MemberInfo) iter.next();

                    PartitionedCache.notifyBacklogNormal(info.getBacklogContinuations());
                    }
                }

            // clear the deferred requests
            checkDeferred();
            }

        /**
         * Create and register an AsyncContext associated with the specified
        * AsynchronousAgent.
         */
        public com.tangosol.coherence.component.net.requestContext.AsyncContext createContext(BinaryMap mapBinary, com.tangosol.util.AsynchronousAgent asyncAgent, com.tangosol.util.Converter convValue)
            {
            // import Component.Net.RequestContext.AsyncContext;
            // import Component.Net.RequestContext.AsyncContext.AsyncAggregatorContext;
            // import Component.Net.RequestContext.AsyncContext.AsyncProcessorContext;
            // import com.tangosol.net.security.SecurityHelper;
            // import com.tangosol.util.aggregator.AbstractAsynchronousAggregator;
            // import com.tangosol.util.processor.AbstractAsynchronousProcessor;

            AsyncContext context;
            PartitionedCache      service = getService();

            if (asyncAgent instanceof AbstractAsynchronousProcessor)
                {
                AsyncProcessorContext ctx = new AsyncProcessorContext();
                ctx.setAsyncProcessor((AbstractAsynchronousProcessor) asyncAgent);
                context = ctx;
                }
            else
                {
                AsyncAggregatorContext ctx = new AsyncAggregatorContext();
                ctx.setAsyncAggregator((AbstractAsynchronousAggregator) asyncAgent);
                context = ctx;
                }
            context.setValueConverter(convValue);

            if (mapBinary.isAuthorizationEnabled())
                {
                context.setSubject(SecurityHelper.getCurrentSubject());
                }

            mapBinary._linkChild(context);
            service.registerRequestContext(context);

            asyncAgent.bind(context);

            return context;
            }

        /**
         * Decrement the backlog counter for the specified Member (could be
        * null).
         */
        protected void decrementBacklog(com.tangosol.net.Member member, int c)
            {
            // import com.tangosol.net.internal.MemberInfo;
            // import com.tangosol.util.SafeLinkedList;

            MemberInfo info     = (MemberInfo) getMemberInfoMap().get(member);
            int        cBacklog = info.getCounter().addAndGet(-c);
            int        cNormal  = getBacklogNormalCount();

            if (cBacklog + c > cNormal
             && cBacklog    <= cNormal)
                {
                SafeLinkedList list = info.getBacklogContinuations();

                if (list != null && !list.isEmpty())
                    {
                    PartitionedCache.notifyBacklogNormal(list);
                    }
                }
            }

        /**
         * Submit the specified [prepared] request message for processing.
        * Return from this method *does not* guarantee that the request has
        * been sent, but simply guarantees the ordering with respect to other
        * requests made by the same client for the same member.
         */
        protected void doSubmit(com.tangosol.coherence.component.net.message.RequestMessage msgRequest, com.tangosol.coherence.component.net.Member member)
            {
            // import Component.Net.MemberSet.SingleMemberSet;

            if (member != null)
                {
                // the following also serves as a "member != null" assertion
                msgRequest.setToMemberSet(SingleMemberSet.instantiate(member));

                // copy the timeout value onto the Poll (see Grid$PollArray#checkPolls)
                msgRequest.ensureRequestPoll().setExpiryTimeMillis(msgRequest.getRequestTimeout());

                try
                    {
                    getService().post(msgRequest); // the caller is responsible for flushing
                    }
                catch (Throwable e)
                    {
                    // RequestMessage.post() closed the poll passing this exception.
                    }
                }
            }

        /**
         * Wait for any backlog associated with the specified partition to
        * drain.
        *
        * @see Grid#drainOverflow for the timeout and return value semantics
         */
        public long drainBacklog(int nPartition, long cMillisTimeout)
                throws java.lang.InterruptedException
            {
            // import com.tangosol.net.RequestTimeoutException;
            // import com.tangosol.util.Base;

            if (checkBacklog(nPartition, null))
                {
                PartitionedCache.RequestCoordinator.BacklogContinuation continuation = new PartitionedCache.RequestCoordinator.BacklogContinuation();

                if (checkBacklog(nPartition, continuation))
                    {
                    if (cMillisTimeout == 0L)
                        {
                        // we don't care about spurios wakeups
                        continuation.getNotifier().await();
                        }
                    else
                        {
                        long ldtTimeout = cMillisTimeout == 0L ? Long.MAX_VALUE : Base.getSafeTimeMillis() + cMillisTimeout;

                        continuation.getNotifier().await(cMillisTimeout);

                        cMillisTimeout = Base.computeSafeWaitTime(ldtTimeout);

                        if (cMillisTimeout < 0L)
                            {
                            throw new RequestTimeoutException("Request timed out");
                            }
                        }
                    }
                }

            return cMillisTimeout;
            }

        /**
         * Wait for any backlog associated with the specified partitions to
        * drain.
        *
        * @see Grid#drainOverflow for the timeout and return value semantics
         */
        public long drainBacklog(com.tangosol.net.partition.PartitionSet partitions, long cMillisTimeout)
                throws java.lang.InterruptedException
            {
            for (int iPart = partitions.next(0); iPart >= 0; iPart = partitions.next(iPart + 1))
                {
                cMillisTimeout = drainBacklog(iPart, cMillisTimeout);
                }

            return cMillisTimeout;
            }

        /**
         * Indicates that ? Poll for an asycnhronous request for a given
        * partition has been closed. Note, that the associated asynchronous
        * processor may have been re-submitted.
         */
        public void finalizeResponse(int nPartition)
            {
            // import Component.Net.Member as com.tangosol.coherence.component.net.Member;
            // import com.tangosol.net.internal.PartitionInfo;

            PartitionInfo info = getPartitionInfo(nPartition);

            decrementBacklog(info.getTarget(), 1);

            if (info.getCounter().decrementAndGet() == 0)
                {
                if (info.getDeferredRequests() == null)
                    {
                    // normal path; no requests are being deferred
                    }
                else
                    {
                    // there are deferred requests, indicating that the ownership has changed.
                    // Try to migrate to a new partition-info, resending any deferred requests,
                    // maintaining the original order.
                    com.tangosol.coherence.component.net.Member memberOwner = getService().getPrimaryOwner(nPartition);
                    if (memberOwner != null &&
                        info.getOwnershipVersion() != getService().getOwnershipVersion(nPartition))
                        {
                        transitionPartitionOwner(nPartition, memberOwner);
                        }
                    }
                }
            }

        /**
         * Indicates that ? Poll for an asycnhronous request for given
        * partitions has been closed. Note, that the associated asynchronous
        * processor may have been re-submitted.
         */
        public void finalizeResponse(com.tangosol.net.partition.PartitionSet partitions)
            {
            for (int iPart = partitions.next(0); iPart >= 0; iPart = partitions.next(iPart + 1))
                {
                finalizeResponse(iPart);
                }
            }

        // Accessor for the property "BacklogNormalCount"
        /**
         * Getter for property BacklogNormalCount.<p>
        * The number of pending messages that is considered to be "back to
        * normal" after backlog has been announced.
         */
        public int getBacklogNormalCount()
            {
            return __m_BacklogNormalCount;
            }

        // Accessor for the property "CloggedCount"
        /**
         * Getter for property CloggedCount.<p>
        * The maximum number of pending asynchronous requests before
        * determining that the service is clogged.
         */
        public int getCloggedCount()
            {
            return __m_CloggedCount;
            }

        // Accessor for the property "DeferredRequestCounter"
        /**
         * Getter for property DeferredRequestCounter.<p>
        * Atomic counter of number of async requests that are currently
        * deferred by this RequestCoordinator (across all partitions).
         */
        public java.util.concurrent.atomic.AtomicInteger getDeferredRequestCounter()
            {
            return __m_DeferredRequestCounter;
            }

        // Accessor for the property "MemberInfoMap"
        /**
         * Getter for property MemberInfoMap.<p>
        * A Map of MemberInfo objects keyed by the corresponding
        * (ownership-enabled) Member. Additionally, this map will always have a
        * MemberInfo keyed by null, representing the messages that are deferred
        * due to an unknown target member.
         */
        public java.util.Map getMemberInfoMap()
            {
            return __m_MemberInfoMap;
            }

        /**
         * Obtain the PartitionInfo for the specified partition.
         */
        protected com.tangosol.net.internal.PartitionInfo getPartitionInfo(int nPartition)
            {
            // import com.tangosol.net.internal.PartitionInfo;

            return (PartitionInfo) getPartitionInfoArray().get(nPartition);
            }

        // Accessor for the property "PartitionInfoArray"
        /**
         * Getter for property PartitionInfoArray.<p>
        * The (atomic/volatile) array of $PartitionInfo objects, indexed by
        * partition-id.
         */
        protected java.util.concurrent.atomic.AtomicReferenceArray getPartitionInfoArray()
            {
            return __m_PartitionInfoArray;
            }

        // Accessor for the property "Service"
        /**
         * Getter for property Service.<p>
         */
        public PartitionedCache getService()
            {
            return (PartitionedCache) get_Module();
            }

        /**
         * Increment the backlog counter for the specified Member (could be
        * null).
         */
        protected void incrementBacklog(com.tangosol.net.Member member, int c)
            {
            // import com.tangosol.net.internal.MemberInfo;

            MemberInfo info = (MemberInfo) getMemberInfoMap().get(member);
            info.getCounter().addAndGet(c);
            }

        /**
         * Initialize the RequestCoordinator.
         */
        public void initialize()
            {
            // import com.tangosol.coherence.config.Config;
            // import com.tangosol.net.internal.MemberInfo;
            // import com.tangosol.util.SafeHashMap;
            // import java.util.concurrent.atomic.AtomicReferenceArray;

            PartitionedCache service = getService();

            setPartitionInfoArray(new AtomicReferenceArray(service.getPartitionCount()));

            SafeHashMap mapInfo = new SafeHashMap();
            mapInfo.put(null, new MemberInfo()); // "missing target" info
            setMemberInfoMap(mapInfo);

            // use the EventDispatcher's threshold value
            int cMaxPending = service.ensureEventDispatcher().getCloggedCount();
            try
                {
                String sMaxPending = Config.getProperty("coherence.async.limit");
                if (sMaxPending != null)
                    {
                    cMaxPending = Integer.parseInt(sMaxPending);
                    }
                }
            catch (Exception ignored) {}

            setCloggedCount(cMaxPending = Math.max(256, cMaxPending));

            // to avoid thrashing, consider the "normal" threshold as 3/4 of the CloggedCount
            setBacklogNormalCount((cMaxPending >> 2) * 3);
            }

        /**
         * Instantiate the PartitionInfo for a given owner.
        *
        * @param member     the owner, or null if the partition is
        * endangered/orphaned
        * @param nVersion    the ownership version of the partition
         */
        protected com.tangosol.net.internal.PartitionInfo instantiatePartitionInfo(com.tangosol.coherence.component.net.Member member, int nVersion)
            {
            // import com.tangosol.net.internal.MemberInfo;
            // import com.tangosol.net.internal.PartitionInfo;
            // import com.tangosol.util.SparseArray;
            // import java.util.Map;

            PartitionInfo info = new PartitionInfo(member, nVersion);

            if (member == null)
                {
                // must defer requests until the membership is assigned
                info.setDeferredRequests(new SparseArray());
                }
            else
                {
                Map mapInfo = getMemberInfoMap();

                // all the concurrency concerns are handled by the callers
                if (!mapInfo.containsKey(member))
                    {
                    mapInfo.put(member, new MemberInfo());
                    }
                }
            return info;
            }

        /**
         * Event notification for performing low frequency periodic maintance
        * tasks.  The interval is dictated by the WaitMillis property.
        *
        * This is used for tasks which have a high enough cost that it is not
        * reasonble to perform them on every call to onWait() since it could be
        * called with a high frequency in the presense of work-loads with fast
        * oscillation between onWait() and onNotify().  As an example a single
        * threaded client could produce such a load.
        *
        * See Grid#onInterval()
        *
        * Called on the Service thread only.
         */
        public void onInterval()
            {
            checkDeferred();
            }

        /**
         * Called when the service has been resumed.
        *
        * Called on the Service thread only.
         */
        public void onServiceResumed()
            {
            // import Component.Net.MemberSet;

            // on service resume, restore the partition ownership, which should cause a flush
            // of the queued up requests

            PartitionedCache   service    = getService();
            MemberSet setMembers = service.getServiceMemberSet();
            int[][]   aaiOwners  = service.getPartitionAssignments();
            for (int iPart = 0, cParts = service.getPartitionCount(); iPart < cParts; iPart++)
                {
                updatePartitionOwner(iPart, setMembers.getMember(aaiOwners[iPart][0]), /*fResume*/true);
                }
            }

        /**
         * Called when the service has been suspended.
        *
        * Called on the Service thread only.
         */
        public void onServiceSuspended()
            {
            // while the service is suspended, the semantics are equivalent to the ownership
            // of all partitions being in-flux; "update" the partition ownership to force
            // the deferral of any additional requests for all partitions
            for (int iPart = 0, cParts = getService().getPartitionCount(); iPart < cParts; iPart++)
                {
                updatePartitionOwner(iPart, null);
                }
            }

        /**
         * Prepare to submit the specified request message for processing.
        *
        * @return member this request should be sent to or null if the request
        * was deferred
         */
        protected com.tangosol.coherence.component.net.Member prepareSubmit(com.tangosol.coherence.component.net.message.RequestMessage msgRequest, int nPartition, java.util.Map mapMsgByOwner)
            {
            // import Component.Net.Member as com.tangosol.coherence.component.net.Member;
            // import Component.Net.Message.RequestMessage.DistributedCacheRequest as com.tangosol.coherence.component.net.message.requestMessage.DistributedCacheRequest;
            // import Component.Net.Poll;
            // import com.tangosol.net.internal.PartitionInfo;
            // import com.tangosol.util.LongArray;
            // import java.util.concurrent.atomic.AtomicInteger;

            PartitionedCache service = (PartitionedCache) get_Module();

            outer:
            while (true)
                {
                PartitionInfo info              = getPartitionInfo(nPartition);
                com.tangosol.coherence.component.net.Member        member            = (com.tangosol.coherence.component.net.Member) info.getTarget();
                LongArray     laDeferred        = info.getDeferredRequests();
                boolean       fFinalizeResponse = false;

                if (laDeferred == null)
                    {
                    AtomicInteger counter = info.getCounter();
                    int           cPending;
                    do
                        {
                        cPending = counter.get();
                        if (cPending == -1)
                            {
                            // this partition-info has been "deactivated"; restart
                            continue outer;
                            }
                        }
                    while (!counter.compareAndSet(cPending, cPending + 1));

                    _assert(member != null);

                    incrementBacklog(member, 1);

                    com.tangosol.coherence.component.net.message.requestMessage.DistributedCacheRequest msgFirst = mapMsgByOwner == null
                                        ? null : (com.tangosol.coherence.component.net.message.requestMessage.DistributedCacheRequest) mapMsgByOwner.get(member);

                    msgRequest = msgFirst == null ? msgRequest : msgFirst;

                    Poll poll = msgRequest.ensureRequestPoll();
                    if (service.isSuspended() && msgRequest.isSuspendable() &&
                            poll.getPollId() > service.getSuspendPollLimit().get())
                        {
                        // concurrent suspend; we must insert this request into the now non-null
                        // laDeferred, and only then decrement info.getCounter()
                        fFinalizeResponse = true;
                        laDeferred        = info.getDeferredRequests();

                        _assert(laDeferred != null);
                        }
                    else
                        {
                        return member;
                        }
                    }

                // the presence of a deferred request array indicates that the partition
                // membership has changed; add the request to the list which will be cleared
                // once all outstanding requests have completed

                synchronized (laDeferred)
                    {
                    validateRequest(msgRequest);

                    if (info != getPartitionInfo(nPartition))
                        {
                        // the partition-info has been concurrently switched
                        continue outer;
                        }

                    laDeferred.set(msgRequest.getRequestContext().getRequestSUID(), msgRequest);
                    }

                getDeferredRequestCounter().incrementAndGet();

                incrementBacklog(member, 1);

                if (fFinalizeResponse)
                    {
                    // suspend transition occured concurrently, correct the count
                    finalizeResponse(nPartition);
                    }

                return null;
                }
            }

        /**
         * Re-submit the specified request message for processing.
        *
        * @param msgRequest the request to be re-submitted
        * @param partRequest the PartitionSet for which the request needs to be
        * re-submitted (can be null for key-based requests)
        * @param partUpdate the PartitionSet for which the partition ownership
        * needs to be updated (can be null)
        *
        * @return true if the request has been successfully scheduled for
        * execution or there is nothing to execute; false if re-submit fails
         */
        public boolean resubmitRequest(com.tangosol.coherence.component.net.message.requestMessage.DistributedCacheRequest msgRequest, com.tangosol.net.partition.PartitionSet partRequest, com.tangosol.net.partition.PartitionSet partUpdate)
            {
            // import Component.Net.Message.RequestMessage.DistributedCacheRequest.KeySetRequest;
            // import Component.Net.Message.RequestMessage.DistributedCacheRequest.PartialRequest.FilterRequest;
            // import Component.Net.RequestContext.AsyncContext;
            // import com.tangosol.net.internal.PartitionVersions;
            // import java.util.Set;

            if (partUpdate != null)
                {
                PartitionedCache           service  = (PartitionedCache) get_Module();
                PartitionVersions versions = msgRequest.getOwnershipVersions();

                for (int iPart = partUpdate.next(0); iPart >= 0; iPart = partUpdate.next(iPart + 1))
                    {
                    if (versions.getVersion(iPart) == service.getOwnershipVersion(iPart))
                        {
                        // partition was not owned, or there was a version conflict;
                        // "update" the partition-info to unowned in order force the
                        // resubmission to be held until updated partition-info is received
                        updatePartitionOwner(iPart, null);
                        }
                    }
                }

            try
                {
                validateRequest(msgRequest);
                }
            catch (Throwable e)
                {
                ((AsyncContext) msgRequest.getRequestContext()).processException(e);
                return false;
                }

            if (msgRequest instanceof KeySetRequest)
                {
                KeySetRequest msgKSR    = (KeySetRequest) msgRequest;
                Set           setResend = msgKSR.getKeySet();

                return setResend == null || setResend.isEmpty() ||
                    submitKeySetRequest(msgKSR, setResend, null, /*fRepeat*/true);
                }

            if (msgRequest instanceof FilterRequest)
                {
                return partRequest == null || partRequest.isEmpty() ||
                    submitPartialRequest((FilterRequest) msgRequest, partRequest, /*fRepeat*/true);
                }

            // this is an assertion; the service will be terminated
            throw new IllegalArgumentException("Invalid resubmit request: " + msgRequest);
            }

        /**
         * Re-submit the specified request message for processing.
        *
        * @param msgRequest the request to be re-submitted
        * @param iPart the targetted partition
        * @param fUpdatePart whether the partition ownership needs to be
        * updated
        *
        * @return true if the request has been successfully scheduled for
        * execution or there is nothing to execute; false if re-submit fails
         */
        public boolean resubmitRequest(PartitionedCache.InvokeRequest msgRequest, int iPart, boolean fUpdatePart)
            {
            // import Component.Net.RequestContext.AsyncContext;

            if (fUpdatePart &&
                    msgRequest.getOwnershipVersion() == getService().getOwnershipVersion(iPart))
                {
                // partition was not owned, or there was a version conflict;
                // "update" the partition-info to unowned in order force the
                // resubmission to be held until updated partition-info is received
                updatePartitionOwner(iPart, null);
                }

            try
                {
                validateRequest(msgRequest);
                }
            catch (Throwable e)
                {
                ((AsyncContext) msgRequest.getRequestContext()).processException(e);
                return false;
                }

            if (msgRequest instanceof PartitionedCache.InvokeRequest)
                {
                return submitKeyRequest((PartitionedCache.InvokeRequest) msgRequest, iPart);
                }

            // this is an assertion; the service will be terminated
            throw new IllegalArgumentException("Invalid resubmit request: " + msgRequest);
            }

        // Accessor for the property "BacklogNormalCount"
        /**
         * Setter for property BacklogNormalCount.<p>
        * The number of pending messages that is considered to be "back to
        * normal" after backlog has been announced.
         */
        protected void setBacklogNormalCount(int c)
            {
            __m_BacklogNormalCount = c;
            }

        // Accessor for the property "CloggedCount"
        /**
         * Setter for property CloggedCount.<p>
        * The maximum number of pending asynchronous requests before
        * determining that the service is clogged.
         */
        protected void setCloggedCount(int nCount)
            {
            __m_CloggedCount = nCount;
            }

        // Accessor for the property "DeferredRequestCounter"
        /**
         * Setter for property DeferredRequestCounter.<p>
        * Atomic counter of number of async requests that are currently
        * deferred by this RequestCoordinator (across all partitions).
         */
        protected void setDeferredRequestCounter(java.util.concurrent.atomic.AtomicInteger atomic)
            {
            __m_DeferredRequestCounter = atomic;
            }

        // Accessor for the property "MemberInfoMap"
        /**
         * Setter for property MemberInfoMap.<p>
        * A Map of MemberInfo objects keyed by the corresponding
        * (ownership-enabled) Member. Additionally, this map will always have a
        * MemberInfo keyed by null, representing the messages that are deferred
        * due to an unknown target member.
         */
        protected void setMemberInfoMap(java.util.Map map)
            {
            __m_MemberInfoMap = map;
            }

        /**
         * Set the PartitionInfo for a given partition.
         */
        protected void setPartitionInfo(int nPartition, com.tangosol.net.internal.PartitionInfo info)
            {
            getPartitionInfoArray().set(nPartition, info);
            }

        // Accessor for the property "PartitionInfoArray"
        /**
         * Setter for property PartitionInfoArray.<p>
        * The (atomic/volatile) array of $PartitionInfo objects, indexed by
        * partition-id.
         */
        protected void setPartitionInfoArray(java.util.concurrent.atomic.AtomicReferenceArray arrayInfo)
            {
            __m_PartitionInfoArray = arrayInfo;
            }

        /**
         * Submit the specified request message for processing.
        *
        * @return true iff the request has been scheduled for execution
         */
        public boolean submitKeyRequest(PartitionedCache.InvokeRequest msgRequest, int nPartition)
            {
            // import Component.Net.RequestContext.AsyncContext;

            try
                {
                ((PartitionedCache) get_Module()).checkQuorum(msgRequest, msgRequest.isReadOnly());

                doSubmit(msgRequest, prepareSubmit(msgRequest, nPartition, null));

                return true;
                }
            catch (Throwable e)
                {
                ((AsyncContext) msgRequest.getRequestContext()).processException(e);
                return false;
                }
            }

        /**
         * Submit the specified partitioned key set-based asynchronous request
        * to all the storage enabled service members that own any of the
        * specified keys.
        *
        * Note: the passed-in key set will not be changed.
        *
        * @param partitions if not null, add all relevant partitions to that
        * PartitionSet
        *
        * @return true iff the request has been scheduled for execution
         */
        public boolean submitKeySetRequest(com.tangosol.coherence.component.net.message.requestMessage.distributedCacheRequest.KeySetRequest msgRequest, java.util.Set setKeys, com.tangosol.net.partition.PartitionSet partitions, boolean fRepeat)
            {
            // import Component.Net.Member as com.tangosol.coherence.component.net.Member;
            // import Component.Net.Message.RequestMessage.DistributedCacheRequest.KeySetRequest as com.tangosol.coherence.component.net.message.requestMessage.distributedCacheRequest.KeySetRequest;
            // import Component.Net.RequestContext.AsyncContext;
            // import java.util.HashMap;
            // import java.util.Iterator;
            // import java.util.Map;
            // import java.util.Map$Entry as java.util.Map.Entry;
            // import java.util.Set;

            PartitionedCache service       = getService();
            Map     mapMsgByOwner = new HashMap();
            boolean fClone        = false;

            try
                {
                service.checkQuorum(msgRequest, msgRequest.isReadOnly());

                Map mapKeysByPID = service.splitKeysByPartition(setKeys.iterator());

                for (Iterator iter = mapKeysByPID.entrySet().iterator(); iter.hasNext(); )
                    {
                    java.util.Map.Entry entry       = (java.util.Map.Entry) iter.next();
                    int   nPartition  = ((Integer) entry.getKey()).intValue();
                    Set   setPartKeys = (Set) entry.getValue();

                    // be ready to defer a message for every partition separately,
                    // but merge the keys if possible

                    if (fClone)
                        {
                        msgRequest = (com.tangosol.coherence.component.net.message.requestMessage.distributedCacheRequest.KeySetRequest) msgRequest.cloneMessage();
                        }
                    else
                        {
                        // allow the very first message to use the original message instance
                        fClone = true;
                        }

                    msgRequest.setKeySet(setPartKeys);
                    msgRequest.setPartitions(service.instantiatePartitionSet(nPartition));

                    com.tangosol.coherence.component.net.Member member = prepareSubmit(msgRequest, nPartition, mapMsgByOwner);
                    if (member == null)
                        {
                        // the message for this partition has been deferred;
                        // it will be submitted later (non-bundled with any other partition)
                        }
                    else
                        {
                        com.tangosol.coherence.component.net.message.requestMessage.distributedCacheRequest.KeySetRequest msgFirst = (com.tangosol.coherence.component.net.message.requestMessage.distributedCacheRequest.KeySetRequest) mapMsgByOwner.get(member);
                        if (msgFirst == null)
                            {
                            mapMsgByOwner.put(member, msgRequest);
                            }
                        else
                            {
                            // simply merge the keys into the existing message and "drop" the new message
                            msgFirst.getKeySet().addAll(setPartKeys);
                            msgFirst.getPartitions().add(nPartition);
                            }
                        }

                    if (partitions != null)
                        {
                        partitions.add(nPartition);
                        }
                    }
                }
            catch (Throwable e)
                {
                ((AsyncContext) msgRequest.getRequestContext()).processException(e);
                return false;
                }

            if (!mapMsgByOwner.isEmpty())
                {
                if (fRepeat)
                    {
                    BinaryMap.reportRepeat(msgRequest.get_Name(), setKeys.size(), 0,
                                ((PartitionedCache) get_Module()).calculatePartitionSet(setKeys));
                    }

                for (Iterator iter = mapMsgByOwner.entrySet().iterator(); iter.hasNext(); )
                    {
                    java.util.Map.Entry entry = (java.util.Map.Entry) iter.next();

                    doSubmit((com.tangosol.coherence.component.net.message.requestMessage.distributedCacheRequest.KeySetRequest) entry.getValue(), (com.tangosol.coherence.component.net.Member) entry.getKey());
                    }
                }
            return true;
            }

        /**
         * Submit the specified partial (filter-based) asynchronous request to
         * all the storage enabled service members that own any of the specified
         * keys. The messages sent are grouped by partition.
         *
         * @param msgRequest  request message
         * @param partitions  partitions to submit the request(s) for
         * @param fRepeat     whether this request is being repeated
         * @return true when all requests have been scheduled
         */
        public boolean submitPartialRequestByPartition(PartialRequest msgRequest, PartitionSet partitions, boolean fRepeat)
            {
            PartitionedCache service           = getService();
            AsyncContext     context           = (AsyncContext) msgRequest.getRequestContext();
            Map<Integer, PartialRequest> mapMsgByPartition = new HashMap<>();
            try
                {
                service.checkQuorum(msgRequest, msgRequest.isReadOnly());

                boolean fClone = false;
                for (int iPart = partitions.next(0); iPart >= 0; iPart = partitions.next(iPart + 1))
                    {
                    PartitionSet partMember  = new PartitionSet(partitions.getPartitionCount());
                    partMember.add(iPart);

                    if (fClone)
                        {
                        msgRequest = (PartialRequest) msgRequest.cloneMessage();
                        }
                    else
                        {
                        // allow the very first message to use the original message instance
                        fClone = true;
                        }

                    msgRequest.setRequestMask(partMember);
                    msgRequest.setPartitions(partitions);

                    com.tangosol.coherence.component.net.Member member = prepareSubmit(msgRequest, iPart, mapMsgByPartition);
                    if (member == null)
                        {
                        // the message for this partition has been deferred;
                        // it will be submitted later (non-bundled with any other partition)
                        }
                    else
                        {
                        msgRequest.setToMemberSet(SingleMemberSet.instantiate(member));

                        mapMsgByPartition.put(iPart, msgRequest);
                        }
                    }
                }
            catch (Throwable e)
                {
                context.processException(e);
                return false;
                }

            if (!mapMsgByPartition.isEmpty())
                {
                if (fRepeat)
                    {
                    BinaryMap.reportRepeat(msgRequest.get_Name(), 0, 0, partitions);
                    }

                for (Map.Entry entry : mapMsgByPartition.entrySet())
                    {
                    PartialRequest msg   = (PartialRequest) entry.getValue();

                    // copy the timeout value onto the Poll (see Grid$PollArray#checkPolls)
                    msg.ensureRequestPoll().setExpiryTimeMillis(msg.getRequestTimeout());
                    try
                        {
                        getService().post(msg); // the caller is responsible for flushing
                        }
                    catch (Throwable e)
                        {
                        // RequestMessage.post() closed the poll passing this exception.
                        }
                    }
                }
            return true;
            }

        /**
         * Submit the specified partial (filter-based) asynchronous request to
        * all the storage enabled service members that own any of the specified
        * keys.
        *
        * @param partitions partitions submit the request(s) for
        *
        * @return true iff the request has been scheduled for execution
         */
        public boolean submitPartialRequest(com.tangosol.coherence.component.net.message.requestMessage.distributedCacheRequest.PartialRequest msgRequest, com.tangosol.net.partition.PartitionSet partitions, boolean fRepeat)
            {
            // import Component.Net.Member as com.tangosol.coherence.component.net.Member;
            // import Component.Net.Message.RequestMessage.DistributedCacheRequest.PartialRequest as com.tangosol.coherence.component.net.message.requestMessage.distributedCacheRequest.PartialRequest;
            // import Component.Net.RequestContext.AsyncContext;
            // import java.util.HashMap;
            // import java.util.Iterator;
            // import java.util.Map;
            // import java.util.Map$Entry as java.util.Map.Entry;

            PartitionedCache      service       = getService();
            AsyncContext context       = (AsyncContext) msgRequest.getRequestContext();
            Map          mapMsgByOwner = new HashMap();
            try
                {
                service.checkQuorum(msgRequest, msgRequest.isReadOnly());

                boolean fClone = false;
                for (int iPart = partitions.next(0); iPart >= 0; iPart = partitions.next(iPart + 1))
                    {
                     if (fClone)
                        {
                        msgRequest = (com.tangosol.coherence.component.net.message.requestMessage.distributedCacheRequest.PartialRequest) msgRequest.cloneMessage();
                        }
                    else
                        {
                        // allow the very first message to use the original message instance
                        fClone = true;
                        }

                    msgRequest.setRequestMask(service.instantiatePartitionSet(iPart));
                    msgRequest.setPartitions(context.getPartitionSet());

                    com.tangosol.coherence.component.net.Member member = prepareSubmit(msgRequest, iPart, mapMsgByOwner);
                    if (member == null)
                        {
                        // the message for this partition has been deferred;
                        // it will be submitted later (non-bundled with any other partition)
                        }
                    else
                        {
                        com.tangosol.coherence.component.net.message.requestMessage.distributedCacheRequest.PartialRequest msgFirst = (com.tangosol.coherence.component.net.message.requestMessage.distributedCacheRequest.PartialRequest) mapMsgByOwner.get(member);
                        if (msgFirst == null)
                            {
                            mapMsgByOwner.put(member, msgRequest);
                            }
                        else
                            {
                            // simply merge the keys into the existing message and "drop" the new message
                            msgFirst.getRequestMask().add(iPart);
                            }
                        }
                    }
                }
            catch (Throwable e)
                {
                context.processException(e);
                return false;
                }

            if (!mapMsgByOwner.isEmpty())
                {
                if (fRepeat)
                    {
                    BinaryMap.reportRepeat(msgRequest.get_Name(), 0, 0, partitions);
                    }

                for (Iterator iter = mapMsgByOwner.entrySet().iterator(); iter.hasNext(); )
                    {
                    java.util.Map.Entry entry = (java.util.Map.Entry) iter.next();

                    doSubmit((com.tangosol.coherence.component.net.message.requestMessage.distributedCacheRequest.PartialRequest) entry.getValue(), (com.tangosol.coherence.component.net.Member) entry.getKey());
                    }
                }
            return true;
            }

        /**
         * Sync the partition-info objects maintained by the request coordinator
        * with the latest partition assignments.
        *
        * This method must only be called on the service thread.
         */
        public void syncAssignments()
            {
            // import Component.Net.MemberSet.ActualMemberSet.ServiceMemberSet as com.tangosol.coherence.component.net.memberSet.actualMemberSet.ServiceMemberSet;

            PartitionedCache   service     = getService();
            int       cPartitions = service.getPartitionCount();
            int[][]   aaiOwner    = service.getPartitionAssignments();
            com.tangosol.coherence.component.net.memberSet.actualMemberSet.ServiceMemberSet setMember  = service.getServiceMemberSet();

            _assert(Thread.currentThread() == service.getThread());

            for (int iPart = 0; iPart < cPartitions; iPart++)
                {
                updatePartitionOwner(iPart, setMember.getMember(aaiOwner[iPart][0]));
                }
            }

        // Declared at the super level
        public String toString()
            {
            // import com.tangosol.net.Member;
            // import com.tangosol.net.internal.MemberInfo;
            // import com.tangosol.net.internal.PartitionInfo;
            // import com.tangosol.util.LongArray;
            // import java.util.Iterator;
            // import java.util.List;
            // import java.util.Map$Entry as java.util.Map.Entry;

            // used for debugging only

            StringBuilder sb = new StringBuilder(get_Name());

            for (int i = 0, c = getService().getPartitionCount(); i < c; ++i)
                {
                PartitionInfo info = getPartitionInfo(i);

                int       cPending   = info.getCounter().get();
                LongArray laDeferred = info.getDeferredRequests();

                if (cPending != 0 || laDeferred != null)
                    {
                    sb.append("\n  Partition ").append(i)
                      .append(": pending=").append(cPending)
                      .append(", deferred=").append(laDeferred == null ? 0 : laDeferred.getSize());
                    }
                }

            for (Iterator iter = getMemberInfoMap().entrySet().iterator(); iter.hasNext();)
                {
                java.util.Map.Entry entry = (java.util.Map.Entry) iter.next();

                Member     member   = (Member) entry.getKey();
                MemberInfo info     = (MemberInfo) entry.getValue();
                int        cPending = info.getCounter().get();
                List       list     = info.getBacklogContinuations();

                if (cPending > 0 || (list != null && !list.isEmpty()))
                    {
                    sb.append("\n    Member ").append(member.getId())
                      .append(": pending=").append(cPending)
                      .append(", awaiting=").append(list == null ? 0 : list.size());
                    }
                }

            return sb.toString();
            }

        /**
         * If there are no outstanding pending requests for the specified
        * partition, transition (by replacing) the PartitionInfo for the
        * specified partition to reflect a new owner. This method
        * can also be called when the service is being resumed after suspend in
        * which case the owner will remain the same but the PartitionInfo is
        * still replaced to indicate that subsequent
        * requests need not be deferred.
        *
        * Otherwise, the update will be made once those requests have been
        * completed.
        *
        * @param memberNew  the new owner (must never be null)
         */
        protected void transitionPartitionOwner(int nPartition, com.tangosol.coherence.component.net.Member memberNew)
            {
            // import Component.Net.MemberSet.SingleMemberSet;
            // import Component.Net.Message.RequestMessage;
            // import com.tangosol.net.Member;
            // import com.tangosol.net.internal.PartitionInfo;
            // import com.tangosol.util.LongArray;
            // import java.util.Iterator;

            PartitionedCache       service = getService();
            PartitionInfo infoOld = getPartitionInfo(nPartition);
            if (infoOld.getCounter().compareAndSet(0, -1))
                {
                _assert(memberNew != null);

                PartitionInfo infoNew = instantiatePartitionInfo(memberNew,
                    service.getOwnershipVersion(nPartition));

                LongArray laDeferred = infoOld.getDeferredRequests();

                synchronized (laDeferred)
                    {
                    int cDeferred = laDeferred.getSize();

                    if (service.isSuspended())
                        {
                        infoNew.setDeferredRequests(laDeferred);
                        }
                    else
                        {
                        // iterate the deferred requests and resubmit them
                        // while keeping track on the new PartitionInfo

                        for (Iterator iter = laDeferred.iterator(); iter.hasNext(); )
                            {
                            RequestMessage msgRequest = (RequestMessage) iter.next();

                            doSubmit(msgRequest, memberNew);
                            }

                        getDeferredRequestCounter().addAndGet(-cDeferred);

                        // we can update the infoNew counter after sending the messages since
                        // this method is always called on the service thread and poll acceleration
                        // for async operations is disabled  - see InvokeRequest.preprocessResponse()
                        infoNew.getCounter().addAndGet(cDeferred);
                        }

                    Member memberOld = infoOld.getTarget();
                    if (memberOld != memberNew)
                        {
                        // update the corresponding backlog counters
                        incrementBacklog(memberNew, cDeferred);
                        decrementBacklog(memberOld, cDeferred);
                        }

                    // lastly, while holding synchronization on the deferred requests
                    // array, replace the partition info
                    setPartitionInfo(nPartition, infoNew);
                    }
                }
            }

        /**
         * Called when the primary ownership of the specified partition has
        * potentially changed.  The specified member is either the new owner,
        * or null if the partition became endangered/orphaned.
        *
        * This method must only be called on the service thread.
        *
        * @param nPartition  partition id
        * @param member     the owner, or null if the partition is
        * endangered/orphaned
         */
        public void updatePartitionOwner(int nPartition, com.tangosol.coherence.component.net.Member member)
            {
            updatePartitionOwner(nPartition, member, /*fResume*/false);
            }

        /**
         * Called when the primary ownership of the specified partition has
        * potentially changed.  The specified member is either the new owner,
        * or null if the partition became endangered/orphaned.
        *
        * This method must only be called on the service thread.
        *
        * @param nPartition  partition id
        * @param member     the owner, or null if the partition is
        * endangered/orphaned
        * @param fResume    true iff the service is being resumed after
        * suspension
         */
        protected void updatePartitionOwner(int nPartition, com.tangosol.coherence.component.net.Member member, boolean fResume)
            {
            // import com.tangosol.net.internal.PartitionInfo;
            // import com.tangosol.util.SparseArray;

            // we must only get here on the service thread
            _assert(Thread.currentThread() == getService().getThread());

            PartitionInfo info = getPartitionInfo(nPartition);
            if (info == null)
                {
                // first assignment
                setPartitionInfo(
                        nPartition, instantiatePartitionInfo(member, getService().getOwnershipVersion(nPartition)));
                }
            else if (info.getTarget() != member ||
                     info.getOwnershipVersion() != getService().getOwnershipVersion(nPartition) ||
                     fResume)
                {
                // set the deferred requests array as a signal that the membership has changed
                if (info.getDeferredRequests() == null)
                    {
                    info.setDeferredRequests(new SparseArray());
                    }

                if (member != null)
                    {
                    transitionPartitionOwner(nPartition, member);
                    }
                }
            }

        /**
         * Throws an exception if the provided request message can not be
        * successfully submitted.
         */
        protected void validateRequest(com.tangosol.coherence.component.net.message.RequestMessage msgRequest)
            {
            // import Component.Net.RequestContext.AsyncContext;
            // import com.tangosol.net.RequestPolicyException;
            // import com.tangosol.net.RequestTimeoutException;
            // import com.tangosol.net.ServiceStoppedException;
            // import com.tangosol.util.Base;

            PartitionedCache      service   = (PartitionedCache) get_Module();
            AsyncContext ctx       = (AsyncContext) msgRequest.getRequestContext();
            BinaryMap   mapBinary = ctx.getCache();

            RuntimeException e = null;
            if (Base.getLastSafeTimeMillis() >= msgRequest.getRequestTimeout())
                {
                throw new RequestTimeoutException("Async request timeout after " +
                    service.calculateRequestTimeout(msgRequest) + "ms");
                }
            else if (service.getServiceState() == PartitionedCache.SERVICE_STOPPED)
                {
                throw new ServiceStoppedException("Service " + service.getServiceName() +
                    " has been terminated");
                }
            else if (!mapBinary.isActive())
                {
                throw new RequestPolicyException("The reference to cache \"" +
                    mapBinary.getCacheName() + "\" has been released");
                }
            }

        // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$RequestCoordinator$BacklogContinuation

        /**
         * Continuation used for the automatic flow control.
         */
        @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
        public static class BacklogContinuation
                extends    com.tangosol.coherence.component.Util
                implements com.oracle.coherence.common.base.Continuation
            {
            // ---- Fields declarations ----

            /**
             * Property Notifier
             *
             * The notifier.
             */
            private com.oracle.coherence.common.base.SingleWaiterMultiNotifier __m_Notifier;

            // Default constructor
            public BacklogContinuation()
                {
                this(null, null, true);
                }

            // Initializing constructor
            public BacklogContinuation(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                {
                super(sName, compParent, false);

                if (fInit)
                    {
                    __init();
                    }
                }

            // Main initializer
            public void __init()
                {
                // private initialization
                __initPrivate();

                // state initialization: public and protected properties
                try
                    {
                    setNotifier(new com.oracle.coherence.common.base.SingleWaiterMultiNotifier());
                    }
                catch (java.lang.Exception e)
                    {
                    // re-throw as a runtime exception
                    throw new com.tangosol.util.WrapperException(e);
                    }

                // signal the end of the initialization
                set_Constructed(true);
                }

            // Private initializer
            protected void __initPrivate()
                {

                super.__initPrivate();
                }

            //++ getter for static property _Instance
            /**
             * Getter for property _Instance.<p>
            * Auto generated
             */
            public static com.tangosol.coherence.Component get_Instance()
                {
                return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.RequestCoordinator.BacklogContinuation();
                }

            //++ getter for static property _CLASS
            /**
             * Getter for property _CLASS.<p>
            * Property with auto-generated accessor that returns the Class
            * object for a given component.
             */
            public static Class get_CLASS()
                {
                Class clz;
                try
                    {
                    clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$RequestCoordinator$BacklogContinuation".replace('/', '.'));
                    }
                catch (ClassNotFoundException e)
                    {
                    throw new NoClassDefFoundError(e.getMessage());
                    }
                return clz;
                }

            //++ getter for autogen property _Module
            /**
             * This is an auto-generated method that returns the global [design
            * time] parent component.
            *
            * Note: the class generator will ignore any custom implementation
            * for this behavior.
             */
            private com.tangosol.coherence.Component get_Module()
                {
                return this.get_Parent().get_Parent();
                }

            // Accessor for the property "Notifier"
            /**
             * Getter for property Notifier.<p>
            * The notifier.
             */
            public com.oracle.coherence.common.base.SingleWaiterMultiNotifier getNotifier()
                {
                return __m_Notifier;
                }

            // From interface: com.oracle.coherence.common.base.Continuation
            public void proceed(Object oResult)
                {
                getNotifier().signal();
                }

            // Accessor for the property "Notifier"
            /**
             * Setter for property Notifier.<p>
            * The notifier.
             */
            protected void setNotifier(com.oracle.coherence.common.base.SingleWaiterMultiNotifier notifier)
                {
                __m_Notifier = notifier;
                }
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$ResourceCoordinator
    
    /**
     * ResourceCoordinator is used to control concurrent access to and manage
     * events generated by the resource (backing) maps.
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class ResourceCoordinator
            extends    com.tangosol.coherence.component.Util
            implements com.tangosol.util.SegmentedConcurrentMap.ContentionObserver
        {
        // ---- Fields declarations ----
        
        /**
         * Property ContentionMap
         *
         * This Map<Thread, SCM$LockableEntry> associates threads that are
         * contending for resource control locks, to the thread that holds the
         * lock being contended for.
         * 
         * This map captures contention for resource locks across all
         * $Storage's in this service.
         */
        private java.util.Map __m_ContentionMap;
        
        /**
         * Property EventFabric
         *
         */
        private com.tangosol.internal.util.BMEventFabric __m_EventFabric;
        
        /**
         * Property FinalizingRequest
         *
         * True if a thread is in finalizing request,  any new backing map
         * event should be added to UnmanagedEventQueue, see#finalizeInvoke.
         */
        private boolean __m_FinalizingRequest;
        
        /**
         * Property IdCounter
         *
         * The atomic counter that generates unique-id's for EventHolders.
         */
        private java.util.concurrent.atomic.AtomicLong __m_IdCounter;
        
        /**
         * Property TloEventQueue
         *
         * ThreadLocal event queue
         */
        private ThreadLocal __m_TloEventQueue;
        
        /**
         * Property TloFinalizingRequest
         *
         * ThreadLocal flag indicating if a request is done and in
         * processChanges.  If true,  any new event occured in this thread
         * should be added to UnmanagedEventQueue. 
         */
        private ThreadLocal __m_TloFinalizingRequest;
        
        /**
         * Property UnmanagedEventQueue
         *
         * The EventQueue used to accumulate all "out-of-band" (raised on
         * "unmanaged" threads) BM events.
         */
        private com.tangosol.internal.util.BMEventFabric.EventQueue __m_UnmanagedEventQueue;
        
        // Default constructor
        public ResourceCoordinator()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public ResourceCoordinator(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                setContentionMap(new com.tangosol.util.SafeHashMap());
                setEventFabric(new com.tangosol.internal.util.BMEventFabric());
                setTloEventQueue(new java.lang.ThreadLocal());
                setTloFinalizingRequest(new java.lang.ThreadLocal());
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.ResourceCoordinator();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$ResourceCoordinator".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        /**
         * Check for a logical deadlock on the acquiring resource locks.
        * Throw IllegalMonitorStateException if a deadlock is detected.
        * 
        * @param oHolder  the contending lock holder
         */
        protected void checkResourceDeadlock(Object oContender)
            {
            // import com.tangosol.internal.util.LockContentionException;
            // import com.tangosol.util.LiteSet;
            // import com.tangosol.util.SegmentedConcurrentMap$LockableEntry as com.tangosol.util.SegmentedConcurrentMap.LockableEntry;
            // import java.util.Map;
            // import java.util.Set;
            
            Map    mapContend  = getContentionMap();
            Set    setHolders  = new LiteSet();
            Object oHolder     = oContender;
            Object oHolderPrev;
            
            do
                {
                setHolders.add(oHolderPrev = oHolder);
                com.tangosol.util.SegmentedConcurrentMap.LockableEntry entry = (com.tangosol.util.SegmentedConcurrentMap.LockableEntry) mapContend.get(oHolder);
            
                oHolder = entry == null ? null : entry.getLockHolder();
                if (setHolders.contains(oHolder))
                    {
                    // found a cycle in the contention map; must be deadlock
            
                    // if this thread is directly involved in the detected deadlock one of the
                    // participating threads should throw a LockContentionException; if the
                    // entry is contended then some thread is already wait()'ing, so this thread
                    // should throw; otherwise pick an arbitrary ordering among threads.
                    com.tangosol.util.SegmentedConcurrentMap.LockableEntry entryThis = (com.tangosol.util.SegmentedConcurrentMap.LockableEntry) mapContend.get(oContender);
                    if ((oContender == oHolder || oContender == oHolderPrev) &&
                        (entry.isContended() ||
                        System.identityHashCode(oContender) <= System.identityHashCode(entryThis.getLockHolder())))
                        {
                        Object   oContenderThat = oContender == oHolder ? oHolderPrev : oHolder;
                        Object[] aoContenders   = new Object[] {oContender, oContenderThat};
                        com.tangosol.util.SegmentedConcurrentMap.LockableEntry[]  aEntries       = new com.tangosol.util.SegmentedConcurrentMap.LockableEntry[] {entryThis, entry};
            
                        reportContendingThreads(aoContenders, aEntries);
                        throw new LockContentionException(
                              "A deadlock was detected while trying to lock cache resource " + getCacheKeyDescription(entryThis) + 
                              " which could be caused by unsafe use of the getBackingMapEntry() " +
                              "method. Threads under contention: " + setHolders);
                        }
            
                    break;
                    }
                }
            while (oHolder != null);
            
            // contention dependency chain terminates; no deadlock, just slow owner
            }
        
        /**
         * Specialized helper method to collect aynchronously observed
        * $EventStatus objects.
        * 
        * @param setStatus    the Set<$EntryStatus> of asynchronously observed
        * statuses, may be null
        * @param holder         the $EventHolder to collect, if it was
        * asynchronously observed
        * 
        * @return the new or updated Set<$EntryStatus> of asynchronously
        * observed statuses, or null
         */
        protected java.util.Set collectOOBStatus(java.util.Set setStatusOOB, com.tangosol.internal.util.BMEventFabric.EventHolder evtHolder)
            {
            // import com.tangosol.util.LiteSet;
            
            if (setStatusOOB == null)
                {
                setStatusOOB = new LiteSet();
                }
            setStatusOOB.add((Storage.EntryStatus) evtHolder.getStatus());
            
            return setStatusOOB;
            }
        
        protected java.util.Set combineResults(java.util.Set set1, java.util.Set set2)
            {
            if (set1 == null || set1.isEmpty())
                {
                return set2;
                }
            if (set2 == null || set2.isEmpty())
                {
                return set1;
                }
            
            set1.addAll(set2);
            return set1;
            }
        
        /**
         * Return an $EventQueue (creating one if necessary) to hold observed
        * backing map events that occurred on this thread.
         */
        public com.tangosol.internal.util.BMEventFabric.EventQueue ensureEventQueue()
            {
            // import com.tangosol.internal.util.BMEventFabric$EventQueue as com.tangosol.internal.util.BMEventFabric.EventQueue;
            
            ThreadLocal tloEventQueue = getTloEventQueue();
            com.tangosol.internal.util.BMEventFabric.EventQueue       queue         = (com.tangosol.internal.util.BMEventFabric.EventQueue) tloEventQueue.get();
            if (queue == null)
                {
                // Note: no synchronization needed, as we are lazy-initializing a TLO
                tloEventQueue.set(queue = instantiateEventQueue(true));
                }
            
            return queue;
            }
        
        /**
         * Return an $EntryStatus (creating one if necessary) for the specified
        * binary key (belonging to the specified storage) to track the observed
        * changes relating to the key.
        * 
        * @param storage   the storage which the specified key belongs to
        * @param binKey     the (binary) key to return a status for
         */
        public Storage.EntryStatus ensureStatus(Storage storage, com.tangosol.util.Binary binKey)
            {
            // import java.util.concurrent.ConcurrentMap as java.util.concurrent.ConcurrentMap;
            
            java.util.concurrent.ConcurrentMap mapStatus = storage.getEntryStatusMap();
            Storage.EntryStatus  status    = (Storage.EntryStatus) mapStatus.get(binKey);
            
            if (status == null)
                {
                // use putIfAbsent here to protect against concurrent ensureStatus() calls.
                // Somebody will win the race, but it doesn't matter who.
                Storage.EntryStatus statusNew = Storage.EntryStatus.instantiateStatus(binKey);
                storage._linkChild(statusNew);
                statusNew.setPartition(getService().getKeyPartition(binKey));
            
                status = (Storage.EntryStatus) mapStatus.putIfAbsent(binKey, statusNew);
                if (status == null)
                    {
                    // putIfAbsent() succeeded; return the new status object
                    status = statusNew;
                    }
                }
            return status;
            }
        
        /**
         * Process queued MapEvents.
        * This method is called on the service or worker threads during a
        * "managed" operation.
        * See //dev/main/doc/coherence-core/BMEHandling.txt
        * 
        * @return  a Set<$EntryStatus> of  asynchronously (to this thread)
        * changed $EntryStatus objects, or null
         */
        public java.util.Set finalizeInvoke()
            {
            // import com.tangosol.internal.util.BMEventFabric$EventQueue as com.tangosol.internal.util.BMEventFabric.EventQueue;
            // import java.util.Set;
            
            com.tangosol.internal.util.BMEventFabric.EventQueue queueThdCurrent = ensureEventQueue();
            com.tangosol.internal.util.BMEventFabric.EventQueue queueOOBEvents  = getUnmanagedEventQueue();
            
            _assert(queueThdCurrent != queueOOBEvents); // OOB threads should not process events
            
            setFinalizingRequest(true);
            
            Set setStatus1 = finalizeInvokeSingleThreaded(queueThdCurrent);
            Set setStatus2 = finalizeInvokeSingleThreaded(queueOOBEvents);
            Set setTotal   = null;
            
            if (setStatus1 == null || setStatus2 == null)
                {
                // Interleaved events posted by multiple threads were found; fall back
                // to the slow-path finalizeInvoke() implementation.
                Set setStatus3 = finalizeInvokeMultiThreaded();
            
                setTotal = combineResults(
                           combineResults(setStatus1, setStatus2), setStatus3);
                }
            else
                {
                // both the current thread's as well as the OOB queues were successfully
                // processed (this is the common case).  Combine and return the results
                setTotal = combineResults(setStatus1, setStatus2);
                }
            
            setFinalizingRequest(false);
            
            return setTotal;
            }
        
        /**
         * A general purpose finalizeInvoke() implementation that can handle a
        * logical sequence of backing map events that may be an arbitrary
        * interleaving of events posted by multiple threads during a "managed"
        * operation.
        * 
        * This method is called on the service or worker threads.
        * 
        * @return a Set<$EntryStatus> of $EntryStatus objects with
        * asynchronously observed events, or null if concurrent threads prevent
        * complete event processing
         */
        protected java.util.Set finalizeInvokeMultiThreaded()
            {
            // import com.tangosol.internal.util.BMEventFabric$EventHolder as com.tangosol.internal.util.BMEventFabric.EventHolder;
            // import com.tangosol.internal.util.BMEventFabric$EventQueue as com.tangosol.internal.util.BMEventFabric.EventQueue;
            // import com.tangosol.util.LiteSet;
            // import com.tangosol.util.LongArray;
            // import com.tangosol.util.NullImplementation;
            // import com.tangosol.util.SparseArray;
            // import java.util.Iterator;
            // import java.util.LinkedList;
            // import java.util.Set;
            
            com.tangosol.internal.util.BMEventFabric.EventQueue queueThdCurrent = ensureEventQueue();
            com.tangosol.internal.util.BMEventFabric.EventQueue queueOOBEvents  = getUnmanagedEventQueue();
            
            LongArray  laEvents      = new SparseArray();
            boolean    fLockAll      = false;
            LinkedList listThdQueues = new LinkedList();
            Set        setSeen       = new LiteSet();
            Set        setStatusOOB  = null;
            
            try
                {
                outer_loop: while (true)
                    {
                    listThdQueues.add(queueThdCurrent);
                    listThdQueues.add(queueOOBEvents);
            
                    while (!listThdQueues.isEmpty())
                        {
                        com.tangosol.internal.util.BMEventFabric.EventQueue queueThd = (com.tangosol.internal.util.BMEventFabric.EventQueue) listThdQueues.removeFirst();
                        if (!fLockAll && !queueThd.lock(0L))
                            {
                            // failure to lock immediately indicates contention in event
                            // processing.  This should be extremely rare, as it can
                            // only occur if multiple threads are modifying the same
                            // keys in an interleaved fashion.  To prevent deadlock,
                            // release all locks and fall back to using a global lock.
                            for (Iterator iter = setSeen.iterator(); iter.hasNext(); )
                                {
                                ((com.tangosol.internal.util.BMEventFabric.EventQueue) iter.next()).unlock();
                                }
            
                            getEventFabric().lockAll(-1L);
                            fLockAll = true;
            
                            // start over
                            laEvents     .clear();
                            setSeen      .clear();
                            listThdQueues.clear();
                            continue outer_loop;
                            }
            
                        setSeen.add(queueThd);
            
                        for (com.tangosol.internal.util.BMEventFabric.EventHolder holderByThd = queueThd.getFirstEvent();
                             holderByThd != null; holderByThd = holderByThd.getNextByThread())
                            {
                            Storage.EntryStatus status = (Storage.EntryStatus) holderByThd.getStatus();
            
                            laEvents.set(holderByThd.getEventId(), holderByThd);
            
                            com.tangosol.internal.util.BMEventFabric.EventQueue queueByKey = status.getEventQueue();
                            for (com.tangosol.internal.util.BMEventFabric.EventHolder holderByKey = queueByKey.getFirstEvent();
                                 holderByKey != null; holderByKey = holderByKey.getNextByKey())
                                {
                                com.tangosol.internal.util.BMEventFabric.EventQueue queueThdOther = holderByKey.getThreadQueue();
            
                                if (!setSeen.contains(queueThdOther) &&
                                    !listThdQueues.contains(queueThdOther))
                                    {
                                    listThdQueues.add(queueThdOther);
                                    }
                                }
                            }
                        }
            
                    break;
                    }
            
                // do the event processing
                for (Iterator iter = laEvents.iterator(); iter.hasNext(); )
                    {
                    com.tangosol.internal.util.BMEventFabric.EventHolder evtHolder = (com.tangosol.internal.util.BMEventFabric.EventHolder) iter.next();
                    if (!processEvent(evtHolder))
                        {
                        // evtHolder was not expected/managed
                        setStatusOOB = collectOOBStatus(setStatusOOB, evtHolder);
                        }
            
                    // Note: laEvents is a transient search array; don't call remove()
                    //       here as it would cause unnecessary tree rebalancing
                    }
            
                return setStatusOOB == null ? NullImplementation.getSet() : setStatusOOB;
                }
            finally
                {
                if (fLockAll)
                    {
                    getEventFabric().unlockAll();
                    }
                else
                    {
                    for (Iterator iter = setSeen.iterator(); iter.hasNext(); )
                        {
                        ((com.tangosol.internal.util.BMEventFabric.EventQueue) iter.next()).unlock();
                        }
                    }
                }
            }
        
        /**
         * An optimistic finalizeInvoke() implementation that is optimized for
        * handling a sequence of EventHolders posted by the same thread.
        * This method is called on the service or worker threads during a
        * "managed" operation.
        * 
        * @return a Set<$EntryStatus> of $EntryStatus objects with
        * asynchronously observed events, or null if concurrent threads prevent
        * complete event processing
         */
        protected java.util.Set finalizeInvokeSingleThreaded(com.tangosol.internal.util.BMEventFabric.EventQueue queueThd)
            {
            // import com.tangosol.internal.util.BMEventFabric$EventHolder as com.tangosol.internal.util.BMEventFabric.EventHolder;
            // import com.tangosol.internal.util.BMEventFabric$EventQueue as com.tangosol.internal.util.BMEventFabric.EventQueue;
            // import com.tangosol.util.NullImplementation;
            // import java.util.Set;
            
            if (queueThd.isEmpty())
                {
                return NullImplementation.getSet();
                }
            
            // Only threads processing service work are allowed to finalize-invoke, so
            // no need to actually lock the data-structure if we are running single threaded
            boolean fLock = getService().isConcurrent();
            if (fLock && !queueThd.lock(0L))
                {
                return null;
                }
            
            Set setStatusOOB = null; // observed status on unmanaged keys
            try
                {
                com.tangosol.internal.util.BMEventFabric.EventHolder holderEnd = null;
                for (com.tangosol.internal.util.BMEventFabric.EventHolder holderByThd = queueThd.getFirstEvent(); holderByThd != null;
                     holderByThd = holderByThd.getNextByThread())
                    {        
                    Storage.EntryStatus status   = (Storage.EntryStatus) holderByThd.getStatus();
                    com.tangosol.internal.util.BMEventFabric.EventQueue        queueKey = status.getEventQueue();
            
                    // there is more than one event in the by-key queue; check
                    // to ensure that all of the events were posted by this thread
                    if (queueKey.getFirstEvent() != queueKey.getLastEvent())
                        {
                        for (com.tangosol.internal.util.BMEventFabric.EventHolder holderByKey = queueKey.getFirstEvent();
                             holderByKey != null; holderByKey = holderByKey.getNextByKey())
                            {
                            if (holderByKey.getThreadQueue() != queueThd)
                                {
                                // Events for this key span multiple threads;
                                // fall back on the slower multi-thread-queue search
                                return null;
                                }
                            }
                        }
            
                    holderEnd = holderByThd;
                    }
                
                // process the events posted by the thread queue
                com.tangosol.internal.util.BMEventFabric.EventHolder holderPrev    = null;
                Object      oMapEvtHolder = null;
                for (com.tangosol.internal.util.BMEventFabric.EventHolder holder = queueThd.getFirstEvent();
                     holder != null && holderPrev != holderEnd;
                     holder = holder.getNextByThread())
                    {
                    if (!processEvent(holder))
                        {
                        // holder was not expected/managed
                        setStatusOOB = collectOOBStatus(setStatusOOB, holder);
                        }
                    holderPrev = holder;
                    }
            
                return setStatusOOB == null ? NullImplementation.getSet() : setStatusOOB;
                }
            finally
                {
                if (fLock)
                    {
                    queueThd.unlock();
                    }
                }
            }
        
        /**
         * Return a string description for parameter entry.
         */
        protected String getCacheKeyDescription(java.util.Map.Entry entry)
            {
            // import com.tangosol.util.Base;
            // import com.tangosol.util.Binary;
            // import com.tangosol.util.SegmentedConcurrentMap;
            // import com.tangosol.util.SegmentedConcurrentMap$LockableEntry as com.tangosol.util.SegmentedConcurrentMap.LockableEntry;
            
            if (entry instanceof com.tangosol.util.SegmentedConcurrentMap.LockableEntry)
                {
                Binary binKey = (Binary) entry.getKey();
                            
                return getCacheName(entry) + "/BinaryKey(" + Base.toHexEscape(binKey, 0, binKey.length()) + ")";
                }
            return "";
            }
        
        /**
         * Return the cache name for parameter entry.
         */
        protected String getCacheName(java.util.Map.Entry entry)
            {
            // import com.tangosol.util.SegmentedConcurrentMap;
            // import com.tangosol.util.SegmentedConcurrentMap$LockableEntry as com.tangosol.util.SegmentedConcurrentMap.LockableEntry;
            // import java.util.Iterator;
            // import java.util.Map;
            
            if (!(entry instanceof com.tangosol.util.SegmentedConcurrentMap.LockableEntry))
                {
                return "";
                }
            
            Map mapSource = ((com.tangosol.util.SegmentedConcurrentMap.LockableEntry) entry).getSource();
            
            for (Iterator iterStore = getService().getStorageArray().iterator(); iterStore.hasNext(); )
                {
                Storage storage = (Storage) iterStore.next();
                if (mapSource == storage.getResourceControlMap())
                    {
                    return storage.getCacheName();
                    }
                }
            
            return "";
            }
        
        // Accessor for the property "ContentionMap"
        /**
         * Getter for property ContentionMap.<p>
        * This Map<Thread, SCM$LockableEntry> associates threads that are
        * contending for resource control locks, to the thread that holds the
        * lock being contended for.
        * 
        * This map captures contention for resource locks across all $Storage's
        * in this service.
         */
        public java.util.Map getContentionMap()
            {
            return __m_ContentionMap;
            }
        
        // Accessor for the property "EventFabric"
        /**
         * Getter for property EventFabric.<p>
         */
        public com.tangosol.internal.util.BMEventFabric getEventFabric()
            {
            return __m_EventFabric;
            }
        
        // Accessor for the property "EventQueue"
        /**
         * Getter for property EventQueue.<p>
        * The EventQueue that the current thread should append BM events to.
         */
        public com.tangosol.internal.util.BMEventFabric.EventQueue getEventQueue()
            {
            // import com.tangosol.internal.util.BMEventFabric$EventQueue as com.tangosol.internal.util.BMEventFabric.EventQueue;
            
            com.tangosol.internal.util.BMEventFabric.EventQueue queue = (com.tangosol.internal.util.BMEventFabric.EventQueue) getTloEventQueue().get();
            
            // default to the out-of-band event queue if this is not a managed thread or
            // we are finalizing the request (@see processChanges) and a backing map event occurred
            return queue == null || isFinalizingRequest() ? getUnmanagedEventQueue() : queue;
            }
        
        // Accessor for the property "IdCounter"
        /**
         * Getter for property IdCounter.<p>
        * The atomic counter that generates unique-id's for EventHolders.
         */
        public java.util.concurrent.atomic.AtomicLong getIdCounter()
            {
            return __m_IdCounter;
            }
        
        // Accessor for the property "Service"
        /**
         * Getter for property Service.<p>
         */
        public PartitionedCache getService()
            {
            return (PartitionedCache) get_Module();
            }
        
        /**
         * Return the $EntryStatus for the specified binary key (belonging to
        * the specified storage) to track the observed changes relating to the
        * key, or null
        * 
        * @param storage   the storage which the specified key belongs to
        * @param binKey    the (binary) key to return a status for
         */
        public Storage.EntryStatus getStatus(Storage storage, com.tangosol.util.Binary binKey)
            {
            return (Storage.EntryStatus) storage.getEntryStatusMap().get(binKey);
            }
        
        // Accessor for the property "TloEventQueue"
        /**
         * Getter for property TloEventQueue.<p>
        * ThreadLocal event queue
         */
        public ThreadLocal getTloEventQueue()
            {
            return __m_TloEventQueue;
            }
        
        // Accessor for the property "TloFinalizingRequest"
        /**
         * Getter for property TloFinalizingRequest.<p>
        * ThreadLocal flag indicating if a request is done and in
        * processChanges.  If true,  any new event occured in this thread
        * should be added to UnmanagedEventQueue. 
         */
        public ThreadLocal getTloFinalizingRequest()
            {
            return __m_TloFinalizingRequest;
            }
        
        // Accessor for the property "UnmanagedEventQueue"
        /**
         * Getter for property UnmanagedEventQueue.<p>
        * The EventQueue used to accumulate all "out-of-band" (raised on
        * "unmanaged" threads) BM events.
         */
        public com.tangosol.internal.util.BMEventFabric.EventQueue getUnmanagedEventQueue()
            {
            return __m_UnmanagedEventQueue;
            }
        
        /**
         * Instantiate a concurrent map that can be used as a resouce control
        * map.
         */
        public com.tangosol.util.ConcurrentMap instantiateControlMap()
            {
            // import com.tangosol.util.SegmentedConcurrentMap;
            
            // return a SCM with this ResourceCoordinator as a LockObserver
            return new SegmentedConcurrentMap(this);
            }
        
        /**
         * Instantiate an $EventQueue.
        * 
        * @param fByThread    true iff the queue is to be used to track events
        * posted by a thread; otherwise the queue is
        *                                      used to to track events relating
        * to the same key
         */
        public com.tangosol.internal.util.BMEventFabric.EventQueue instantiateEventQueue(boolean fByThread)
            {
            return fByThread ? getEventFabric().createThreadQueue() :
                getEventFabric().createKeyQueue();
            }
        
        // Accessor for the property "FinalizingRequest"
        /**
         * Getter for property FinalizingRequest.<p>
        * True if a thread is in finalizing request,  any new backing map event
        * should be added to UnmanagedEventQueue, see#finalizeInvoke.
         */
        public boolean isFinalizingRequest()
            {
            Boolean fFinalizingRequest = (Boolean) getTloFinalizingRequest().get();
            
            return fFinalizingRequest != null && fFinalizingRequest.booleanValue();
            }
        
        /**
         * Attempt to lock the specified key (from the specified $Storage),
        * waiting at most the specified wait time.  If the key is successfully
        * locked, it will also be marked as "managed".
        * 
        * NOTE: InvocationContext.lockEntry *must* be used instead of this
        * lockKey, if the request uses an InvocationContext.
        * 
        * @param storage    the $Storage that the specified key belongs to
        * @param binKey      the (binary) key to lock
        * @param cWait        the maximum time to wait to acquire a lock.  Pass
        * -1 for indefinite; 0 for no-wait.
        * 
        * @return true iff the key is successfully locked
         */
        public boolean lock(Storage storage, com.tangosol.util.Binary binKey, long cWait)
            {
            // ensure that there is a TLO event-queue for this thread
            ensureEventQueue();
            
            if (!getService().isConcurrent() || // no need to use a physical lock if there are no worker threads
                storage.getResourceControlMap().lock(binKey, cWait))
                {
                // all locked keys are "managed" (as they are "front-door" operations)
                ensureStatus(storage, binKey).setManaged(true);
                return true;
                }
            
            return false;
            }
        
        /**
         * Attempt to lock all keys from the specified $Storage, waiting at most
        * the specified wait time.
        * 
        * Note: the keys will not automatically be recorded as "managed".
        * 
        * @param storage    the $Storage to lock all keys for
        * @param cWait        the maximum time to wait to acquire a lock.  Pass
        * -1 for indefinite; 0 for no-wait.
        * 
        * @return true iff the keys are successfully locked
         */
        public boolean lockAll(Storage storage, long cWait)
            {
            // import com.tangosol.util.ConcurrentMap;
            
            // ensure that there is a TLO event-queue for this thread
            ensureEventQueue();
            
            return storage.getResourceControlMap().lock(ConcurrentMap.LOCK_ALL, cWait);
            }
        
        /**
         * Attempt to lock the specified key (from the specified $Storage).  If
        * the key is successfully locked, it will also be marked as "managed".
        * 
        * @param storage    the $Storage that the specified key belongs to
        * @param binKey      the (binary) key to lock
         */
        public void lockForTransfer(Storage storage, com.tangosol.util.Binary binKey)
            {
            if (!lock(storage, binKey, 100L))
                {
                // It should not be possible to fail to lock the key here
                // as we don't yet even own the key, but we are running
                // on the service thread so we must not block or fail.
                _trace("Failed to lock key for primary transfer", 2);
                }
            }
        
        // From interface: com.tangosol.util.SegmentedConcurrentMap$ContentionObserver
        public void onContend(Object oContender, com.tangosol.util.SegmentedConcurrentMap.LockableEntry entry)
            {
            getContentionMap().put(oContender, entry);
            
            checkResourceDeadlock(oContender);
            }
        
        // Declared at the super level
        /**
         * The "component has been initialized" method-notification called out
        * of setConstructed() for the topmost component and that in turn
        * notifies all the children.
        * 
        * This notification gets called before the control returns back to this
        * component instantiator (using <code>new Component.X()</code> or
        * <code>_newInstance(sName)</code>) and on the same thread. In
        * addition, visual components have a "posted" notification
        * <code>onInitUI</code> that is called after (or at the same time as)
        * the control returns back to the instantiator and possibly on a
        * different thread.
         */
        public void onInit()
            {
            // import java.util.concurrent.atomic.AtomicLong;
            
            setIdCounter          (new AtomicLong());
            setUnmanagedEventQueue(instantiateEventQueue(true));
            }
        
        // From interface: com.tangosol.util.SegmentedConcurrentMap$ContentionObserver
        public void onUncontend(Object oContender, com.tangosol.util.SegmentedConcurrentMap.LockableEntry entry)
            {
            getContentionMap().remove(oContender);
            }
        
        /**
         * Process the specified event that was observed from the backing-map.
        * See //dev/main/doc/coherence-core/BMEHandling.txt
        * 
        * @param evtHolder    the holder for the observed BM event to be
        * processed
        * 
        * @return true iff the event's entry status does not need to be added
        * to the OOB set
         */
        protected boolean processEvent(com.tangosol.internal.util.BMEventFabric.EventHolder evtHolder)
            {
            // import com.tangosol.internal.util.BMEventFabric;
            // import com.tangosol.internal.util.BMEventFabric$EventHolder as com.tangosol.internal.util.BMEventFabric.EventHolder;
            // import com.tangosol.internal.util.BMEventFabric$EventQueue as com.tangosol.internal.util.BMEventFabric.EventQueue;
            // import com.tangosol.net.cache.CacheEvent;
            // import com.tangosol.net.events.partition.TransactionEvent$Type as com.tangosol.net.events.partition.TransactionEvent.Type;
            // import com.tangosol.net.events.partition.UnsolicitedCommitEvent$Type as com.tangosol.net.events.partition.UnsolicitedCommitEvent.Type;
            // import com.tangosol.util.Base;
            // import com.tangosol.util.Binary;
            // import com.tangosol.util.ExternalizableHelper as com.tangosol.util.ExternalizableHelper;
            // import com.tangosol.util.MapEvent as com.tangosol.util.MapEvent;
            
            PartitionedCache      service    = getService();
            com.tangosol.util.MapEvent     event      = evtHolder.getEvent();
            Storage.EntryStatus status     = (Storage.EntryStatus) evtHolder.getStatus();
            Storage     storage    = status.getStorage();
            Binary       binKey     = (Binary) status.getKey();
            boolean      fOOBEvent  = false;
            Storage.BinaryEntry entry      = null;
            boolean      fSynthetic = false;
            
            //  attempt to lock the entry (thus make the entry managed) prior to
            //  updating the index & partitioned key index
            if (!status.isManaged())
               {
               if (getService().lockKey(storage, binKey, true, 0L))
                   {
                   fOOBEvent = true;
                   }
               else if (!service.isPrimaryOwner(status.getPartition()))
                   {
                   // the only scenario in which this is possible is an OOB event that landed
                   // on the fabric however was processed after the associated partition had
                   // sucessfully transferred out to another member; do not process the event
                   // and return control suggesting it is not OOB thus will not be published
                   return true;
                   }
               // else this is a troubling case; process the com.tangosol.util.MapEvent updating anciliary
               //      data structures
               }
            
            // event could be null if this is a "synthetic" event holder used
            // to force a flush of the backup & client event changes
            if (event != null)
                {
                int           nEventType  = event.getId();
                Binary        binValueOld = (Binary) event.getOldValue();
                Binary        binValueNew = (Binary) event.getNewValue();
                PartitionedCache.EventsHelper evtHelper   = service.getEventsHelper();
                boolean       fKeyIndex   = true;
                boolean       fExpiryOnly = false;
                boolean       fIndex      = storage.isIndexed();
                boolean       fEvents     = storage.hasListeners();
                boolean       fIncptrs    = storage.hasInterceptors() ||
                                            evtHelper.hasServiceInterceptors(com.tangosol.net.events.partition.TransactionEvent.Type.COMMITTED) ||
                                            evtHelper.hasServiceInterceptors(com.tangosol.net.events.partition.UnsolicitedCommitEvent.Type.COMMITTED);
            
                if (nEventType == com.tangosol.util.MapEvent.ENTRY_UPDATED)
                    {
                    if (binValueOld != null && binValueNew != null)
                        {
                        PartitionedCache.InvocationContext ctxInvoke = service.getInvocationContext();
            
                        fExpiryOnly = !status.hasEvent(event);
            
                        if (fExpiryOnly)
                            {
                            // neither index nor interceptors for expiry-only events
                            fEvents  = false;
                            fIndex   = false;
                            fIncptrs = false;
                            }
            
                        // check for a decoration-only update
                        if ((fIndex || fEvents || fIncptrs) &&
                            (com.tangosol.util.ExternalizableHelper.isDecorated(binValueOld) || com.tangosol.util.ExternalizableHelper.isDecorated(binValueNew)) &&
                            com.tangosol.util.ExternalizableHelper.getUndecorated(binValueOld).equals(com.tangosol.util.ExternalizableHelper.getUndecorated(binValueNew)))
                            {
                            if (com.tangosol.util.ExternalizableHelper.isDecorated(binValueOld, com.tangosol.util.ExternalizableHelper.DECO_STORE) &&
                                !com.tangosol.util.ExternalizableHelper.isDecorated(binValueNew, com.tangosol.util.ExternalizableHelper.DECO_STORE))
                                {
                                // no need to send events for updates that remove DECO_STORE
                                fEvents  = false;
                                fIncptrs = false;
                                }
                    
                            // no need update user indices for decoration updates
                            fIndex = false;
                            }
                        }
            
                    // no need to update the key-index for an update
                    fKeyIndex = false;
                    }
                if (fIndex || fEvents || fIncptrs)
                    {
                    fSynthetic = event instanceof CacheEvent &&
                                ((CacheEvent) event).isSynthetic();
                    entry = status.getReadOnlyEntry();
            
                    // COH-3146: the BinaryEntry may not have the OriginalValue if the operation
                    //           never pulled it and may be needed for index maintenance or
                    //           interceptors; also update the OriginalValue prior to the isPresent
                    //           call to ensure the OriginalValue is equality checked against the
                    //           new value if BinaryEntry.BinaryValue is absent (OOB updates)
            
                    entry.updateOriginalBinaryValue(binValueOld);
            
                    // as we are dispatching events, override any previous intent to suppress event
                    status.setSuppressEvents(false);
            
                    if (!Base.equals(entry.isPresent() ? entry.getBinaryValue() : null, binValueNew))
                        {
                        // It is possible (if there are multiple changes on the same key)
                        // that the Storage.BinaryEntry held by the Storage.EntryStatus does not reflect
                        // the correct update.  For example suppose:
                        //
                        // T1: invoke(k1) => Storage.BinaryEntry.setValue(v1) => postInvoke() => onBME()
                        //                => BM.put(k1, v2) => onBME()
                        //
                        // In this case, the event generated by the "backdoor" put should
                        // reflect an update to "v2", but the Storage.BinaryEntry (representing the
                        // "front-door" operation) holds the old value (v1).
                        entry.ensureWriteable();
                        entry.updateBinaryValue(binValueNew, fSynthetic);
                        entry.ensureReadOnly();
                        }
                    else if (fSynthetic)
                        {
                        entry.setSynthetic(true);
                        }
            
                    // mark the entry as read-only, ensuring that interceptors
                    // may not inadvertently interact with a defunct transaction context
                    entry.ensureReadOnly();
                    }
            
                if (fOOBEvent)
                    {
                    status.setBinaryEntry(entry);
                    }
            
                try
                    {
                    if (fKeyIndex)
                        {
                        // update the key index
                        storage.updateKeyIndex(event);
                        }
            
                    if (fIndex)
                        {
                        // update the user indices
                        storage.updateIndex(event.getId(), entry, null);
                        }
                    }
                finally
                    {
                    if (!fExpiryOnly)
                        {
                        storage.getVersion().commit(status.getPartition());
                        }
                    }
            
                Object oHolder = null;
                if (fEvents)
                    {
                    // prepare PartitionedCache.MapEvent messages for listeners
                    //
                    // Note: prepareDispatch must be called before backup messages are sent
                    //       because event messages are not posted until the backup request
                    //       poll completes
                    oHolder = storage.prepareDispatch(event, entry);
                    }
            
                // if the status is managed by another thread, a partial status could be
                // published. Make the status pending and prevent it from being published
                // while setting values.
                status.setPending(true);
                try
                    {
                    if (status.isAnyAction())
                        {
                        if (!fExpiryOnly)
                            {
                            status.setExpiryOnly(false);
                            }
                        }
                    else
                        {
                        // this is the first event processed for this Storage.EntryStatus
                        status.setAnyAction(true);
                        status.setOldValue(binValueOld);
                        status.setExpiryOnly(fExpiryOnly);
                        }
            
                    status.setMergedNewValue(binValueNew);
            
                    if (oHolder != null)
                        {
                        status.addEventMessages(oHolder);
                        }
                    }
                finally
                    {
                    status.setPending(false);
                    }
                }
            
            // This following (very subtle) logic attempts to reconcile 2 concerns:
            // 1) in-order delivery of changes that are causal or with provable ordering 
            // 2) atomic publishing of changes from an enlisted "transaction"
            //
            // The event being processed may or may not have been caused/observed by this
            // thread.  While the current thread is guaranteed to be a "managed" thread,
            // it may, through the EventFabric, observe OOB updates made by unmanaged
            // threads, or updates made by other managed threads. There are 3 possibilities:
            // 1) the status is unmanaged
            // 2) the status is managed by this thread
            // 3) the status is managed by another thread
            //
            // If the status is unmanaged, we should try to lock the key and "take"
            // ownership of the EntryStatus (and become reponsible for publishing
            // backup and client-event changes).  Note: we must not be overly aggressive
            // in attempting to lock due to the possibility of deadlock (see COH-5436).
            //
            // If the status is managed by another thread (or we are unable to lock),
            // the other thread should be responsible for publishing; we do not need to
            // take any action here.
            //
            // If the status is managed by this thread, the callers of this function
            // are aware and will arrange to publish changes (see #processChanges).
            if (status.isManaged())
                {
                Storage.BinaryEntry entryManaged = status.getBinaryEntry();
                if (entryManaged != null && entryManaged != entry)
                    {
                    // another thread has the key locked (@see Storage.EntryStatus.getReadOnlyEntry)
                    // but we store the observed change caused by this com.tangosol.util.MapEvent on the
                    // Storage.EntryStatus to ensure the backup is sync'd; also ensure the
                    // synthetic flag for post interceptors is retained
            
                    if (fSynthetic && !entryManaged.isValueChanged())
                        {
                        entryManaged.setSynthetic(true);
                        }
                    }
                }
            
            // remove the eventHolder from the event fabric
            synchronized (status)
                {
                BMEventFabric fabric = getEventFabric();
            
                fabric.remove(evtHolder);
                if (!status.isManaged())
                    {
                    // this could either mean that the status *was* managed by another
                    // thread, which has proceeded to unlock the key in the meantime, or
                    // the status is not managed, but we could not obtain the lock above.
                    // In either case, insert a "synthetic" event on the OOB thread queue
                    // to force the backup to be published.  The EntryStatus will be
                    // removed during #unlockKey.
                    com.tangosol.internal.util.BMEventFabric.EventHolder holder = fabric.createEventHolder(
                            status, null, getIdCounter().incrementAndGet());
            
                    fabric.add(holder, getUnmanagedEventQueue(), status.getEventQueue());
                    }
                }
            
            // return true iff the status has been locked by this method
            // and therefore needs to be added to the OOB status collection
            return !fOOBEvent;
            }
        
        /**
         * Disassociate the specified key from the specified $EntryStatus,
        * marking it "inactive".
        * This method is called on the service or worker threads, only while
        * holding synchronization on the status.
        * 
        * @param storage   the storage that the specified key belongs to
        * @param binKey    the key to remove the status for
        * @param status      the status to remove
         */
        protected void removeStatus(Storage storage, com.tangosol.util.Binary binKey, Storage.EntryStatus status)
            {
            status.setActive(false);
            storage.getEntryStatusMap().remove(binKey);
            }
        
        /**
         * Report cache/key contention between threads at appropriate logging
        * level.
         */
        protected void reportContendingThreads(Object[] aoContenders, com.tangosol.util.SegmentedConcurrentMap.LockableEntry[] aEntries)
            {
            // import com.tangosol.util.Base;
            // import com.tangosol.util.Binary;
            // import com.tangosol.util.SegmentedConcurrentMap$LockableEntry as com.tangosol.util.SegmentedConcurrentMap.LockableEntry;
            // import java.util.Collection;
            // import java.util.Iterator;
            // import java.util.Map;
            // import java.util.Map$Entry as java.util.Map.Entry;
            
            if (!_isTraceEnabled(5))
                {
                return;
                }
            
            StringBuilder sb = new StringBuilder("\n");
            
            for (int i = 0, c = aoContenders.length; i < c; ++i)
                {    
                Object oThread = aoContenders[i];
                com.tangosol.util.SegmentedConcurrentMap.LockableEntry  entry   = (com.tangosol.util.SegmentedConcurrentMap.LockableEntry) aEntries[i];
            
                if (entry != null)
                    {
                    sb.append(oThread);
                    sb.append(" waiting on (").append(getCacheKeyDescription(entry));
                    sb.append(")\n");
            
                    // only include contention stack trace at log level 8 
                    if (_isTraceEnabled(8))
                        {
                        StackTraceElement[] aoElement = ((Thread) oThread).getStackTrace();
            
                        for (int j = 0; j < aoElement.length; j++)
                            {
                            sb.append("  at ").append(aoElement[j]).append("\n"); 
                            }
                        sb.append("\n");
                        }
                    }
                }
            
            _trace("Key contention between threads detected on cache/key " + getCacheKeyDescription(aEntries[0]) +
                " that would result in deadlock" + sb, 5);
            }
        
        // Accessor for the property "ContentionMap"
        /**
         * Setter for property ContentionMap.<p>
        * This Map<Thread, SCM$LockableEntry> associates threads that are
        * contending for resource control locks, to the thread that holds the
        * lock being contended for.
        * 
        * This map captures contention for resource locks across all $Storage's
        * in this service.
         */
        protected void setContentionMap(java.util.Map map)
            {
            __m_ContentionMap = map;
            }
        
        // Accessor for the property "EventFabric"
        /**
         * Setter for property EventFabric.<p>
         */
        public void setEventFabric(com.tangosol.internal.util.BMEventFabric pEventFabric)
            {
            __m_EventFabric = pEventFabric;
            }
        
        // Accessor for the property "FinalizingRequest"
        /**
         * Setter for property FinalizingRequest.<p>
        * True if a thread is in finalizing request,  any new backing map event
        * should be added to UnmanagedEventQueue, see#finalizeInvoke.
         */
        public void setFinalizingRequest(boolean fFinalizing)
            {
            getTloFinalizingRequest().set(Boolean.valueOf(fFinalizing));
            }
        
        // Accessor for the property "IdCounter"
        /**
         * Setter for property IdCounter.<p>
        * The atomic counter that generates unique-id's for EventHolders.
         */
        protected void setIdCounter(java.util.concurrent.atomic.AtomicLong atomicCounter)
            {
            __m_IdCounter = atomicCounter;
            }
        
        // Accessor for the property "TloEventQueue"
        /**
         * Setter for property TloEventQueue.<p>
        * ThreadLocal event queue
         */
        protected void setTloEventQueue(ThreadLocal tloEventQueue)
            {
            __m_TloEventQueue = tloEventQueue;
            }
        
        // Accessor for the property "TloFinalizingRequest"
        /**
         * Setter for property TloFinalizingRequest.<p>
        * ThreadLocal flag indicating if a request is done and in
        * processChanges.  If true,  any new event occured in this thread
        * should be added to UnmanagedEventQueue. 
         */
        public void setTloFinalizingRequest(ThreadLocal localRequest)
            {
            __m_TloFinalizingRequest = localRequest;
            }
        
        // Accessor for the property "UnmanagedEventQueue"
        /**
         * Setter for property UnmanagedEventQueue.<p>
        * The EventQueue used to accumulate all "out-of-band" (raised on
        * "unmanaged" threads) BM events.
         */
        protected void setUnmanagedEventQueue(com.tangosol.internal.util.BMEventFabric.EventQueue queue)
            {
            __m_UnmanagedEventQueue = queue;
            }
        
        /**
         * Unlock the specified key (from the specified $Storage).
        * 
        * @param storage   the storage which the specified key to unlock
        * belongs to
        * @param binKey    the key to unlock
         */
        public void unlock(Storage storage, com.tangosol.util.Binary binKey)
            {
            Storage.EntryStatus status = getStatus(storage, binKey);
            
            if (status != null)
                {
                synchronized (status)
                    {
                    // Note: it is possible that after finalizeInvoke, some additional
                    //       OOB events were observed for this status
                    if (status.getEventQueue().isEmpty())
                        {
                        removeStatus(storage, binKey, status);
                        }
                    else
                        {
                        // we need to leave the non-empty eventQueue in place so that it can be subsequently
                        // processed; we cannot however leave a non-null BinaryEntry once we've unlocked as
                        // the next thread to lock needs to see a fresh entry.
                        status.setBinaryEntry(null);
                        }
                    status.setManaged(false);
                    }
                }
            
            if (getService().isConcurrent())
                {
                storage.getResourceControlMap().unlock(binKey);
                }
            // else; // there is no physical lock to release if we are single-threaded
            }
        
        /**
         * Unlock all keys from the specified storage.
        * 
        * @param storage   the storage to unlock all keys for
         */
        public void unlockAll(Storage storage)
            {
            // import com.tangosol.util.ConcurrentMap;
            
            storage.getResourceControlMap().unlock(ConcurrentMap.LOCK_ALL);
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$ResultInfo
    
    /**
     * Contains data related to a partial results of an invocation request.
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class ResultInfo
            extends    com.tangosol.coherence.component.Util
        {
        // ---- Fields declarations ----
        
        /**
         * Property PartitionResultMap
         *
         * Map invocation results (in Binary format) keyed by the associated
         * partition (or PartitionSet).
         * 
         * More formally, this is a Map<Integer | PartitionSet , Map<Binary,
         * Binary>>.
         * 
         * Note: the Map<Binary, Binary> result-map could be quite inefficient
         * for key-lookup (see registerSingleResult/registerMultiResult calls
         * by onInvokeRequest/onInvokeAllRequest/onPutRequest/onRemoveRequest)
         */
        private java.util.Map __m_PartitionResultMap;
        
        /**
         * Property Partitions
         *
         * Represents a set of partitions that have already been processed in
         * the context of a particular request.
         * 
         * @volatile
         */
        private volatile com.tangosol.net.partition.PartitionSet __m_Partitions;
        
        /**
         * Property SUID
         *
         * The SUID of the corresponding request.
         */
        private long __m_SUID;
        
        // Default constructor
        public ResultInfo()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public ResultInfo(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                setPartitionResultMap(new com.tangosol.util.LiteMap());
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.ResultInfo();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$ResultInfo".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        /**
         * Collect entries from the ResultMap that belong to specified
        * partitions.
        * 
        * @param partMask    the partition-set to collect the results for
        * 
        * @return the Map<Binary, Binary> of results for the specified
        * partitions
         */
        protected java.util.Map collectEntries(com.tangosol.net.partition.PartitionSet partMask)
            {
            // import com.tangosol.net.partition.PartitionSet;
            // import com.tangosol.util.Binary;
            // import java.util.HashMap;
            // import java.util.Iterator;
            // import java.util.Map;
            // import java.util.Map$Entry as java.util.Map.Entry;
            
            Map mapPartResults = getPartitionResultMap();
            if (mapPartResults == null || !getPartitions().intersects(partMask))
                {
                // no results for any of the requested partitions
                return null;
                }
            
            PartitionedCache service    = getService();
            Map     mapCollect = new HashMap();
            
            for (Iterator iter = mapPartResults.entrySet().iterator(); iter.hasNext();)
                {
                java.util.Map.Entry  entryPartResult = (java.util.Map.Entry) iter.next();
                Object oKey            = entryPartResult.getKey();
                Map    mapResults      = (Map) entryPartResult.getValue();
            
                if (oKey instanceof Integer)
                    {
                    int nPartition = ((Integer) oKey).intValue();
                    if (partMask.contains(nPartition))
                        {
                        mapCollect.putAll(mapResults);
                        }
                    }
                else // oKey instanceof PartitionSet
                    {
                    PartitionSet partsThis = (PartitionSet) oKey;
                    if (partsThis.intersects(partMask))
                        {
                        for (Iterator iterResults = mapResults.entrySet().iterator(); iterResults.hasNext(); )
                            {
                            java.util.Map.Entry  entry  = (java.util.Map.Entry) iterResults.next();
                            Binary binKey = (Binary) entry.getKey();
            
                            if (partMask.contains(service.getKeyPartition(binKey)))
                                {
                                mapCollect.put(binKey, entry.getValue());
                                }
                            }
                        }
                    }
                }
            
            return mapCollect;
            }
        
        public synchronized com.tangosol.net.partition.PartitionSet ensurePartitions()
            {
            // import com.tangosol.net.partition.PartitionSet;
            
            PartitionSet parts = getPartitions();
            if (parts == null)
                {
                setPartitions(parts = new PartitionSet(getService().getPartitionCount()));
                }
            
            return parts;
            }
        
        /**
         * Extract previously processed results from the ResultInfo object that
        * match the specified partition id.
        * 
        * @param nPartition    the partition to extract the results for
        * 
        * @return an array of previously processed result entries
        * (Entry<binKey, binResult>); null if none exist
         */
        public synchronized java.util.Map extractResults(int nPartition)
            {
            // import com.tangosol.net.partition.PartitionSet;
            
            PartitionSet partsPrev = getPartitions();
            if (partsPrev != null && partsPrev.contains(nPartition))
                {
                partsPrev = new PartitionSet(partsPrev.getPartitionCount());
                partsPrev.add(nPartition);
            
                return collectEntries(partsPrev);
                }
            else
                {
                return null;
                }
            }
        
        /**
         * Extract previously processed results from the ResultInfo object that
        * match the specified PartitionSet mask. If those results do exist, the
        * passed PartitionSet parameter will be stripped from all the
        * previously processed partitions
        * 
        * @param partMask  the partition set to extract the results for
        * 
        * @return an array of previously processed result entries
        * (Entry<binKey, binResult>); null if none exist
         */
        public synchronized java.util.Map extractResults(com.tangosol.net.partition.PartitionSet partMask)
            {
            // import com.tangosol.net.partition.PartitionSet;
            
            PartitionSet partPrev = getPartitions();
            if (partPrev != null && partPrev.intersects(partMask))
                {
                partPrev = new PartitionSet(partPrev); // copy
                partPrev.retain(partMask);             // partPrev = partPrev & partMask
                partMask.remove(partPrev);             // partMask = partMask \ partPrev
            
                return collectEntries(partPrev);
                }
            else
                {
                return null;
                }
            }
        
        /**
         * Extract previously processed results from the ResultInfo object for
        * the specified key set. If those results do exist, the passed set will
        * be stripped from all the previously processed keys.
        * 
        * @param keySet  the set of keys to extract the results for
        * 
        * @return a Map<binKey, binResult> containing previousely processed
        * results; null if none exist
         */
        public synchronized java.util.Map extractResults(com.tangosol.util.Binary binKey)
            {
            // Note: though we only have a single result to return, return it
            //       as a Map both for consistency, but also to allow callers
            //       to differentiate between a null and a missing result
            // Note: the result could be null (or non-existent)
            
            int nPartition = ((PartitionedCache) getService()).getKeyPartition(binKey);
            
            return extractResults(nPartition);
            }
        
        // Accessor for the property "PartitionResultMap"
        /**
         * Getter for property PartitionResultMap.<p>
        * Map invocation results (in Binary format) keyed by the associated
        * partition (or PartitionSet).
        * 
        * More formally, this is a Map<Integer | PartitionSet , Map<Binary,
        * Binary>>.
        * 
        * Note: the Map<Binary, Binary> result-map could be quite inefficient
        * for key-lookup (see registerSingleResult/registerMultiResult calls by
        * onInvokeRequest/onInvokeAllRequest/onPutRequest/onRemoveRequest)
         */
        public java.util.Map getPartitionResultMap()
            {
            return __m_PartitionResultMap;
            }
        
        // Accessor for the property "Partitions"
        /**
         * Getter for property Partitions.<p>
        * Represents a set of partitions that have already been processed in
        * the context of a particular request.
        * 
        * @volatile
         */
        public com.tangosol.net.partition.PartitionSet getPartitions()
            {
            return __m_Partitions;
            }
        
        // Accessor for the property "Service"
        /**
         * Getter for property Service.<p>
        * The service.
         */
        public PartitionedCache getService()
            {
            return (PartitionedCache) get_Parent();
            }
        
        // Accessor for the property "SUID"
        /**
         * Getter for property SUID.<p>
        * The SUID of the corresponding request.
         */
        public long getSUID()
            {
            return __m_SUID;
            }
        
        /**
         * Merge the specified results into the ResultInfo.
         */
        public synchronized void mergeResults(int nPartition, java.util.Map mapResults)
            {
            getPartitionResultMap().put(Integer.valueOf(nPartition), mapResults);
            ensurePartitions().add(nPartition);
            }
        
        /**
         * Merge the specified results into the ResultInfo.
         */
        public synchronized void mergeResults(com.tangosol.net.partition.PartitionSet parts, java.util.Map mapResults)
            {
            getPartitionResultMap().put(parts, mapResults);
            ensurePartitions().add(parts);
            }
        
        // Accessor for the property "PartitionResultMap"
        /**
         * Setter for property PartitionResultMap.<p>
        * Map invocation results (in Binary format) keyed by the associated
        * partition (or PartitionSet).
        * 
        * More formally, this is a Map<Integer | PartitionSet , Map<Binary,
        * Binary>>.
        * 
        * Note: the Map<Binary, Binary> result-map could be quite inefficient
        * for key-lookup (see registerSingleResult/registerMultiResult calls by
        * onInvokeRequest/onInvokeAllRequest/onPutRequest/onRemoveRequest)
         */
        protected void setPartitionResultMap(java.util.Map map)
            {
            __m_PartitionResultMap = map;
            }
        
        // Accessor for the property "Partitions"
        /**
         * Setter for property Partitions.<p>
        * Represents a set of partitions that have already been processed in
        * the context of a particular request.
        * 
        * @volatile
         */
        protected void setPartitions(com.tangosol.net.partition.PartitionSet parts)
            {
            __m_Partitions = parts;
            }
        
        // Accessor for the property "SUID"
        /**
         * Setter for property SUID.<p>
        * The SUID of the corresponding request.
         */
        public void setSUID(long lD)
            {
            __m_SUID = lD;
            }
        
        // Declared at the super level
        public String toString()
            {
            return get_Name() + "{Partitions=" + getPartitions() +
                ", Results=" + collectEntries(getService().instantiatePartitionSet(true)) + '}';
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$SendBackupsTask
    
    /**
     * A task to send scheduled backup message  ($BackupAllRequest) for pending
     * backup changes.
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class SendBackupsTask
            extends    com.tangosol.coherence.component.Util
            implements com.oracle.coherence.common.base.Continuation,
                       Runnable
        {
        // ---- Fields declarations ----
        
        // Default constructor
        public SendBackupsTask()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public SendBackupsTask(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.SendBackupsTask();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$SendBackupsTask".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        // From interface: com.oracle.coherence.common.base.Continuation
        public void proceed(Object oResult)
            {
            // import Component.Util.DaemonPool as com.tangosol.coherence.component.util.DaemonPool;
            
            PartitionedCache    service           = (PartitionedCache) get_Module();
            com.tangosol.coherence.component.util.DaemonPool pool              = service.getDaemonPool();
            long       cNextBackupMillis = service.getAsyncBackupInterval();
            
            // should not enter here without a pool
            _assert(pool.isStarted());
            
            pool.schedule(this, cNextBackupMillis);
            }
        
        // From interface: java.lang.Runnable
        public void run()
            {
            ((PartitionedCache) get_Module()).onSendBackups(this);
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$ServiceConfig
    
    /**
     * ServiceConfig provides a service-wide configuration map.  All updates to
     * a service config are published service-wide by the configuration
     * coordinator.
     * The Service-wide config map for service-related shared state.
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class ServiceConfig
            extends    com.tangosol.coherence.component.util.daemon.queueProcessor.service.Grid.ServiceConfig
        {
        // ---- Fields declarations ----
        
        /**
         * Property TRUNCATE_TIME_ATTRIBUTE
         *
         */
        public static final String TRUNCATE_TIME_ATTRIBUTE = "truncateTime";
        
        // Default constructor
        public ServiceConfig()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public ServiceConfig(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                // identified pendingPolls required thread-safe data structure and
                // verified that pendingConfigUpdates only accessed on single service thread, see details in COH-30132.
                setPendingConfigUpdates(new java.util.LinkedList());
                setPendingPolls(new ConcurrentHashMap<>());
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // containment initialization: children
            _addChild(new PartitionedCache.ServiceConfig.ConfigListener("ConfigListener", this, true), "ConfigListener");
            _addChild(new com.tangosol.coherence.component.util.daemon.queueProcessor.service.Grid.ServiceConfig.Map("Map", this, true), "Map");
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.ServiceConfig();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$ServiceConfig".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }

        // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$ServiceConfig$ConfigListener
        
        /**
         * ConfigListener is used to receive config map updates for this
         * ServiceConfig.
         */
        @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
        public static class ConfigListener
                extends    com.tangosol.coherence.component.util.ServiceConfig.ConfigListener
            {
            // ---- Fields declarations ----
            
            // Default constructor
            public ConfigListener()
                {
                this(null, null, true);
                }
            
            // Initializing constructor
            public ConfigListener(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                {
                super(sName, compParent, false);
                
                if (fInit)
                    {
                    __init();
                    }
                }
            
            // Main initializer
            public void __init()
                {
                // private initialization
                __initPrivate();
                
                
                // signal the end of the initialization
                set_Constructed(true);
                }
            
            // Private initializer
            protected void __initPrivate()
                {
                
                super.__initPrivate();
                }
            
            //++ getter for static property _Instance
            /**
             * Getter for property _Instance.<p>
            * Auto generated
             */
            public static com.tangosol.coherence.Component get_Instance()
                {
                return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.ServiceConfig.ConfigListener();
                }
            
            //++ getter for static property _CLASS
            /**
             * Getter for property _CLASS.<p>
            * Property with auto-generated accessor that returns the Class
            * object for a given component.
             */
            public static Class get_CLASS()
                {
                Class clz;
                try
                    {
                    clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$ServiceConfig$ConfigListener".replace('/', '.'));
                    }
                catch (ClassNotFoundException e)
                    {
                    throw new NoClassDefFoundError(e.getMessage());
                    }
                return clz;
                }
            
            //++ getter for autogen property _Module
            /**
             * This is an auto-generated method that returns the global [design
            * time] parent component.
            * 
            * Note: the class generator will ignore any custom implementation
            * for this behavior.
             */
            private com.tangosol.coherence.Component get_Module()
                {
                return this.get_Parent().get_Parent();
                }
            
            // Declared at the super level
            public void entryDeleted(com.tangosol.util.MapEvent evt)
                {
                // import com.tangosol.net.events.internal.StorageDispatcher as com.tangosol.net.events.internal.StorageDispatcher;
                // import com.tangosol.net.events.partition.cache.CacheLifecycleEvent$Type as com.tangosol.net.events.partition.cache.CacheLifecycleEvent.Type;
                // import com.tangosol.net.internal.ScopedCacheReferenceStore as com.tangosol.net.internal.ScopedCacheReferenceStore;
                // import com.tangosol.run.xml.XmlElement;
                // import java.util.Iterator;
                
                super.entryDeleted(evt);
                
                Object oKey = evt.getKey();
                if (oKey instanceof String)
                    {
                    PartitionedCache service = (PartitionedCache) get_Module();
                
                    String     sCacheName   = (String) oKey;
                    XmlElement xmlCacheInfo = (XmlElement) evt.getOldValue();
                    com.tangosol.net.events.internal.StorageDispatcher dispatcher   = null;
                
                    if (service.isAcceptingClients())
                        {
                        // invalidate all associated views and the storage
                        synchronized (service)
                            {
                            com.tangosol.net.internal.ScopedCacheReferenceStore store = service.getScopedCacheStore();
                        
                            for (Iterator iter = store.getAllCaches(sCacheName).iterator(); iter.hasNext();)
                                {
                                ViewMap mapCache = (ViewMap) iter.next();
                                mapCache.invalidate(true);
                                }
                            store.remove(sCacheName);
                
                            BinaryMap mapBinary = (BinaryMap) service.
                                getReferencesBinaryMap().remove(sCacheName);
                            if (mapBinary != null)
                                {
                                service.getBinaryMapArray().remove(mapBinary.getCacheId());
                
                                dispatcher = mapBinary.getDispatcher();
                
                                mapBinary.destroy();
                                }
                            }
                        }
                
                    if (service.isAcceptingOthers() && service.isOwnershipEnabled())
                        {
                        long     lCacheId = xmlCacheInfo.getAttribute("id").getLong();
                        Storage storage  = service.removeStorage(lCacheId);
                
                        if (storage == null)
                            {
                            service.getStorageGraveyard().put(Long.valueOf(lCacheId), sCacheName);
                            }
                        else
                            {
                            dispatcher = storage.getEventDispatcher();
                
                            storage.invalidate();
                            service.destroyPersistentExtent(storage);
                            }
                        }
                
                    // generate the post-event
                    service.getEventsHelper().onCacheLifecycle(dispatcher, com.tangosol.net.events.partition.cache.CacheLifecycleEvent.Type.DESTROYED);
                    }
                }
            
            // Declared at the super level
            public void entryInserted(com.tangosol.util.MapEvent evt)
                {
                // import Component.Net.Member;
                // import com.tangosol.net.events.internal.StorageDispatcher as com.tangosol.net.events.internal.StorageDispatcher;
                // import com.tangosol.net.events.partition.cache.CacheLifecycleEvent$Type as com.tangosol.net.events.partition.cache.CacheLifecycleEvent.Type;
                // import com.tangosol.run.xml.XmlElement;
                
                super.entryInserted(evt);

                PartitionedCache service = (PartitionedCache) get_Module();
                Object  oKey    = evt.getKey();
                
                if (oKey instanceof String && service.isAcceptingOthers())
                    {
                    // make this Member aware of that cache
                    String     sName        = (String)     oKey;
                    XmlElement xmlCacheInfo = (XmlElement) evt.getNewValue();
                    long       lCacheId     = xmlCacheInfo.getAttribute("id").getLong();
                
                    service.ensureStorageInternal(sName, lCacheId, /*fInit*/ true);
                    }
                }
            
            // Declared at the super level
            public void entryUpdated(com.tangosol.util.MapEvent evt)
                {
                // import Component.Util.CacheEvent as com.tangosol.coherence.component.util.CacheEvent;
                // import com.tangosol.net.events.internal.StorageDispatcher as com.tangosol.net.events.internal.StorageDispatcher;
                // import com.tangosol.net.events.partition.cache.CacheLifecycleEvent$Type as com.tangosol.net.events.partition.cache.CacheLifecycleEvent.Type;
                // import com.tangosol.net.internal.ScopedCacheReferenceStore as com.tangosol.net.internal.ScopedCacheReferenceStore;
                // import com.tangosol.run.xml.XmlElement;
                // import com.tangosol.run.xml.XmlValue;
                // import com.tangosol.util.Listeners;
                // import com.tangosol.util.MapEvent as com.tangosol.util.MapEvent;
                // import java.util.Iterator;
                
                super.entryUpdated(evt);
                
                PartitionedCache  service   = (PartitionedCache) get_Module();
                Object   oKey      = evt.getKey();
                XmlValue xmlValNew = ((XmlElement) evt.getNewValue()).
                                     getAttribute(PartitionedCache.ServiceConfig.TRUNCATE_TIME_ATTRIBUTE);
                XmlValue xmlValOld = ((XmlElement) evt.getOldValue()).
                                     getAttribute(PartitionedCache.ServiceConfig.TRUNCATE_TIME_ATTRIBUTE);
                
                if (oKey instanceof String && service.isAcceptingClients() && xmlValNew != null
                    && (xmlValOld == null || xmlValNew.getInt() != xmlValOld.getInt()))
                    {
                    String     sName      = (String) oKey;
                    Storage   storage    = service.getStorage(sName);
                    com.tangosol.net.events.internal.StorageDispatcher dispatcher = null;
                
                    if (storage == null)
                        {
                        BinaryMap mapBinary = (BinaryMap) service.
                                getReferencesBinaryMap().get(sName);
                
                        if (mapBinary != null)
                            {
                            dispatcher = mapBinary.getDispatcher();
                            }
                        }
                    else
                        {
                        dispatcher = storage.getEventDispatcher();
                        }
                
                    service.getEventsHelper().onCacheLifecycle(dispatcher, com.tangosol.net.events.partition.cache.CacheLifecycleEvent.Type.TRUNCATED);
                
                    com.tangosol.net.internal.ScopedCacheReferenceStore store = service.getScopedCacheStore();
                
                    for (Iterator iter = store.getAllCaches(sName).iterator(); iter.hasNext();)
                        {
                        ViewMap  mapView   = (ViewMap) iter.next();
                        Listeners listeners = mapView.getDeactivationListeners();
                
                        if (!listeners.isEmpty())
                            {
                            com.tangosol.util.MapEvent evtTruncated = new com.tangosol.util.MapEvent(mapView, com.tangosol.util.MapEvent.ENTRY_UPDATED, null, null, null);
                
                            // dispatch the event to the listeners, which are all synchronous (hence the null Queue)
                            com.tangosol.coherence.component.util.CacheEvent.dispatchSafe(evtTruncated, listeners, null /*Queue*/);
                            }
                        }
                    }
                }
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$SizeRequest
    
    /**
     * @see $BinaryMap#size
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class SizeRequest
            extends    com.tangosol.coherence.component.net.message.requestMessage.distributedCacheRequest.PartialRequest
        {
        // ---- Fields declarations ----
        private static com.tangosol.util.ListMap __mapChildren;
        
        // Static initializer
        static
            {
            __initStatic();
            }
        
        // Default static initializer
        private static void __initStatic()
            {
            // register child classes
            __mapChildren = new com.tangosol.util.ListMap();
            __mapChildren.put("Poll", PartitionedCache.SizeRequest.Poll.get_CLASS());
            }
        
        // Default constructor
        public SizeRequest()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public SizeRequest(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                setMessageType(77);
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // containment initialization: children
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.SizeRequest();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$SizeRequest".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        //++ getter for autogen property _ChildClasses
        /**
         * This is an auto-generated method that returns the map of design time
        * [static] children.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        protected java.util.Map get_ChildClasses()
            {
            return __mapChildren;
            }
        
        // Declared at the super level
        public void run()
            {
            ((PartitionedCache) getService()).onSizeRequest(this);
            }
        
        // Declared at the super level
        /**
         * Setter for property RequestTimeout.<p>
        * Transient property optionally used on the client to indicate the
        * (safe local) time after which this logical request should be
        * considered timed out.
        * 
        * Note that a single logical request message may result in multiple
        * physical request messages being sent to mulitple members; this
        * RequestTimeout value will be cloned to all resulting RequestMessage
        * instances.
        * 
        * This value is lazily calculated by #getRequestTimeout or
        * #calculateTimeoutRemaining.
         */
        public void setRequestTimeout(long ldtTimeout)
            {
            super.setRequestTimeout(ldtTimeout);
            }

        // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$SizeRequest$Poll
        
        /**
         * The Poll contains information regarding a request sent to one or
         * more Cluster Members that require responses. A Service may poll
         * other Members that are running the same Service, and the Poll is
         * used to wait for and assemble the responses from each of those
         * Members. A client thread may also use the Poll to block on a
         * response or set of responses, thus waiting for the completion of the
         * Poll. In its simplest form, which is a Poll that is sent to one
         * Member of the Cluster, the Poll actually represents the
         * request/response model.
         */
        @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
        public static class Poll
                extends    com.tangosol.coherence.component.net.message.requestMessage.distributedCacheRequest.PartialRequest.Poll
            {
            // ---- Fields declarations ----
            
            // Default constructor
            public Poll()
                {
                this(null, null, true);
                }
            
            // Initializing constructor
            public Poll(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                {
                super(sName, compParent, false);
                
                if (fInit)
                    {
                    __init();
                    }
                }
            
            // Main initializer
            public void __init()
                {
                // private initialization
                __initPrivate();
                
                
                // signal the end of the initialization
                set_Constructed(true);
                }
            
            // Private initializer
            protected void __initPrivate()
                {
                
                super.__initPrivate();
                }
            
            // Getter for virtual constant Preprocessable
            public boolean isPreprocessable()
                {
                return true;
                }
            
            //++ getter for static property _Instance
            /**
             * Getter for property _Instance.<p>
            * Auto generated
             */
            public static com.tangosol.coherence.Component get_Instance()
                {
                return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.SizeRequest.Poll();
                }
            
            //++ getter for static property _CLASS
            /**
             * Getter for property _CLASS.<p>
            * Property with auto-generated accessor that returns the Class
            * object for a given component.
             */
            public static Class get_CLASS()
                {
                Class clz;
                try
                    {
                    clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$SizeRequest$Poll".replace('/', '.'));
                    }
                catch (ClassNotFoundException e)
                    {
                    throw new NoClassDefFoundError(e.getMessage());
                    }
                return clz;
                }
            
            //++ getter for autogen property _Module
            /**
             * This is an auto-generated method that returns the global [design
            * time] parent component.
            * 
            * Note: the class generator will ignore any custom implementation
            * for this behavior.
             */
            private com.tangosol.coherence.Component get_Module()
                {
                return this.get_Parent().get_Parent();
                }
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$SnapshotListRequest
    
    /**
     * SnapshotListRequest is sent to all storage-enabled members of a
     * persistence-enabled service in order to retrieve either:
     * 1) a list of the available snapshots if SnapshotName is
     * null or
     * 2) a list of the available archived snapshot stores if
     * SnapshotName is not null.
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class SnapshotListRequest
            extends    com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.SnapshotListRequest
        {
        // ---- Fields declarations ----
        private static com.tangosol.util.ListMap __mapChildren;
        
        // Static initializer
        static
            {
            __initStatic();
            }
        
        // Default static initializer
        private static void __initStatic()
            {
            // register child classes
            __mapChildren = new com.tangosol.util.ListMap();
            __mapChildren.put("Poll", com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.SnapshotListRequest.Poll.get_CLASS());
            }
        
        // Default constructor
        public SnapshotListRequest()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public SnapshotListRequest(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                setMessageType(48);
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // containment initialization: children
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.SnapshotListRequest();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$SnapshotListRequest".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        //++ getter for autogen property _ChildClasses
        /**
         * This is an auto-generated method that returns the map of design time
        * [static] children.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        protected java.util.Map get_ChildClasses()
            {
            return __mapChildren;
            }
        
        // Declared at the super level
        /**
         * Setter for property RequestTimeout.<p>
        * Transient property optionally used on the client to indicate the
        * (safe local) time after which this logical request should be
        * considered timed out.
        * 
        * Note that a single logical request message may result in multiple
        * physical request messages being sent to mulitple members; this
        * RequestTimeout value will be cloned to all resulting RequestMessage
        * instances.
        * 
        * This value is lazily calculated by #getRequestTimeout or
        * #calculateTimeoutRemaining.
         */
        public void setRequestTimeout(long ldtTimeout)
            {
            super.setRequestTimeout(ldtTimeout);
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$SnapshotRequest
    
    /**
     * SnapshotRequest is sent to all ownership-enabled service members to
     * create or remove a persistent snapshot.
     * 
     * The attribute 'Create' indicates if this is a create or remove snapshot
     * request.
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class SnapshotRequest
            extends    com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.SnapshotRequest
        {
        // ---- Fields declarations ----
        private static com.tangosol.util.ListMap __mapChildren;
        
        // Static initializer
        static
            {
            __initStatic();
            }
        
        // Default static initializer
        private static void __initStatic()
            {
            // register child classes
            __mapChildren = new com.tangosol.util.ListMap();
            __mapChildren.put("Poll", com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.SnapshotRequest.Poll.get_CLASS());
            }
        
        // Default constructor
        public SnapshotRequest()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public SnapshotRequest(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                setAttempt(10);
                setMessageType(47);
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // containment initialization: children
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.SnapshotRequest();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$SnapshotRequest".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        //++ getter for autogen property _ChildClasses
        /**
         * This is an auto-generated method that returns the map of design time
        * [static] children.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        protected java.util.Map get_ChildClasses()
            {
            return __mapChildren;
            }
        
        // Declared at the super level
        /**
         * Setter for property RequestTimeout.<p>
        * Transient property optionally used on the client to indicate the
        * (safe local) time after which this logical request should be
        * considered timed out.
        * 
        * Note that a single logical request message may result in multiple
        * physical request messages being sent to mulitple members; this
        * RequestTimeout value will be cloned to all resulting RequestMessage
        * instances.
        * 
        * This value is lazily calculated by #getRequestTimeout or
        * #calculateTimeoutRemaining.
         */
        public void setRequestTimeout(long ldtTimeout)
            {
            super.setRequestTimeout(ldtTimeout);
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$StorageConfirmRequest
    
    /**
     * StorageConfirmRequest is a poll (by a client) sent to ownership-enabled
     * members to confirm the existence of a cache.
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class StorageConfirmRequest
            extends    com.tangosol.coherence.component.net.message.requestMessage.distributedCacheRequest.PartialRequest
        {
        // ---- Fields declarations ----
        private static com.tangosol.util.ListMap __mapChildren;
        
        // Static initializer
        static
            {
            __initStatic();
            }
        
        // Default static initializer
        private static void __initStatic()
            {
            // register child classes
            __mapChildren = new com.tangosol.util.ListMap();
            __mapChildren.put("Poll", StorageConfirmRequest.Poll.get_CLASS());
            }
        
        // Default constructor
        public StorageConfirmRequest()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public StorageConfirmRequest(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                setMessageType(83);
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // containment initialization: children
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new StorageConfirmRequest();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$StorageConfirmRequest".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        //++ getter for autogen property _ChildClasses
        /**
         * This is an auto-generated method that returns the map of design time
        * [static] children.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        protected java.util.Map get_ChildClasses()
            {
            return __mapChildren;
            }
        
        // Declared at the super level
        /**
         * This is the event that is executed when a Message is received.
        * <p>
        * It is the main processing event of the Message called by the
        * <code>Service.onMessage()</code> event. With regards to the use of
        * Message components within clustered Services, Services are designed
        * by dragging Message components into them as static children. These
        * Messages are the components that a Service can send to other running
        * instances of the same Service within a cluster. When the onReceived
        * event is invoked by a Service, it means that the Message has been
        * received; the code in the onReceived event is therefore the Message
        * specific logic for processing a received Message. For example, when
        * onReceived is invoked on a Message named FindData, the onReceived
        * event should do the work to "find the data", because it is being
        * invoked by the Service that received the "find the data" Message.
         */
        public void onReceived()
            {
            ((PartitionedCache) getService()).onStorageConfirmRequest(this);
            }
        
        // Declared at the super level
        /**
         * Preprocess this message.
        * 
        * @return true iff this message has been fully processed (onReceived
        * was called)
         */
        public boolean preprocess()
            {
            return false;
            }

        // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$StorageConfirmRequest$Poll
        
        /**
         * The Poll contains information regarding a request sent to one or
         * more Cluster Members that require responses. A Service may poll
         * other Members that are running the same Service, and the Poll is
         * used to wait for and assemble the responses from each of those
         * Members. A client thread may also use the Poll to block on a
         * response or set of responses, thus waiting for the completion of the
         * Poll. In its simplest form, which is a Poll that is sent to one
         * Member of the Cluster, the Poll actually represents the
         * request/response model.
         */
        @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
        public static class Poll
                extends    com.tangosol.coherence.component.net.message.requestMessage.distributedCacheRequest.PartialRequest.Poll
            {
            // ---- Fields declarations ----
            
            // Default constructor
            public Poll()
                {
                this(null, null, true);
                }
            
            // Initializing constructor
            public Poll(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                {
                super(sName, compParent, false);
                
                if (fInit)
                    {
                    __init();
                    }
                }
            
            // Main initializer
            public void __init()
                {
                // private initialization
                __initPrivate();
                
                
                // signal the end of the initialization
                set_Constructed(true);
                }
            
            // Private initializer
            protected void __initPrivate()
                {
                
                super.__initPrivate();
                }
            
            //++ getter for static property _Instance
            /**
             * Getter for property _Instance.<p>
            * Auto generated
             */
            public static com.tangosol.coherence.Component get_Instance()
                {
                return new StorageConfirmRequest.Poll();
                }
            
            //++ getter for static property _CLASS
            /**
             * Getter for property _CLASS.<p>
            * Property with auto-generated accessor that returns the Class
            * object for a given component.
             */
            public static Class get_CLASS()
                {
                Class clz;
                try
                    {
                    clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$StorageConfirmRequest$Poll".replace('/', '.'));
                    }
                catch (ClassNotFoundException e)
                    {
                    throw new NoClassDefFoundError(e.getMessage());
                    }
                return clz;
                }
            
            //++ getter for autogen property _Module
            /**
             * This is an auto-generated method that returns the global [design
            * time] parent component.
            * 
            * Note: the class generator will ignore any custom implementation
            * for this behavior.
             */
            private com.tangosol.coherence.Component get_Module()
                {
                return this.get_Parent().get_Parent();
                }
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$StorageIdRequest
    
    /**
     * StorageIdRequest is a poll (by a client) sent to the Senior member to
     * create or destroy a cache.  The action must be taken by the senior in
     * order to guarantee a unique storage id for a given cache name.
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class StorageIdRequest
            extends    com.tangosol.coherence.component.net.message.RequestMessage
        {
        // ---- Fields declarations ----
        
        /**
         * Property CACHE_CREATE
         *
         */
        public static final int CACHE_CREATE = 1;
        
        /**
         * Property CACHE_DESTROY
         *
         */
        public static final int CACHE_DESTROY = 2;
        
        /**
         * Property CacheAction
         *
         * Action requested for the given cache name.
         */
        private int __m_CacheAction;
        
        /**
         * Property CacheIds
         *
         * An array of cache ids that should be used for the given array of
         * cache names associated by the array index.
         */
        private long[] __m_CacheIds;
        
        /**
         * Property CacheNames
         *
         * The list of cache names.
         */
        private String[] __m_CacheNames;
        
        /**
         * Property CreateBinaryMap
         *
         * Transient value that specifies whether or not the BinaryMap should
         * be created before the message is responded to. Note, that this value
         * is used only if the request comes from a client thread on the same
         * node.
         */
        private boolean __m_CreateBinaryMap;
        
        /**
         * Property Response
         *
         * Transient property holding a deferred response to the original
         * request.
         */
        private com.tangosol.coherence.component.net.Message __m_Response;
        private static com.tangosol.util.ListMap __mapChildren;
        
        // Static initializer
        static
            {
            __initStatic();
            }
        
        // Default static initializer
        private static void __initStatic()
            {
            // register child classes
            __mapChildren = new com.tangosol.util.ListMap();
            __mapChildren.put("Poll", StorageIdRequest.Poll.get_CLASS());
            }
        
        // Default constructor
        public StorageIdRequest()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public StorageIdRequest(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                setMessageType(78);
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // containment initialization: children
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new StorageIdRequest();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$StorageIdRequest".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        //++ getter for autogen property _ChildClasses
        /**
         * This is an auto-generated method that returns the map of design time
        * [static] children.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        protected java.util.Map get_ChildClasses()
            {
            return __mapChildren;
            }
        
        // Declared at the super level
        /**
         * Instantiate a copy of this message. This is quite different from the
        * standard "clone" since only the "transmittable" portion of the
        * message (and none of the internal) state should be cloned.
         */
        public com.tangosol.coherence.component.net.Message cloneMessage()
            {
            StorageIdRequest msg = (StorageIdRequest) super.cloneMessage();
            
            msg.setCacheAction(getCacheAction());
            msg.setCacheIds(getCacheIds());
            msg.setCacheNames(getCacheNames());
            msg.setCreateBinaryMap(isCreateBinaryMap());
            msg.setResponse(getResponse());
            
            return msg;
            }
        
        /**
         * Return a String array of cache names without null slots.
         */
        public void compressCacheNames()
            {
            String[] asCacheNames = getCacheNames();
            int      cCacheNames  = asCacheNames.length;
            
            while (asCacheNames[cCacheNames-1] == null)
                {
                --cCacheNames;
                }
            
            if (cCacheNames != asCacheNames.length)
                {
                String[] asCacheNamesNew = new String[cCacheNames];
                System.arraycopy(asCacheNames, 0, asCacheNamesNew, 0, cCacheNames);
                setCacheNames(asCacheNamesNew);
            
                long[] alCacheIds = getCacheIds();
                if (alCacheIds != null)
                    {
                    long[] alCacheIdsNew = new long[cCacheNames];
                    System.arraycopy(alCacheIds, 0, alCacheIdsNew, 0, cCacheNames);
                    setCacheIds(alCacheIdsNew);
                    }
                }
            }
        
        // Accessor for the property "CacheAction"
        /**
         * Getter for property CacheAction.<p>
        * Action requested for the given cache name.
         */
        public int getCacheAction()
            {
            return __m_CacheAction;
            }
        
        // Accessor for the property "CacheIds"
        /**
         * Getter for property CacheIds.<p>
        * An array of cache ids that should be used for the given array of
        * cache names associated by the array index.
         */
        public long[] getCacheIds()
            {
            return __m_CacheIds;
            }
        
        // Accessor for the property "CacheNames"
        /**
         * Getter for property CacheNames.<p>
        * The list of cache names.
         */
        public String[] getCacheNames()
            {
            return __m_CacheNames;
            }
        
        // Accessor for the property "Response"
        /**
         * Getter for property Response.<p>
        * Transient property holding a deferred response to the original
        * request.
         */
        public com.tangosol.coherence.component.net.Message getResponse()
            {
            return __m_Response;
            }
        
        // Declared at the super level
        protected com.tangosol.coherence.component.net.Poll instantiatePoll()
            {
            // import Component.Net.Poll;
            
            return (Poll) _newChild("Poll");
            }
        
        // Accessor for the property "CreateBinaryMap"
        /**
         * Getter for property CreateBinaryMap.<p>
        * Transient value that specifies whether or not the BinaryMap should be
        * created before the message is responded to. Note, that this value is
        * used only if the request comes from a client thread on the same node.
         */
        public boolean isCreateBinaryMap()
            {
            return __m_CreateBinaryMap;
            }
        
        // Declared at the super level
        /**
         * This is the event that is executed when a Message is received.
        * <p>
        * It is the main processing event of the Message called by the
        * <code>Service.onMessage()</code> event. With regards to the use of
        * Message components within clustered Services, Services are designed
        * by dragging Message components into them as static children. These
        * Messages are the components that a Service can send to other running
        * instances of the same Service within a cluster. When the onReceived
        * event is invoked by a Service, it means that the Message has been
        * received; the code in the onReceived event is therefore the Message
        * specific logic for processing a received Message. For example, when
        * onReceived is invoked on a Message named FindData, the onReceived
        * event should do the work to "find the data", because it is being
        * invoked by the Service that received the "find the data" Message.
         */
        public void onReceived()
            {
            // import Component.Net.Member as com.tangosol.coherence.component.net.Member;
            // import com.tangosol.run.xml.SimpleElement;
            // import com.tangosol.run.xml.XmlElement;
            // import java.util.ArrayList;
            // import java.util.Arrays;
            // import java.util.ConcurrentModificationException;
            // import java.util.Iterator;
            // import java.util.HashMap;
            // import java.util.List;
            // import java.util.Map;
            
            super.onReceived();
            
            PartitionedCache   service      = (PartitionedCache) getService();
            Map       mapConfig    = service.getServiceConfigMap();
            String[]  asCacheNames = getCacheNames();
            PartitionedCache.Response msgResponse  = (PartitionedCache.Response) service.instantiateMessage("Response");
            
            msgResponse.respondTo(this);
            
            com.tangosol.coherence.component.net.Member memberThis        = service.getThisMember();
            com.tangosol.coherence.component.net.Member memberFrom        = getFromMember();
            com.tangosol.coherence.component.net.Member memberCoordinator = service.getServiceOldestMember();
            
            switch (getCacheAction())
                {
                case CACHE_CREATE:
                    {
                    long[]   alCacheIds     = getCacheIds();
                    Map      mapXml         = null;
                    String[] asCachesCreate = null;
                    long  [] alIdsCreate    = null;
            
                    for (int i = 0, j = 0, cNames = asCacheNames.length; i < cNames; i++)
                        {
                        String sCacheName = asCacheNames[i];
                        long   lCacheId   = alCacheIds == null ? 0L : alCacheIds[i];
            
                        if (sCacheName == null)
                            {
                            _trace("Unexpected null cache name: " + Arrays.toString(asCacheNames), 2);
                            continue;
                            }
            
                         XmlElement xmlCacheInfo = (XmlElement) mapConfig.get(sCacheName);
            
                        if (xmlCacheInfo == null)
                            {
                            if (memberThis != memberCoordinator)
                                {
                                if (asCachesCreate == null)
                                    {
                                    asCachesCreate = new String[cNames - i];
                                    alIdsCreate    = new long[asCachesCreate.length];
                                    }
                                asCachesCreate[j] = sCacheName;
                                alIdsCreate[j++]  = lCacheId;
            
                                continue;
                                }
            
                            xmlCacheInfo = service.createCacheInfo(sCacheName, lCacheId);
            
                            if (mapXml == null)
                                {
                                mapXml = new HashMap(cNames);
                                }
                            mapXml.put(sCacheName, xmlCacheInfo);
                            }
            
                        if (alCacheIds == null)
                            {
                            alCacheIds = new long[cNames];
                            }
                        lCacheId = alCacheIds[i] = xmlCacheInfo.getAttribute("id").getLong();
            
                        if (isCreateBinaryMap())
                            {
                            service.ensureBinaryMap(sCacheName, lCacheId);
                            }
                        }
            
                    if (mapXml != null)
                        {
                        // must be coordinator; do a bulk-update of the service-config
                        mapConfig.putAll(mapXml);
                        }
            
                    if (asCachesCreate == null)
                        {
                        msgResponse.setValue(alCacheIds);
                        service.post(msgResponse);
                        }
                    else
                        {
                        // only the Service senior is allowed to create the cache id
                        StorageIdRequest msg = (StorageIdRequest) this.cloneMessage();
            
                        msg.setCacheNames(asCachesCreate);
                        msg.setCacheIds(alIdsCreate);
                        msg.addToMember(memberCoordinator);
                        msg.setResponse(msgResponse);
                        msg.compressCacheNames();
                        service.post(msg);
                        }
                    break;
                    }
             
                case CACHE_DESTROY:
                    // Destroy the cache.  Updating the service-config map will result in
                    // config updates sent to all service members
                    for (int i = 0, cNames = asCacheNames.length; i < cNames; i++)
                        {
                        mapConfig.remove(asCacheNames[i]);
                        }
            
                    service.post(msgResponse);
                    break;
            
                default:
                    throw new IllegalStateException();
                }
            }
        
        // Declared at the super level
        public void read(com.tangosol.io.ReadBuffer.BufferInput input)
                throws java.io.IOException
            {
            // import com.tangosol.util.ExternalizableHelper as com.tangosol.util.ExternalizableHelper;
            
            super.read(input);
            
            setCacheNames(com.tangosol.util.ExternalizableHelper.readStringArray(input));
            setCacheAction(input.readInt());
            
            // Note: while the sender may be version compatible with the receiver
            //       (this member), this may be a multi-point message with one
            //       of the recepients not being version compatible
            try
                {
                if (com.tangosol.util.ExternalizableHelper.isVersionCompatible(input, 12, 2, 1, 1, 0))
                    {
                    long[] alCacheIds = new long[input.readPackedInt()];
                    for (int i = 0, c = alCacheIds.length; i < c; ++i)
                        {
                        alCacheIds[i] = input.readLong();
                        }
                    setCacheIds(alCacheIds);
                    }
                }
            catch (Throwable t) {}
            
            readTracing(input);
            }
        
        // Accessor for the property "CacheAction"
        /**
         * Setter for property CacheAction.<p>
        * Action requested for the given cache name.
         */
        public void setCacheAction(int pCacheAction)
            {
            __m_CacheAction = pCacheAction;
            }
        
        // Accessor for the property "CacheIds"
        /**
         * Setter for property CacheIds.<p>
        * An array of cache ids that should be used for the given array of
        * cache names associated by the array index.
         */
        public void setCacheIds(long[] asNames)
            {
            __m_CacheIds = asNames;
            }
        
        // Accessor for the property "CacheNames"
        /**
         * Setter for property CacheNames.<p>
        * The list of cache names.
         */
        public void setCacheNames(String[] asNames)
            {
            __m_CacheNames = asNames;
            }
        
        // Accessor for the property "CreateBinaryMap"
        /**
         * Setter for property CreateBinaryMap.<p>
        * Transient value that specifies whether or not the BinaryMap should be
        * created before the message is responded to. Note, that this value is
        * used only if the request comes from a client thread on the same node.
         */
        public void setCreateBinaryMap(boolean fCreate)
            {
            __m_CreateBinaryMap = fCreate;
            }
        
        // Declared at the super level
        /**
         * Setter for property RequestTimeout.<p>
        * Transient property optionally used on the client to indicate the
        * (safe local) time after which this logical request should be
        * considered timed out.
        * 
        * Note that a single logical request message may result in multiple
        * physical request messages being sent to mulitple members; this
        * RequestTimeout value will be cloned to all resulting RequestMessage
        * instances.
        * 
        * This value is lazily calculated by #getRequestTimeout or
        * #calculateTimeoutRemaining.
         */
        public void setRequestTimeout(long ldtTimeout)
            {
            super.setRequestTimeout(ldtTimeout);
            }
        
        // Accessor for the property "Response"
        /**
         * Setter for property Response.<p>
        * Transient property holding a deferred response to the original
        * request.
         */
        public void setResponse(com.tangosol.coherence.component.net.Message msgResponse)
            {
            __m_Response = msgResponse;
            }
        
        // Declared at the super level
        public void write(com.tangosol.io.WriteBuffer.BufferOutput output)
                throws java.io.IOException
            {
            // import com.tangosol.util.ExternalizableHelper as com.tangosol.util.ExternalizableHelper;
            
            super.write(output);
            
            com.tangosol.util.ExternalizableHelper.writeStringArray(output, getCacheNames());
            output.writeInt(getCacheAction());
            
            if (getService().isVersionCompatible(getToMemberSet(), 12, 2, 1, 1, 0))
                {
                long[] alCacheIds = getCacheIds();
                int    cCacheIds  = alCacheIds == null ? 0 : alCacheIds.length;
            
                output.writePackedInt(cCacheIds);
                for (int i = 0; i < cCacheIds; ++i)
                    {
                    // intentionally non-packed as cache ids use the high order bits
                    output.writeLong(alCacheIds[i]);
                    }
                }
            
            writeTracing(output);
            }

        // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$StorageIdRequest$Poll
        
        /**
         * The Poll contains information regarding a request sent to one or
         * more Cluster Members that require responses. A Service may poll
         * other Members that are running the same Service, and the Poll is
         * used to wait for and assemble the responses from each of those
         * Members. A client thread may also use the Poll to block on a
         * response or set of responses, thus waiting for the completion of the
         * Poll. In its simplest form, which is a Poll that is sent to one
         * Member of the Cluster, the Poll actually represents the
         * request/response model.
         */
        @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
        public static class Poll
                extends    com.tangosol.coherence.component.net.Poll
            {
            // ---- Fields declarations ----
            
            // Default constructor
            public Poll()
                {
                this(null, null, true);
                }
            
            // Initializing constructor
            public Poll(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                {
                super(sName, compParent, false);
                
                if (fInit)
                    {
                    __init();
                    }
                }
            
            // Main initializer
            public void __init()
                {
                // private initialization
                __initPrivate();
                
                
                // signal the end of the initialization
                set_Constructed(true);
                }
            
            // Private initializer
            protected void __initPrivate()
                {
                
                super.__initPrivate();
                }
            
            //++ getter for static property _Instance
            /**
             * Getter for property _Instance.<p>
            * Auto generated
             */
            public static com.tangosol.coherence.Component get_Instance()
                {
                return new StorageIdRequest.Poll();
                }
            
            //++ getter for static property _CLASS
            /**
             * Getter for property _CLASS.<p>
            * Property with auto-generated accessor that returns the Class
            * object for a given component.
             */
            public static Class get_CLASS()
                {
                Class clz;
                try
                    {
                    clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$StorageIdRequest$Poll".replace('/', '.'));
                    }
                catch (ClassNotFoundException e)
                    {
                    throw new NoClassDefFoundError(e.getMessage());
                    }
                return clz;
                }
            
            //++ getter for autogen property _Module
            /**
             * This is an auto-generated method that returns the global [design
            * time] parent component.
            * 
            * Note: the class generator will ignore any custom implementation
            * for this behavior.
             */
            private com.tangosol.coherence.Component get_Module()
                {
                return this.get_Parent().get_Parent();
                }
            
            // Declared at the super level
            /**
             * This is the event that is executed when all the Members that were
            * polled have responded or have left the Service.
             */
            protected void onCompletion()
                {
                // import Component.Net.Member;
                // import Component.Net.Message;
                // import java.util.Map;
                
                super.onCompletion();
                
                StorageIdRequest msgRequest  = (StorageIdRequest) get_Parent();
                Message           msgResponse = (Message) msgRequest.getResponse();
                
                if (msgResponse != null)
                    {
                    _assert(msgRequest.getCacheAction() == msgRequest.CACHE_CREATE);
                    PartitionedCache service   = (PartitionedCache) getService();
                    long[]  alCacheId = (long[]) getResult();
                
                    if (alCacheId == null)
                        {
                        // the senior died; repeat the request & compress the cache names
                        // incase we become the new senior avoiding serialization methods
                
                        if (!service.isExiting() && service.getServiceState() < PartitionedCache.SERVICE_STOPPING)
                            {
                            StorageIdRequest msg = (StorageIdRequest) msgRequest.cloneMessage();
                            msg.addToMember(service.getServiceOldestMember());
                
                            service.post(msg);
                            }
                        }
                    else
                        {
                        if (msgRequest.isCreateBinaryMap())
                            {
                            String[] asName = msgRequest.getCacheNames();
                
                            for (int i = 0, c = asName.length; i < c; i++)
                                {
                                service.ensureBinaryMap(asName[i], alCacheId[i]);
                                }
                            }
                
                        service.post(msgResponse);
                        }
                    }
                }
            
            // Declared at the super level
            /**
             * This event occurs for each response Message from each polled
            * Member.
             */
            public void onResponse(com.tangosol.coherence.component.net.Message msg)
                {
                PartitionedCache.Response response = (PartitionedCache.Response) msg;
                
                setResult(response.getValue()); // long[]
                
                super.onResponse(msg);
                }
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$TransferControl
    
    /**
     * TransferControl manages state associated with incoming and outgoing
     * transfers to/from this service.
     * 
     * For example, TransferControl manages:
     * * size-limits for batched outgoing transfer
     * * incoming TransferRequests waiting to be processed
     * * partitions that have been transferred but are awaiting ownership
     * publication
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class TransferControl
            extends    com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.TransferControl
        {
        // ---- Fields declarations ----
        
        /**
         * Property Addendums
         *
         * Addendums to add to the currently in-progress transfer. The map
         * holds a list of deferred events for each partition in transfer.
         * 
         * Map<int, List<$DeferredEvent>>
         */
        private java.util.Map __m_Addendums;
        private static com.tangosol.util.ListMap __mapChildren;
        
        // Static initializer
        static
            {
            __initStatic();
            }
        
        // Default static initializer
        private static void __initStatic()
            {
            // register child classes
            __mapChildren = new com.tangosol.util.ListMap();
            __mapChildren.put("TransferIterator", com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.TransferControl.TransferIterator.get_CLASS());
            }
        
        // Default constructor
        public TransferControl()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public TransferControl(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                setAddendums(new com.tangosol.util.LiteMap());
                setIncomingTransfers(new java.util.HashMap());
                setPartitionsOut(new com.tangosol.util.PrimitiveSparseArray());
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // containment initialization: children
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.TransferControl();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$TransferControl".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        //++ getter for autogen property _ChildClasses
        /**
         * This is an auto-generated method that returns the map of design time
        * [static] children.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        protected java.util.Map get_ChildClasses()
            {
            return __mapChildren;
            }
        
        // Declared at the super level
        /**
         * Called when the transfer for the specified partition has commenced
        * (the partition was locked), but later has been cancelled. This method
        * is called prior to the partition being unlocked.
         */
        public void cancelTransmit(int iPartition)
            {
            // import java.util.Iterator;
            // import java.util.List;
            // import java.util.Map;
            
            // the partition was locked to be ready for transfer and could have accumulated
            // deferred events (see Storage.onBackingMapEvent);
            // need to replay those events now
            
            Map  mapAddendums = getAddendums();
            List listAddendums;
            
            synchronized (mapAddendums)
                {
                listAddendums = (List) mapAddendums.remove(Integer.valueOf(iPartition));
                }
            
            // move deferred events into the unlock actions for that partition control
            if (listAddendums != null)
                {
                PartitionedCache.PartitionControl ctrlPartition = (PartitionedCache.PartitionControl) getPartitionControl(iPartition);   
                for (Iterator iter = listAddendums.iterator(); iter.hasNext(); )
                    {
                    Storage.DeferredEvent deferredEvt = (Storage.DeferredEvent) iter.next();
                    deferredEvt.setReapply(false);
                    ctrlPartition.addUnlockAction(deferredEvt);
                    }
                }
            }
        
        /**
         * Add an event to the transfer message stream.
        * The caller of this method should hold synchronization on the transfer
        * control.
        * 
        * @param evt            a backing-map event that is raised while the
        * corresponding key is in the process of being transferred out 
        * @param lCacheId   the id of the cache that generated the event
         */
        public void deferEvent(Storage.DeferredEvent evt)
            {
            // import com.tangosol.util.Binary;
            // import com.tangosol.util.LiteMap;
            // import com.tangosol.util.MapEvent as com.tangosol.util.MapEvent;
            // import com.tangosol.util.SafeLinkedList;
            // import java.util.List;
            // import java.util.Map;
            
            PartitionedCache  service      = (PartitionedCache) get_Module();
            com.tangosol.util.MapEvent mapEvt       = (com.tangosol.util.MapEvent) evt.getEvent();
            Binary   binKey       = (Binary) mapEvt.getKey();
            int      iPartition   = service.getKeyPartition(binKey);
            Map      mapAddendums = getAddendums();
            
            synchronized (mapAddendums)
                {
                Integer IPartition    = Integer.valueOf(iPartition);
                List    listAddendums = (List) mapAddendums.get(IPartition);
                if (listAddendums == null)
                    {
                    // use a thread safe list to prevent concurrency issues
                    // during $TransferREquest.write()
                    listAddendums = new SafeLinkedList();
                    mapAddendums.put(IPartition, listAddendums);
                    }
                listAddendums.add(evt);
                }
            }
        
        // Declared at the super level
        public void finalizeReceivePartition(int iPartition, java.util.List listXferRequests)
            {
            // import com.tangosol.util.MapEvent as com.tangosol.util.MapEvent;
            // import com.tangosol.util.ValueExtractor;
            // import java.util.Comparator;
            // import java.util.Iterator;
            // import java.util.Map$Entry as java.util.Map.Entry;
            
            super.finalizeReceivePartition(iPartition, listXferRequests);
            
            // only after all the addenums are processed, schedule an index update
            PartitionedCache service = (PartitionedCache) get_Module();

            if (service.isIndexed())
                {
                // create partition indices
                for (Iterator iterStore = service.getStorageArray().iterator(); iterStore.hasNext();)
                    {
                    Storage storage = (Storage) iterStore.next();
                    if (storage.isIndexed())
                        {
                        for (Iterator iterIndex = storage.getIndexExtractorMap().entrySet().iterator(); iterIndex.hasNext(); )
                            {
                            java.util.Map.Entry index      = (java.util.Map.Entry) iterIndex.next();
                            ValueExtractor      extractor  = (ValueExtractor) index.getKey();
                            Comparator          comparator = (Comparator) index.getValue();

                            storage.createMapIndex(storage.getPartitionIndexMap(iPartition), extractor, comparator);
                            }
                        if (!service.getDaemonPool().isStarted())
                            {
                            // re-create partition index on service thread
                            storage.createPartitionIndex(iPartition, null);
                            }
                        }
                    }

                if (service.getDaemonPool().isStarted())
                    {
                    service.scheduleIndexUpdate(iPartition, com.tangosol.util.MapEvent.ENTRY_INSERTED);
                    }
                }
            }
        
        // Declared at the super level
        /**
         * Perform any final actions once the last transfer message in the
        * distribution has been posted.
        * 
        * @param msgTransferLast   the last transfer message in the distribution
         */
        protected void finalizeTransmit(com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.TransferRequest msgTransferLast)
            {
            // import java.util.List;
            // import java.util.Map;
            
            super.finalizeTransmit(msgTransferLast);
            
            Map mapAddendums = getAddendums();
            synchronized (mapAddendums)
                {
                List listAddendums = (List)
                    mapAddendums.get(Integer.valueOf(msgTransferLast.getPartition()));
                if (listAddendums != null)
                    {
                    ((PartitionedCache.TransferRequest) msgTransferLast).setAddendums(listAddendums);
                    }
                }
            }
        
        // Accessor for the property "Addendums"
        /**
         * Getter for property Addendums.<p>
        * Addendums to add to the currently in-progress transfer. The map holds
        * a list of deferred events for each partition in transfer.
        * 
        * Map<int, List<$DeferredEvent>>
         */
        public java.util.Map getAddendums()
            {
            return __m_Addendums;
            }
        
        // Declared at the super level
        /**
         * The transfer messages received for the current distribution have been
        * committed.
        * 
        * @param msgLastTransfer  the last transfer message in the distribution
         */
        public void onReceiveCommitted(com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.TransferRequest msgLastTransfer)
            {
            super.onReceiveCommitted(msgLastTransfer);
            
            if (msgLastTransfer.getStore() == 0)
                {
                processAddendums((PartitionedCache.TransferRequest) msgLastTransfer);
                }
            }
        
        // Declared at the super level
        /**
         * The specified TransferRequest was received. 
        * 
        * See PartitionedService#onTransferRequest for details.
         */
        public void onReceiveStarted(com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.TransferRequest msgRequest, com.oracle.coherence.common.base.Continuation continuation)
            {
            PartitionedCache          service     = (PartitionedCache) get_Module();
            PartitionedCache.TransferRequest msgTransfer = (PartitionedCache.TransferRequest) msgRequest;
            long             lCacheId    = msgTransfer.getCacheId();
            
            if (lCacheId != -1L)
                {
                // COH-3275: the cache that this transfer msg relates to may have just been
                //           concurrently created/destroyed (with the update msg delayed
                //           in-flight.  Check in the storage-graveyard if the storage was
                //           already destroyed on this member.  Ensure that the cache-name is
                //           set if this member hasn't been updated with the new cache-name yet.
                String   sName   = msgTransfer.getCacheName();
                Storage storage = service.ensureUniqueStorage(lCacheId, sName, /*fCheckGraveyard*/ true);
                if (storage != null)
                    {
                    try
                        {
                        storage.ensureInitialized(sName, /*fRegisterExtents*/ true);
                        }
                    catch (IllegalArgumentException e)
                        {
                        // the storage and backing map already exist;
                        // the cache data must be stale; invalidate the storage
                        // we have just created, so that the data will not be received
                        // (see receivePartition)
            
                        _trace("The transfer request for cache \""
                            + msgTransfer.getCacheName() + "\" on partition "
                            + msgTransfer.getPartition()
                            + " is stale; discarding the transfer data", 1);
            
                        // get rid of the Storage we have just created
                        service.removeStorage(lCacheId);
                        storage.invalidate();
                        }
                    }
                }
            
            if (msgRequest.getStore() == 0 && msgTransfer.isLastInTransfer())
                {
                super.onReceiveStarted(msgRequest, null);
            
                service.getEventsHelper().onEntriesArrived(
                    getQueuedTransfers(msgRequest.getFromMember()), continuation);
                }
            else
                {
                super.onReceiveStarted(msgRequest, continuation);
                }
            }
        
        // Declared at the super level
        /**
         * The specified outgoing transfer has been received.  This indicates
        * that the recipient of the transfer received all transfer messages and
        * has sent acknowledgment to the sender, though the ownership change
        * may not have been published to the service senior yet.
        * 
        * Called on the service thread only.
         */
        public void onTransmitCompleted(int iPartition, int iStore)
            {
            // import java.util.Iterator;
            // import java.util.Map;
            
            super.onTransmitCompleted(iPartition, iStore);
            
            if (iStore == 0)
                {
                // drop the deferred events for this partition
                Map mapAddendums = getAddendums();
                synchronized (mapAddendums)
                    {
                    mapAddendums.remove(Integer.valueOf(iPartition));
                    }
            
                PartitionedCache service = (PartitionedCache) get_Module();
            
                // drop indices for this partition
                for (Iterator it = service.getStorageArray().iterator(); it.hasNext(); )
                    {
                    Storage storage = (Storage) it.next();
                    if (storage.isIndexed())
                        {
                        storage.getPartitionedIndexMap().remove(iPartition);
                        }
                    }
            
                // drop the pending index rebuild for this partition
                service.updatePendingIndexPartition(iPartition, false);
                }
            }
        
        /**
         * Process an addendum attached to the specified transfer.
        * 
        * @param msgLastTransfer  the last $TransferRequest message in a
        * distribution
         */
        protected void processAddendums(PartitionedCache.TransferRequest msgLastTransfer)
            {
            // import com.oracle.coherence.common.base.Continuation;
            // import java.util.Iterator;
            // import java.util.List;
            
            // Copy the deferred events to the PartitionControl for execution upon the
            // partition being unlocked.
            // Addendums can be generated if BackingMapEvents are raised during the
            // process of gathering the transfer data. The transfer has been fully received
            // and once the partition is unlocked the addendums need to be replayed to
            // ensure that:
            //   1. the primary storage properly reflects the BME change
            //   2. the backup owners and listeners are properly notified
            
            List listAddendums = msgLastTransfer.getAddendums();
            if (listAddendums != null)
                {
                PartitionedCache.PartitionControl ctrlPart = (PartitionedCache.PartitionControl)
                    getPartitionControl(msgLastTransfer.getPartition());
                
                // As of 3.6, the only addendums are Storage.DeferredEvent
                for (Iterator iter = listAddendums.iterator(); iter.hasNext(); )
                    {
                    ctrlPart.addUnlockAction((Continuation) iter.next());
                    }
                }
            }
        
        // Accessor for the property "Addendums"
        /**
         * Setter for property Addendums.<p>
        * Addendums to add to the currently in-progress transfer. The map holds
        * a list of deferred events for each partition in transfer.
        * 
        * Map<int, List<$DeferredEvent>>
         */
        protected void setAddendums(java.util.Map mapAddendum)
            {
            __m_Addendums = mapAddendum;
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$TransferRequest
    
    /**
     * TransferRequest is a poll (by data owner) that transfers partition data.
     *  
     * 
     * Note: Multiple TransferRequests may be sent for a given partition
     * transfer (e.g. PartitionedCache may send a TransferRequest message per
     * cache).
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class TransferRequest
            extends    com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.TransferRequest
        {
        // ---- Fields declarations ----
        
        /**
         * Property Addendums
         *
         * List of addendums that were generated during the transfer process
         * that must be processed atomically with either transfer commit or
         * rollback.
         * 
         * Only the last transfer message in a distribution (isLastTransfer())
         * will hold addendums.
         * 
         * For example, if during primary partition transfer, a backing-map
         * event is generated on the sender corresponding to data in the
         * transfer, the handling of that update (e.g. generating backup &
         * listener events) must be handled either by the new primary owner
         * upon transfer success, or by the sender upon transfer failure.
         * 
         * See $TransferControl#onTransfersCommitted,
         * $TransferControl#onTransfersRollback
         */
        private java.util.List __m_Addendums;
        
        /**
         * Property CacheId
         *
         * The Id of the cache this request is for.
         */
        private long __m_CacheId;
        
        /**
         * Property CacheName
         *
         * The name of the cache this request is for.
         */
        private String __m_CacheName;
        
        /**
         * Property EventsStoreBinary
         *
         */
        private com.tangosol.io.ReadBuffer __m_EventsStoreBinary;
        
        /**
         * Property LastCache
         *
         * Set to true if the very last cache in a bucket.
         */
        private boolean __m_LastCache;
        
        /**
         * Property Lease
         *
         * An array of Leases to transfer.
         */
        private com.tangosol.coherence.component.net.Lease[] __m_Lease;
        
        /**
         * Property Listener
         *
         * An array of Listener Entries to transfer.
         */
        private java.util.Map.Entry[] __m_Listener;
        
        /**
         * Property MapEventVersion
         *
         * The version of the last MapEvent for this partition.
         */
        private long __m_MapEventVersion;
        
        /**
         * Property Resource
         *
         * An array of resource Entries to transfer.
         */
        private java.util.Map.Entry[] __m_Resource;
        private static com.tangosol.util.ListMap __mapChildren;
        
        // Static initializer
        static
            {
            __initStatic();
            }
        
        // Default static initializer
        private static void __initStatic()
            {
            // register child classes
            __mapChildren = new com.tangosol.util.ListMap();
            __mapChildren.put("Poll", com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.TransferRequest.Poll.get_CLASS());
            }
        
        // Default constructor
        public TransferRequest()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public TransferRequest(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                setMessageType(34);
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // containment initialization: children
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.TransferRequest();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$TransferRequest".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        //++ getter for autogen property _ChildClasses
        /**
         * This is an auto-generated method that returns the map of design time
        * [static] children.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        protected java.util.Map get_ChildClasses()
            {
            return __mapChildren;
            }
        
        // Accessor for the property "Addendums"
        /**
         * Getter for property Addendums.<p>
        * List of addendums that were generated during the transfer process
        * that must be processed atomically with either transfer commit or
        * rollback.
        * 
        * Only the last transfer message in a distribution (isLastTransfer())
        * will hold addendums.
        * 
        * For example, if during primary partition transfer, a backing-map
        * event is generated on the sender corresponding to data in the
        * transfer, the handling of that update (e.g. generating backup &
        * listener events) must be handled either by the new primary owner upon
        * transfer success, or by the sender upon transfer failure.
        * 
        * See $TransferControl#onTransfersCommitted,
        * $TransferControl#onTransfersRollback
         */
        public java.util.List getAddendums()
            {
            return __m_Addendums;
            }
        
        // Accessor for the property "CacheId"
        /**
         * Getter for property CacheId.<p>
        * The Id of the cache this request is for.
         */
        public long getCacheId()
            {
            return __m_CacheId;
            }
        
        // Accessor for the property "CacheName"
        /**
         * Getter for property CacheName.<p>
        * The name of the cache this request is for.
         */
        public String getCacheName()
            {
            return __m_CacheName;
            }
        
        // Accessor for the property "EventsStoreBinary"
        /**
         * Getter for property EventsStoreBinary.<p>
         */
        public com.tangosol.io.ReadBuffer getEventsStoreBinary()
            {
            return __m_EventsStoreBinary;
            }
        
        // Accessor for the property "Lease"
        /**
         * Getter for property Lease.<p>
        * An array of Leases to transfer.
         */
        public com.tangosol.coherence.component.net.Lease[] getLease()
            {
            return __m_Lease;
            }
        
        // Accessor for the property "Listener"
        /**
         * Getter for property Listener.<p>
        * An array of Listener Entries to transfer.
         */
        public java.util.Map.Entry[] getListener()
            {
            return __m_Listener;
            }
        
        // Accessor for the property "MapEventVersion"
        /**
         * Getter for property MapEventVersion.<p>
        * The version of the last MapEvent for this partition.
         */
        public long getMapEventVersion()
            {
            return __m_MapEventVersion;
            }
        
        // Accessor for the property "Resource"
        /**
         * Getter for property Resource.<p>
        * An array of resource Entries to transfer.
         */
        public java.util.Map.Entry[] getResource()
            {
            return __m_Resource;
            }
        
        // Accessor for the property "LastCache"
        /**
         * Getter for property LastCache.<p>
        * Set to true if the very last cache in a bucket.
         */
        public boolean isLastCache()
            {
            return __m_LastCache;
            }
        
        // Declared at the super level
        public void read(com.tangosol.io.ReadBuffer.BufferInput input)
                throws java.io.IOException
            {
            // import Component.Net.Lease;
            // import Component.Net.Member;
            // import Component.Net.MemberSet;
            // import Component.Net.Message.MapEventMessage;
            // import com.tangosol.io.ReadBuffer;
            // import com.tangosol.util.ExternalizableHelper as com.tangosol.util.ExternalizableHelper;
            // import com.tangosol.util.LongArray;
            // import com.tangosol.util.SafeHashMap;
            // import com.tangosol.util.SimpleMapEntry;
            // import com.tangosol.util.SparseArray;
            // import java.util.ArrayList;
            // import java.util.List;
            // import java.util.Map;
            // import java.util.Map$Entry as java.util.Map.Entry;
            // import java.util.HashMap;
            
            super.read(input);
            
            PartitionedCache   service    = (PartitionedCache) getService();
            MemberSet setMembers = service.getServiceMemberSet();
            
            long lCacheId = com.tangosol.util.ExternalizableHelper.readLong(input);
            
            setCacheId(lCacheId);
            if (lCacheId != -1L)
                {
                setCacheName(input.readUTF());
                }
            
            // resources
                {
                int     cResources = com.tangosol.util.ExternalizableHelper.readInt(input);
                java.util.Map.Entry[] aResource  = new java.util.Map.Entry[cResources];
                for (int i = 0; i < cResources; i++)
                    {
                    Object binKey   = com.tangosol.util.ExternalizableHelper.readObject(input);
                    Object binValue = com.tangosol.util.ExternalizableHelper.readObject(input);
                  
                    aResource[i] = new SimpleMapEntry(binKey, binValue);
                    }
                setResource(aResource);
                }
            
            // leases
                {
                int     cLeases  = com.tangosol.util.ExternalizableHelper.readInt(input);
                Lease[] aLease   = new Lease[cLeases];
                for (int i = 0; i < cLeases; i++)
                    {
                    Object binKey = readObject(input);
            
                    Lease  lease  = Lease.instantiate(0, binKey, service);
                    lease.read(input);
            
                    aLease[i] = lease;
                    }
                setLease(aLease);
                }
            
            // key listeners
                {
                int     cListens = com.tangosol.util.ExternalizableHelper.readInt(input);
                java.util.Map.Entry[] aListen  = new java.util.Map.Entry[cListens];
            
                for (int iL = 0; iL < cListens; iL++)
                    {
                    Object binKey = readObject(input);
            
                    Map mapMembers = new SafeHashMap();
                    int cMembers   = com.tangosol.util.ExternalizableHelper.readInt(input);
            
                    for (int iM = 0; iM < cMembers; iM++)
                        {
                        int     nMember = input.readUnsignedShort();
                        boolean fLite   = input.readBoolean();
                        
                        Member member = setMembers.getMember(nMember);
                        if (member != null)
                            {
                            mapMembers.put(member, Boolean.valueOf(fLite));
                            }
                        }
                    aListen[iL] = new SimpleMapEntry(binKey, mapMembers);
                    }
                setListener(aListen);
                }
            
            if (isLastInPartition())
                {
                // pending results
                int cRequests = com.tangosol.util.ExternalizableHelper.readInt(input);
                if (cRequests > 0)
                    {
                    LongArray laPending = new SparseArray();
            
                    for (int i = 0; i < cRequests; i++)
                        {
                        long lSUID     = com.tangosol.util.ExternalizableHelper.readLong(input);
                        int  cResults  = com.tangosol.util.ExternalizableHelper.readInt(input);
                        Map  mapResult = new HashMap(cResults);
            
                        for (int iResult = 0; iResult < cResults; iResult++)
                            {
                            Object binKey    = com.tangosol.util.ExternalizableHelper.readObject(input);  // Binary key
                            Object binResult = com.tangosol.util.ExternalizableHelper.readObject(input);  // Binary result (may be null)
            
                            mapResult.put(binKey, binResult);
                            }
            
                        laPending.set(lSUID, mapResult);
                        }
                    setPendingResults(laPending);
                    }
            
                // pending events
                setPendingEvents(MapEventMessage.readSupplemental(input, getService()));
            
                // check for any addendums that may have been attached by the sender
                int cAddendum = input.readInt();
                if (cAddendum > 0)
                    {
                    List listAddendum = new ArrayList();
                    for (int i = 0; i < cAddendum; i++)
                        {
                        lCacheId = input.readLong(); // cache-id for this addendum
            
                        Storage storage = service.ensureStorage(lCacheId, /*fCheckGraveyard*/ true);
                        if (storage != null)
                            {
                            Storage.DeferredEvent deferred = new Storage.DeferredEvent();
            
                            storage._linkChild(deferred);
                            deferred.read(input);
                            listAddendum.add(deferred);
                            }
                        }
                    setAddendums(listAddendum);
                    }
            
                // event history
                if (service.isVersionCompatible(getFromMember(), 21, 6, 0))
                    {
                    setEventsStoreBinary((ReadBuffer) readObject(input));
                    }
                }
            
            // latest event version
            if (service.isVersionCompatible(getFromMember(), 21, 6, 0))
                {
                setMapEventVersion(com.tangosol.util.ExternalizableHelper.readLong(input));
                }
            }
        
        // Accessor for the property "Addendums"
        /**
         * Setter for property Addendums.<p>
        * List of addendums that were generated during the transfer process
        * that must be processed atomically with either transfer commit or
        * rollback.
        * 
        * Only the last transfer message in a distribution (isLastTransfer())
        * will hold addendums.
        * 
        * For example, if during primary partition transfer, a backing-map
        * event is generated on the sender corresponding to data in the
        * transfer, the handling of that update (e.g. generating backup &
        * listener events) must be handled either by the new primary owner upon
        * transfer success, or by the sender upon transfer failure.
        * 
        * See $TransferControl#onTransfersCommitted,
        * $TransferControl#onTransfersRollback
         */
        public void setAddendums(java.util.List listAddendum)
            {
            __m_Addendums = listAddendum;
            }
        
        // Accessor for the property "CacheId"
        /**
         * Setter for property CacheId.<p>
        * The Id of the cache this request is for.
         */
        public void setCacheId(long lCacheId)
            {
            __m_CacheId = lCacheId;
            }
        
        // Accessor for the property "CacheName"
        /**
         * Setter for property CacheName.<p>
        * The name of the cache this request is for.
         */
        public void setCacheName(String sCacheName)
            {
            __m_CacheName = sCacheName;
            }
        
        // Accessor for the property "EventsStoreBinary"
        /**
         * Setter for property EventsStoreBinary.<p>
         */
        public void setEventsStoreBinary(com.tangosol.io.ReadBuffer bufBinary)
            {
            __m_EventsStoreBinary = bufBinary;
            }
        
        // Accessor for the property "LastCache"
        /**
         * Setter for property LastCache.<p>
        * Set to true if the very last cache in a bucket.
         */
        public void setLastCache(boolean pLastCache)
            {
            __m_LastCache = pLastCache;
            }
        
        // Accessor for the property "Lease"
        /**
         * Setter for property Lease.<p>
        * An array of Leases to transfer.
         */
        public void setLease(com.tangosol.coherence.component.net.Lease[] pResource_)
            {
            __m_Lease = pResource_;
            }
        
        // Accessor for the property "Listener"
        /**
         * Setter for property Listener.<p>
        * An array of Listener Entries to transfer.
         */
        public void setListener(java.util.Map.Entry[] pResource_)
            {
            __m_Listener = pResource_;
            }
        
        // Accessor for the property "MapEventVersion"
        /**
         * Setter for property MapEventVersion.<p>
        * The version of the last MapEvent for this partition.
         */
        public void setMapEventVersion(long lVersion)
            {
            __m_MapEventVersion = lVersion;
            }
        
        // Declared at the super level
        /**
         * Setter for property RequestTimeout.<p>
        * Transient property optionally used on the client to indicate the
        * (safe local) time after which this logical request should be
        * considered timed out.
        * 
        * Note that a single logical request message may result in multiple
        * physical request messages being sent to mulitple members; this
        * RequestTimeout value will be cloned to all resulting RequestMessage
        * instances.
        * 
        * This value is lazily calculated by #getRequestTimeout or
        * #calculateTimeoutRemaining.
         */
        public void setRequestTimeout(long ldtTimeout)
            {
            super.setRequestTimeout(ldtTimeout);
            }
        
        // Accessor for the property "Resource"
        /**
         * Setter for property Resource.<p>
        * An array of resource Entries to transfer.
         */
        public void setResource(java.util.Map.Entry[] pResource)
            {
            __m_Resource = pResource;
            }
        
        // Declared at the super level
        public void write(com.tangosol.io.WriteBuffer.BufferOutput output)
                throws java.io.IOException
            {
            // import Component.Net.Lease;
            // import Component.Net.Member;
            // import Component.Net.Message.MapEventMessage;
            // import com.oracle.coherence.persistence.PersistenceManager;
            // import com.tangosol.io.ReadBuffer;
            // import com.tangosol.util.ExternalizableHelper as com.tangosol.util.ExternalizableHelper;
            // import com.tangosol.util.LongArray;
            // import com.tangosol.util.LongArray$Iterator as com.tangosol.util.LongArray.Iterator;
            // import java.util.Iterator;
            // import java.util.List;
            // import java.util.Map;
            // import java.util.Map$Entry as java.util.Map.Entry;
            
            super.write(output);
            
            long lCacheId = getCacheId();
            
            com.tangosol.util.ExternalizableHelper.writeLong(output, lCacheId);
            if (lCacheId != -1L)
                {
                // COH-3275: send the cache-name with the transfer to protect
                //           against concurrent ensure/destroy cache during transfer
                output.writeUTF(getCacheName());
                }
            
            // since the TransferRequest is a poll and the Poll object is in fact
            // an instance child, this message will not be GC'd until after the poll is closed.
            // To reduce the memory usage we will do some cleanup right away
            
            // resources
                {
                java.util.Map.Entry[] aResource  = getResource();
                int     cResources = aResource.length;
            
                com.tangosol.util.ExternalizableHelper.writeInt(output, cResources);
            
                for (int i = 0; i < cResources; i++)
                    {
                    java.util.Map.Entry entry = aResource[i];
            
                    com.tangosol.util.ExternalizableHelper.writeObject(output, entry.getKey());
                    com.tangosol.util.ExternalizableHelper.writeObject(output, entry.getValue());
            
                    aResource[i] = null; // cleanup
                    }
                setResource(null); // cleanup
                }
            
            // leases
                {
                Lease[] aLease  = getLease();
                int     cLeases = aLease.length;
            
                com.tangosol.util.ExternalizableHelper.writeInt(output, cLeases);
            
                for (int i = 0; i < cLeases; i++)
                    {
                    Lease lease = aLease[i];
            
                    writeObject(output, lease.getResourceKey());
                    lease.write(output);
                    }
                setLease(null); // cleanup
                }
            
            // key listeners
                {
                java.util.Map.Entry[] aListen  = getListener();
                int     cListens = aListen.length;
            
                com.tangosol.util.ExternalizableHelper.writeInt(output, cListens);
            
                for (int i = 0; i < cListens; i++)
                    {
                    java.util.Map.Entry entry = aListen[i];
            
                    writeObject(output, entry.getKey());
            
                    Map mapMembers = (Map) entry.getValue();
                    synchronized (mapMembers)
                        {
                        com.tangosol.util.ExternalizableHelper.writeInt(output, mapMembers.size());
                        for (Iterator iter = mapMembers.entrySet().iterator(); iter.hasNext();)
                            {
                            java.util.Map.Entry entryMember = (java.util.Map.Entry) iter.next();
            
                            Member  member = (Member) entryMember.getKey();
                            Boolean FLite  = (Boolean) entryMember.getValue();
            
                            output.writeShort(member.getId());
                            output.writeBoolean(FLite.booleanValue());
                            }
                        }
                    }
                setListener(null); // cleanup
                }
            
            if (isLastInPartition())
                {
                // pending results
                //
                // The PendingResults for a given request are held in a LongArray, keyed by request
                // SUID (LongArray<lSUID, Map<binKey, binResult>>)
                
                LongArray laPending = getPendingResults();
                int       cRequests = laPending == null ? 0 : laPending.getSize();
            
                com.tangosol.util.ExternalizableHelper.writeInt(output, cRequests);
            
                if (cRequests > 0)
                    {
                    for (com.tangosol.util.LongArray.Iterator crawler = laPending.iterator(); crawler.hasNext(); )
                        {
                        Map  mapResult = (Map) crawler.next();
                        long lSUID     = crawler.getIndex();
            
                        com.tangosol.util.ExternalizableHelper.writeLong(output, lSUID);
                        com.tangosol.util.ExternalizableHelper.writeInt (output, mapResult.size());
            
                        for (Iterator iterResult = mapResult.entrySet().iterator(); iterResult.hasNext(); )
                            {
                            java.util.Map.Entry entryResult = (java.util.Map.Entry) iterResult.next();
            
                            com.tangosol.util.ExternalizableHelper.writeObject(output, entryResult.getKey());    // Binary key
                            com.tangosol.util.ExternalizableHelper.writeObject(output, entryResult.getValue());  // Binary result (may be null)
                            }
                        }
                    }
            
                // pending events
                MapEventMessage.writeSupplemental(output, getPendingEvents());
            
                List listAddendum = getAddendums();
                int  cAddendum    = listAddendum == null ? 0 : listAddendum.size();
            
                output.writeInt(cAddendum);
                if (cAddendum > 0)
                    {
                    for (Iterator iter = listAddendum.iterator(); iter.hasNext(); )
                        {
                        Storage.DeferredEvent deferred = (Storage.DeferredEvent) iter.next();
            
                        output.writeLong(deferred.getCacheId());
                        deferred.write(output);
                        }
                    }
            
                // event history @since 21.06
                writeObject(output, getEventsStoreBinary());
                }
            
            // latest event version @since 21.06
            com.tangosol.util.ExternalizableHelper.writeLong(output, getMapEventVersion());
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$UnlockRequest
    
    /**
     * @see $BinaryMap#unlock
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class UnlockRequest
            extends    com.tangosol.coherence.component.net.message.requestMessage.DistributedCacheKeyRequest
        {
        // ---- Fields declarations ----
        
        /**
         * Property LeaseHolderId
         *
         * The member id for the for this Lease holder. If Primary is true this
         * value must be equal to getFromMember().getId().
         */
        private int __m_LeaseHolderId;
        
        /**
         * Property LeaseThreadId
         *
         * Unique (within the requestor's VM) id of the Thread which requests
         * an unlock for this Lease.
         */
        private long __m_LeaseThreadId;
        private static com.tangosol.util.ListMap __mapChildren;
        
        // Static initializer
        static
            {
            __initStatic();
            }
        
        // Default static initializer
        private static void __initStatic()
            {
            // register child classes
            __mapChildren = new com.tangosol.util.ListMap();
            __mapChildren.put("Poll", PartitionedCache.UnlockRequest.Poll.get_CLASS());
            }
        
        // Default constructor
        public UnlockRequest()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public UnlockRequest(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                setMessageType(79);
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // containment initialization: children
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        // Getter for virtual constant ReadOnly
        public boolean isReadOnly()
            {
            return false;
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.UnlockRequest();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$UnlockRequest".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        //++ getter for autogen property _ChildClasses
        /**
         * This is an auto-generated method that returns the map of design time
        * [static] children.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        protected java.util.Map get_ChildClasses()
            {
            return __mapChildren;
            }
        
        // Declared at the super level
        /**
         * Instantiate a copy of this message. This is quite different from the
        * standard "clone" since only the "transmittable" portion of the
        * message (and none of the internal) state should be cloned.
         */
        public com.tangosol.coherence.component.net.Message cloneMessage()
            {
            PartitionedCache.UnlockRequest msg = (PartitionedCache.UnlockRequest) super.cloneMessage();
            
            msg.fromLease(toLease());
            
            return msg;
            }
        
        /**
         * Set the request's info based on the specified Lease object.
         */
        public void fromLease(com.tangosol.coherence.component.net.Lease lease)
            {
            // import com.tangosol.util.Binary;
            
            setKey((Binary) lease.getResourceKey());
            setLeaseHolderId(lease.getHolderId());
            setLeaseThreadId(lease.getHolderThreadId());
            }
        
        // Declared at the super level
        /**
         * Getter for property EstimatedByteSize.<p>
        * The estimated serialized size of this message.  A negative value
        * indicates that the size is unknown and that it is safe to estimate
        * the size via a double serialization.
         */
        public int getEstimatedByteSize()
            {
            return -1;
            }
        
        // Accessor for the property "LeaseHolderId"
        /**
         * Getter for property LeaseHolderId.<p>
        * The member id for the for this Lease holder. If Primary is true this
        * value must be equal to getFromMember().getId().
         */
        public int getLeaseHolderId()
            {
            return __m_LeaseHolderId;
            }
        
        // Accessor for the property "LeaseThreadId"
        /**
         * Getter for property LeaseThreadId.<p>
        * Unique (within the requestor's VM) id of the Thread which requests an
        * unlock for this Lease.
         */
        public long getLeaseThreadId()
            {
            return __m_LeaseThreadId;
            }
        
        // Declared at the super level
        public void read(com.tangosol.io.ReadBuffer.BufferInput input)
                throws java.io.IOException
            {
            // import com.tangosol.util.ExternalizableHelper;
            
            super.read(input);
            
            setLeaseHolderId(input.readUnsignedShort());
            setLeaseThreadId(ExternalizableHelper.readLong(input));
            
            readTracing(input);
            }
        
        // Declared at the super level
        public void run()
            {
            ((PartitionedCache) getService()).onUnlockRequest(this);
            }
        
        // Accessor for the property "LeaseHolderId"
        /**
         * Setter for property LeaseHolderId.<p>
        * The member id for the for this Lease holder. If Primary is true this
        * value must be equal to getFromMember().getId().
         */
        public void setLeaseHolderId(int nHolderId)
            {
            __m_LeaseHolderId = nHolderId;
            }
        
        // Accessor for the property "LeaseThreadId"
        /**
         * Setter for property LeaseThreadId.<p>
        * Unique (within the requestor's VM) id of the Thread which requests an
        * unlock for this Lease.
         */
        public void setLeaseThreadId(long nThreadId)
            {
            __m_LeaseThreadId = nThreadId;
            }
        
        // Declared at the super level
        /**
         * Setter for property RequestTimeout.<p>
        * Transient property optionally used on the client to indicate the
        * (safe local) time after which this logical request should be
        * considered timed out.
        * 
        * Note that a single logical request message may result in multiple
        * physical request messages being sent to mulitple members; this
        * RequestTimeout value will be cloned to all resulting RequestMessage
        * instances.
        * 
        * This value is lazily calculated by #getRequestTimeout or
        * #calculateTimeoutRemaining.
         */
        public void setRequestTimeout(long ldtTimeout)
            {
            super.setRequestTimeout(ldtTimeout);
            }
        
        /**
         * Calculate a Lease object based on the request's info.
         */
        public com.tangosol.coherence.component.net.Lease toLease()
            {
            // import Component.Net.Lease;
            
            Lease lease = Lease.instantiate(0, getKey(), getService());
            
            lease.setHolderId(getLeaseHolderId());
            lease.setHolderThreadId(getLeaseThreadId());
            
            return lease;
            }
        
        // Declared at the super level
        public void write(com.tangosol.io.WriteBuffer.BufferOutput output)
                throws java.io.IOException
            {
            // import com.tangosol.util.ExternalizableHelper;
            
            super.write(output);
            
            output.writeShort(getLeaseHolderId());
            ExternalizableHelper.writeLong(output, getLeaseThreadId());
            
            writeTracing(output);
            }

        // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$UnlockRequest$Poll
        
        /**
         * The Poll contains information regarding a request sent to one or
         * more Cluster Members that require responses. A Service may poll
         * other Members that are running the same Service, and the Poll is
         * used to wait for and assemble the responses from each of those
         * Members. A client thread may also use the Poll to block on a
         * response or set of responses, thus waiting for the completion of the
         * Poll. In its simplest form, which is a Poll that is sent to one
         * Member of the Cluster, the Poll actually represents the
         * request/response model.
         */
        @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
        public static class Poll
                extends    com.tangosol.coherence.component.net.message.requestMessage.DistributedCacheKeyRequest.Poll
            {
            // ---- Fields declarations ----
            
            // Default constructor
            public Poll()
                {
                this(null, null, true);
                }
            
            // Initializing constructor
            public Poll(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                {
                super(sName, compParent, false);
                
                if (fInit)
                    {
                    __init();
                    }
                }
            
            // Main initializer
            public void __init()
                {
                // private initialization
                __initPrivate();
                
                
                // signal the end of the initialization
                set_Constructed(true);
                }
            
            // Private initializer
            protected void __initPrivate()
                {
                
                super.__initPrivate();
                }
            
            //++ getter for static property _Instance
            /**
             * Getter for property _Instance.<p>
            * Auto generated
             */
            public static com.tangosol.coherence.Component get_Instance()
                {
                return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.UnlockRequest.Poll();
                }
            
            //++ getter for static property _CLASS
            /**
             * Getter for property _CLASS.<p>
            * Property with auto-generated accessor that returns the Class
            * object for a given component.
             */
            public static Class get_CLASS()
                {
                Class clz;
                try
                    {
                    clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$UnlockRequest$Poll".replace('/', '.'));
                    }
                catch (ClassNotFoundException e)
                    {
                    throw new NoClassDefFoundError(e.getMessage());
                    }
                return clz;
                }
            
            //++ getter for autogen property _Module
            /**
             * This is an auto-generated method that returns the global [design
            * time] parent component.
            * 
            * Note: the class generator will ignore any custom implementation
            * for this behavior.
             */
            private com.tangosol.coherence.Component get_Module()
                {
                return this.get_Parent().get_Parent();
                }
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$UpdateIndexRequest
    
    /**
     * The [local only] message used to defer the index rebuild when a
     * partition is received or restored.
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class UpdateIndexRequest
            extends    com.tangosol.coherence.component.net.message.RequestMessage
            implements com.tangosol.net.PriorityTask,
                       Runnable
        {
        // ---- Fields declarations ----
        
        /**
         * Property EventId
         *
         * The index rebuild cause. As of Coherence 12.1.3, we only use this
         * message for ENTRY_INSERTED events (when a partition is received).
         */
        private int __m_EventId;
        
        /**
         * Property Partition
         *
         * The partition that needs to rebuild the index.
         */
        private int __m_Partition;
        
        /**
         * Property UpdateMap
         *
         * A Map<$Storage, Map<ValueExtractor, MapIndex>> that contains the
         * storage and corresponding extractor for which the index needs to be
         * created or null which infers all MapIndex's registered against
         * $Storage.
         */
        private java.util.Map __m_UpdateMap;
        private static com.tangosol.util.ListMap __mapChildren;
        
        // Static initializer
        static
            {
            __initStatic();
            }
        
        // Default static initializer
        private static void __initStatic()
            {
            // register child classes
            __mapChildren = new com.tangosol.util.ListMap();
            __mapChildren.put("Poll", PartitionedCache.UpdateIndexRequest.Poll.get_CLASS());
            }
        
        // Default constructor
        public UpdateIndexRequest()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public UpdateIndexRequest(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                setMessageType(84);
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // containment initialization: children
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.UpdateIndexRequest();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$UpdateIndexRequest".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        //++ getter for autogen property _ChildClasses
        /**
         * This is an auto-generated method that returns the map of design time
        * [static] children.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        protected java.util.Map get_ChildClasses()
            {
            return __mapChildren;
            }
        
        // Accessor for the property "EventId"
        /**
         * Getter for property EventId.<p>
        * The index rebuild cause. As of Coherence 12.1.3, we only use this
        * message for ENTRY_INSERTED events (when a partition is received).
         */
        public int getEventId()
            {
            return __m_EventId;
            }
        
        // From interface: com.tangosol.net.PriorityTask
        public long getExecutionTimeoutMillis()
            {
            return 0L;
            }
        
        // Accessor for the property "Partition"
        /**
         * Getter for property Partition.<p>
        * The partition that needs to rebuild the index.
         */
        public int getPartition()
            {
            return __m_Partition;
            }
        
        // From interface: com.tangosol.net.PriorityTask
        public long getRequestTimeoutMillis()
            {
            return 0L;
            }
        
        // From interface: com.tangosol.net.PriorityTask
        public int getSchedulingPriority()
            {
            // import com.tangosol.net.PriorityTask;
            
            return PriorityTask.SCHEDULE_IMMEDIATE;
            }
        
        // Accessor for the property "UpdateMap"
        /**
         * Getter for property UpdateMap.<p>
        * A Map<$Storage, Map<ValueExtractor, MapIndex>> that contains the
        * storage and corresponding extractor for which the index needs to be
        * created or null which infers all MapIndex's registered against
        * $Storage.
         */
        public java.util.Map getUpdateMap()
            {
            return __m_UpdateMap;
            }
        
        // Declared at the super level
        protected com.tangosol.coherence.component.net.Poll instantiatePoll()
            {
            // import Component.Net.Poll;
            
            return (Poll) _newChild("Poll");
            }
        
        // Declared at the super level
        /**
         * This is the event that is executed when a Message is received.
        * <p>
        * It is the main processing event of the Message called by the
        * <code>Service.onMessage()</code> event. With regards to the use of
        * Message components within clustered Services, Services are designed
        * by dragging Message components into them as static children. These
        * Messages are the components that a Service can send to other running
        * instances of the same Service within a cluster. When the onReceived
        * event is invoked by a Service, it means that the Message has been
        * received; the code in the onReceived event is therefore the Message
        * specific logic for processing a received Message. For example, when
        * onReceived is invoked on a Message named FindData, the onReceived
        * event should do the work to "find the data", because it is being
        * invoked by the Service that received the "find the data" Message.
         */
        public void onReceived()
            {
            super.onReceived();
            getService().getDaemonPool().add(this);
            }
        
        // From interface: java.lang.Runnable
        public void run()
            {
            ((PartitionedCache) getService()).onUpdateIndexRequest(this);
            }
        
        // From interface: com.tangosol.net.PriorityTask
        public void runCanceled(boolean fAbandoned)
            {
            }
        
        // Accessor for the property "EventId"
        /**
         * Setter for property EventId.<p>
        * The index rebuild cause. As of Coherence 12.1.3, we only use this
        * message for ENTRY_INSERTED events (when a partition is received).
         */
        public void setEventId(int nId)
            {
            __m_EventId = nId;
            }
        
        // Accessor for the property "Partition"
        /**
         * Setter for property Partition.<p>
        * The partition that needs to rebuild the index.
         */
        public void setPartition(int nPartition)
            {
            __m_Partition = nPartition;
            }
        
        // Accessor for the property "UpdateMap"
        /**
         * Setter for property UpdateMap.<p>
        * A Map<$Storage, Map<ValueExtractor, MapIndex>> that contains the
        * storage and corresponding extractor for which the index needs to be
        * created or null which infers all MapIndex's registered against
        * $Storage.
         */
        public void setUpdateMap(java.util.Map mapUpdate)
            {
            __m_UpdateMap = mapUpdate;
            }

        // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache$UpdateIndexRequest$Poll
        
        /**
         * The Poll contains information regarding a request sent to one or
         * more Cluster Members that require responses. A Service may poll
         * other Members that are running the same Service, and the Poll is
         * used to wait for and assemble the responses from each of those
         * Members. A client thread may also use the Poll to block on a
         * response or set of responses, thus waiting for the completion of the
         * Poll. In its simplest form, which is a Poll that is sent to one
         * Member of the Cluster, the Poll actually represents the
         * request/response model.
         */
        @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
        public static class Poll
                extends    com.tangosol.coherence.component.net.Poll
            {
            // ---- Fields declarations ----
            
            // Default constructor
            public Poll()
                {
                this(null, null, true);
                }
            
            // Initializing constructor
            public Poll(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                {
                super(sName, compParent, false);
                
                if (fInit)
                    {
                    __init();
                    }
                }
            
            // Main initializer
            public void __init()
                {
                // private initialization
                __initPrivate();
                
                
                // signal the end of the initialization
                set_Constructed(true);
                }
            
            // Private initializer
            protected void __initPrivate()
                {
                
                super.__initPrivate();
                }
            
            // Getter for virtual constant Preprocessable
            public boolean isPreprocessable()
                {
                return false;
                }
            
            //++ getter for static property _Instance
            /**
             * Getter for property _Instance.<p>
            * Auto generated
             */
            public static com.tangosol.coherence.Component get_Instance()
                {
                return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.UpdateIndexRequest.Poll();
                }
            
            //++ getter for static property _CLASS
            /**
             * Getter for property _CLASS.<p>
            * Property with auto-generated accessor that returns the Class
            * object for a given component.
             */
            public static Class get_CLASS()
                {
                Class clz;
                try
                    {
                    clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/partitionedService/PartitionedCache$UpdateIndexRequest$Poll".replace('/', '.'));
                    }
                catch (ClassNotFoundException e)
                    {
                    throw new NoClassDefFoundError(e.getMessage());
                    }
                return clz;
                }
            
            //++ getter for autogen property _Module
            /**
             * This is an auto-generated method that returns the global [design
            * time] parent component.
            * 
            * Note: the class generator will ignore any custom implementation
            * for this behavior.
             */
            private com.tangosol.coherence.Component get_Module()
                {
                return this.get_Parent().get_Parent();
                }
            
            // Declared at the super level
            /**
             * This event occurs for each response Message from each polled
            * Member.
             */
            public void onResponse(com.tangosol.coherence.component.net.Message msg)
                {
                PartitionedCache.Response msgResponse = (PartitionedCache.Response) msg;
                PartitionedCache   service     = (PartitionedCache) getService();
                
                // schedule a next pending request
                // (before potentially rescheduling a deferred or failed one)
                
                PartitionedCache.UpdateIndexRequest msgRequest    = (PartitionedCache.UpdateIndexRequest) service.getPendingIndexUpdate().poll();
                int                 cIndexUpdates = service.getIndexUpdateCount() - 1;
                
                if (msgRequest == null) 
                    {
                    service.setIndexUpdateCount(cIndexUpdates);
                    }
                else
                    {
                    service.post(msgRequest);
                    }
                
                if (msgResponse.getResult() == PartitionedCache.Response.RESULT_RETRY)
                    {
                    PartitionedCache.UpdateIndexRequest msgRetry = (PartitionedCache.UpdateIndexRequest) msgResponse.getValue();
                
                    // the request may have been processed already
                    if (msgRetry != null)
                        {
                        int nPartition = msgRetry.getPartition();
                
                        if (service.getIndexPendingPartitions().contains(nPartition))
                            {
                            service.scheduleIndexUpdate(nPartition, msgRetry.getEventId(), msgRetry.getUpdateMap());
                            }
                        }
                    }
                
                if (cIndexUpdates == 0)
                    {
                    // end build index timer when all requests are done
                    service.updateIndexBuildTime();
                    }
                
                super.onResponse(msg);
                }
            }
        }
    }
