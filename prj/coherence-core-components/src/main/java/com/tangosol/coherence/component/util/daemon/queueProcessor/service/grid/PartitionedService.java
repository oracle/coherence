
/*
 * Copyright (c) 2000, 2024, Oracle and/or its affiliates.
 *
 * Licensed under the Universal Permissive License v 1.0 as shown at
 * https://oss.oracle.com/licenses/upl.
 */

// ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService

package com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid;

import com.tangosol.coherence.component.net.Cluster;
import com.tangosol.coherence.component.net.Member;
import com.tangosol.coherence.component.net.MemberSet;
import com.tangosol.coherence.component.net.Message;
import com.tangosol.coherence.component.net.memberSet.ActualMemberSet;
import com.tangosol.coherence.component.net.memberSet.DependentMemberSet;
import com.tangosol.coherence.component.net.memberSet.actualMemberSet.ServiceMemberSet;
import com.tangosol.coherence.component.net.message.RequestMessage;
import com.tangosol.coherence.component.net.message.requestMessage.chainedRequest.BackupRequest;
import com.tangosol.coherence.component.util.DistributionStrategy;
import com.tangosol.coherence.component.util.PartialJob;
import com.tangosol.coherence.component.util.daemon.queueProcessor.service.Grid;
import com.oracle.coherence.common.base.Blocking;
import com.oracle.coherence.common.base.Continuation;
import com.oracle.coherence.common.base.MutableLong;
import com.oracle.coherence.common.internal.Platform;
import com.oracle.coherence.common.util.Duration;
import com.oracle.coherence.common.util.MemorySize;
import com.oracle.coherence.persistence.ConcurrentAccessException;
import com.oracle.coherence.persistence.FatalAccessException;
import com.oracle.coherence.persistence.PersistenceEnvironment;
import com.oracle.coherence.persistence.PersistenceException;
import com.oracle.coherence.persistence.PersistenceManager;
import com.oracle.coherence.persistence.PersistentStore;
import com.oracle.coherence.persistence.PersistentStoreInfo;

import com.tangosol.coherence.component.util.daemon.queueProcessor.service.Grid;
import com.tangosol.coherence.config.Config;
import com.tangosol.coherence.config.builder.ParameterizedBuilder;
import com.tangosol.internal.net.service.grid.DefaultPartitionedServiceDependencies;
import com.tangosol.internal.net.service.grid.PartitionedServiceDependencies;
import com.tangosol.internal.net.service.grid.PersistenceDependencies;
import com.tangosol.internal.tracing.Span;
import com.tangosol.internal.tracing.TracingHelper;
import com.tangosol.internal.util.AtomicsHelper;
import com.tangosol.internal.util.OwnershipConflictResolver;
import com.tangosol.internal.util.VersionHelper;
import com.tangosol.io.ReadBuffer;
import com.tangosol.io.Serializer;
import com.tangosol.io.pof.ConfigurablePofContext;
import com.tangosol.license.LicenseException;
import com.tangosol.net.ActionPolicy;
import com.tangosol.net.GuardSupport;
import com.tangosol.net.MemberEvent;
import com.tangosol.net.PriorityTask;
import com.tangosol.net.cache.LocalCache;
import com.tangosol.net.internal.PartitionRecoverInfo;
import com.tangosol.net.internal.PartitionVersions;
import com.tangosol.net.internal.QuorumInfo;
import com.tangosol.net.management.AnnotatedStandardEmitterMBean;
import com.tangosol.net.management.MBeanHelper;
import com.tangosol.net.management.Registry;
import com.tangosol.net.partition.KeyAssociator;
import com.tangosol.net.partition.KeyPartitioningStrategy;
import com.tangosol.net.partition.Ownership;
import com.tangosol.net.partition.PartitionAssignmentStrategy;
import com.tangosol.net.partition.PartitionEvent;
import com.tangosol.net.partition.PartitionListener;
import com.tangosol.net.partition.PartitionSet;
import com.tangosol.net.partition.PartitionStatistics;
import com.tangosol.net.partition.SimpleAssignmentStrategy;
import com.tangosol.net.partition.VersionedOwnership;
import com.tangosol.persistence.AbstractPersistenceEnvironment;
import com.tangosol.persistence.CachePersistenceHelper;
import com.tangosol.persistence.GUIDHelper;
import com.tangosol.persistence.PersistenceManagerMBean;
import com.tangosol.persistence.SafePersistenceWrappers;
import com.tangosol.persistence.Snapshot;
import com.tangosol.persistence.SnapshotArchiver;
import com.tangosol.persistence.SnapshotArchiverFactory;
import com.tangosol.run.xml.SimpleElement;
import com.tangosol.run.xml.XmlElement;
import com.tangosol.util.Base;
import com.tangosol.util.Binary;
import com.tangosol.util.ClassHelper;
import com.tangosol.util.CopyOnWriteLongArray;
import com.tangosol.util.ExternalizableHelper;
import com.tangosol.util.Gate;
import com.tangosol.util.HashEncoded;
import com.tangosol.util.ImmutableArrayList;
import com.tangosol.util.LiteMap;
import com.tangosol.util.LiteSet;
import com.tangosol.util.LongArray;
import com.tangosol.util.NullImplementation;
import com.tangosol.util.PrimitiveSparseArray;
import com.tangosol.util.SparseArray;
import com.tangosol.util.ThreadGateLite;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.ConcurrentModificationException;
import java.util.EventListener;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.NoSuchElementException;
import java.util.Random;
import java.util.Set;
import java.util.TreeMap;
import java.util.TreeSet;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicLong;

import static com.tangosol.internal.util.VersionHelper.VERSION_14_1_2_0;
import static com.tangosol.internal.util.VersionHelper.VERSION_24_09;


/**
 * Base for partitioned clustered service components.
 * 
 * The message range from [33,50] is reserved for usage by the
 * PartitionedService component.
 * 
 * Currently used MessageTypes:
 * 33  OwnershipRequest
 * 34  TransferRequest
 * 35  DistributionRequest
 * 36  DistributionPlanUpdate (see $CentralDistribution)
 * 37  BackupAssignment
 * 38  TransferResponse
 * 39  PartitionSwapRequest
 * 40  BackupConfirmRequest
 * 41  PartitionVersionSyncRequest
 * 42  OwnershipResponse
 * 43  PartitionRecoverRequest
 * 44  NotifySnapshotRecoverRequest
 * 45  PartitionRecoverCleanup
 * 46  PartitionAbandonRequest
 * 47  SnapshotRequest
 * 48  SnapshotListRequest
 * 49  SnapshotArchiveRequest
 * 50  PartitionStatsUpdate  (see $CentralDistribution)
 */
@SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
public abstract class PartitionedService
        extends    com.tangosol.coherence.component.util.daemon.queueProcessor.service.Grid
        implements com.tangosol.net.PartitionedService
    {
    // ---- Fields declarations ----
    
    /**
     * Property AsyncBackup
     *
     * True if this member is configured to do async backup.
     */
    private boolean __m_AsyncBackup;
    
    /**
     * Property AsyncBackupInterval
     *
     * The time interval to send periodic backups to backup copies of this
     * member's primiary partitions.
     */
    private long __m_AsyncBackupInterval;
    
    /**
     * Property BACKUP_STRENGTH_ENDANGERED
     *
     * A partition is ENDANGERED when the actual number of backup copies of
     * that partition is less than the configured backup count for the service.
     *  
     * A service is endangered when one or more of its partitions are
     * endangered.
     */
    public static final int BACKUP_STRENGTH_ENDANGERED = 1;
    
    /**
     * Property BACKUP_STRENGTH_MACHINE
     *
     * A partition is machine-safe when it has a primary copy and the
     * configured number of backups distributed such that no two members
     * holding a copy of the partition are located on the same machine. Such a
     * distribution guarantees that the loss of any single machine would not
     * cause the loss of that partition.
     * A service is machine-safe when all of its partitions are at least
     * machine-safe.
     */
    public static final int BACKUP_STRENGTH_MACHINE = 3;
    
    /**
     * Property BACKUP_STRENGTH_NODE
     *
     * A partition is node-safe when it has a primary copy and the configured
     * number of backups. Such distribution guarantees that the loss of any
     * single coherence node would not cause loss of that partition.
     * A service is node-safe when all of its partitions are at least node-safe.
     */
    public static final int BACKUP_STRENGTH_NODE = 2;
    
    /**
     * Property BACKUP_STRENGTH_ORPHANED
     *
     * A partition is orphaned when there is no storage-enabled member of the
     * service that holds the primary copy of that partition.
     * A service that has one or more orphaned partitions is in an orphaned HA
     * state.
     */
    public static final int BACKUP_STRENGTH_ORPHANED = 0;
    
    /**
     * Property BACKUP_STRENGTH_RACK
     *
     * A partition is rack-safe when it has a primary copy and a the configured
     * number of backups distributed such that no two members holding a copy of
     * the partition  are located on the same rack . Such a distribution
     * guarantees that a loss of any single rack would not cause loss of that
     * partition.
     * A service is rack-safe when all of its partitions are at least rack-safe.
     */
    public static final int BACKUP_STRENGTH_RACK = 4;
    
    /**
     * Property BACKUP_STRENGTH_SITE
     *
     * A partition is site-safe when it has a primary copy and a the configured
     * number of backups distributed such that no two members holding a copy of
     * the partition  are located on the same site. Such a distribution
     * guarantees that the loss of any single site would not cause loss of that
     * partition.
     * A service is site-safe when all of its partitions are  site-safe.
     */
    public static final int BACKUP_STRENGTH_SITE = 5;
    
    /**
     * Property BackupCount
     *
     * Specifies the number of backups for each partition.
     */
    private int __m_BackupCount;
    
    /**
     * Property Concurrent
     *
     * True if the service is configured such that it may concurrently process
     * requests.
     */
    private boolean __m_Concurrent;
    
    /**
     * Property CONFIG_MAP_PARTITION
     *
     */
    public static final int CONFIG_MAP_PARTITION = 2;
    
    /**
     * Property ConfiguredKeyAssociator
     *
     * Configured KeyAssociator implementation; never null.
     */
    private transient com.tangosol.net.partition.KeyAssociator __m_ConfiguredKeyAssociator;
    
    /**
     * Property ConfiguredKeyPartitioningStrategy
     *
     * The configured KeyPartitioningStrategy implementation.
     */
    private transient com.tangosol.net.partition.KeyPartitioningStrategy __m_ConfiguredKeyPartitioningStrategy;
    
    /**
     * Property Continuations
     *
     */
    private PartitionedService.Continuations __m_Continuations;
    
    /**
     * Property DeferredBackupTimeoutMillis
     *
     * The delay in milliseconds after which a missing backup version is
     * considered lost.
     * 
     * Controlled by the "coherence.distributed.deferredbackuptimeout" system
     * property.
     */
    private long __m_DeferredBackupTimeoutMillis;
    
    /**
     * Property DistributionAggressiveness
     *
     * The DistributionAggressiveness factor specifies how aggressively the
     * failback operations will be scheduled. The factor of 1 means a lazy
     * (pre- Coherence 3.1) behavior. A  factor of 100 will attempt to finish
     * the failback distribution 100 times faster. Default value is 20.
     * 
     * @since Coherence 3.1
     */
    private int __m_DistributionAggressiveness;
    
    /**
     * Property DistributionNextMillis
     *
     * The DistributionNextMillis value is the time (in local system millis) at
     * which the next cache distribution analysis will be performed.
     * 
     * Initial value is Long.MAX_VALUE.
     * 
     * @volatile
     */
    private volatile transient long __m_DistributionNextMillis;
    
    /**
     * Property DistributionRepeatMillis
     *
     * The DistributionRepeatMillis value specifies how many milliseconds
     * between repeatedly performed task of cache distribution analysis and
     * operations.
     */
    private int __m_DistributionRepeatMillis;
    
    /**
     * Property DistributionStable
     *
     * Specifies whether or not the ownership has stabilized.
     */
    private boolean __m_DistributionStable;
    
    /**
     * Property DistributionStrategy
     *
     * CentralDistribution component.
     */
    private PartitionedService.CentralDistribution __m_DistributionStrategy;
    
    /**
     * Property DistributionSynchronized
     *
     * Specifies whether or not the re-distribution should be deferred until
     * all the configuration updates issued by the previous distribution
     * requests were confirmed by the service senior.
     * 
     * @since Coherence 3.2
     */
    private boolean __m_DistributionSynchronized;
    
    /**
     * Property Finalizing
     *
     * Set to true when the Service has been welcomed by other members of the
     * service but finalizing the startup must be deferred due to lack of
     * member or partition configuration.
     * 
     * @see onNotify()
     */
    private boolean __m_Finalizing;
    
    /**
     * Property KeyAssociator
     *
     * KeyAssociator implementation; never null.
     */
    private transient com.tangosol.net.partition.KeyAssociator __m_KeyAssociator;
    
    /**
     * Property KeyPartitioningStrategy
     *
     * KeyPartitioningStrategy implementation.
     */
    private transient com.tangosol.net.partition.KeyPartitioningStrategy __m_KeyPartitioningStrategy;
    
    /**
     * Property KeyToBinaryConverter
     *
     * The singleton converter used by this service to convert object keys to
     * binary form.
     */
    private PartitionedService.ConverterKeyToBinary __m_KeyToBinaryConverter;
    
    /**
     * Property MAX_PENDING_BACKUP_POLL
     *
     * Maximum in-flight backup requests for a partition beyond which backup
     * requests are sent sync even though PartitionedService is configured for
     * async backups. This provides some basic flow-control for the primary
     * server.
     */
    public static final int MAX_PENDING_BACKUP_POLL = 100;
    
    /**
     * Property MaxContendMillis
     *
     * Max wait time for a partition control lock.
     */
    private long __m_MaxContendMillis;
    
    /**
     * Property MaxLockAttempt
     *
     * The number of lock attempt for a partition control after which maximum
     * wait of MaxContendMillis is used to acquire the lock.
     */
    private int __m_MaxLockAttempt;
    
    /**
     * Property MsgCAE
     *
     * Coherence ApplicationEdition+ license support.
     * 
     * @see onEnter
     */
    private transient String __m_MsgCAE;
    
    /**
     * Property OWNERSHIP_DISABLED
     *
     * Indicates that a node is storage-disabled.
     */
    public static final int OWNERSHIP_DISABLED = 1;
    
    /**
     * Property OWNERSHIP_ENABLED
     *
     * Indicates that a node is storage-enabled.
     */
    public static final int OWNERSHIP_ENABLED = 4;
    
    /**
     * Property OWNERSHIP_PENDING
     *
     * Indicates that a storage-enabled node is joining.
     */
    public static final int OWNERSHIP_PENDING = 2;
    
    /**
     * Property OWNERSHIP_UNKNOWN
     *
     * Status is unknown.
     */
    public static final int OWNERSHIP_UNKNOWN = 0;
    
    /**
     * Property OwnershipEnabled
     *
     * Specifies whether or not the local ownership is enabled for this Member.
     */
    private boolean __m_OwnershipEnabled;
    
    /**
     * Property OwnershipInProgress
     *
     * Specifies how many times in a row this node (OwnershipSenior) had to
     * initiate the OwnershipRequest poll. A positive count indicates that
     * there is an active poll (sent but not yet answered). A negative count
     * indicates that currently there is no active poll, but the previous
     * attempts fail to reconcile the differences. Not more than one
     * OwnershipRequest poll could be active at any given time for the service.
     * 
     * 
     * Note: Only the service thread uses this property.
     */
    private transient int __m_OwnershipInProgress;
    
    /**
     * Property OwnershipVersion
     *
     * The current "ownership version" of each partition.
     */
    private int[] __m_OwnershipVersion;
    
    /**
     * Property PartitionAssignments
     *
     * An array indexed by partition number. Each value is an array indexed by
     * backup index (zero being the primary index) of member ids.
     * 
     * As of Coherence 3.1, modifications to the primary partition ownership
     * should be done while holding a synchronization monitor for this array.
     * The reason for this is that during preparation for bulk operations,
     * which happens on client threads, we need to spilt a collection of keys
     * across a number of members. If the primary membership changes at that
     * time, this split would be inconsistent.
     * 
     * @volatile: As of Coherence 3.2, (by Mark's suggestion) we never
     * synchronize. Instead, every time the assignments change, we replace the
     * assignments array with a new clone.
     * 
     * @see #assignPartitionOwner
     */
    private volatile int[][] __m_PartitionAssignments;
    
    /**
     * Property PartitionConfigMap
     *
     * The PartitionConfig$Map.
     */
    private PartitionedService.PartitionConfig.Map __m_PartitionConfigMap;
    
    /**
     * Property PartitionContention
     *
     * An array of $Contention objects indexed by the corresponding partition
     * number. Most of the time, all the entries are null. The $Contention
     * objects are instantiated only if one of the client side requests come
     * back with a response indicating an on-going distribution and client
     * threads need to wait for such a distribution to complete. Access to the
     * array elements is protected by the Common Monitors.
     */
    private transient PartitionedService.Contention[] __m_PartitionContention;
    
    /**
     * Property PartitionControl
     *
     * An array of PartitionControl objects indexed by partition number.
     */
    private transient PartitionedService.PartitionControl[] __m_PartitionControl;
    
    /**
     * Property PartitionCount
     *
     * Specifies the number of partitions that a distributed cache will be
     * "chopped up" into.
     */
    private int __m_PartitionCount;
    
    /**
     * Property PartitionEvents
     *
     * Map of events keyed by partition that caused partition unavailability.
     */
    private java.util.Map __m_PartitionEvents;
    
    /**
     * Property PartitionListeners
     *
     */
    private com.tangosol.util.Listeners __m_PartitionListeners;
    
    /**
     * Property PartitionTraceEvents
     *
     * Bitmask containing setting for partition events tracing and/or storing.
     */
    private int __m_PartitionTraceEvents;
    
    /**
     * Property PersistenceControl
     *
     * The PersistenceControl for this service, if a persistence-environment is
     * configured.
     */
    private PartitionedService.PersistenceControl __m_PersistenceControl;
    
    /**
     * Property PersistenceDependencies
     *
     * The PersistenceDependencies, or null.
     */
    private com.tangosol.internal.net.service.grid.PersistenceDependencies __m_PersistenceDependencies;
    
    /**
     * Property PreprocessingGate
     *
     * Gate governing if threads are actively preprocessing requets for this
     * service.
     */
    private transient com.tangosol.util.ThreadGate __m_PreprocessingGate;
    
    /**
     * Property RemainsOwnershipReport
     *
     * This property is only used during graceful shutdown to report partitions
     * that remain to be transferred.
     */
    private String __m_RemainsOwnershipReport;
    
    /**
     * Property RestoreInProgress
     *
     * Indicates whether or not the service is in the process of restoring from
     * backup. 
     * 
     * Note:  Both the service thread and worker threads use this property (see
     * PC.onSizeRequest()).
     */
    private transient boolean __m_RestoreInProgress;
    
    /**
     * Property ScratchSpaceCounter
     *
     * Some requests may need a significant amount of heap (scratch space) for
     * intermediate data structures. For example, aggregation requests
     * routinely create large number of entries to perform the calculations.
     * This counter is used to prevent the heap exhaustion caused by concurrent
     * execution of such requests.
     * 
     * In the beginning of the execution, a caller is supposed to call
     * reserveScratchSpace(), which "allocates" a portion of available space.
     * It is the responsibility of the caller to limit the heap usage according
     * to the returned value. At the end of the execution, the caller is
     * supposed to "return" the allocated space using the releaseScratchSpace()
     * method.
     * 
     * While this facility is in no way connected to the actual heap
     * statistics, it assumes that the initial capacity is always available and
     * basically simulates a shared memory allocation pool. 
     * 
     * Currently, this counter is initialized to 50MB.
     */
    private java.util.concurrent.atomic.AtomicLong __m_ScratchSpaceCounter;
    
    /**
     * Property TLORecoveryThread
     *
     * True if this thread is processing PartitionRecoverRequest, otherwise
     * null or false.
     */
    private ThreadLocal __m_TLORecoveryThread;
    
    /**
     * Property TransferControl
     *
     * The transfer control for this service.
     */
    private PartitionedService.TransferControl __m_TransferControl;
    
    /**
     * Property TransferThreshold
     *
     * Threshold for the primary partition distribution.
     * 
     * Default value is 0.5MB
     * 
     * @see #transferPrimary()
     */
    private int __m_TransferThreshold;
    private static com.tangosol.util.ListMap __mapChildren;
    
    /**
     * The interval (in milliseconds) between scheduling two maintenance tasks.
     */
    protected static final int MAINTENANCE_INTERVAL = 120000;

    // Static initializer
    static
        {
        __initStatic();
        }
    
    // Default static initializer
    private static void __initStatic()
        {
        // register child classes
        __mapChildren = new com.tangosol.util.ListMap();
        __mapChildren.put("Acknowledgement", com.tangosol.coherence.component.util.daemon.queueProcessor.service.Grid.Acknowledgement.get_CLASS());
        __mapChildren.put("BackupAssignment", PartitionedService.BackupAssignment.get_CLASS());
        __mapChildren.put("BackupConfirmRequest", PartitionedService.BackupConfirmRequest.get_CLASS());
        __mapChildren.put("BusEventMessage", com.tangosol.coherence.component.util.daemon.queueProcessor.service.Grid.BusEventMessage.get_CLASS());
        __mapChildren.put("CentralDistribution", PartitionedService.CentralDistribution.get_CLASS());
        __mapChildren.put("ConfigRequest", com.tangosol.coherence.component.util.daemon.queueProcessor.service.Grid.ConfigRequest.get_CLASS());
        __mapChildren.put("ConfigResponse", com.tangosol.coherence.component.util.daemon.queueProcessor.service.Grid.ConfigResponse.get_CLASS());
        __mapChildren.put("ConfigSync", com.tangosol.coherence.component.util.daemon.queueProcessor.service.Grid.ConfigSync.get_CLASS());
        __mapChildren.put("ConfigUpdate", com.tangosol.coherence.component.util.daemon.queueProcessor.service.Grid.ConfigUpdate.get_CLASS());
        __mapChildren.put("Contention", PartitionedService.Contention.get_CLASS());
        __mapChildren.put("ConverterKeyToBinary", PartitionedService.ConverterKeyToBinary.get_CLASS());
        __mapChildren.put("DispatchEvent", PartitionedService.DispatchEvent.get_CLASS());
        __mapChildren.put("DispatchNotification", com.tangosol.coherence.component.util.daemon.queueProcessor.service.Grid.DispatchNotification.get_CLASS());
        __mapChildren.put("DistributionPlanUpdate", PartitionedService.DistributionPlanUpdate.get_CLASS());
        __mapChildren.put("DistributionRequest", PartitionedService.DistributionRequest.get_CLASS());
        __mapChildren.put("MemberConfigUpdate", PartitionedService.MemberConfigUpdate.get_CLASS());
        __mapChildren.put("MemberJoined", com.tangosol.coherence.component.util.daemon.queueProcessor.service.Grid.MemberJoined.get_CLASS());
        __mapChildren.put("MemberRecovered", com.tangosol.coherence.component.util.daemon.queueProcessor.service.Grid.MemberRecovered.get_CLASS());
        __mapChildren.put("MemberWelcome", PartitionedService.MemberWelcome.get_CLASS());
        __mapChildren.put("MemberWelcomeRequest", PartitionedService.MemberWelcomeRequest.get_CLASS());
        __mapChildren.put("MemberWelcomeRequestTask", com.tangosol.coherence.component.util.daemon.queueProcessor.service.Grid.MemberWelcomeRequestTask.get_CLASS());
        __mapChildren.put("NotifyConnectionClose", com.tangosol.coherence.component.util.daemon.queueProcessor.service.Grid.NotifyConnectionClose.get_CLASS());
        __mapChildren.put("NotifyConnectionOpen", com.tangosol.coherence.component.util.daemon.queueProcessor.service.Grid.NotifyConnectionOpen.get_CLASS());
        __mapChildren.put("NotifyMemberJoined", com.tangosol.coherence.component.util.daemon.queueProcessor.service.Grid.NotifyMemberJoined.get_CLASS());
        __mapChildren.put("NotifyMemberLeaving", com.tangosol.coherence.component.util.daemon.queueProcessor.service.Grid.NotifyMemberLeaving.get_CLASS());
        __mapChildren.put("NotifyMemberLeft", com.tangosol.coherence.component.util.daemon.queueProcessor.service.Grid.NotifyMemberLeft.get_CLASS());
        __mapChildren.put("NotifyMessageReceipt", com.tangosol.coherence.component.util.daemon.queueProcessor.service.Grid.NotifyMessageReceipt.get_CLASS());
        __mapChildren.put("NotifyPollClosed", com.tangosol.coherence.component.util.daemon.queueProcessor.service.Grid.NotifyPollClosed.get_CLASS());
        __mapChildren.put("NotifyResponse", com.tangosol.coherence.component.util.daemon.queueProcessor.service.Grid.NotifyResponse.get_CLASS());
        __mapChildren.put("NotifyServiceAnnounced", com.tangosol.coherence.component.util.daemon.queueProcessor.service.Grid.NotifyServiceAnnounced.get_CLASS());
        __mapChildren.put("NotifyServiceJoining", com.tangosol.coherence.component.util.daemon.queueProcessor.service.Grid.NotifyServiceJoining.get_CLASS());
        __mapChildren.put("NotifyServiceLeaving", PartitionedService.NotifyServiceLeaving.get_CLASS());
        __mapChildren.put("NotifyServiceLeft", com.tangosol.coherence.component.util.daemon.queueProcessor.service.Grid.NotifyServiceLeft.get_CLASS());
        __mapChildren.put("NotifyServiceQuiescence", PartitionedService.NotifyServiceQuiescence.get_CLASS());
        __mapChildren.put("NotifyShutdown", PartitionedService.NotifyShutdown.get_CLASS());
        __mapChildren.put("NotifySnapshotRecoverRequest", PartitionedService.NotifySnapshotRecoverRequest.get_CLASS());
        __mapChildren.put("NotifyStartup", com.tangosol.coherence.component.util.daemon.queueProcessor.service.Grid.NotifyStartup.get_CLASS());
        __mapChildren.put("OwnershipRequest", PartitionedService.OwnershipRequest.get_CLASS());
        __mapChildren.put("OwnershipResponse", PartitionedService.OwnershipResponse.get_CLASS());
        __mapChildren.put("PartitionAbandonRequest", PartitionedService.PartitionAbandonRequest.get_CLASS());
        __mapChildren.put("PartitionControl", PartitionedService.PartitionControl.get_CLASS());
        __mapChildren.put("PartitionFilter", PartitionedService.PartitionFilter.get_CLASS());
        __mapChildren.put("PartitionRecoverCleanup", PartitionedService.PartitionRecoverCleanup.get_CLASS());
        __mapChildren.put("PartitionRecoverRequest", PartitionedService.PartitionRecoverRequest.get_CLASS());
        __mapChildren.put("PartitionStatsUpdate", PartitionedService.PartitionStatsUpdate.get_CLASS());
        __mapChildren.put("PartitionSwapRequest", PartitionedService.PartitionSwapRequest.get_CLASS());
        __mapChildren.put("PartitionVersionSyncRequest", PartitionedService.PartitionVersionSyncRequest.get_CLASS());
        __mapChildren.put("PersistenceControl", PartitionedService.PersistenceControl.get_CLASS());
        __mapChildren.put("PingRequest", com.tangosol.coherence.component.util.daemon.queueProcessor.service.Grid.PingRequest.get_CLASS());
        __mapChildren.put("PinningIterator", PartitionedService.PinningIterator.get_CLASS());
        __mapChildren.put("ProtocolContext", com.tangosol.coherence.component.util.daemon.queueProcessor.service.Grid.ProtocolContext.get_CLASS());
        __mapChildren.put("Response", com.tangosol.coherence.component.util.daemon.queueProcessor.service.Grid.Response.get_CLASS());
        __mapChildren.put("SnapshotArchiveRequest", PartitionedService.SnapshotArchiveRequest.get_CLASS());
        __mapChildren.put("SnapshotListRequest", PartitionedService.SnapshotListRequest.get_CLASS());
        __mapChildren.put("SnapshotRequest", PartitionedService.SnapshotRequest.get_CLASS());
        __mapChildren.put("TransferRequest", PartitionedService.TransferRequest.get_CLASS());
        __mapChildren.put("TransferResponse", PartitionedService.TransferResponse.get_CLASS());
        __mapChildren.put("WrapperGuardable", com.tangosol.coherence.component.util.daemon.queueProcessor.service.Grid.WrapperGuardable.get_CLASS());
        }
    
    // Initializing constructor
    public PartitionedService(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
        {
        super(sName, compParent, false);
        }
    
    // Private initializer
    protected void __initPrivate()
        {
        
        super.__initPrivate();
        
        // state initialization: private properties
        try
            {
            __m_PreprocessingGate = new com.tangosol.util.ThreadGate();
            }
        catch (java.lang.Exception e)
            {
            // re-throw as a runtime exception
            throw new com.tangosol.util.WrapperException(e);
            }
        }
    
    //++ getter for static property _CLASS
    /**
     * Getter for property _CLASS.<p>
    * Property with auto-generated accessor that returns the Class object for a
    * given component.
     */
    public static Class get_CLASS()
        {
        Class clz;
        try
            {
            clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/PartitionedService".replace('/', '.'));
            }
        catch (ClassNotFoundException e)
            {
            throw new NoClassDefFoundError(e.getMessage());
            }
        return clz;
        }
    
    //++ getter for autogen property _Module
    /**
     * This is an auto-generated method that returns the global [design time]
    * parent component.
    * 
    * Note: the class generator will ignore any custom implementation for this
    * behavior.
     */
    private com.tangosol.coherence.Component get_Module()
        {
        return this;
        }
    
    //++ getter for autogen property _ChildClasses
    /**
     * This is an auto-generated method that returns the map of design time
    * [static] children.
    * 
    * Note: the class generator will ignore any custom implementation for this
    * behavior.
     */
    protected java.util.Map get_ChildClasses()
        {
        return __mapChildren;
        }
    
    /**
     * Abandon the provided partitions.
     */
    protected void abandonPartitions(com.tangosol.net.partition.PartitionSet parts)
        {
        // import com.tangosol.net.partition.VersionedOwnership;
        // import com.tangosol.util.LiteMap;
        // import java.util.Map;
        
        int cBackups    = getBackupCount();
        int nMemberThis = getThisMember().getId();
        Map mapUpdate   = new LiteMap();
        
        _trace("Abandoning the ownership of partitions " + parts, 3);
        
        for (int iPart = parts.next(0); iPart >= 0; iPart = parts.next(iPart + 1))
            {
            int iStore = getOwnedIndex(iPart, nMemberThis);
            if (iStore >= 0)
                {
                if (iStore == 0)
                    {
                    PartitionedService.PartitionControl ctrlPart = getPartitionControl(iPart);
        
                    // service should be quiesced, so we should get the lock immediately
                    // if not, let guardian interrupt
                    ctrlPart.lock(-1L, PartitionedService.PartitionControl.LOCK_PRIMARY_XFER_OUT);
                    try
                        {
                        // set the transfer state flag so the remove's from the
                        // backing-map do not appear to be unsolicited OOB events
                        ctrlPart.setTransferState(PartitionedService.PartitionControl.XFER_SENT);
        
                        // update the local assignments
                        assignPartitionOwner(iPart, iStore, 0);
        
                        // release the transient and persistent storage
                        releasePartition(iPart, iStore);
                        }
                    finally
                        {
                        ctrlPart.setTransferState(PartitionedService.PartitionControl.XFER_NONE);
                        ctrlPart.unlock();
        
                        mapUpdate.put(Integer.valueOf(iPart),
                            new VersionedOwnership(cBackups, incrementOwnershipVersion(iPart)));
                        }
                    }
                else
                    {
                    // update the local assignments
                    assignPartitionOwner(iPart, iStore, 0);
        
                    // release the transient and persistent storage
                    releasePartition(iPart, iStore);
                    }
        
                releasePartitionControl(iPart);
                }
            else
                {
                // shouldn't happen
                _trace("Ignoring PartitionAbandonRequest for un-owned partition " + iPart, 2);
                }
            }
        
        // remove the abandoned partitions from previous distribution suggestion
        // that are still in pending changeset 
        getDistributionStrategy().clearAdvice(parts);
        
        if (mapUpdate != null && !mapUpdate.isEmpty())
            {
            // publish the orphaned config to everybody else
            putPartitionConfig(mapUpdate);
            }
        }
    
    // From interface: com.tangosol.net.PartitionedService
    public void addPartitionListener(com.tangosol.net.partition.PartitionListener listener)
        {
        getPartitionListeners().add(listener);
        }
    
    /**
     * Assign the specified orphaned partition to this member. This can only be
    * called on a service thread.
     */
    protected void assignOrphan(int iPartition)
        {
        // import com.oracle.coherence.persistence.PersistentStore as com.oracle.coherence.persistence.PersistentStore;
        // import com.tangosol.persistence.CachePersistenceHelper as com.tangosol.persistence.CachePersistenceHelper;
        
        PartitionedService.PartitionControl ctrl = ensurePartitionControl(iPartition);
        
        if (isActivePersistence())
            {
            com.oracle.coherence.persistence.PersistentStore store = ctrl.ensurePersistentStore();
        
            saveQuorum(iPartition);
        
            // no contents to write; seal the store immediately if it has been opened
            if (!isExiting() && getServiceState() != SERVICE_STOPPING)
                {
                // seal the events store first
                com.oracle.coherence.persistence.PersistentStore storeEvents = ctrl.getPersistentEventsStore();
                if (storeEvents != null)
                    {
                    com.tangosol.persistence.CachePersistenceHelper.seal(storeEvents, this, /*oToken*/ null);
                    }
        
                com.tangosol.persistence.CachePersistenceHelper.seal(ctrl.ensurePersistentStore(), this, /*oToken*/ null);
                }
            }
        
        handlePartitionTrace(iPartition,
            PartitionedService.PartitionControl.getPartitionEventDescription(PartitionedService.PartitionControl.PARTITION_EVENT_ASSIGNED));
        }
    
    /**
     * Assign all the orphaned partitions to this member. This can only be
    * called on a service thread.
    * 
    * @param msgResponse (optional) message to send when the partition are
    * assigned and all corresponding events dispatched
     */
    public void assignOrphans(com.tangosol.net.partition.PartitionSet parts, com.tangosol.coherence.component.net.Message msgResponse)
        {
        // import com.tangosol.net.partition.Ownership;
        // import com.tangosol.net.partition.PartitionEvent;
        // import com.tangosol.net.partition.PartitionSet;
        // import com.tangosol.util.LiteMap;
        // import java.util.Map;
        
        int[][]      aaiOwner      = getPartitionAssignments();
        int          cPartitions   = aaiOwner.length;
        Map          mapUpdate     = new LiteMap();
        PartitionSet partsAssigned = null;
        PartitionSet partsLost     = null;
        boolean      fActive       = isActivePersistence();
        
        PartitionedService.PartitionConfig.Map mapConfig = getPartitionConfigMap();
        for (int iPartition = parts.next(0), c = 0; iPartition >= 0 &&
                !isExiting() && getServiceState() != SERVICE_STOPPING;
                 iPartition = parts.next(iPartition + 1))
            {
            int nOwner = aaiOwner[iPartition][0];
            if (nOwner == 0)
                {
                Ownership owners = assignPrimaryPartition(iPartition, 'r');
                mapUpdate.put(Integer.valueOf(iPartition), owners);
        
                assignOrphan(iPartition);
        
                if (fActive && ((c++ & 0xF) == 0xF))
                    {
                    // persistence is more expensive during the assign
                    // thus make sure we notify the guardian
                    heartbeat();
                    }
        
                if (mapConfig.isAssignmentCompleted(iPartition))
                    {
                    if (partsLost == null)
                        {
                        partsLost = new PartitionSet(cPartitions);
                        }
                    partsLost.add(iPartition);
                    }
                else
                    {
                    if (partsAssigned == null)
                        {
                        partsAssigned = new PartitionSet(cPartitions);
                        }
                    partsAssigned.add(iPartition);
                    }
                }
            else
                {
                // should not happen; soft assert
                _trace("Unable to assign orphaned partition " + iPartition
                     + "; current owner is member " + nOwner, 2);
                }
            }
        
        if (partsLost != null)
            {   
            _trace("Assigned " + partsLost.cardinality() + " orphaned primary partitions: " + partsLost, 2);
        
            firePartitionEvent(PartitionEvent.PARTITION_LOST, partsLost, null, getThisMember());
            }
        
        if (partsAssigned != null)
            {
            firePartitionEvent(PartitionEvent.PARTITION_ASSIGNED, partsAssigned, null, getThisMember());
            }
        
        onPartitionsAssigned(partsAssigned, partsLost,
            getContinuations().instantiateFinalizeAssignPrimaries(mapUpdate, msgResponse));
        }
    
    /**
     * Assign a given partition at a given store to a given member and return
    * the resulting PartitionAssignments
     */
    protected int[][] assignPartitionOwner(int iPartition, int iStore, int nMember)
        {
        // see comments to the PartitionAssignments property
        int[][] aaiOwner = getPartitionAssignments();
        int[]   aiOwner  = aaiOwner[iPartition];
        
        if (iStore == 0)
            {
            aaiOwner = (int[][]) aaiOwner.clone();
            aiOwner  = (int[])   aiOwner.clone();
            aaiOwner[iPartition] = aiOwner;
            }
        aiOwner[iStore] = nMember;
        setPartitionAssignments(aaiOwner);
        
        return aaiOwner;
        }
    
    /**
     * Assign a given partition to the given owners.
     */
    protected void assignPartitionOwners(int iPartition, int[] aiOwnerThat)
        {
        // import Component.Net.MemberSet.ActualMemberSet.ServiceMemberSet;
        
        // see comments to the PartitionAssignments property
        int[][] aaiOwner    = getPartitionAssignments();
        int[]   aiOwnerThis = aaiOwner[iPartition];
        
        ServiceMemberSet setService = getServiceMemberSet();
        
        // we can not blindly accept aiOwnerThat as we may have a more accurate
        // view than the sender due to this member having processed the departure
        // of a member in aiOwnerThat
        for (int i = 0, c = aiOwnerThis.length; i < c; ++i)
            {
            int nOwnerThat = aiOwnerThat[i];
            if (aiOwnerThis[i] != nOwnerThat)
                {
                if (i == 0)
                    {
                    aaiOwner = (int[][]) aaiOwner.clone();
                    }
        
                if (!setService.contains(nOwnerThat))
                    {
                    aiOwnerThat[i] = 0;
                    }
                }
            }
        
        aaiOwner[iPartition] = aiOwnerThat;
        
        setPartitionAssignments(aaiOwner);
        }
    
    /**
     * Assign the specified primary partition for this member. This can only be
    * called on a service thread.
    * 
    * @param iPartition  the partition being assigned to this member
    * @param chBackupOp  a code for the backup operation; 'm' - move partition
    * to primary, 'r' - release partition from backup
    * 
    * @return an Ownership object with a new partition configuration
    * 
    * Note: the reason we don't update the service config right here is that
    * there could be other operations necessary prior to that
     */
    protected com.tangosol.net.partition.VersionedOwnership assignPrimaryPartition(int iPartition, char chBackupOp)
        {
        // import Component.Net.Member;
        // import Component.Net.MemberSet.ActualMemberSet.ServiceMemberSet as com.tangosol.coherence.component.net.memberSet.actualMemberSet.ServiceMemberSet;
        // import com.tangosol.net.partition.VersionedOwnership;
        
        Member  memberThis   = getThisMember();
        int     nMemberThis  = memberThis.getId();
        int     nMachineThis = memberThis.getMachineId();
        int[][] aaiOwner     = getPartitionAssignments();
        
        // reassign the backups
        int cBackups = getBackupCount();
        if (cBackups > 0)
            {
            int[]     aiOwner     = aaiOwner[iPartition];
            com.tangosol.coherence.component.net.memberSet.actualMemberSet.ServiceMemberSet setMember   = getServiceMemberSet();
            int       nPrimeOwner = aiOwner[0]; // current owner
        
            if (nPrimeOwner == nMemberThis ||
                !setMember.contains(nPrimeOwner) || setMember.isServiceLeaving(nPrimeOwner))
                {
                nPrimeOwner = 0;
                }
        
            // check whether this member currently serves as a backup for this partition
            // and assume the "swap" between the current owner and this member;
            // if there is an unowned backup, assume it being taken by the current owner
            int iBackupSwap = 0;
            for (int iBackup = 1; iBackup <= cBackups; iBackup++)
                {
                int nBackupOwner = aiOwner[iBackup];
                if (nBackupOwner == nMemberThis)
                    {
                    if (chBackupOp == 'm')
                        {
                        // as of Coherence 12.2.1.1 the actual "move" is performed by the caller
                        // (see restoreOrphans) after the ownership version is incremented
                        }
                    else // chOp == 'r'
                        {
                        // release from backup
                        releasePartition(iPartition, iBackup);
                        }
                    iBackupSwap = iBackup;
                    }
                else if (iBackupSwap == 0 && !setMember.contains(nBackupOwner))
                    {
                    // the backup is not owned
                    iBackupSwap = iBackup;
                    }
                }
        
            if (iBackupSwap > 0)
                {
                // Note: clone the assignments array here even for changes to
                //       the backup ownership (even though it is not strictly
                //       necessary) in order to allow callers to determine the
                //       "old" ownership
                aiOwner = (int[]) aiOwner.clone();
                aiOwner[iBackupSwap] = nPrimeOwner;
                aaiOwner[iPartition] = aiOwner;
                }
            }
        
        // the partition could be already "prepared" during movePartition() call
        preparePartition(iPartition, /*iBackup*/0);
        
        // assign the primary owner (this replaces the assignments array)
        int nVersionNew = incrementOwnershipVersion(iPartition);
        aaiOwner = assignPartitionOwner(iPartition, 0, nMemberThis);
        
        // construct the new (global) ownership from the updated local assignments
        VersionedOwnership owners = new VersionedOwnership(cBackups, nVersionNew);
        owners.setOwners(aaiOwner[iPartition]);  // the updated assignments
        
        return owners;
        }
    
    /**
     * Calculate the total number of endangered partitions. Used by the JMX.
     */
    public int calculateEndangered()
        {
        int[][] aaiOwner    = getPartitionAssignments();
        int     cPartitions = aaiOwner.length;
        int     cBackups    = getBackupCount();
        
        if (cBackups == 0)
            {
            // without a backup all partitions are endangered
            return cPartitions;
            }
        
        int cEndangered = 0;
        
        for (int iPartition = 0; iPartition < cPartitions; iPartition++)
            {
            int[] aiOwner = aaiOwner[iPartition];
            for (int iBackup = 1; iBackup <= cBackups; iBackup++)
                {
                if (aiOwner[iBackup] == 0)
                    {
                    cEndangered++;
                    break;
                    }
                }
            }
        
        return cEndangered;
        }
    
    /**
     * Calculate a total number of members that have any endangered partitions.
     */
    public int calculateEndangeredMembers()
        {
        // import java.util.HashSet;
        
        int[][] aaiOwner    = getPartitionAssignments();
        int     cPartitions = aaiOwner.length;
        int     cBackups    = getBackupCount();
        HashSet setId       = new HashSet();
        
        for (int iPartition = 0; iPartition < cPartitions; iPartition++)
            {
            int[] aiOwner = aaiOwner[iPartition];
            for (int iBackup = 1; iBackup <= cBackups; iBackup++)
                {
                if (aiOwner[iBackup] == 0)
                    {
                    setId.add(Integer.valueOf(aiOwner[0]));
                    }
                }
            }
        
        return setId.size();
        }
    
    /**
     * Calculate the partition ownership distribution for the specified
    * MemberSet.
    * 
    * @param setOwners  the set of ownership-enabled service members
    * @param fPrimary      if true, calculate the primary ownership; otherwise
    * the backup ownership
    * 
    * @return an array of partition counts indexed by owner's member id
     */
    public int[] calculateOwnership(com.tangosol.coherence.component.net.MemberSet setOwners, boolean fPrimary)
        {
        // import Component.Net.Member;
        // import java.util.Iterator;
        // import java.util.Set;
        
        if (setOwners == null)
            {
            setOwners = getOwnershipMemberSet();
            }
        
        int[][] aaiOwner     = getPartitionAssignments();
        int     cPartitions  = aaiOwner.length;
        int     nMaxMember   = setOwners.getLastId();
        int[]   acPartitions = new int[nMaxMember + 1];
        
        if (fPrimary)
            {
            for (int iPartition = 0; iPartition < cPartitions; iPartition++)
                {
                int nMemberOwner = aaiOwner[iPartition][0];
                if (nMemberOwner <= nMaxMember)
                    {
                    acPartitions[nMemberOwner]++;
                    }
                }
            }
        else
            {
            int cBackups = getBackupCount();
            for (int iPartition = 0; iPartition < cPartitions; iPartition++)
                {
                int[] aiOwner = aaiOwner[iPartition];
                for (int iBackup = 1; iBackup <= cBackups; iBackup++)
                    {
                    int nMemberOwner = aiOwner[iBackup];
                    if (nMemberOwner <= nMaxMember)
                        {
                        acPartitions[nMemberOwner]++;
                        }
                    }
                }
            }
        
        return acPartitions;
        }
    
    /**
     * Calculate the PartitionSet of conflicting partitions.
     */
    public void calculateOwnershipConflicts(int nMemberThat, int[][] aaiOwnerThat, int cAttempts)
        {
        // import Component.Net.MemberSet;
        // import com.tangosol.net.partition.Ownership;
        // import com.tangosol.net.partition.PartitionSet;
        // import java.util.HashMap;
        // import java.util.Iterator;
        // import java.util.Map;
        // import java.util.Map$Entry as java.util.Map.Entry;
        
        int     nMemberThis  = getThisMember().getId();
        int[][] aaiOwnerThis = getPartitionAssignments();
        int     cBackups     = getBackupCount();
        String  sSubstToken  = "{partitions}"; // logging
        Map     mapLogMsgs   = null;           // logging
        
        for (int iPartition = 0, cPartitions = aaiOwnerThis.length;
             iPartition < cPartitions; iPartition++)
            {
            int[] aiOwnerThis = aaiOwnerThis[iPartition];
            int[] aiOwnerThat = aaiOwnerThat[iPartition];
        
            for (int iStore = 0; iStore <= cBackups; iStore++)
                {
                int nOwnerThis = aiOwnerThis[iStore];
                int nOwnerThat = aiOwnerThat[iStore];
        
                if (nOwnerThis != nOwnerThat)
                    {
                    String sLogTemplate = null; // logging
        
                    if (iStore == 0 &&
                        (nOwnerThat == nMemberThis && nOwnerThis == 0 ||
                         nOwnerThis == nMemberThis && nOwnerThat == 0))
                        {
                        // the requestor thinks we own it but we think it's orphaned, or
                        // we own it, but the requestor thinks it's orphaned
                        sLogTemplate = "Re-publishing the ownership for " +
                            sSubstToken + " [" + nOwnerThis + ']';
        
                        // republish the ownership
                        publishPartitionOwnership(iPartition, iStore, nOwnerThis);
                        }
        
                    if (cAttempts > PartitionedService.OwnershipRequest.REQUEST_COUNT_THRESHOLD)
                        {
                        int nOwnerGlobal = getPartitionConfig(iPartition).getOwner(iStore);
        
                        // record this partition conflict for logging
                        sLogTemplate = cAttempts + "> Ownership conflict for " + sSubstToken
                             + (iStore == 0 ? "(primary)" : "(backup[" + iStore + "])")
                             + " with member " + nMemberThat
                             + " (" + nOwnerThis + "!=" + nOwnerThat
                             + (nOwnerGlobal == nOwnerThis ? "" : "; global=" + nOwnerGlobal)
                             + ')';
        
                        // arbitrary tie-break logic to prevent endless ownership-conflict
                        if ((nOwnerThis == nMemberThis || nOwnerThat == nMemberThis) &&
                            nOwnerThat > 0)
                            {
                            // we think that we own the partition in question, but the
                            // senior thinks that somebody else owns it.  Enough
                            // iterations of the Ownership protocol have taken place
                            // without a peaceful resolution; must force a tie-breaker.
                            // Give preference to the (prospective) owner with the lower
                            // member number.
        
                            if (nMemberThis == Math.min(nOwnerThis, nOwnerThat))
                                {
                                // to settle the conflict, let the member with the lower
                                // member ID impose its view
                                publishPartitionOwnership(iPartition, iStore, nOwnerThis);
                                }
                            else
                                {
                                // the member with the higher ID concedes to the member
                                // member with the lower ID that claims ownership.
                                // 
                                // Note: we know that the other member has claimed
                                // ownership because otherwise it would have
                                // re-published the partition as orphaned (see earlier
                                // block) in a previous iteration of the Ownership
                                // protocol.
                                //
                                // Note: we assign and publish the partition as orphaned
                                // and rely on a subsequent iteration and re-publishing
                                // by the owner (with lower ID) to settle the ownership.
                                _trace("Unreconcilable ownership conflict; " +
                                       "conceding the ownership.", 1);
                                assignPartitionOwner(iPartition, iStore, 0);
                                if (nOwnerThis == nMemberThis)
                                    {
                                    // release local data strucutres iff we are still in the
                                    // local assignments
                                    releasePartition(iPartition, iStore);
                                    releasePartitionControl(iPartition);
                                    }
                                publishPartitionOwnership(iPartition, iStore, 0);
                                }
                            }
                        else if (iStore == 0 &&
                                 nMemberThis != getOwnershipSenior().getId())
                            {
                            // this node is not the senior, and its view differs
                            // from the senior for a large number of iterations;
                            // declare the partition orphaned to force the real owner
                            // to re-publish and correct the picture
                            _trace("Multi-way ownership conflict; " +
                                   "requesting a republish of the ownership", 1);
                            assignPartitionOwner(iPartition, 0, 0);
                            publishPartitionOwnership(iPartition, 0, 0);
                            }
                        }
        
                    // note the partition in conflict for later logging
                    if (sLogTemplate != null)
                        {
                        if (mapLogMsgs == null)
                            {
                            mapLogMsgs = new HashMap();
                            }
                        PartitionSet parts = (PartitionSet) mapLogMsgs.get(sLogTemplate);
                        if (parts == null)
                            {
                            parts = new PartitionSet(cPartitions);
                            mapLogMsgs.put(sLogTemplate, parts);
                            }
                        parts.add(iPartition);
                        }
                    }
                }
            }
        
        // log partition conflict messages
        if (mapLogMsgs != null)
            {
            for (Iterator iter = mapLogMsgs.entrySet().iterator(); iter.hasNext(); )
                {
                java.util.Map.Entry  entry        = (java.util.Map.Entry) iter.next();
                String sLogTemplate = (String) entry.getKey();
                int    ofStart      = sLogTemplate.indexOf(sSubstToken);
                int    ofEnd        = ofStart + sSubstToken.length();
        
                _trace(sLogTemplate.substring(0, ofStart) + entry.getValue() +
                       sLogTemplate.substring(ofEnd, sLogTemplate.length()), 2);
                }
            }
        }
    
    /**
     * Calculate the PartitionSet of all partitions owned by the specified
    * Member.
    * 
    * @param member  a ownership-enabled Member
    * @param iStore      the specified store index (zero for primary ownership)
    * 
    * @return PartitionSet containing owned partitions
     */
    public com.tangosol.net.partition.PartitionSet calculatePartitionSet(com.tangosol.net.Member member, int iStore)
        {
        return calculatePartitionSet(member, iStore,/*fCheckLocked*/ false);
        }
    
    /**
     * Calculate the PartitionSet of all partitions owned by the specified
    * Member. 
    * 
    * @param member             a ownership-enabled Member
    * @param iStore                  the specified store index (zero for
    * primary ownership)
    * @param fCheckLocked   true iff locked partitions should be checked
    * 
    * @return PartitionSet containing owned partitions
     */
    public com.tangosol.net.partition.PartitionSet calculatePartitionSet(com.tangosol.net.Member member, int iStore, boolean fCheckLocked)
        {
        // import com.tangosol.net.partition.PartitionSet;
        
        _assert(iStore <= getBackupCount());
        
        int[][] aaiOwner    = getPartitionAssignments();
        int     cPartitions = aaiOwner.length;
        int     nMember     = member == null ? 0 : member.getId();
        
        PartitionSet partitions = new PartitionSet(cPartitions);
        for (int iPartition = 0; iPartition < cPartitions; iPartition++)
            {
            if (aaiOwner[iPartition][iStore] == nMember &&
                (!fCheckLocked || !getPartitionControl(iPartition).isLocked()))
                {
                partitions.add(iPartition);
                }
            }
        return partitions;
        }
    
    /**
     * Calculate the PartitionSet that contains all partitions for the specified
    * key set.
    * 
    * @return PartitionSet containing all relevant partitions
     */
    public com.tangosol.net.partition.PartitionSet calculatePartitionSet(java.util.Set setKeys)
        {
        // import com.tangosol.net.partition.PartitionSet;
        // import com.tangosol.util.Binary;
        // import java.util.Iterator;
        
        PartitionSet partitions = new PartitionSet(getPartitionCount());
        
        for (Iterator iter = setKeys.iterator(); iter.hasNext();)
            {
            partitions.add(getKeyPartition((Binary) iter.next()));
            }
        
        return partitions;
        }
    
    /**
     * Calculate how many partitions this member owns.
    * 
    * @param fPrimary if true, calculate the primary ownership; otherwise the
    * backup ownership
    * 
    * @return the number of partitions owned by this member
     */
    public int calculateThisOwnership(boolean fPrimary)
        {
        int     nMemberThis      = getThisMember().getId();
        int[][] aaiOwner         = getPartitionAssignments();
        int     cPartitionsTotal = aaiOwner.length;
        int     cPartitionsThis  = 0;
        
        if (fPrimary)
            {
            for (int iPartition = 0; iPartition < cPartitionsTotal; iPartition++)
                {
                if (aaiOwner[iPartition][0] == nMemberThis)
                    {
                    cPartitionsThis++;
                    }
                }
            }
        else
            {
            int cBackups = getBackupCount();
            for (int iPartition = 0; iPartition < cPartitionsTotal; iPartition++)
                {
                int[] aiOwner = aaiOwner[iPartition];
                for (int iBackup = 1; iBackup <= cBackups; iBackup++)
                    {
                    if (aiOwner[iBackup] == nMemberThis)
                        {
                        cPartitionsThis++;
                        }
                    }
                }
            }
        
        return cPartitionsThis;
        }
    
    /**
     * Calculate the total number of unbalanced partitions. Used by the JMX and
    * tests.
     */
    public int calculateUnbalanced()
        {
        // import Component.Net.Member;
        // import Component.Net.MemberSet;
        // import com.tangosol.net.partition.Ownership;
        
        // this code was moved from the ServiceModel without any modifications
        // to preserve the existing algorithm
        
        int cBuckets = getPartitionCount();
        int cBackups = getBackupCount();
        
        int cMembers = getOwnershipMemberSet().size();
        if (cMembers == 0)
            {
            // all orphans
            return cBuckets * (cBackups + 1);
            }
        
        // primary
        int[] acBucket = calculateOwnership(null, true);
        
        // count all orphans as unbalanced
        int cUnbalanced = acBucket[0];
        
        if (cMembers == 1)
            {
            return cUnbalanced;
            }
        
        if (cMembers == 2)
            {
            // consider the "trivial" SE-One style distribution as balanced
            Ownership owners     = getPartitionConfig(0);
            MemberSet setMembers = getServiceMemberSet();
        
            Member memberPrime = setMembers.getMember(owners.getPrimaryOwner());
            if (memberPrime != null && calculatePartitionSet(memberPrime, 0).isFull())
                {
                if (cBackups == 0)
                    {
                    return 0; // SE-One distribution for backup-count of zero
                    }
                Member memberBackup = setMembers.getMember(owners.getOwner(1));
                if (memberBackup != null && calculatePartitionSet(memberBackup, 1).isFull())
                    {
                    return 0; // SE-One distribution for backup-count of one
                    }
                }
            }
        
        int cFairShare = Math.min(cBuckets/cMembers + 1, cBuckets);
        
        // count total number of partitions which reside on overloaded members
        for (int i = 1, c = acBucket.length; i < c; ++i)
            {
            cUnbalanced += Math.max(0, acBucket[i] - cFairShare);
            }
        
        // backup(s)
        cBuckets *= cBackups;
        if (cBuckets > 0)
            {
            cFairShare = Math.min(cBuckets/cMembers + 1, cBuckets);
            acBucket   = calculateOwnership(null, false);
        
            // count all endangered as unbalanced
            cUnbalanced += acBucket[0];
        
            // temporary fix for COH-12424, a complete fix will follow.
            // Consider as balanced if backupCount >= 2 and member overload is less than 10%
            boolean fForgive = cBackups > 1;
            for (int i = 1, c = acBucket.length; i < c; ++i)
                {
                int cOverload = Math.max(0, acBucket[i] - cFairShare);
                cUnbalanced += fForgive && (cOverload < cFairShare * 0.1) ? 0 : cOverload;
                }
            }
        
        return Math.min(cUnbalanced, cBuckets);
        }
    
    /**
     * Calculate the number of vulnerable partitions at all (not just owned by
    * this member).
     */
    public int calculateVulnerable()
        {
        return calculateVulnerable(true);
        }
    
    /**
     * Calculate the number of vulnerable partitions at all (not just owned by
    * this member).
     */
    public int calculateVulnerable(boolean fStrict)
        {
        int cPartitions = getPartitionCount();
        if (getBackupCount() == 0)
            {
            return cPartitions;
            }
        
        int cVulnerable = 0;
        
        for (int iPartition = 0; iPartition < cPartitions; iPartition++)
            {
            if (isPartitionVulnerable(iPartition, fStrict))
                {
                cVulnerable++;
                }
            }
        
        return cVulnerable;
        }
    
    /**
     * Checks whether or not the next re-distribution cycle should be deferred
    * due to a currently pending distribution request, transfer request or, if
    * configuration synchronization is on, any pending configuration requests.
    * 
    * @return true if the distribution should be deferred; false otherwise
     */
    public boolean checkDeferredDistribution()
        {
        // import Component.Util.DistributionStrategy;
        
        DistributionStrategy strategy = getDistributionStrategy();
        if (isDistributionInProgress() || isOwnershipChangeInProgress() ||
                isRecoveryInProgress() || isRestoreInProgress())
            {
            strategy.reportLateDistributions();
            return true;
            }
        
        // reset pending distribution timers
        strategy.setDistributionsPendingStart(0L);
        strategy.setWarningNextMillis(0L);
        
        int cPending = getPartitionConfigMap().getPendingConfigRequestCount();
        if (isDistributionSynchronized() && cPending > 0)
            {
            _trace("Deferring the distribution due to " + cPending +
                   " pending configuration updates", 3);
            return true;
            }
        
        return false;
        }
    
    /**
     * Check the partition distribution to ensure that:
    * 
    * - Departing service members have relinquished any partitions they may
    * own,
    * - Orphaned partitions are properly adopted,
    * - Backups are properly maintained
    * - Partitions are distributed according to the configured
    * DistributionStrategy.
     */
    protected void checkDistribution()
        {
        // import Component.Net.MemberSet;
        // import com.tangosol.net.partition.PartitionSet;
        // import com.tangosol.util.Base;
        // import java.util.Set;
        
        // assume a regular distribution scheduling interval
        setDistributionNextMillis(
            Base.getSafeTimeMillis() + getDistributionRepeatMillis());
        
        if (checkDeferredDistribution())
            {
            // allow current distribution or transfers to complete
            setDistributionStable(false);
            return;
            }
        
        MemberSet setOwners  = getOwnershipMemberSet();
        MemberSet setOthers  = getOwnershipOtherMemberSet(setOwners);
        Set       setLeaving = getOwnershipLeavingMembers(setOwners);
        
        // check if there remain any partitions to transfer before stopping
        if (getServiceState() == SERVICE_STOPPING)
            {
            PartitionSet partsPrimary = collectOwnedPartitions(true);
            PartitionSet partsBackup  = collectOwnedPartitions(false);
        
            int cRemainPrimary = partsPrimary.cardinality();
            int cRemainBackup  = partsBackup.cardinality();
            if (cRemainPrimary == 0 && cRemainBackup == 0)
                {
                // everything has been transferred
                stop();
                }
            else if (setLeaving.size() == 1 + setOthers.size())
                {
                // everyone is leaving;
                // (setLeaving must include this member)
                stop();
                }
            else if (!isDistributionAllowed() || !isRestorePartitionAllowed())
                {
                // distribution is disallowed
                stop();
                }
            else
                {
                // the getOwnershipOtherMemberSet is not synchronously reliable,
                // it's possible that it shows more ownership enabled members then
                // there in fact are; reschedule
        
                _trace("Remains to transfer before shutting down: "
                     + cRemainPrimary + " primary partitions, "
                     + cRemainBackup  + " backup partitions", 3);
        
                // output the state of owned partitions; if a partition is in
                // transfer logging is performed by checkDeferredDistribution
        
                String sRemainsPrev = getRemainsOwnershipReport();
                String sRemains;
                if (sRemainsPrev == null)
                    {
                    // skip reportOwnership for the first invocation of
                    // checkDistribution allowing time for new owners to
                    // request the transfer
                    sRemains = "";
                    }
                else
                    {
                    sRemains = reportOwnership(getThisMember().getId(), true);
                    if (!Base.equals(sRemainsPrev, sRemains))
                        {
                        _trace(sRemains, 5);
                        }
                    }
                setRemainsOwnershipReport(sRemains);
                }
            return;
            }
        
        _assert(isOwnershipEnabled());
        
        int cOrphans = calculateOwnership(setOwners, true)[0];
        if (cOrphans > 0)
            {
            // There are orphaned partitions;
            // they must be restored or re-assigned before we can move any further.
            // We cannot immediately assign a partition to ourselves;
            // consider the following scenario:
            // - M1 owns a partition; M2 is first backup (owners=[M1, M2])
            // - M1 transfers the primary ownership to M3 and stops right after that
            // - M2 assigns a partition to itself as a backup owner and
            //      notifies everyone (owners=[M2, 0])
            // - M3 notifies everyone on the transfer success (owners=[M3, M2])
            // to resolve this problem the ownership must be agreed on by everyone
            if (isRestorePartitionAllowed() &&
                getThisMember() == getOwnershipSenior() && getOwnershipInProgress() <= 0)
                {
                // begin the ownership protocol
                doOwnershipProtocol(setOwners, /*sSnapshotToRecover*/ null);
                }
        
            setDistributionStable(false);
            return;
            }
        setOwnershipInProgress(0);
        
        // we are ready to participate in distribution
        getDistributionStrategy().checkDistribution(setOwners, setLeaving);
        
        if (isDistributionInProgress() || isOwnershipChangeInProgress() ||
                !isAllAllowed() || calculateUnbalanced() > 0)
            {
            setDistributionStable(false);
            }
        else if (!isDistributionStable())
            {
            onOwnershipStable();
        
            setDistributionStable(true);
            }
        }
    
    /**
     * Return true iff it is required to lock the partitions before assign
    * orphans.
     */
    public boolean checkLockRequired()
        {
        return isActivePersistence();
        }
    
    /**
     * Clear a contention for the specified partition.
     */
    public void clearContention(int iPartition)
        {
        // import com.tangosol.util.Base;
        
        PartitionedService.Contention[] aContention = getPartitionContention();
        Object        oMonitor    = Base.getCommonMonitor(
            System.identityHashCode(aContention) + iPartition);
        
        PartitionedService.Contention contention;
        synchronized (oMonitor)
            {
            contention = aContention[iPartition];
            if (contention != null)
                {
                aContention[iPartition] = null;
                }
            }
        
        if (contention != null)
            {
            contention.clear();
            }
        }
    
    /**
     * Clear contentions for the specified partitions.
     */
    public void clearContention(com.tangosol.net.partition.PartitionSet partitions)
        {
        for (int iPartition = partitions.next(0); iPartition >= 0;
                 iPartition = partitions.next(iPartition + 1))
            {
            clearContention(iPartition);
            }
        }
    
    // Declared at the super level
    /**
     * Create a new Default dependencies object by copying the supplies
    * dependencies.  Each class or component that uses dependencies implements
    * a Default dependencies class which provides the clone functionality.  
    * The dependency injection design pattern requires every component in the
    * component hierarchy to implement clone, producing their variant of the
    * dependencies interface.
    * 
    * @return the cloned dependencies
     */
    protected com.tangosol.internal.net.service.DefaultServiceDependencies cloneDependencies(com.tangosol.net.ServiceDependencies deps)
        {
        // import com.tangosol.internal.net.service.grid.DefaultPartitionedServiceDependencies;
        // import com.tangosol.internal.net.service.grid.PartitionedServiceDependencies;
        
        return new DefaultPartitionedServiceDependencies((PartitionedServiceDependencies) deps);
        }
    
    /**
     * Collect endangered partitions owned by this node for the specified backup
    * index.
    * 
    * @return the set of endangered partition indexes
     */
    public com.tangosol.net.partition.PartitionSet collectEndangeredPartitions(int iBackup)
        {
        // import com.tangosol.net.partition.PartitionSet;
        
        int[][]      aaiOwner      = getPartitionAssignments();
        int          cPartitions   = aaiOwner.length;
        int          nMemberThis   = getThisMember().getId();
        PartitionSet setEndangered = new PartitionSet(cPartitions);
        
        for (int iPartition = 0; iPartition < cPartitions; iPartition++)
            {
            if (aaiOwner[iPartition][0] == nMemberThis &&
                aaiOwner[iPartition][iBackup] == 0)
                {
                setEndangered.add(iPartition);
                }
            }
        
        return setEndangered;
        }
    
    /**
     * Collect orphaned partitions.
    * 
    * @return the set of orphaned partitions
     */
    public com.tangosol.net.partition.PartitionSet collectOrphanPartitions()
        {
        // import com.tangosol.net.partition.PartitionSet;
        
        int[][]      aaiOwner    = getPartitionAssignments();
        int          cPartitions = aaiOwner.length;
        PartitionSet parts       = new PartitionSet(cPartitions);
        
        for (int iPartition = 0; iPartition < cPartitions; iPartition++)
            {
            if (aaiOwner[iPartition][0] == 0)
                {
                parts.add(iPartition);
                }
            }
        
        return parts;
        }
    
    /**
     * Calculate the PartitionSet that contains all partitions owned by this
    * Member.
    * 
    * @param fPrimary if true, calculate the primary ownership; otherwise the
    * backup ownership
    * 
    * @return PartitionSet containing owned partitions
     */
    public com.tangosol.net.partition.PartitionSet collectOwnedPartitions(boolean fPrimary)
        {
        // import Component.Net.Member;
        // import com.tangosol.net.partition.PartitionSet;
        
        Member memberThis = getThisMember();
        if (fPrimary)
            {
            return calculatePartitionSet(memberThis, 0);
            }
        
        int cBackups = getBackupCount();
        if (cBackups == 0)
            {
            return new PartitionSet(getPartitionCount());
            }
        
        PartitionSet setOwned = calculatePartitionSet(memberThis, 1);
        if (cBackups > 1)
            {
            // almost never happens
            for (int iStore = 2; iStore <= cBackups; iStore++)
                {
                setOwned.add(calculatePartitionSet(memberThis, iStore));
                }
            }
            
        return setOwned;
        }
    
    /**
     * Collect and return the ownership versions of the specified partition set.
    * 
    * @param parts    the set of partitions to collect the versions of
     */
    public com.tangosol.net.internal.PartitionVersions collectOwnershipVersions(com.tangosol.net.partition.PartitionSet parts)
        {
        // import com.tangosol.net.internal.PartitionVersions;
        
        int[] anVersions = new int[parts.cardinality()];
        for (int iVersion = 0, iPart = parts.next(0); iPart >= 0; iPart = parts.next(iPart + 1))
            {
            anVersions[iVersion++] = getOwnershipVersion(iPart);
            }
        
        return new PartitionVersions(parts, anVersions);
        }
    
    /**
     * Collect vulnerable partitions owned by this node.
    * 
    * @return the set of vulnerable partitions
     */
    public com.tangosol.net.partition.PartitionSet collectVulnerablePartitions()
        {
        return collectVulnerablePartitions(false);
        }
    
    /**
     * Collect vulnerable partitions owned by this node.
    * 
    * @return the set of vulnerable partitions
     */
    public com.tangosol.net.partition.PartitionSet collectVulnerablePartitions(boolean fStrict)
        {
        // import com.tangosol.net.partition.PartitionSet;
        
        int[][]      aaiOwner        = getPartitionAssignments();
        int          cPartitions     = aaiOwner.length;
        int          nMemberThis     = getThisMember().getId();
        PartitionSet partsVulnerable = new PartitionSet(cPartitions);
        
        for (int iPartition = 0; iPartition < cPartitions; iPartition++)
            {
            if (aaiOwner[iPartition][0] == nMemberThis &&
                isPartitionVulnerable(iPartition, fStrict))
                {
                partsVulnerable.add(iPartition);
                }
            }
        
        return partsVulnerable;
        }
    
    // Declared at the super level
    /**
     * Compare importance of the specified Member with the local Member. This
    * method is usually called during processing of the partial packet delivery
    * failure, when a decision has to be made to either kill another member or
    * commit a suicide.
    * 
    * @return zero if this service does not care or views those members as of
    * "equal importance"; negative number if the importance of this Member is
    * lesser than of the specified one and positive number if the importance of
    * this Member is greater than of the specified one. The absolute value of
    * the return value signifies a difference in importance.
     */
    public int compareImportance(com.tangosol.coherence.component.net.Member memberThat)
        {
        if (!isAcceptingClients())
            {
            // not really up yet; shouldn't cause any data loss
            return -1;
            }
        
        boolean fThisOwnership = isOwnershipEnabled();
        boolean fThatOwnership = isOwnershipEnabled(memberThat);
        
        // respect a preference result returned by a custom importance plugin
        int iResult = super.compareImportance(memberThat);
        if (iResult == 0 && (fThisOwnership ^ fThatOwnership))
            {
            iResult = fThisOwnership ? +1 : -1;
            }
        
        return iResult;
        }
    
    // From interface: com.tangosol.net.PartitionedService
    // Declared at the super level
    /**
     * Configure the component by transforming XML into a Dependencies object
    * and then injecting that Dependencies object into the component.
     */
    public synchronized void configure(com.tangosol.run.xml.XmlElement xml)
        {
        // import com.tangosol.internal.net.service.grid.DefaultPartitionedServiceDependencies;
        // import com.tangosol.internal.net.service.grid.LegacyXmlPartitionedServiceHelper as com.tangosol.internal.net.service.grid.LegacyXmlPartitionedServiceHelper;
        
        setDependencies(com.tangosol.internal.net.service.grid.LegacyXmlPartitionedServiceHelper.fromXml(xml,
            new DefaultPartitionedServiceDependencies(), getOperationalContext(),
            getContextClassLoader()));
        
        setServiceConfig(xml);
        }
    
    /**
     * Convert the provided hash to a permitted hash, avoiding the reserved
    * value (Integer.MIN_VALUE).
    * 
    * @param nHash  the hash to be interrogated
    * 
    * @return a permitted hash code
     */
    public int convertHash(int nHash)
        {
        // import com.tangosol.util.HashEncoded;
        
        // Note: a hash value of HashEncoder.UNDECORATED is forbidden as it is a constant
        //       used to determine no value in data structures such as BinaryRadixTree
        
        if (nHash == HashEncoded.UNENCODED)
            {
            nHash += getPartitionCount();
            }
        return nHash;
        }
    
    /**
     * Create a PinningIterator over the specified set to prevent distribution
    * for specified keys by acquiring shared locks for all corresponding
    * partitions.  The keys that could not be pinned will be filtered out by
    * the iterator, removed from the passed in set, and the corresponding
    * partition will be added to the "rejected" partitions.
    * 
    * The only thing that pinning a partition prevents is an attempt to lock
    * the partition when the distribution process attempts to transfer
    * partitions.
    * 
    * @param set   a set of Binary keys or Entry<Binary, *> to pin the
    * partitions for
    * 
    * @return a PinningIterator over the specified set
     */
    protected PartitionedService.PinningIterator createPinningIterator(java.util.Set set)
        {
        return createPinningIterator(set, null);
        }
    
    /**
     * Create a PinningIterator over the specified set to prevent distribution
    * for specified keys by acquiring shared locks for all corresponding
    * partitions.  The keys that could not be pinned will be filtered out by
    * the iterator, removed from the passed in set, and the corresponding
    * partition will be added to the "rejected" partitions.
    * 
    * The only thing that pinning a partition prevents is an attempt to lock
    * the partition when the distribution process attempts to transfer
    * partitions.
    * 
    * @param set   a set of Binary keys or Entry<Binary, *> to pin the
    * partitions for
    * 
    * @return a PinningIterator over the specified set
     */
    protected PartitionedService.PinningIterator createPinningIterator(java.util.Set set, com.tangosol.net.internal.PartitionVersions versions)
        {
        PartitionedService.PinningIterator pinner = (PartitionedService.PinningIterator) _newChild("PinningIterator");
        pinner.setFullSet(set);
        pinner.setPartitionVersions(versions);
        return pinner;
        }
    
    /**
     * Discard the backup ownership of the specified partition, dropping the
    * storage, persistence, meta-data control structures and informing the
    * primary owner.
    * 
    * Called on the service thread only.
     */
    public void discardBackupOwnership(int nPartition)
        {
        // import Component.Net.Member;
        
        int iStore = getOwnedIndex(nPartition, getThisMember().getId());
        
        if (iStore > 0)
            {
            // update the local assignments
            assignPartitionOwner(nPartition, iStore, 0);
        
            // release the transient and persistent storage
            releasePartition(nPartition, iStore);
        
            // release the partition control structures
            releasePartitionControl(nPartition);
        
            // notify the primary owner
            Member memberOwner = getPrimaryOwner(nPartition);
            getTransferControl().sendBackupRelease(nPartition, iStore, memberOwner.getId(), 0, memberOwner, null);
            }
        }
    
    /**
     * Start the ownership protocol either as a result of the normal
    * distribution checks, or an explicit recovery from persistent snapshot.
    * 
    * @param sSnapshotToRecover    the name of the persistent snapshot to
    * recover, or null if no explicit recovery
     */
    public void doOwnershipProtocol(com.tangosol.coherence.component.net.MemberSet setOwners, String sSnapshotToRecover)
        {
        // issue an ownership request (poll) to all ownership-enabled members
        PartitionedService.OwnershipRequest msg = (PartitionedService.OwnershipRequest) instantiateMessage("OwnershipRequest");
        msg.setSenderMemberSet(setOwners);
        msg.setQuery(true);
        msg.setSnapshotToRecover(sSnapshotToRecover);
        msg.setToMemberSet(setOwners);
        
        setOwnershipInProgress(-getOwnershipInProgress() + 1); // 0 -> 1; -N -> N+1
        post(msg);
        }
    
    protected PartitionedService.PartitionControl ensurePartitionControl(int nPartition)
        {
        // import com.oracle.coherence.common.base.MutableLong;
        // import com.tangosol.net.partition.PartitionStatistics;
        // import com.tangosol.util.Base;
        
        PartitionedService.PartitionControl ctrl = getPartitionControl(nPartition);
        if (ctrl == null)
            {
            ctrl = (PartitionedService.PartitionControl) _newChild("PartitionControl");
            ctrl.setPartitionId(nPartition);
            ctrl.setStatistics(new PartitionStatistics(nPartition, Base.getLastSafeTimeMillis()));
            ctrl.setTLOEnterCounter(MutableLong.createThreadLocal());
            setPartitionControl(nPartition, ctrl);
            }
        
        return ctrl;
        }
    
    public java.util.List ensurePartitionEventsList(int iPartition)
        {
        // import java.util.List;
        // import java.util.Map;
        // import java.util.concurrent.CopyOnWriteArrayList;
        
        Map     mapEvents  = getPartitionEvents();
        List    listEvents = (List) mapEvents.get(Integer.valueOf(iPartition));
        
        if (listEvents == null)
            {
            mapEvents.put(Integer.valueOf(iPartition), new CopyOnWriteArrayList());
            listEvents = (List) mapEvents.get(Integer.valueOf(iPartition));
            }
        
        return listEvents;
        }
    
    /**
     * Check for a valid license for ApplicationEdition+ only features.
    * 
    * The method name is intentionally vague.
     */
    protected Exception ensureSupport(com.tangosol.coherence.component.net.message.requestMessage.DistributedCacheRequest msgRequest, String sFeature)
        {
        // import com.tangosol.license.LicenseException;
        
        Exception e = msgRequest == null ? null : msgRequest.getReadException();
        if (e == null && getMsgCAE() != null)
            {
            // see onEnter()
            e = new LicenseException(sFeature + ": " + getMsgCAE());
            }
        
        return e;
        }
    
    /**
     * Attempt to enter the specified partition, and return true iff the
    * partition is successfully entered.
     */
    public boolean enterPartition(int nPartition)
        {
        return enterPartition(nPartition, -1L);
        }
    
    /**
     * Attempt to enter the specified partition, and return true iff the
    * partition is successfully entered.
     */
    public boolean enterPartition(int nPartition, long cWait)
        {
        PartitionedService.PartitionControl ctrlPartition = getPartitionControl(nPartition);
        
        if (ctrlPartition == null)
            {
            // the partition must be unowned
            return false;
            }
        
        if (ctrlPartition.enter(0L))
            {
            return true;
            }
        
        if (cWait == 0L)
            {
            return false;
            }
        
        // the only reason a gate cannot be entered if the service thread closed it
        // due to the partition transfer;
        // "primary-transfer-out" should result in a quick fail,
        // "backup-transfer-out" should be waited for
        //
        // Until COH-9861 is fully addressed, a "primary-transfer-in" will result in
        // a quick fail (and reject back to the client) to avoid a logical deadlock
        int nLockType = ctrlPartition.getLockType();
        if (nLockType == PartitionedService.PartitionControl.LOCK_BACKUP_XFER_OUT ||
            nLockType == PartitionedService.PartitionControl.LOCK_NONE ||
            nLockType == PartitionedService.PartitionControl.LOCK_PERSISTENCE)
            {
            ctrlPartition.enter(-1L);
            return true;
            }
        
        return false;
        }
    
    /**
     * Exit the specified partition.
     */
    public void exitPartition(int nPartition)
        {
        // it is possible for the partition-control to be concurrently
        // released while this thread has "entered" it, only to immediately
        // discover that the partition is no longer owned
        
        PartitionedService.PartitionControl ctrlPart = getPartitionControl(nPartition);
        if (ctrlPart != null)
            {
            ctrlPart.exit();
            }
        }

    protected void scheduleEnvironmentMaintenance()
        {
        if (isRunning())
            {
            getDaemonPool().schedule(new MaintenanceTask(), MAINTENANCE_INTERVAL);
            }
        }
    
    /**
     * Finalize the startup sequence for this service member.  This method is
    * responsible for completing the startup of services that are Running, but
    * have not yet finished AcceptingClients or AcceptingOthers.
     */
    protected void finalizeStartup()
        {
        // import Component.Net.Member;
        // import com.tangosol.util.Base;
        
        _assert(!isAcceptingOthers());
        
        if (validateMemberConfig() && validatePartitionConfig())
           {
           // member and partition configuration data have been synchronized;
           // complete the startup sequence and start accepting clients/others
        
           // setAcceptingOthers first; see PartitionedService.PartitionConfig.getConfigCoordinator()
           setAcceptingOthers(true);
        
           // update the PartitionConfig to reflect the initial partition assignments
           PartitionedService.PartitionConfig.Map mapConfig = getPartitionConfigMap();
        
           mapConfig.initializePartitions();
        
           if (isOwnershipEnabled())
               {
               // publish that we are ownership-enabled prior to accepting clients
               // to ensure the ownership memberset includes this member
               getThisMemberConfigMap().
                   put("ownership-enabled", Integer.valueOf(OWNERSHIP_ENABLED));
        
               Member memberThis = getThisMember();
               if (getOwnershipSenior() == memberThis)
                   {
                   _assert(mapConfig.getConfigCoordinator() == memberThis);
        
                   // If we are the partition config coordinator, send out the
                   // partition config.  Although we are the first ownership member,
                   // we need to send it out here just in case there are other members
                   // that are in the process of joining simultaneously.
                   //
                   // We don't set ownership-enabled (and hence cannot be considered
                   // OwnershipSenior) until we are finished starting up in order to
                   // avoid prematurely declaring our seniority (and causing the
                   // possibility of revocation). Because of this, members who are
                   // simultaneously joining will not receive the partition config
                   // with their MemberWelcome (see COH-2711).
        
                   mapConfig.publishConfig(null);
            
                   // this will initialize the persistence manager
                   onOwnershipSeniority(null);
                   }
        
               if (isActivePersistence())
                   {
                   // send a message to this storage member to delete old versions of
                   // persisted partitions 
                   PartitionedService.PartitionRecoverCleanup msg =
                       (PartitionedService.PartitionRecoverCleanup) instantiateMessage("PartitionRecoverCleanup");
        
                   msg.setPartitions(instantiatePartitionSet(true));
                   msg.setPrimary(true);
                   msg.addToMember(memberThis);
        
                   post(msg);
                   }
        
               // schedule a distribution immediately
               setDistributionNextMillis(0L);
               }
           else
               {
               setDistributionNextMillis(Long.MAX_VALUE);
               }
        
           onFinalizeStartup();
           }
        else
           {
           setFinalizing(true);
        
           // wait until the configuration data are updated (but not too long)
        
           long ldtStart   = getStartTimestamp();
           long ldtCurrent = Base.getSafeTimeMillis();
           long lTimeout   = getStartupTimeout();
        
           // report the problem slightly ahead of the startup timeout
           if (ldtCurrent > ldtStart + lTimeout - 1000)
               {
               _trace("Failed to synchronize the service configuration; "
                    + "stopping the service", 1);
               stop();
               }
           }
        }
    
    protected void firePartitionEvent(int nEventId, int nPartition, com.tangosol.coherence.component.net.Member memberFrom, com.tangosol.coherence.component.net.Member memberTo)
        {
        // import com.tangosol.net.partition.PartitionSet;
        
        PartitionSet partitions = new PartitionSet(getPartitionCount());
        if (nPartition == -1)
            {
            partitions.fill();
            }
        else
            {
            partitions.add(nPartition);
            }
        
        firePartitionEvent(nEventId, partitions, memberFrom, memberTo);
        }
    
    protected void firePartitionEvent(int nEventId, com.tangosol.net.partition.PartitionSet partitions, com.tangosol.coherence.component.net.Member memberFrom, com.tangosol.coherence.component.net.Member memberTo)
        {
        // import com.tangosol.net.partition.PartitionEvent;
        // import com.tangosol.net.partition.PartitionListener;
        // import java.util.EventListener;
        
        EventListener[] listeners  = getPartitionListeners().listeners();
        int             cListeners = listeners.length;
        if (cListeners > 0)
            {
            try
                {
                for(int i = 0; i < cListeners; i++)
                    {
                    ((PartitionListener) listeners[i]).onPartitionEvent(
                        new PartitionEvent(this, nEventId, partitions, memberFrom, memberTo));
                    }
                }
            catch (RuntimeException e)
                {
                _trace("The following exception was thrown by PartitionListener:\n" +
                    getStackTrace(e) +
                    "\n(The service thread has logged the exception and is continuing.)", 1);
                }
            }
        }
    
    // Accessor for the property "AsyncBackupInterval"
    /**
     * Getter for property AsyncBackupInterval.<p>
    * The time interval to send periodic backups to backup copies of this
    * member's primiary partitions.
     */
    public long getAsyncBackupInterval()
        {
        return __m_AsyncBackupInterval;
        }
    
    // From interface: com.tangosol.net.PartitionedService
    // Accessor for the property "BackupCount"
    /**
     * Getter for property BackupCount.<p>
    * Specifies the number of backups for each partition.
     */
    public int getBackupCount()
        {
        return __m_BackupCount;
        }
    
    // From interface: com.tangosol.net.PartitionedService
    /**
     * Return a backup owner of the specified copy for the given partition.
     */
    public com.tangosol.net.Member getBackupOwner(int iPartition, int nBackup)
        {
        if (nBackup <= 0 || nBackup > getBackupCount())
            {
            throw new IllegalArgumentException("invalid backup: " + nBackup);
            }
        
        try
            {
            int nMember = getPartitionAssignments()[iPartition][nBackup];
            return nMember == 0 ? null : getServiceMemberSet().getMember(nMember);
            }
        catch (IndexOutOfBoundsException e)
            {
            throw new IllegalArgumentException("invalid partition: " + iPartition);
            }
        }
    
    /**
     * Return a List of non-leaving backup owners of the specified partition.
     */
    public java.util.List getBackupOwners(int iPartition)
        {
        // Note: this will no longer be needed once COH-5400 is fully implemented,
        //       as the "transitional" ownership will always be reflected in the
        //       local ownership as the primary owner will direct all "swaps"
        
        return getBackupOwners(iPartition, true);
        }
    
    /**
     * Return a List of non-leaving backup owners of the specified partition.
     */
    public java.util.List getBackupOwners(int iPartition, boolean fIncludeTransitional)
        {
        // import Component.Net.Member;
        // import Component.Net.MemberSet.ActualMemberSet.ServiceMemberSet;
        // import com.tangosol.net.partition.Ownership;
        // import java.util.ArrayList;
        // import java.util.Collections;
        // import java.util.List;
        
        int cBackups = getBackupCount();
        if (cBackups == 0)
            {
            // degenerate case
            return Collections.emptyList();
            }
        else
            {
            ServiceMemberSet setMembers  = getServiceMemberSet();
            int[]            aiOwner     = getPartitionAssignments()[iPartition];
            Ownership        owners      = getPartitionConfig(iPartition);
            List             listOwners  = new ArrayList(cBackups);
        
            // Iterate the partition assignments for each storage index and
            // collect the backup owners
            for (int iStore = 1; iStore <= cBackups; iStore++)
                {
                int nOwner = aiOwner[iStore];
                if (nOwner > 0 && !setMembers.isServiceLeaving(nOwner))
                    {
                    Member memberOwner = setMembers.getMember(nOwner);
                    if (memberOwner != null)
                        {
                        listOwners.add(memberOwner);
                        }
                    }
        
                int nOwnerGlobal = owners.getOwner(iStore);
                if (fIncludeTransitional && nOwnerGlobal != nOwner &&
                    nOwnerGlobal > 0 && !setMembers.isServiceLeaving(nOwnerGlobal))
                    {
                    Member memberGlobal = setMembers.getMember(nOwnerGlobal);
                    if (memberGlobal != null)
                        {
                        listOwners.add(memberGlobal);
                        }
                    }
                }
        
            return listOwners;
            }
        }
    
    /**
     * Return a list of the backup owners of the specified resource.
     */
    public java.util.List getBackupOwners(com.tangosol.util.Binary binKey)
        {
        return getBackupOwners(getKeyPartition(binKey));
        }
    
    // From interface: com.tangosol.net.PartitionedService
    /**
     * Return the current backup strength (one of the BACKUP_STRENGTH_*
    * constants) representing the backup-strength of the partitioned service.
     */
    public int getBackupStrength()
        {
        return getBackupStrength(/*fLocal*/ false);
        }
    
    /**
     * Return the current backup strength (one of the BACKUP_STRENGTH_*
    * constants) representing the backup-strength of the specified ownership
    * array.
     */
    public int getBackupStrength(int[] aiOwners)
        {
        // import Component.Net.Member;
        // import Component.Net.MemberSet;
        // import com.tangosol.util.Base;
        
        int cBackups = getBackupCount();
        if (cBackups == 0)
            {
            return BACKUP_STRENGTH_ENDANGERED;
            }
        
        MemberSet setMembers = getServiceMemberSet();
        int       nStrength  = BACKUP_STRENGTH_SITE;
        for (int iStoreThis = 0; iStoreThis <= cBackups; iStoreThis++)
            {
            Member memberThis = setMembers.getMember(aiOwners[iStoreThis]);
            if (memberThis == null)
                {
                // this can only happen for iStoreThis==0, i.e. primary partition
                // missing backups would be caught in the inner loop
                return BACKUP_STRENGTH_ORPHANED;
                }
        
            for (int iStoreThat = iStoreThis + 1; iStoreThat <= cBackups; iStoreThat++)
                {
                Member memberThat = setMembers.getMember(aiOwners[iStoreThat]);
        
                if (memberThat == null)
                    {
                    return BACKUP_STRENGTH_ENDANGERED;
                    }
                else if (nStrength > BACKUP_STRENGTH_NODE &&
                         memberThis.getMachineId() == memberThat.getMachineId())
                    {
                    return BACKUP_STRENGTH_NODE;
                    }
                else if (nStrength > BACKUP_STRENGTH_MACHINE && 
                         Base.equals(memberThis.getRackName(), memberThat.getRackName()))
                    {
                    return BACKUP_STRENGTH_MACHINE;
                    }
                else if (nStrength > BACKUP_STRENGTH_RACK && 
                         Base.equals(memberThis.getSiteName(), memberThat.getSiteName()))
                    {
                    return BACKUP_STRENGTH_RACK;
                    }
                else
                    {
                    return nStrength;
                    }
                }
            }
        
        return nStrength;
        }
    
    /**
     * Return the current backup strength (one of the BACKUP_STRENGTH_*
    * constants) representing the backup-strength of the specified partition
    * and the specified view (local assignment or global assignment).
     */
    public int getBackupStrength(int iPartition, boolean fLocal)
        {
        int[] aiOwners = fLocal ? getPartitionAssignments()[iPartition]
                                : getPartitionConfig(iPartition).getOwners();
        
        return getBackupStrength(aiOwners);
        }
    
    /**
     * Return the current backup strength (one of the BACKUP_STRENGTH_*
    * constants) representing the specified view (local assignment or global
    * assignment) of  backup-strength of the partitioned service.
     */
    public int getBackupStrength(boolean fLocal)
        {
        if (getBackupCount() == 0)
            {
            return BACKUP_STRENGTH_ENDANGERED;
            }
        
        int nStatusSvc  = BACKUP_STRENGTH_SITE;
        int cPartitions = getPartitionCount();
        for (int iPartition = 0; iPartition < cPartitions; iPartition++)
            {
            int nStatusPart = getBackupStrength(iPartition, fLocal);
            if (nStatusSvc > nStatusPart)
                {
                nStatusSvc = nStatusPart;
                } 
            }
        
        return nStatusSvc;
        }
    
    // From interface: com.tangosol.net.PartitionedService
    /**
     * Return the string representing current backup strength.
     */
    public String getBackupStrengthName()
        {
        switch (getBackupStrength())
            {
            case BACKUP_STRENGTH_ORPHANED:
            case BACKUP_STRENGTH_ENDANGERED:
                return "ENDANGERED";
        
            case BACKUP_STRENGTH_NODE:
                return "NODE-SAFE";
        
            case BACKUP_STRENGTH_MACHINE:
                return "MACHINE-SAFE";
        
            case BACKUP_STRENGTH_RACK:
                return "RACK-SAFE";
        
            case BACKUP_STRENGTH_SITE:
                return "SITE-SAFE";
        
            default:
                return null;
            }
        }
    
    /**
     * Return the closest owner (based on distance) relative to this member for
    * the given partition.
     */
    public com.tangosol.coherence.component.net.Member getClosestOwner(int iPartition)
        {
        // import Component.Net.Member;
        // import Component.Net.MemberSet.ActualMemberSet.ServiceMemberSet;
        // import com.tangosol.util.Base;
        
        int[] anOwners = getPartitionAssignments()[iPartition];
        
        ServiceMemberSet setMembers    = getServiceMemberSet();
        Member           memberThis    = getThisMember();
        Member           memberClosest = null;
        
        for (int i = 0, c = anOwners.length; i < c; ++i)
            {
            Member member = setMembers.getMember(anOwners[i]);
            if (member != null)
                {
                if (memberClosest == null)
                    {
                    memberClosest = member;
                    }
        
                if (memberThis.getMachineId() == member.getMachineId())
                    {
                    return member;
                    }
                else if (Base.equals(memberThis.getRackName(), member.getRackName()) &&
                         !Base.equals(memberClosest.getRackName(), memberThis.getRackName()))
                    {
                    memberClosest = member;
                    }
                else if (Base.equals(memberThis.getSiteName(), member.getSiteName()) &&
                         !Base.equals(memberClosest.getSiteName(), memberThis.getSiteName()))
                    {
                    memberClosest = member;
                    }
                }
            }
        return memberClosest;
        }
    
    // Declared at the super level
    /**
     * Return the ServiceConfig$Map for the specified map type.
     */
    public com.tangosol.coherence.component.util.ServiceConfig.Map getConfigMap(int nMapType)
        {
        if (nMapType == CONFIG_MAP_PARTITION)
            {
            return getPartitionConfigMap();
            }
        else
            {
            return super.getConfigMap(nMapType);
            }
        }
    
    // Accessor for the property "ConfiguredKeyAssociator"
    /**
     * Getter for property ConfiguredKeyAssociator.<p>
    * Configured KeyAssociator implementation; never null.
     */
    public com.tangosol.net.partition.KeyAssociator getConfiguredKeyAssociator()
        {
        return __m_ConfiguredKeyAssociator;
        }
    
    // Accessor for the property "ConfiguredKeyPartitioningStrategy"
    /**
     * Getter for property ConfiguredKeyPartitioningStrategy.<p>
    * The configured KeyPartitioningStrategy implementation.
     */
    public com.tangosol.net.partition.KeyPartitioningStrategy getConfiguredKeyPartitioningStrategy()
        {
        return __m_ConfiguredKeyPartitioningStrategy;
        }
    
    // Accessor for the property "Continuations"
    /**
     * Getter for property Continuations.<p>
     */
    public PartitionedService.Continuations getContinuations()
        {
        return __m_Continuations;
        }
    
    // Accessor for the property "DeferredBackupTimeoutMillis"
    /**
     * Getter for property DeferredBackupTimeoutMillis.<p>
    * The delay in milliseconds after which a missing backup version is
    * considered lost.
    * 
    * Controlled by the "coherence.distributed.deferredbackuptimeout" system
    * property.
     */
    public long getDeferredBackupTimeoutMillis()
        {
        return __m_DeferredBackupTimeoutMillis;
        }
    
    // Declared at the super level
    /**
     * Getter for property Description.<p>
    * Human-readable description of additional Service properties. Used by
    * toString().
     */
    public String getDescription()
        {
        // import com.tangosol.net.Member as com.tangosol.net.Member;
        
        if (isAcceptingClients())
            {
            StringBuilder sb = new StringBuilder(super.getDescription()).append(", ");
            if (isOwnershipEnabled())
                {
                sb.append("LocalStorage=enabled")
                  .append(", PartitionCount=")
                  .append(getPartitionCount())
                  .append(", BackupCount=")
                  .append(getBackupCount())
                  .append(", AssignedPartitions=")
                  .append(calculateThisOwnership(true));
        
                if (getBackupCount() > 0)
                    {
                    sb.append(", BackupPartitions=")
                      .append(calculateThisOwnership(false));
                    }
                }
            else
                {
                sb = new StringBuilder("LocalStorage=disabled");
                }
            com.tangosol.net.Member member = getOwnershipSenior();
            sb.append(", CoordinatorId=")
              .append(member == null ? "n/a" : String.valueOf(member.getId()))
              .append(", PersistenceMode=").append(getPersistenceMode())
              .append(", Serializer=").append(getSerializer().getName());
        
            return sb.toString();
            }
        else
            {
            return "Not initialized";
            }
        }
    
    // Accessor for the property "DistributionAggressiveness"
    /**
     * Getter for property DistributionAggressiveness.<p>
    * The DistributionAggressiveness factor specifies how aggressively the
    * failback operations will be scheduled. The factor of 1 means a lazy (pre-
    * Coherence 3.1) behavior. A  factor of 100 will attempt to finish the
    * failback distribution 100 times faster. Default value is 20.
    * 
    * @since Coherence 3.1
     */
    public int getDistributionAggressiveness()
        {
        return __m_DistributionAggressiveness;
        }
    
    // Accessor for the property "DistributionContendMillis"
    /**
     * Getter for property DistributionContendMillis.<p>
    * The DistributionContendMillis value specifies the maximum number of
    * milliseconds to contend for a partition lock in order to perform
    * distribution or 
    * building snapshot.
     */
    public long getDistributionContendMillis()
        {
        return (long) Math.max(100L, getDistributionAggressiveness());
        }
    
    // Accessor for the property "DistributionNextMillis"
    /**
     * Getter for property DistributionNextMillis.<p>
    * The DistributionNextMillis value is the time (in local system millis) at
    * which the next cache distribution analysis will be performed.
    * 
    * Initial value is Long.MAX_VALUE.
    * 
    * @volatile
     */
    public long getDistributionNextMillis()
        {
        return __m_DistributionNextMillis;
        }
    
    // Accessor for the property "DistributionRepeatMillis"
    /**
     * Getter for property DistributionRepeatMillis.<p>
    * The DistributionRepeatMillis value specifies how many milliseconds
    * between repeatedly performed task of cache distribution analysis and
    * operations.
     */
    public int getDistributionRepeatMillis()
        {
        return __m_DistributionRepeatMillis;
        }
    
    // Accessor for the property "DistributionStrategy"
    /**
     * Getter for property DistributionStrategy.<p>
    * CentralDistribution component.
     */
    public PartitionedService.CentralDistribution getDistributionStrategy()
        {
        return __m_DistributionStrategy;
        }
    
    /**
     * Return the global (based on the PartitionConfig$Map) primary owner of the
    * specified partition.
     */
    public com.tangosol.coherence.component.net.Member getGlobalPrimaryOwner(int iPartition)
        {
        int nMember = getPartitionConfig(iPartition).getPrimaryOwner();
        return nMember == 0 ? null : getServiceMemberSet().getMember(nMember);
        }
    
    // From interface: com.tangosol.net.PartitionedService
    // Accessor for the property "KeyAssociator"
    /**
     * Getter for property KeyAssociator.<p>
    * KeyAssociator implementation; never null.
     */
    public com.tangosol.net.partition.KeyAssociator getKeyAssociator()
        {
        return __m_KeyAssociator;
        }
    
    // From interface: com.tangosol.net.PartitionedService
    public com.tangosol.net.Member getKeyOwner(Object oKey)
        {
        // import com.tangosol.util.Binary;
        
        return getPrimaryOwner((Binary) getKeyToBinaryConverter().convert(oKey));
        }
    
    /**
     * Return a partition number for the specified Binary key.
     */
    public int getKeyPartition(com.tangosol.util.Binary binKey)
        {
        // import com.tangosol.net.partition.DefaultKeyPartitioningStrategy as com.tangosol.net.partition.DefaultKeyPartitioningStrategy;
        // import com.tangosol.util.ExternalizableHelper as com.tangosol.util.ExternalizableHelper;
        
        if (binKey == null)
            {
            return 0;
            }
        
        return com.tangosol.util.ExternalizableHelper.isIntDecorated(binKey)
            ? com.tangosol.net.partition.DefaultKeyPartitioningStrategy.calculatePartition(this, com.tangosol.util.ExternalizableHelper.extractIntDecoration(binKey))
            : binKey.calculateNaturalPartition(getPartitionCount());
        }
    
    // From interface: com.tangosol.net.PartitionedService
    // Accessor for the property "KeyPartitioningStrategy"
    /**
     * Getter for property KeyPartitioningStrategy.<p>
    * KeyPartitioningStrategy implementation.
     */
    public com.tangosol.net.partition.KeyPartitioningStrategy getKeyPartitioningStrategy()
        {
        return __m_KeyPartitioningStrategy;
        }
    
    /**
     * Return the partition set represented by the specified set of keys.
    * 
    * @param setKey  the set of keys
     */
    public com.tangosol.net.partition.PartitionSet getKeyPartitions(java.util.Set setKey)
        {
        // import com.tangosol.net.partition.PartitionSet;
        // import com.tangosol.util.Binary;
        // import java.util.Iterator;
        
        PartitionSet setPartition = new PartitionSet(getPartitionCount());
        for (Iterator iter = setKey.iterator(); iter.hasNext(); )
            {
            setPartition.add(getKeyPartition((Binary) iter.next()));
            }
        
        return setPartition;
        }
    
    // Accessor for the property "KeyToBinaryConverter"
    /**
     * Getter for property KeyToBinaryConverter.<p>
    * The singleton converter used by this service to convert object keys to
    * binary form.
     */
    public PartitionedService.ConverterKeyToBinary getKeyToBinaryConverter()
        {
        return __m_KeyToBinaryConverter;
        }
    
    // Accessor for the property "MaxContendMillis"
    /**
     * Getter for property MaxContendMillis.<p>
    * Max wait time for a partition control lock.
     */
    public long getMaxContendMillis()
        {
        return __m_MaxContendMillis;
        }
    
    // Accessor for the property "MaxLockAttempt"
    /**
     * Getter for property MaxLockAttempt.<p>
    * The number of lock attempt for a partition control after which maximum
    * wait of MaxContendMillis is used to acquire the lock.
     */
    public int getMaxLockAttempt()
        {
        return __m_MaxLockAttempt;
        }
    
    // Accessor for the property "MsgCAE"
    /**
     * Getter for property MsgCAE.<p>
    * Coherence ApplicationEdition+ license support.
    * 
    * @see onEnter
     */
    private String getMsgCAE()
        {
        return __m_MsgCAE;
        }
    
    // Declared at the super level
    /**
     * A helper method to obtain a MemberSet of all other Members running this
    * Service.
     */
    public com.tangosol.coherence.component.net.MemberSet getOthersMemberSet()
        {
        // import Component.Net.MemberSet.ActualMemberSet;
        
        // we cannot use the super call, which returns a plain member set
        // that is just a bitset that doesn't implement iterator()
        ActualMemberSet setOthers = new ActualMemberSet();
        setOthers.addAll(getServiceMemberSet());
        setOthers.remove(getThisMember());
        
        return setOthers;
        }
    
    /**
     * Return the store index of the specified partition that is owned by the
    * specified member, or -1 if the member is neither a primary nor a backup
    * owner of the partition.
    * 
    * @param iPartition    the partition
    * @param nMember   the member id
     */
    public int getOwnedIndex(int iPartition, int nMember)
        {
        return getOwnedIndex(iPartition, nMember, true);
        }
    
    /**
     * Return the store index of the specified partition that is owned by the
    * specified member, or -1 if the member is neither a primary nor a backup
    * owner of the partition.
    * 
    * @param iPartition    the partition
    * @param nMember   the member id
    * @param fLocal         true if asking for local view
     */
    public int getOwnedIndex(int iPartition, int nMember, boolean fLocal)
        {
        // import com.tangosol.net.partition.VersionedOwnership;
        
        int[]              aiOwner = getPartitionAssignments()[iPartition];
        VersionedOwnership owners  = getPartitionConfig(iPartition);
        
        for (int iStore = 0, cBackups = getBackupCount(); iStore <= cBackups; iStore++)
            {
            int nOwner = fLocal ? aiOwner[iStore] : owners.getOwner(iStore);
            if (nOwner == nMember)
                {
                return iStore;
                }
            }
        return -1;
        }
    
    // From interface: com.tangosol.net.PartitionedService
    public com.tangosol.net.partition.PartitionSet getOwnedPartitions(com.tangosol.net.Member member)
        {
        return getServiceMemberSet().contains(member) ?
            calculatePartitionSet(member, 0) : null;
        }
    
    // From interface: com.tangosol.net.PartitionedService
    public java.util.Set getOwnershipEnabledMembers()
        {
        return getOwnershipMemberSet();
        }
    
    // Accessor for the property "OwnershipInProgress"
    /**
     * Getter for property OwnershipInProgress.<p>
    * Specifies how many times in a row this node (OwnershipSenior) had to
    * initiate the OwnershipRequest poll. A positive count indicates that there
    * is an active poll (sent but not yet answered). A negative count indicates
    * that currently there is no active poll, but the previous attempts fail to
    * reconcile the differences. Not more than one OwnershipRequest poll could
    * be active at any given time for the service. 
    * 
    * Note: Only the service thread uses this property.
     */
    public int getOwnershipInProgress()
        {
        return __m_OwnershipInProgress;
        }
    
    /**
     * Calculated set of all ownership enabled Members that are leaving this
    * Service.
     */
    public java.util.Set getOwnershipLeavingMembers()
        {
        return getOwnershipLeavingMembers(getOwnershipMemberSet());
        }
    
    /**
     * Calculated set of all ownership enabled Members [from the specified set]
    * that are leaving this Service.
     */
    public java.util.Set getOwnershipLeavingMembers(java.util.Set setOwners)
        {
        // import Component.Net.Member;
        // import Component.Net.MemberSet.ActualMemberSet.ServiceMemberSet;
        // import com.tangosol.util.LiteSet;
        // import java.util.Iterator;
        
        LiteSet          setLeaving = new LiteSet();
        ServiceMemberSet setService = getServiceMemberSet();
        
        if (setOwners == null)
            {
            setOwners = getOwnershipMemberSet();
            }
        for (Iterator iter = setOwners.iterator(); iter.hasNext();)
            {
            Member member = (Member) iter.next();
        
            if (setService.isServiceLeaving(member.getId()))
                {
                setLeaving.add(member);
                }
            }
        
        return setLeaving;
        }
    
    // Accessor for the property "OwnershipMemberSet"
    /**
     * Getter for property OwnershipMemberSet.<p>
    * Calculated set of Members that are OwnershipEnabled (including leaving
    * members).
    * 
    * Note: the content of the set is not synchronously reliable; it's possible
    * that during short periods of time during a startup and shutdown that it
    * shows more ownership enabled members that there in fact are. Moreover, if
    * the service is not running this returns an empty set.
     */
    public com.tangosol.coherence.component.net.MemberSet getOwnershipMemberSet()
        {
        return getOwnershipMemberSet(/*fIncludePending*/ false);
        }
    
    // Accessor for the property "OwnershipMemberSet"
    /**
     * Return a snapshot of the ownership enabled service members.
    * 
    * @param  fIncludePending if false, the returned set will not iclude the
    * ownership-enabled members that have not yet finished the "service join
    * protocol" sequence.
     */
    public com.tangosol.coherence.component.net.MemberSet getOwnershipMemberSet(boolean fIncludePending)
        {
        // import Component.Net.Member;
        // import Component.Net.MemberSet.ActualMemberSet;
        // import Component.Net.MemberSet.ActualMemberSet.ServiceMemberSet;
        // import java.util.Iterator;
        
        ActualMemberSet setOwners = new ActualMemberSet();
        switch (getServiceState())
            {
            case SERVICE_STARTED:
            case SERVICE_STOPPING:
                {
                ServiceMemberSet setMembers = getServiceMemberSet();
                if (setMembers != null)
                    {
                    for (Iterator iter = setMembers.iterator(); iter.hasNext();)
                        {
                        Member member  = (Member) iter.next();
                        int    nStatus = getOwnershipStatus(member);
                        if (nStatus == OWNERSHIP_ENABLED ||
                            (fIncludePending && nStatus == OWNERSHIP_PENDING))
                            {
                            setOwners.add(member);
                            }
                        }
                    }
                // else service has not yet joined the cluster
                }
            }
        return setOwners;
        }
    
    /**
     * Calculated set of all other Members [from the specified set] that are
    * OwnershipEnabled (including leaving members).
     */
    public com.tangosol.coherence.component.net.MemberSet getOwnershipOtherMemberSet(com.tangosol.coherence.component.net.MemberSet setOwners)
        {
        // import Component.Net.MemberSet.DependentMemberSet;
        
        DependentMemberSet setOthers = new DependentMemberSet();
        setOthers.setBaseSet(setOwners == null ? getOwnershipMemberSet() : setOwners);
        setOthers.addAll();
        setOthers.remove(getThisMember());
        return setOthers;
        }
    
    // From interface: com.tangosol.net.PartitionedService
    public com.tangosol.net.Member getOwnershipSenior()
        {
        return getOwnershipSenior(/*fIncludeLeaving*/ true);
        }
    
    /**
     * Return the senior ownership-enabled member in the service.  If
    * fIncludeLeaving is true, include members that may be leaving the service.
    * 
    * @param fIncludeLeaving    true iff leaving members should be included
     */
    public com.tangosol.coherence.component.net.Member getOwnershipSenior(boolean fIncludeLeaving)
        {
        // import Component.Net.Member;
        // import Component.Net.MemberSet;
        // import Component.Net.MemberSet.ActualMemberSet.ServiceMemberSet;
        // import java.util.Iterator;
        
        // The returned member may not be the oldest one (in cluster time),
        // but all service members will always receive the same answer,
        // which is the only important consideration here
        
        MemberSet        setOwners       = getOwnershipMemberSet();
        ServiceMemberSet setService      = getServiceMemberSet();
        Member           memberAnchor    = null;
        long             ldtJoinedAnchor = Long.MAX_VALUE;
        
        for (Iterator iter = setOwners.iterator(); iter.hasNext();)
            {
            Member member  = (Member) iter.next();
            int    nMember = member.getId();
        
            if (!fIncludeLeaving && setService.isServiceLeaving(nMember))
                {
                continue;
                }
        
            // Note: the service member set may no longer hold the member (COH-4819)
            long ldtJoined = setService.getServiceJoinTime(nMember);
            if (ldtJoined != 0L && ldtJoined < ldtJoinedAnchor)
                {
                memberAnchor    = member;
                ldtJoinedAnchor = ldtJoined;
                }
            }
        
        return memberAnchor;
        }
    
    /**
     * Obtain the ownership status for specified Member.
    * 
    * @return one of the OWNERSHIP_* constants
     */
    public int getOwnershipStatus(com.tangosol.coherence.component.net.Member member)
        {
        Integer IOwnership = (Integer) getServiceMemberSet().
            getMemberConfigMap(member.getId()).get("ownership-enabled");
        
        return IOwnership == null ? OWNERSHIP_UNKNOWN : IOwnership.intValue();
        }
    
    // Accessor for the property "OwnershipVersion"
    /**
     * Getter for property OwnershipVersion.<p>
    * The current "ownership version" of each partition.
     */
    public int[] getOwnershipVersion()
        {
        return __m_OwnershipVersion;
        }
    
    // From interface: com.tangosol.net.PartitionedService
    // Accessor for the property "OwnershipVersion"
    /**
     * Getter for property OwnershipVersion.<p>
    * The current "ownership version" of each partition.
     */
    public int getOwnershipVersion(int i)
        {
        return getOwnershipVersion()[i];
        }
    
    // Accessor for the property "PartitionAssignments"
    /**
     * Getter for property PartitionAssignments.<p>
    * An array indexed by partition number. Each value is an array indexed by
    * backup index (zero being the primary index) of member ids.
    * 
    * As of Coherence 3.1, modifications to the primary partition ownership
    * should be done while holding a synchronization monitor for this array.
    * The reason for this is that during preparation for bulk operations, which
    * happens on client threads, we need to spilt a collection of keys across a
    * number of members. If the primary membership changes at that time, this
    * split would be inconsistent.
    * 
    * @volatile: As of Coherence 3.2, (by Mark's suggestion) we never
    * synchronize. Instead, every time the assignments change, we replace the
    * assignments array with a new clone.
    * 
    * @see #assignPartitionOwner
     */
    public int[][] getPartitionAssignments()
        {
        return __m_PartitionAssignments;
        }
    
    // From interface: com.tangosol.net.PartitionedService
    public com.tangosol.net.partition.PartitionAssignmentStrategy getPartitionAssignmentStrategy()
        {
        return getDistributionStrategy().getPartitionAssignmentStrategy();
        }
    
    /**
     * Return an Ownership descriptor of the specified partition.
     */
    public com.tangosol.net.partition.VersionedOwnership getPartitionConfig(int iPartition)
        {
        // import com.tangosol.net.partition.VersionedOwnership;
        
        return (VersionedOwnership) getPartitionConfigMap().get(Integer.valueOf(iPartition));
        }
    
    // Accessor for the property "PartitionConfigMap"
    /**
     * Getter for property PartitionConfigMap.<p>
    * The PartitionConfig$Map.
     */
    public PartitionedService.PartitionConfig.Map getPartitionConfigMap()
        {
        return __m_PartitionConfigMap;
        }
    
    // Accessor for the property "PartitionContention"
    /**
     * Getter for property PartitionContention.<p>
    * An array of $Contention objects indexed by the corresponding partition
    * number. Most of the time, all the entries are null. The $Contention
    * objects are instantiated only if one of the client side requests come
    * back with a response indicating an on-going distribution and client
    * threads need to wait for such a distribution to complete. Access to the
    * array elements is protected by the Common Monitors.
     */
    public PartitionedService.Contention[] getPartitionContention()
        {
        return __m_PartitionContention;
        }
    
    // Accessor for the property "PartitionControl"
    /**
     * Getter for property PartitionControl.<p>
    * An array of PartitionControl objects indexed by partition number.
     */
    public PartitionedService.PartitionControl[] getPartitionControl()
        {
        return __m_PartitionControl;
        }
    
    // Accessor for the property "PartitionControl"
    /**
     * Getter for property PartitionControl.<p>
    * An array of PartitionControl objects indexed by partition number.
     */
    public PartitionedService.PartitionControl getPartitionControl(int i)
        {
        return getPartitionControl()[i];
        }
    
    // From interface: com.tangosol.net.PartitionedService
    // Accessor for the property "PartitionCount"
    /**
     * Getter for property PartitionCount.<p>
    * Specifies the number of partitions that a distributed cache will be
    * "chopped up" into.
     */
    public int getPartitionCount()
        {
        return __m_PartitionCount;
        }
    
    // Accessor for the property "PartitionEvents"
    /**
     * Getter for property PartitionEvents.<p>
    * Map of events keyed by partition that caused partition unavailability.
     */
    public java.util.Map getPartitionEvents()
        {
        return __m_PartitionEvents;
        }
    
    // Accessor for the property "PartitionListeners"
    /**
     * Getter for property PartitionListeners.<p>
     */
    public com.tangosol.util.Listeners getPartitionListeners()
        {
        return __m_PartitionListeners;
        }
    
    // From interface: com.tangosol.net.PartitionedService
    public com.tangosol.net.Member getPartitionOwner(int nPartition)
        {
        try
            {
            return getPrimaryOwner(nPartition);
            }
        catch (IndexOutOfBoundsException e)
            {
            throw new IllegalArgumentException("invalid partition: " + nPartition);
            }
        }
    
    /**
     * Create an Ownership object for the specified partition.
     */
    public com.tangosol.net.partition.Ownership getPartitionOwnership(int nPartition)
        {
        // import com.tangosol.net.partition.Ownership;
        
        Ownership owners = new Ownership(getBackupCount());
        
        owners.setOwners(getPartitionAssignments()[nPartition]);
        
        return owners;
        }
    
    // Accessor for the property "PartitionTraceEvents"
    /**
     * Getter for property PartitionTraceEvents.<p>
    * Bitmask containing setting for partition events tracing and/or storing.
     */
    public int getPartitionTraceEvents()
        {
        return __m_PartitionTraceEvents;
        }
    
    // Accessor for the property "PersistenceControl"
    /**
     * Getter for property PersistenceControl.<p>
    * The PersistenceControl for this service, if a persistence-environment is
    * configured.
     */
    public PartitionedService.PersistenceControl getPersistenceControl()
        {
        return __m_PersistenceControl;
        }
    
    // Accessor for the property "PersistenceDependencies"
    /**
     * Getter for property PersistenceDependencies.<p>
    * The PersistenceDependencies, or null.
     */
    public com.tangosol.internal.net.service.grid.PersistenceDependencies getPersistenceDependencies()
        {
        return __m_PersistenceDependencies;
        }
    
    // Accessor for the property "PersistenceEventsManager"
    /**
     * Getter for property PersistenceEventsManager.<p>
    * The "active" PersistenceManager, or null if ownership-disabled, or if
    * active persistence is not configured.
     */
    public com.oracle.coherence.persistence.PersistenceManager getPersistenceEventsManager()
        {
        return getPersistenceControl().getEventsManager();
        }
    
    // Accessor for the property "PersistenceManager"
    /**
     * Getter for property PersistenceManager.<p>
    * The "active" PersistenceManager, or null if ownership-disabled, or if
    * active persistence is not configured.
     */
    public com.oracle.coherence.persistence.PersistenceManager getPersistenceManager()
        {
        return getPersistenceControl().getActiveManager();
        }
    
    // From interface: com.tangosol.net.PartitionedService
    public String getPersistenceMode()
        {
        // import com.tangosol.internal.net.service.grid.PersistenceDependencies;
        
        //import Component.Util.Daemon.QueueProcessor.Service.Grid.PartitionedService$PersistenceControl as PersistenceControl;
        
        PartitionedService.PersistenceControl      ctrl        = getPersistenceControl();
        PersistenceDependencies depsPersist = getPersistenceDependencies();
        
        String sMode = depsPersist == null
                ? null : depsPersist.getPersistenceMode();
        
        return ctrl != null && ctrl.isDisabled()
                ? "disabled" : sMode;
        }
    
    // Accessor for the property "PreprocessingGate"
    /**
     * Getter for property PreprocessingGate.<p>
    * Gate governing if threads are actively preprocessing requets for this
    * service.
     */
    public com.tangosol.util.ThreadGate getPreprocessingGate()
        {
        return __m_PreprocessingGate;
        }
    
    /**
     * Return a primary owner of the specified partition.
     */
    public com.tangosol.coherence.component.net.Member getPrimaryOwner(int iPartition)
        {
        int nMember = getPartitionAssignments()[iPartition][0];
        return nMember == 0 ? null : getServiceMemberSet().getMember(nMember);
        }
    
    /**
     * Return a primary owner of the specified resource.
     */
    public com.tangosol.coherence.component.net.Member getPrimaryOwner(com.tangosol.util.Binary binKey)
        {
        return getPrimaryOwner(getKeyPartition(binKey));
        }
    
    // Accessor for the property "RemainsOwnershipReport"
    /**
     * Getter for property RemainsOwnershipReport.<p>
    * This property is only used during graceful shutdown to report partitions
    * that remain to be transferred.
     */
    public String getRemainsOwnershipReport()
        {
        return __m_RemainsOwnershipReport;
        }
    
    // Accessor for the property "ScratchSpaceCounter"
    /**
     * Getter for property ScratchSpaceCounter.<p>
    * Some requests may need a significant amount of heap (scratch space) for
    * intermediate data structures. For example, aggregation requests routinely
    * create large number of entries to perform the calculations. This counter
    * is used to prevent the heap exhaustion caused by concurrent execution of
    * such requests.
    * 
    * In the beginning of the execution, a caller is supposed to call
    * reserveScratchSpace(), which "allocates" a portion of available space. It
    * is the responsibility of the caller to limit the heap usage according to
    * the returned value. At the end of the execution, the caller is supposed
    * to "return" the allocated space using the releaseScratchSpace() method.
    * 
    * While this facility is in no way connected to the actual heap statistics,
    * it assumes that the initial capacity is always available and basically
    * simulates a shared memory allocation pool. 
    * 
    * Currently, this counter is initialized to 50MB.
     */
    public java.util.concurrent.atomic.AtomicLong getScratchSpaceCounter()
        {
        return __m_ScratchSpaceCounter;
        }
    
    /**
     * Return the MemberSet containing all members whose status is included into
    * the specified status mask.
     */
    public com.tangosol.coherence.component.net.MemberSet getStatusMemberSet(int nMask)
        {
        // import Component.Net.Member;
        // import Component.Net.MemberSet.ActualMemberSet;
        // import java.util.Iterator;
        
        ActualMemberSet setMembers = new ActualMemberSet();
        if (getServiceState() != SERVICE_STOPPED)
            {
            for (Iterator iter = getServiceMemberSet().iterator(); iter.hasNext();)
                {
                Member member = (Member) iter.next();
                if ((getOwnershipStatus(member) & nMask) != 0)
                    {
                    setMembers.add(member);
                    }
                }
            }
        return setMembers;
        }
    
    // Accessor for the property "TLORecoveryThread"
    /**
     * Getter for property TLORecoveryThread.<p>
    * True if this thread is processing PartitionRecoverRequest, otherwise null
    * or false.
     */
    public ThreadLocal getTLORecoveryThread()
        {
        return __m_TLORecoveryThread;
        }
    
    // Accessor for the property "TransferControl"
    /**
     * Getter for property TransferControl.<p>
    * The transfer control for this service.
     */
    public PartitionedService.TransferControl getTransferControl()
        {
        PartitionedService.TransferControl control = __m_TransferControl;
        
        if (control == null)
            {
            control = (PartitionedService.TransferControl) _findChild("TransferControl");
            setTransferControl(control);
            }
        
        return control;
        }
    
    // Accessor for the property "TransferThreshold"
    /**
     * Getter for property TransferThreshold.<p>
    * Threshold for the primary partition distribution.
    * 
    * Default value is 0.5MB
    * 
    * @see #transferPrimary()
     */
    public int getTransferThreshold()
        {
        return __m_TransferThreshold;
        }
    
    // Declared at the super level
    /**
     * Getter for property WaitMillis.<p>
    * The number of milliseconds that the daemon will wait for notification.
    * Zero means to wait indefinitely. Negative value means to skip waiting
    * altogether.
    * 
    * @see #onWait
     */
    public long getWaitMillis()
        {
        // import com.tangosol.util.Base;
        
        long cWait1 = super.getWaitMillis();
        long ldtNow = Base.getSafeTimeMillis();
        long cWait2 = Math.max(1L, getDistributionNextMillis() - ldtNow);
        return cWait1 <= 0L ? cWait2 : Math.min(cWait1, cWait2);
        }
    
    /**
     * Partition trace for ASSIGN events per partition. These are only stored if
    * configured to do so, to avoid confusion in logs.
     */
    public void handlePartitionTrace(int iPartition, String sEventDescription)
        {
        handlePartitionTrace(iPartition, "PartitionId: " + iPartition, sEventDescription, 0L, /*fStore*/ true, /*fLog*/ false);
        }
    
    /**
     * Partition trace for all events except ASSIGN. These can be logged, stored
    * or both depending on configuration settings for
    * "coherence.distributed.partition.events".
     */
    public void handlePartitionTrace(int iPartition, String sEventDescription, long ldtTimeSpent)
        {
        handlePartitionTrace(iPartition, "PartitionId: " + iPartition, sEventDescription, ldtTimeSpent, /*fStore*/ true, /*fLog*/ true);
        }
    
    /**
     * Main partition trace method, internally called when partition events
    * occur.
     */
    protected void handlePartitionTrace(int iPartition, String sPartsDesc, String sEventDescription, long ldtTimeSpent, boolean fStore, boolean fLog)
        {
        // import com.tangosol.util.Base;
        // import java.util.List;
        // import java.util.Map;
        
        if (!isPartitionTraceEventsEnabled())
            {
            return;
            }
        
        String sMsg = new StringBuilder(sPartsDesc)
            .append(", Owner: ").append(getThisMember().getId())
            .append(", Action: ").append(sEventDescription)
            .append(", UnavailableTime: ").append(ldtTimeSpent).toString();
        
        // store events temporarily
        if (fStore && isStorePartitionTraceEvents())
            {
            List listMsgs = ensurePartitionEventsList(iPartition);
        
            if (listMsgs != null)
                {
                listMsgs.add(sMsg);
                }
            }
        
        if (fLog && isLogPartitionTraceEvents())
            {
            _trace(sMsg, 8);
            }
        }
    
    /**
     * Partition trace for ASSIGN events for a given partition set. These are
    * only logged if configured to do so.
     */
    public void handlePartitionTrace(com.tangosol.net.partition.PartitionSet partsAssign, String sEventDescription)
        {
        handlePartitionTrace(0, partsAssign.toString(), sEventDescription, 0L, /*fStore*/ false, /*fLog*/ true);
        }
    
    // Declared at the super level
    /**
     * Issue heartbeat.
     */
    public void heartbeat()
        {
        super.heartbeat();
        }
    
    // Declared at the super level
    /**
     * Issue heartbeat.  See com.tangosol.net.Guardian$GuardContext.
    * 
    * @param cMillis  the duration of heartbeat to issue, or 0 for the default
    * heartbeat
     */
    public void heartbeat(long cMillis)
        {
        // import com.tangosol.net.GuardSupport;
        
        if (getThread() == Thread.currentThread())
            {
            super.heartbeat(cMillis);
            return;
            }
        
        if (cMillis > 0)
            {
            GuardSupport.heartbeat(cMillis);
            }
        else
            {
            GuardSupport.heartbeat();
            }
        }

    /**
     * Return true iff there are entries in the specified partition.
     *
     * @param iPartition  partition number to check
     *
     * @return  true iff there are entries
     */
    public boolean hasPersistentData(int iPartition)
        {
        return CachePersistenceHelper.isGlobalPartitioningSchemePID(iPartition);
        }

    /**
     * Increment and return the ownership version for the specified partition.
    * 
    * This method is called on the service thread only.
     */
    public int incrementOwnershipVersion(int nPartition)
        {
        _assert(Thread.currentThread() == getThread()); // should only run on the service thread
        
        return ++getOwnershipVersion()[nPartition];
        }
    
    /**
     * Initialize the empty partition config for this member.  This method does
    * not cause ownership to be published.
     */
    protected void initPartitionConfig()
        {
        // import com.tangosol.net.partition.VersionedOwnership;
        // import java.util.HashMap;
        
        int     cPartitions = getPartitionCount();
        int     cBackups    = getBackupCount();
        HashMap mapUpdates  = new HashMap();
        
        for (int iPartition = 0; iPartition < cPartitions; ++iPartition)
            {
            mapUpdates.put(Integer.valueOf(iPartition), new VersionedOwnership(cBackups, 0));
            }
        
        // we only want to update the local config map without publishing
        getPartitionConfigMap().updateInternal(mapUpdates, /*fRemove*/false);
        }
    
    // Declared at the super level
    /**
     * Initialize the service config for this member.
    * 
    * @return  the config element to put in the service config map.
     */
    protected com.tangosol.run.xml.XmlElement initServiceConfig()
        {
        // import com.tangosol.net.ActionPolicy;
        // import com.tangosol.net.ConfigurableQuorumPolicy$PartitionedCacheQuorumPolicy as com.tangosol.net.ConfigurableQuorumPolicy.PartitionedCacheQuorumPolicy;
        // import com.tangosol.net.partition.KeyAssociator;
        // import com.tangosol.net.partition.KeyPartitioningStrategy as com.tangosol.net.partition.KeyPartitioningStrategy;
        // import com.tangosol.net.partition.PartitionAssignmentStrategy as com.tangosol.net.partition.PartitionAssignmentStrategy;
        // import com.tangosol.net.partition.SimpleAssignmentStrategy as com.tangosol.net.partition.SimpleAssignmentStrategy;
        // import com.tangosol.run.xml.XmlElement;
        
        // see symmetric logic in #validateServiceConfig
        
        if (getThisMember() != getServiceOldestMember())
            {
            throw new IllegalStateException(
                "Missing ServiceConfigMap from senior=" + getServiceOldestMember().getId());
            }
        
        KeyAssociator associator   = getConfiguredKeyAssociator();
        com.tangosol.net.partition.KeyPartitioningStrategy           partitioning = getConfiguredKeyPartitioningStrategy();
        ActionPolicy  quorumPolicy = getActionPolicy();
        
        String sAssociator   = associator   == null ? "none" : associator.getClass().getName();
        String sPartitioning = partitioning == null ? "none" : partitioning.getClass().getName();
        String sQuorumPolicy = quorumPolicy == null ? "none" : quorumPolicy.getClass().getName();
        
        // There is no chance for this node to become a senior while older version nodes are
        // still around. Since we don't support rolling downgrades, no need to be concerned
        // about backward compatibility during the service config initialization.
        
        // set up the service config values
        XmlElement xmlConfig = super.initServiceConfig();
        
        xmlConfig.addAttribute("partition-count" ).setInt(getPartitionCount());
        xmlConfig.addAttribute("redundancy-count").setInt(getBackupCount());
        xmlConfig.addAttribute("key-associator").setString(sAssociator);
        xmlConfig.addAttribute("key-partitioning").setString(sPartitioning);
        xmlConfig.addAttribute("quorum-policy").setString(sQuorumPolicy);
        
        // Starting with Coherence 12.2.1.1.0 we completely removed the legacy (distributed)
        // strategy, leaving the centralized PartitionAssignmentStrategy as the only option.
        // That means the strategy is only active on a signle (coordinator) node at any give
        // time and there is no need to enforce the identical setup across the cluster anymore.
        // Moreover this allows a strategy change to be performed via a rolling restart.
        
        return xmlConfig;
        }
    
    public PartitionedService.ConverterKeyToBinary instantiateKeyToBinaryConverter(ClassLoader loader, boolean fPassThrough)
        {
        // import com.tangosol.io.Serializer;
        // import com.tangosol.io.pof.ConfigurablePofContext;
        
        PartitionedService.ConverterKeyToBinary conv       =
            (PartitionedService.ConverterKeyToBinary) _newChild("ConverterKeyToBinary");
        Serializer            serializer = ensureSerializer(loader);
        
        if (serializer instanceof ConfigurablePofContext)
            {
            ConfigurablePofContext cpc = (ConfigurablePofContext) serializer;
            if (cpc.isReferenceEnabled())
                {
                cpc = new ConfigurablePofContext(cpc);
                cpc.setReferenceEnabled(false);
                serializer = cpc;
                }
            }
        conv.setSerializer(serializer);
        conv.setPassThrough(fPassThrough);
        
        return conv;
        }
    
    /**
     * Helper to instantiate a $PartitionFilter.
    * 
    * @param nPartition    the partition-id to instantiate a $PartitionFilter
    * for
     */
    public PartitionedService.PartitionFilter instantiatePartitionFilter(int nPartition)
        {
        // import com.tangosol.net.partition.PartitionSet;
        
        PartitionedService.PartitionFilter filter = (PartitionedService.PartitionFilter) _newChild("PartitionFilter");
        PartitionSet     parts  = instantiatePartitionSet(false);
        
        parts.add(nPartition);
        filter.setPartitionSet(parts);
        
        return filter;
        }
    
    /**
     * Helper to instantiate a partition set (with the service's
    * partition-count) containing the specified partition.
     */
    public com.tangosol.net.partition.PartitionSet instantiatePartitionSet(int nPartition)
        {
        // import com.tangosol.net.partition.PartitionSet;
        
        PartitionSet parts = new PartitionSet(getPartitionCount());
        parts.add(nPartition);
        
        return parts;
        }
    
    /**
     * Helper to instantiate a partition set (with the service's
    * partition-count).
    * 
    * @param fFill    true iff the partition-set should be filled, otherwise
    * empty
     */
    public com.tangosol.net.partition.PartitionSet instantiatePartitionSet(boolean fFill)
        {
        // import com.tangosol.net.partition.PartitionSet;
        
        PartitionSet parts = new PartitionSet(getPartitionCount());
        if (fFill)
            {
            parts.fill();
            }
        
        return parts;
        }
    
    // Accessor for the property "ActivePersistence"
    /**
     * Getter for property ActivePersistence.<p>
    * True iff "active" persistence is configured.
     */
    public boolean isActivePersistence()
        {
        return getPersistenceManager() != null;
        }
    
    /**
     * Return true iff partition lock time is cacluated adaptively.
     */
    public boolean isAdaptivePartitionLock()
        {
        return getMaxLockAttempt() > 1;
        }
    
    /**
     * Check whether or not all operations are allowed for this service.
     */
    public boolean isAllAllowed()
        {
        // import com.tangosol.net.PartitionedService$PartitionedAction as com.tangosol.net.PartitionedService.PartitionedAction;
        
        return !isSuspended()
                && getActionPolicy().isAllowed(this, com.tangosol.net.PartitionedService.PartitionedAction.DISTRIBUTE)
                && getActionPolicy().isAllowed(this, com.tangosol.net.PartitionedService.PartitionedAction.RESTORE);
        }
    
    // Accessor for the property "AsyncBackup"
    /**
     * Getter for property AsyncBackup.<p>
    * True if this member is configured to do async backup.
     */
    public boolean isAsyncBackup()
        {
        return __m_AsyncBackup;
        }
    
    /**
     * Return true iff this Member is the backup owner of the specified
    * partition.
     */
    public boolean isBackupOwner(int iPartition)
        {
        return isBackupOwner(iPartition, getThisMember().getId());
        }
    
    /**
     * Return true iff the specified Member is the backup owner of the specified
    * partition.
     */
    public boolean isBackupOwner(int iPartition, int nMember)
        {
        return getOwnedIndex(iPartition, nMember) > 0;
        }
    
    /**
     * Return true iff this Member is the backup owner of the specified resource.
     */
    public boolean isBackupOwner(com.tangosol.util.Binary binKey)
        {
        return isBackupOwner(getKeyPartition(binKey));
        }
    
    public boolean isBackupPersistence()
        {
        return getPersistenceControl().getBackupManager() != null;
        }
    
    // Accessor for the property "Concurrent"
    /**
     * Getter for property Concurrent.<p>
    * True if the service is configured such that it may concurrently process
    * requests.
     */
    public boolean isConcurrent()
        {
        return __m_Concurrent;
        }
    
    // Accessor for the property "DistributionAllowed"
    /**
     * Getter for property DistributionAllowed.<p>
    * True iff partition distribution is currently allowed by the service
    * action policy.
     */
    public boolean isDistributionAllowed()
        {
        // import com.tangosol.net.PartitionedService$PartitionedAction as com.tangosol.net.PartitionedService.PartitionedAction;
        
        return !isSuspended() && getActionPolicy().isAllowed(this, com.tangosol.net.PartitionedService.PartitionedAction.DISTRIBUTE);
        }
    
    // Accessor for the property "DistributionInProgress"
    /**
     * Getter for property DistributionInProgress.<p>
    * Indicates whether or not the service is in the progress of conducting
    * distribution.  Distribution is in progress if the service has a currently
    * active outgoing (sent but not yet answered) request. Note: more then one
    * outgoing request could be active at any given time for the service. 
    * 
    * Note:  Both the service thread and worker threads uses this property.
    * (see PC.onSizeRequest())
     */
    public boolean isDistributionInProgress()
        {
        return getDistributionStrategy().isDistributionInProgress();
        }
    
    // Accessor for the property "DistributionStable"
    /**
     * Getter for property DistributionStable.<p>
    * Specifies whether or not the ownership has stabilized.
     */
    public boolean isDistributionStable()
        {
        return __m_DistributionStable;
        }
    
    // Accessor for the property "DistributionSynchronized"
    /**
     * Getter for property DistributionSynchronized.<p>
    * Specifies whether or not the re-distribution should be deferred until all
    * the configuration updates issued by the previous distribution requests
    * were confirmed by the service senior.
    * 
    * @since Coherence 3.2
     */
    public boolean isDistributionSynchronized()
        {
        return __m_DistributionSynchronized;
        }
    
    // Accessor for the property "Finalizing"
    /**
     * Getter for property Finalizing.<p>
    * Set to true when the Service has been welcomed by other members of the
    * service but finalizing the startup must be deferred due to lack of member
    * or partition configuration.
    * 
    * @see onNotify()
     */
    protected boolean isFinalizing()
        {
        return __m_Finalizing;
        }
    
    // Accessor for the property "LogPartitionTraceEvents"
    /**
     * Getter for property LogPartitionTraceEvents.<p>
    * Whether tracing of partition events should be sent to log.
     */
    public boolean isLogPartitionTraceEvents()
        {
        return (getPartitionTraceEvents() & 0x2) != 0;
        }
    
    public boolean isOwnershipChangeInProgress()
        {
        // import com.tangosol.net.partition.PartitionSet;
        
        if (getTransferControl().isInProgress())
            {
            return true;
            }
        
        // ensure delivery for $TransferRespond, PartitionedService.BackupAssignment or PartitionVersionSynRequest;
        // otherwise consider transfer "in-progress".
        PartitionSet parts = collectOwnedPartitions(/*fPrimary*/ true);
        for (int iPart = parts.next(0); iPart >= 0; iPart = parts.next(iPart + 1))
            {
            if (getPartitionControl(iPart).isTransferDisallowed())
                {
                return true;
                }
            }
        
        return false;
        }
    
    /**
     * Determine whether or not the specified Member is ownership disabled.
     */
    public boolean isOwnershipDisabled(com.tangosol.coherence.component.net.Member member)
        {
        return getOwnershipStatus(member) == OWNERSHIP_DISABLED;
        }
    
    // Accessor for the property "OwnershipEnabled"
    /**
     * Getter for property OwnershipEnabled.<p>
    * Specifies whether or not the local ownership is enabled for this Member.
     */
    public boolean isOwnershipEnabled()
        {
        return __m_OwnershipEnabled;
        }
    
    // Accessor for the property "OwnershipEnabled"
    /**
     * Determine whether or not the specified Member is ownership enabled.
     */
    public boolean isOwnershipEnabled(com.tangosol.coherence.component.net.Member member)
        {
        return getOwnershipStatus(member) == OWNERSHIP_ENABLED;
        }
    
    /**
     * Determine whether or not the specified Member is in the process of
    * becoming ownership enabled.
     */
    public boolean isOwnershipPending(com.tangosol.coherence.component.net.Member member)
        {
        return getOwnershipStatus(member) == OWNERSHIP_PENDING;
        }
    
    // Accessor for the property "PartitionTraceEventsEnabled"
    /**
     * Getter for property PartitionTraceEventsEnabled.<p>
    * Whether tracing of partition events is enabled.
     */
    public boolean isPartitionTraceEventsEnabled()
        {
        return getPartitionTraceEvents() > 0;
        }
    
    /**
     * Return true iff the specified partition is vulnerable.  If the "strict"
    * definition is specified, a partition is vulnerable if any of the primary
    * or backup copies are located on the same machine as one another. 
    * Otherwise, a partition is vulnerable if the primary and all backups are
    * on the same machine.
    * 
    * @param fStrict    use a "strict" definition of vulnerability
     */
    public boolean isPartitionVulnerable(int iPartition, boolean fStrict)
        {
        return fStrict ?
            getBackupStrength(iPartition, /*fLocal*/ false) < BACKUP_STRENGTH_MACHINE :
            isPartitionVulnerableLegacy(iPartition);
        }
    
    /**
     * Check if a partition is vulnerable in the 'non-strict' sense. Used only
    * in the legacy PartitionService$AutonomousDistribution strategy.
     */
    protected boolean isPartitionVulnerableLegacy(int iPartition)
        {
        // import Component.Net.Member;
        // import java.util.Iterator;
        
        // Note: this method is only used by the JMX;
        // see ServiceModel#getPartitionsVulnerable()
        
        if (getBackupCount() > 0)
           {
           Member memberPrime = getPrimaryOwner(iPartition);
        
           if (memberPrime != null)
               {
               for (Iterator iter = getBackupOwners(iPartition).iterator(); iter.hasNext();)
                   {
                   Member memberBackup = (Member) iter.next();
        
                   if (memberPrime.getMachineId() != memberBackup.getMachineId())
                       {
                       return false;
                       }
                   }
               }
           }
        
        return true;
        }
    
    // Accessor for the property "PersistEvents"
    /**
     * Getter for property PersistEvents.<p>
    * True iff "active" persistence is configured.
     */
    public boolean isPersistEvents()
        {
        return getPersistenceControl().getEventsManager() != null;
        }
    
    /**
     * Return true iff this Member is the primary owner of the specified
    * partition.
     */
    public boolean isPrimaryOwner(int iPartition)
        {
        if (getPartitionAssignments()[iPartition][0] == getThisMember().getId())
            {
            PartitionedService.PartitionControl control = getPartitionControl(iPartition);
            if (control.isLocked())
                {
                // Do not consider the partition to be fully "owned" if we are still in the
                // process of receiving the incoming transfer or sending the outgoing transfer
                //
                // Note: the "receive" operation itself is asynchronous through both the
                //       UEM dispatchers as well as pending delivery notification of the transfer
                //       response to the sender.  See #onFinalizeReceivePrimary.
        
                int nLockType = control.getLockType();
                return nLockType != PartitionedService.PartitionControl.LOCK_PERSISTENCE     &&
                       nLockType != PartitionedService.PartitionControl.LOCK_PRIMARY_XFER_IN &&
                       nLockType != PartitionedService.PartitionControl.LOCK_PRIMARY_XFER_OUT;
                }
            else
                {
                return true;
                }
            }
        else
            {
            return false;
            }
        }
    
    /**
     * Return true iff this Member is the primary owner of the specified
    * resource.
     */
    public boolean isPrimaryOwner(com.tangosol.util.Binary binKey)
        {
        return isPrimaryOwner(getKeyPartition(binKey));
        }
    
    /**
     * Return true if the specified partition is being recoverd.
     */
    public boolean isRecovering(int nPartition)
        {
        return getPartitionControl(nPartition).isRecovering();
        }
    
    /**
     * Return true iff recovering the orphaned partitions is currently allowed
    * by the service action policy.
    * 
    * @param partsOrphan    the set of orphaned partitions
    * @param asGUID              the set of persistent GUIDs known to
    * ownership-enabled members of the service
     */
    public boolean isRecoverPartitionsAllowed(com.tangosol.net.partition.PartitionSet partsOrphan, com.tangosol.persistence.GUIDHelper.GUIDResolver resolver, com.tangosol.net.internal.QuorumInfo info)
        {
        // import com.tangosol.net.PartitionedService$PartitionRecoveryAction as com.tangosol.net.PartitionedService.PartitionRecoveryAction;
        
        if (isSuspended())
            {
            return false;
            }
        
        if (!isActivePersistence() || getPersistenceControl().isForceRecovery())
            {
            return true;
            }
        
        return getActionPolicy().isAllowed(this, new com.tangosol.net.PartitionedService.PartitionRecoveryAction(partsOrphan, resolver, info));
        }
    
    // Accessor for the property "RecoveryInProgress"
    /**
     * Return true if recovery is in progress.
     */
    public boolean isRecoveryInProgress()
        {
        return getPersistenceControl().getActiveRecoveryRequests().get() > 0;
        }
    
    /**
     * True if this thread is processing PartitionRecoverRequest, otherwise null
    * or false.
     */
    public boolean isRecoveryThread()
        {
        Boolean fRecoveryThread = (Boolean) getTLORecoveryThread().get();
        
        return fRecoveryThread != null && fRecoveryThread.booleanValue();
        }
    
    // Accessor for the property "RestoreInProgress"
    /**
     * Getter for property RestoreInProgress.<p>
    * Indicates whether or not the service is in the process of restoring from
    * backup. 
    * 
    * Note:  Both the service thread and worker threads use this property (see
    * PC.onSizeRequest()).
     */
    public boolean isRestoreInProgress()
        {
        return __m_RestoreInProgress;
        }
    
    // Accessor for the property "RestorePartitionAllowed"
    /**
     * Getter for property RestorePartitionAllowed.<p>
    * True iff restoring orphaned partitions is currently allowed by the
    * service action policy.
     */
    public boolean isRestorePartitionAllowed()
        {
        // import com.tangosol.net.PartitionedService$PartitionedAction as com.tangosol.net.PartitionedService.PartitionedAction;
        
        return !isSuspended() && getActionPolicy().isAllowed(this, com.tangosol.net.PartitionedService.PartitionedAction.RESTORE);
        }
    
    // Accessor for the property "ScheduledBackups"
    /**
     * Getter for property ScheduledBackups.<p>
    * True if this member is configured to do scheduled backup.
     */
    public boolean isScheduledBackups()
        {
        return getAsyncBackupInterval() > 0L;
        }
    
    /**
     * Return true if the provided PersistenceManager is based on a persisted
    * snapshot.
     */
    public boolean isSnapshotManager(com.oracle.coherence.persistence.PersistenceManager mgrRecover)
        {
        return mgrRecover != getPersistenceManager();
        }
    
    // Accessor for the property "StorePartitionTraceEvents"
    /**
     * Getter for property StorePartitionTraceEvents.<p>
    * Whether tracing of partition events should be stored.
     */
    public boolean isStorePartitionTraceEvents()
        {
        return (getPartitionTraceEvents() & 0x1) != 0;
        }
    
    // Declared at the super level
    /**
     * Getter for property SuspendedFully.<p>
    * As opposed to the Suspended this property indicates if the service has
    * finished the process of suspending itself, i.e. it has ensured that all
    * in-flight operations have completed.   Note this only refers to
    * operations which are "owned" by this service instance as we cannot
    * locally prevent new operations coming in from the outside and must still
    * honor them even while fully suspended in order to let our peers also
    * fully suspend.  Thus from a clustered perspective a service is not
    * finished suspending until all its members have become fully suspended.
    * 
    * This property has no specific meaning if the service is not suspend.
     */
    public boolean isSuspendedFully()
        {
        // import com.tangosol.net.partition.PartitionSet;
        
        if (super.isSuspendedFully())
            {
            PartitionSet parts = getOwnedPartitions(getThisMember());
            PartitionedService.PartitionControl[] actrlPartition = getPartitionControl();
            for (int nPartition = parts.next(0); nPartition >= 0;
                 nPartition = parts.next(nPartition + 1))
                {
                PartitionedService.PartitionControl ctrl = actrlPartition[nPartition];
                if (ctrl != null)
                    {
                    if (ctrl.getPersistenceTasks().get() > 0)
                        {
                        return false;
                        }
                    }
                }
        
            return !isOwnershipEnabled() ||
                   !isDistributionInProgress() && !isOwnershipChangeInProgress();
            }
        
        return false;
        }
    
    // Accessor for the property "TransferInProgress"
    /**
     * Getter for property TransferInProgress.<p>
    * Indicates whether or not this service has a currently active outgoing
    * TransferRequest.
     */
    public boolean isTransferInProgress()
        {
        return getTransferControl().isInProgress();
        }
    
    /**
     * Return true iff the suggested transfer (which is a "move",  not a "copy")
    * will make the backup vulnerable.
     */
    public boolean isTransferVulnerable(int iPartition, int iStorage, com.tangosol.coherence.component.net.Member memberTo)
        {
        // import Component.Net.Member;
        // import java.util.Iterator;
        // import java.util.List;
        // import java.util.Set;
        
        _assert(memberTo != null);
        
        if (getBackupCount() > 0)
            {
            int  nMachineTo = memberTo.getMachineId();
            List listOwners = getBackupOwners(iPartition);
        
            // optimize simple cases when setOwners is immutable
            switch (listOwners.size())
                {
                case 0:
                    return true;
        
                case 1:
                    if (iStorage > 0)
                        {
                        // this member is and remains the primary owner, but backup is moving to memberTo
                        Member memberPrimary = getThisMember();
                        return memberPrimary.getMachineId() == nMachineTo;
                        }
                    else
                        {
                        // backup(s) stay as is, but the primary ownership moves from this member to memberTo
                        Member memberBackup = (Member) listOwners.iterator().next();
                        return memberBackup.getMachineId() == nMachineTo;
                        }
        
                default:
                    if (iStorage > 0)
                        {
                        listOwners.add(getThisMember());
        
                        Member memberBackup = (Member) getBackupOwner(iPartition, iStorage);
                        if (memberBackup != null)
                            {
                            listOwners.remove(memberBackup);
                            }
                        }
        
                    for (Iterator iter = listOwners.iterator(); iter.hasNext();)
                        {
                        Member member = (Member) iter.next();
                        if (member.getMachineId() == nMachineTo)
                            {
                            return true;
                            }
                        }
                    return false;
                }
            }
        return true;
        }
    
    /**
     * Check whether or not the vulnerability is avoidable for the specified
    * MemberSet of ownership enabled members.
     */
    public boolean isVulnerabilityAvoidable(com.tangosol.coherence.component.net.MemberSet setOwners)
        {
        // import Component.Net.Member;
        // import java.util.Iterator;
        // import java.util.HashMap;
        // import java.util.Set;
        
        int cMembers = setOwners.size();
        int cBackups = getBackupCount();
        
        if (cMembers <= 1 || cBackups == 0)
            {
            return false;
            }
        
        HashMap mapCount = new HashMap(); // key = machineId; value = # of members
        
        for (Iterator iter = setOwners.iterator(); iter.hasNext();)
            {
            Member member = (Member) iter.next();
        
            Integer IMachine = Integer.valueOf(member.getMachineId());
            Integer ICount   = (Integer) mapCount.get(IMachine);
            int     nCount   = ICount == null ? 1 : ICount.intValue() + 1;
        
            if (nCount * (cBackups + 1) >= cMembers)
                {
                // Consider the number of members belonging to a specific group (e.g. a
                // machine, rack or site) to be given by m_i.  If there are K distinct
                // groups the counts of members-per-group can be expressed as
                // m_1, m_2, ... m_K where:
                //
                // 1) let CMembers = Sum(m_1, ..., m_K)
                // 2) m_1 <= m_2 <= ... <= m_(K-1) <= m_K
                //
                // With a backup-count = B, the "worst-case" number of members' worth of
                // primary partitions that could be lost and should be tolerated is:
                //
                // sum of the members in the largest K groups
                // 3) let MaxLost = m_(K-B-1), ... m_(K-1), m_K
                //
                // In order for the loss of that many members' worth of partitions to be
                // tolerated, the surviving members must have enough backup-storage (in
                // the trivially balanced case) to compensate:
                //
                // 4) B (CMembers - MaxLost) >= MaxLost
                //
                // therefore, it follows:
                //
                // B*CMembers - B*MaxLost >= MaxLost
                // B*CMembers >= MaxLost + B*MaxLost
                // B*CMembers >= (B + 1)*MaxLost
                //
                // If we take a conservative approximation that:
                //
                // m_(K-B-1) ~= m_(K-B-2) ~= ... ~= m_(K-1) ~= m_K
                //
                // then MaxLost is conservatively estimated as:
                //
                // MaxLost ~= B*m_K
                //
                // therefore:
                // B*CMembers >= (B + 1)*(B*m_K)
                // B*CMembers >= B*(B + 1)*(m_K)
                // CMembers >= (B + 1)*(m_K)
        
                return false;
                }
        
            mapCount.put(IMachine, Integer.valueOf(nCount));
            }
        
        return true;
        }
    
    /**
     * Lock the partitions before recovery process starts and assign any
    * orphaned partitions.
     */
    public java.util.Map lockForRecovery(PartitionedService.PartitionRecoverRequest msgRequest)
        {
        // import com.oracle.coherence.persistence.PersistenceManager;
        // import com.tangosol.net.partition.Ownership;
        // import com.tangosol.net.partition.PartitionSet;
        // import com.tangosol.net.internal.PartitionRecoverInfo;
        // import com.tangosol.persistence.GUIDHelper;
        // import com.tangosol.util.LiteMap;
        // import com.tangosol.util.LongArray;
        // import com.tangosol.util.SparseArray;
        // import java.util.ArrayList;
        // import java.util.HashMap;
        // import java.util.List;
        // import java.util.Map;
        
        // lock all partitions that we will attempt to recover in parallel
        
        String[] asGUIDs   = msgRequest.getGUIDs();
        int      cGUIDs    = asGUIDs.length;  
        Map      mapUpdate = new HashMap(cGUIDs);
        
        for (int i = 0; i < cGUIDs; i++)
            {
            String sGUID      = asGUIDs[i];
            int    nPartition = GUIDHelper.getPartition(sGUID);
        
            PartitionedService.PartitionControl ctrlPart = ensurePartitionControl(nPartition);
            if (ctrlPart.isLocked() && ctrlPart.getLockType() == PartitionedService.PartitionControl.LOCK_PERSISTENCE)
                {
                // partition can be subject of recovery attempt from another request received concurrently;
                // prevent from trying to recover more than once (and potentially terminate the service
                // due to FatalException after first request unlocks...)
                continue;
                }
            ctrlPart.lock(-1L, PartitionedService.PartitionControl.LOCK_PERSISTENCE);

            _assert(getPrimaryOwner(nPartition) == null);
        
            // the common flow is to maintain and increment the global versioning for
            // each partition, however if versioning information is absent (partition
            // has not been assigned during the lifetime of this service) align the
            // version with the version being recovered from; this version will be
            // incremented during assignPrimaryPartition
            if (getOwnershipVersion(nPartition) == 0)
                {
                setOwnershipVersion(nPartition, (int) GUIDHelper.getVersion(sGUID));
                }
        
            // this increments the partition ownership version
            Ownership owners = assignPrimaryPartition(nPartition, 'r');
            mapUpdate.put(Integer.valueOf(nPartition), owners);
            }
        
        // assign all partitions while on the service thread, asynchronously creating
        // persistent stores
        
        Map          mapAssigned = new LiteMap();
        PartitionSet partsAssign = msgRequest.getPartsAssign(); 
        if (!partsAssign.isEmpty())
            {
            int[][]              aaiOwner      = getPartitionAssignments();
            int                  cPartitions   = aaiOwner.length;
            PartitionedService.PartitionConfig.Map mapConfig     = getPartitionConfigMap();
            PartitionSet         partsAssigned = null;
            PartitionSet         partsLost     = null;
        
            // assign primary for partsAssign
            for (int iPartition = partsAssign.next(0); iPartition >= 0;
                     iPartition = partsAssign.next(iPartition + 1))
                {
                int nOwner = aaiOwner[iPartition][0];
                if (nOwner == 0)
                    {
                    PartitionedService.PartitionControl ctrlPart = ensurePartitionControl(iPartition);
        
                    if (checkLockRequired())
                        {
                        // lock to prevent processing client requests prematurely
                        ctrlPart.lock(-1L, PartitionedService.PartitionControl.LOCK_PERSISTENCE);
                        }
        
                    Ownership owners = assignPrimaryPartition(iPartition, 'r');
        
                    mapAssigned.put(Integer.valueOf(iPartition), owners);
        
                   if (mapConfig.isAssignmentCompleted(iPartition))
                        {
                        if (partsLost == null)
                            {
                            partsLost = new PartitionSet(cPartitions);
                            }
                        partsLost.add(iPartition);
                        }
                    else
                        {
                        if (partsAssigned == null)
                            {
                            partsAssigned = new PartitionSet(cPartitions);
                            }
                        partsAssigned.add(iPartition);
                        }
                    }
                else
                    {
                    // should not happen; soft assert
                    _trace("Unable to assign orphaned partition " + iPartition
                         + "; current owner is member " + nOwner, 2);
                    partsAssign.remove(iPartition);     
                    }
                }
        
            msgRequest.setPartsAssigned(partsAssigned);
            msgRequest.setPartsLost(partsLost);
            msgRequest.setMapAssigned(mapAssigned);
            }
        
        return mapUpdate;
        }
    
    /**
     * Move the specified partition from one store index to another. Called on
    * the service thread only.
    * 
    * @param iPartition  the partition number to move
    * @param iBackupTo  the store index to move the partition to (zero for
    * primary store)
    * 
    * @see #preparePartition, releasePartition, transferPartition,
    * receivePartition
     */
    protected void movePartition(int iPartition, int iBackupTo)
        {
        // import com.oracle.coherence.persistence.PersistentStore as com.oracle.coherence.persistence.PersistentStore;
        // import com.tangosol.persistence.CachePersistenceHelper as com.tangosol.persistence.CachePersistenceHelper;
        
        if (isActivePersistence())
            {
            PartitionedService.PartitionControl ctrl = getPartitionControl(iPartition);
            if (iBackupTo > 0)
                {
                // primary to backup: delete the persistent store
                ctrl.deletePersistentStore();
                
                if (isBackupPersistence())
                    {
                    // create the backup store
                    com.oracle.coherence.persistence.PersistentStore store = ctrl.ensurePersistentStore(null, /*fEventsStore*/ false, /*fBackupStore*/ true);
        
                    // do not save quorum into backup store at this point
        
                    if (!isExiting() && getServiceState() != SERVICE_STOPPING)
                        {
                        com.tangosol.persistence.CachePersistenceHelper.seal(store, this, /*oToken*/ null);
                        }
                    }
                }
            else
                {
                if (isBackupPersistence())
                    {
                    // delete backup store
                    ctrl.deleteBackupPersistentStore();
                    }
        
                // backup to primary
                saveQuorum(iPartition);
        
                if (!isExiting() && getServiceState() != SERVICE_STOPPING)
                    {
                    // seal the events store first
                    com.oracle.coherence.persistence.PersistentStore storeEvents = ctrl.getPersistentEventsStore();
                    if (storeEvents != null)
                        {
                        com.tangosol.persistence.CachePersistenceHelper.seal(storeEvents, this, /*oToken*/ null);
                        }

                    com.tangosol.persistence.CachePersistenceHelper.seal(ctrl.ensurePersistentStore(), this, /*oToken*/ null);
                    }
                }
            }
        }
    
    /**
     * Called (on the service thread) when a BackupAssignment message is
    * received.
     */
    public void onBackupAssignment(PartitionedService.BackupAssignment msgAssignment)
        {
        // import Component.Net.Member;
        // import Component.Net.MemberSet;
        // import com.tangosol.net.partition.VersionedOwnership;
        
        int                iPartition  = msgAssignment.getPartition();
        int                iStore      = msgAssignment.getStore();
        Member             memberFrom  = msgAssignment.getFromMember();
        Member             memberThis  = getThisMember();
        int                nMemberFrom = memberFrom.getId();
        int                nMemberThis = memberThis.getId();
        int[][]            aaiOwner    = getPartitionAssignments();      // local assignments
        VersionedOwnership owners      = getPartitionConfig(iPartition); // global assignments
        MemberSet          setMembers  = getServiceMemberSet();
        
        _assert(iStore != 0);
        if (msgAssignment.isRelease())
            {
            if (aaiOwner[iPartition][iStore] == nMemberThis)
                {
                // we currently hold the backup ownership and were told to release
                // by either the primary, or the new backup owner.  Update the
                // local partition assignments, release the partition, and notify
                // the primary owner to announce
        
                PartitionedService.PartitionControl control    = getPartitionControl(iPartition);
                int               nBackupNew = msgAssignment.getNewBackupOwner();
        
                if (!setMembers.contains(nBackupNew))
                    {
                    nBackupNew = 0;
                    }
                assignPartitionOwner(iPartition, iStore, nBackupNew);
                releasePartition(iPartition, iStore);
                releasePartitionControl(iPartition);
        
                // if the primary owner is alive, notify it to announce
                //
                // COH-4520: use the primary owner carried by the BackupAssignment, as
                //           it is possible that the primary owner has changed but we
                //           didn't hear about it yet.
                Member memberOwner = setMembers.getMember(msgAssignment.getPrimaryOwner());
                if (memberOwner != null)
                    {
                    getTransferControl().sendBackupAnnounce(iPartition, iStore, memberOwner, null);
                    }
                }
            else if (aaiOwner[iPartition][0] == nMemberThis)
                {
                // we are the primary owner and received a RELEASE.  This must be
                // from the "old" backup owner.  Declare and publish that this
                // backup index is endangered.
        
                if (owners.getOwner(iStore) == nMemberFrom)
                    {
                    aaiOwner[iPartition][iStore] = 0;
                    publishPartitionOwnership(iPartition, iStore, 0);
                    }
                else
                    {
                    // we received a release command from a member that was not the
                    // old backup owner; ignore it and log a warning
                    _trace("Ignoring BackupAssignment for partition " + iPartition
                         + " (" + iStore + ") received from member " + nMemberFrom, 2);
                    }
                }
            else
                {
                // we received a command to release a partition backup that we no
                // longer own; nothing can be done other than to ignore it
                _trace("Ignoring BackupAssignment for un-owned backup(" + iStore
                      +") of partition " + iPartition + " from member " + nMemberFrom, 2);
                }
            }
        else // ANNOUNCE command
            {
            if (aaiOwner[iPartition][0] == nMemberThis)
                {
                // the ANNOUNCE could be received:
                // 1) from the new backup owner if
                //   a) there is no old owner (was endangered)
                //   b) it is confirming a transfer (see #validatePartitionAssignments)
                // 2) from the old backup owner if
                //   a) the new backup owner sent it a RELEASE (normal, common case)
                //   b) the new backup owner died, and we sent the old owner a CONFIRM
                //      update and publish the ownership
                // 3) from a backup-owner requesting the announcement of pending local
                //    assignments changes for all storage indices (e.g. as a result of
                //    a backup swap).  In this case, iStore == -1.
                if (iStore >= 0)
                    {
                    int nBackupLocal  = aaiOwner[iPartition][iStore];
                    int nBackupGlobal = owners.getOwner(iStore);
        
                    if (nMemberFrom == nBackupGlobal || // from the old backup owner
                        nMemberFrom == nBackupLocal)    // from the new backup owner
                        {
                        if (nBackupLocal == nBackupGlobal)
                            {
                            // case 1b, 2b; nothing to do
                            }
                        else
                            {
                            // cases 1a, 2a; publish the new backup owner globally
                            owners = new VersionedOwnership(owners);
                            owners.setOwner(iStore, nBackupLocal);
                            putPartitionConfig(iPartition, owners);
                            }
                        }
                    else
                        {
                        // we received an 'announce' command from a member that is
                        // neither the new nor the old backup owner
                        _trace("Ignoring unsolicited BackupAssignment announcement for partition "
                             + iPartition + " (backup " + iStore +") from member " + nMemberFrom
                             + "; (local=" + nBackupLocal + ", global=" + nBackupGlobal + ")", 2);
                        }
                    }
                else
                    {
                    // case 3: announce all storage indices
                    owners = new VersionedOwnership(owners);
                    owners.setOwners(aaiOwner[iPartition]);
        
                    putPartitionConfig(iPartition, owners);
                    }
        
                // backup ownership is fully announced now; re-enable the transfer
                getPartitionControl(iPartition).enableTransfer();
                }
            else
                {
                // we received a notification to announce the new ownership for
                // a partition that we are no longer the owner for
                _trace("Ignoring BackupAssignment announcement for un-owned partition "
                     + iPartition + " (backup " + iStore + ") from member "+ nMemberFrom, 2);
                }
            }
        }
    
    /**
     * Called (on the service thread) when a BackupConfirmRequest message is
    * received.
     */
    public void onBackupConfirmRequest(PartitionedService.BackupConfirmRequest msgConfirm)
        {
        // import Component.Net.Member;
        
        int    iPartition = msgConfirm.getPartition();
        int    iStore     = msgConfirm.getStore();
        Member memberFrom = msgConfirm.getFromMember();
        
        _assert(iStore != 0);
        
        // The BackupConfirmRequest is sent by the primary owner to either
        // - the old backup owner following the death of the new backup owner.
        //   The old owner must be confirmed, as it may or may not have received
        //   a RELEASE from the new backup owner before it departed.
        // - the new backup owner following the death of the old backup owner.
        //   This confirmation is sent if the old backup owner's death is detected
        //   before the new backup has acknowledged transfer receipt.  The confirmation
        //   is used to "force" the cycle to complete before the new ownership can
        //   be published (the only possible response is ANNOUNCE).
        //   See #validatePartitionAssignments.
        //
        // The request asks the backup owner to confirm or deny the backup ownership
        
        if (getPartitionAssignments()[iPartition][iStore] == getThisMember().getId())
            {
            // we still own the partition backup (we never received a RELEASE).
            // Because the BackupConfirmRequest is deferred until the departing member
            // has been removed from the service, we know that we will not receive a
            // RELEASE in the future.
            getTransferControl().sendBackupAnnounce(iPartition, iStore, memberFrom, msgConfirm);
            }
        else
            {
            // we have already released the backup; send the release notice
            // directly to the CONFIRM requestor (which must be the primary owner)
            getTransferControl().sendBackupRelease(
                    iPartition, iStore, memberFrom.getId(), 0, memberFrom, msgConfirm);
            }
        }
    
    // Declared at the super level
    /**
     * This event occurs when dependencies are injected into the component. 
    * Unless this is a base component, call super.onDependencies to allow all
    * super components to process the Dependencies.  Each component is free to
    * chose how it consumes dependencies.  Typically, the  dependencies are
    * copied into the component's properties.  This technique isolates
    * Dependency Injection from the rest of the component code since components
    * continue to access properties just as they did before. 
    * 
    * However, for read-only dependency properties, the component can access
    * the dependencies directly as shown in the example below for
    * PartitionedCache dependencies.  The advantage to this technique is that
    * the property only exists in the dependencies object, it is not duplicated
    * in the component properties.
    * 
    * PartitionedCacheDependencies deps = (PartitionedCacheDependencies)
    * getDependencies();
    * deps.getFoo();
    * 
     */
    protected void onDependencies(com.tangosol.net.ServiceDependencies deps)
        {
        // import com.oracle.coherence.common.util.Duration;
        // import com.tangosol.coherence.config.Config;
        // import com.tangosol.coherence.config.builder.ParameterizedBuilder;
        // import com.tangosol.internal.net.service.grid.PartitionedServiceDependencies;
        // import com.tangosol.net.partition.PartitionAssignmentStrategy;
        // import com.tangosol.net.partition.PartitionListener;
        // import com.tangosol.net.partition.SimpleAssignmentStrategy;
        // import java.util.Iterator;
        // import java.util.List;
        
        super.onDependencies(deps);
        
        PartitionedServiceDependencies depsPS = (PartitionedServiceDependencies) deps;
        
        setBackupCount(depsPS.getPreferredBackupCount());
        setDistributionAggressiveness(depsPS.getDistributionAggressiveness());
        setDistributionSynchronized(depsPS.isDistributionSynchronized());
        setConfiguredKeyAssociator(depsPS.getKeyAssociator());
        setKeyAssociator(depsPS.getKeyAssociator());
        setConfiguredKeyPartitioningStrategy(depsPS.getKeyPartitioningStrategy());
        setKeyPartitioningStrategy(depsPS.getKeyPartitioningStrategy());
        setOwnershipEnabled(depsPS.isOwnershipCapable());
        setPartitionCount(depsPS.getPreferredPartitionCount());
        setTransferThreshold(depsPS.getTransferThreshold());
        setAsyncBackup(depsPS.isAsyncBackupEnabled());
        
        Duration asyncBackupInterval = depsPS.getAsyncBackupInterval();
        long     cBackupInterval     = asyncBackupInterval == null
                          ? -1L : asyncBackupInterval.getNanos() / 1000000;
                
        if (cBackupInterval > 0L && getBackupCount() > 0L)
            {
            if (depsPS.getWorkerThreadCountMin() > 0)
                {
                setAsyncBackupInterval(cBackupInterval);
                }
            else
                {
                _trace("Reverting scheduled backups due to thread pool being disabled", 2);
                }
            }
        
        // instantiate and save the distribution strategy and partition assignment strategy
        PartitionAssignmentStrategy pas = depsPS.getPartitionAssignmentStrategyBuilder().
                realize(createResolver(), getContextClassLoader(), null);
        if (pas == null)
            {
            pas = new SimpleAssignmentStrategy();
            }
        
        PartitionedService.CentralDistribution strategy = (PartitionedService.CentralDistribution) _newChild("CentralDistribution");
        strategy.setService(this);
        strategy.setPartitionAssignmentStrategy(pas);
        
        setDistributionStrategy(strategy);
        
        if (isOwnershipEnabled())
            {
            // add the partition listeners
            List listBuilders = depsPS.getPartitionListenerBuilders();
            if (listBuilders != null)
                {
                for (Iterator iter = listBuilders.iterator(); iter.hasNext(); )
                    {
                    ParameterizedBuilder bldr = (ParameterizedBuilder) iter.next();
        
                    addPartitionListener((PartitionListener) bldr.realize(createResolver(), getContextClassLoader(), null));
                    }
                }
        
            setPersistenceDependencies(depsPS.getPersistenceDependencies());
            }
        
        String sTraceEvents = Config.getProperty("coherence.distributed.partition.events", "store");
        
        String[] asTraceModes = sTraceEvents.toLowerCase().split(",");
        int nTraceEvents = 0;
        for (int i = 0, c = asTraceModes.length; i < c; ++i)
            {
            if ("none".equals(asTraceModes[i]))
                {
                nTraceEvents |= 0x0;
                }
            if ("store".equals(asTraceModes[i]))
                {
                nTraceEvents |= 0x1;
                }
            else if ("log".equals(asTraceModes[i]))
                {
                nTraceEvents |= 0x2;
                }
            }
        setPartitionTraceEvents(nTraceEvents);
        
        long cLockWait    = getDistributionContendMillis();
        long cMaxLockWait = Config.getLong("coherence.distributed.lock.wait", cLockWait).longValue();
        setMaxContendMillis(cMaxLockWait);
        setMaxLockAttempt(Config.getInteger("coherence.distributed.lock.attempt", cLockWait == cMaxLockWait ? 1 : 10).intValue());
        }
    
    // Declared at the super level
    /**
     * Event notification called once the daemon's thread starts and before the
    * daemon thread goes into the "wait - perform" loop. Unlike the
    * <code>onInit()</code> event, this method executes on the daemon's thread.
    * 
    * Note1: this method is called while the caller's thread is still waiting
    * for a notification to  "unblock" itself.
    * Note2: any exception thrown by this method will terminate the thread
    * immediately
    * Note3: most commonly, the assumption is that onEnter() method executes
    * while the service state is "SERVICE_INITIAL", so it is important for the
    * subclasses to make the super.onEnter() call at the very end
     */
    protected void onEnter()
        {
        // import com.oracle.coherence.persistence.PersistenceEnvironment;
        // import com.tangosol.coherence.config.Config;
        // import com.tangosol.coherence.config.builder.ParameterizedBuilder;
        // import com.tangosol.internal.net.service.grid.PersistenceDependencies;
        // import com.tangosol.persistence.SnapshotArchiver;
        // import com.tangosol.persistence.SnapshotArchiverFactory;
        
        // check the license
        try
            {
            new com.tangosol.license.CoherenceCommunityEdition();
            }
        catch (Exception e)
            {
            setMsgCAE(e.getMessage());
            }
        
        // if this member is ownership-enabled, start as an ownership in-progress
        // member; turn on ownership only after configuration is validated
        // (see #validateMemberConfig, #validatePartitionConfig)
        boolean fOwnershipEnabled = isOwnershipEnabled();
        
        getThisMemberConfigMap().put("ownership-enabled",
            Integer.valueOf(fOwnershipEnabled ? OWNERSHIP_PENDING : OWNERSHIP_DISABLED));
        
        // configure the deferred backup timeout; default to packet timeout
        String sDelayMillis = Config.getProperty("coherence.distributed.deferredbackuptimeout");
        setDeferredBackupTimeoutMillis(sDelayMillis == null
                ? getClusterService().getDeliveryTimeoutMillis()
                : Long.parseLong(sDelayMillis));
        
        // configure persistence
        PartitionedService.PersistenceControl     ctrlPersistence = (PartitionedService.PersistenceControl) _newChild("PersistenceControl");
        setPersistenceControl(ctrlPersistence);
        
        if (fOwnershipEnabled)
            {
            PersistenceDependencies depsPersistence = getPersistenceDependencies();
            ParameterizedBuilder    bldr            = depsPersistence == null ? null
                : depsPersistence.getPersistenceEnvironmentBuilder();
        
            if (bldr != null)
                {
                // configure the persistence manager
                PersistenceEnvironment env = (PersistenceEnvironment)
                    bldr.realize(createResolver(), getContextClassLoader(), null);
        
                ctrlPersistence.setActiveFailureMode(depsPersistence.getFailureMode());
                ctrlPersistence.setAsync(depsPersistence.isAsync());
                ctrlPersistence.setPersistenceEnvironment(env);
        
                // inject the snapshot archiver if any
                SnapshotArchiver        archiver        = null;
                SnapshotArchiverFactory factoryArchiver = depsPersistence.getArchiverFactory();
                if (factoryArchiver != null)
                    {
                    archiver = factoryArchiver.createSnapshotArchiver(
                                 getCluster().getClusterName(), getServiceName());
                    ctrlPersistence.setSnapshotArchiver(archiver);
                    }
                }
            }
        
        super.onEnter();
        }
    
    // Declared at the super level
    /**
     * Event notification called right before the daemon thread terminates. This
    * method is guaranteed to be called only once and on the daemon's thread.
     */
    protected void onExit()
        {
        // import com.oracle.coherence.persistence.PersistenceManager;
        
        if (!getPreprocessingGate().close(1000L)) // similar to Service.onExit's join of the worker threads
            {
            _trace("timeout waiting for " + getPreprocessingGate().getActiveCount() + " preprocessing threads to complete; abandoning", 2);
            }
        
        // release persistence control before we call onExit to ensure the
        // mbean is unregistered prior to restarting this service
        getPersistenceControl().release();
        
        super.onExit();
        
        // detach the partition and service config listeners
        getServiceConfigMap()  .getConfig().removeConfigListener();
        getPartitionConfigMap().getConfig().removeConfigListener();
        }
    
    /**
     * Finalizes the primary assignment process.  This method is called after
    * the last event have been raised to publish the batch config update
    * globally.
     */
    public void onFinalizeAssignPrimary(java.util.Map mapConfig)
        {
        // import java.util.Iterator;
        
        if (mapConfig != null && !mapConfig.isEmpty())
            {
            if (checkLockRequired())
                {
                for (Iterator iter = mapConfig.keySet().iterator(); iter.hasNext(); )
                   {
                   int               iPartition = ((Integer) iter.next()).intValue();
                   PartitionedService.PartitionControl control    = getPartitionControl(iPartition);
        
                   control.unlock();
                   }
                }
        
            // update the global configuration
            putPartitionConfig(mapConfig);
            }
        
        // this re-opens the distribution
        setOwnershipInProgress(0);
        }
    
    /**
     * Finalizes the incoming partition transfer request process.  This method
    * is called at the conclusion of a transfer request after the last message
    * from the client has been received and all events (managed by the transfer
    * control) have been raised. It is responsible for handling the following
    * responsibilities for a primary transfer:
    *     a) issue a batch response to the sender indicating whether to
    *        release or backup each transferred partition
    *     b) publish the batch config update globally
    *     c) insert primary partition data (see #receivePartition)
    *     d) cleanup intermediate metadata (unlock partitions, etc.)
    * 
    * @param msgLastTransfer  the final TransferRequest from the remote Member
    * that we need to respond to 
     */
    public void onFinalizeReceivePrimary(PartitionedService.TransferRequest msgLastTransfer)
        {
        // import Component.Net.Member;
        // import Component.Net.MemberSet;
        // import com.tangosol.net.partition.VersionedOwnership;
        // import com.tangosol.net.partition.PartitionEvent;
        // import com.tangosol.net.partition.PartitionSet;
        // import java.util.HashMap;
        // import java.util.Iterator;
        // import java.util.List;
        // import java.util.Map;
        
        PartitionedService.TransferResponse msgResponse = (PartitionedService.TransferResponse) instantiateMessage("TransferResponse");
        msgResponse.respondTo(msgLastTransfer);
        
        // This is the last transfer request in this logical
        // distribution.  Go through the queued up transfers
        // and determine the disposition of each partition.
        
        PartitionSet     partsLocked  = new PartitionSet(getPartitionCount());
        PartitionedService.TransferControl ctrlTransfer = getTransferControl();
        Member           memberThis   = getThisMember();
        Member           memberFrom   = msgLastTransfer.getFromMember();
        MemberSet        setMembers   = getServiceMemberSet();
        int              nMemberThis  = memberThis.getId();
        int              cBackup      = getBackupCount();
        Map              mapResponse  = new HashMap();
        Map              mapOwners    = new HashMap();
        int              iPart        = -1;
        int              iPartPrev;
        
        _assert(Thread.currentThread() == getThread()); // should only run on the service thread
        
        if (!ctrlTransfer.isIncomingTransfer(memberFrom))
            {
            // the transfer control does not contain any pending incoming transfer
            // from this member; soft assert as this should not happen
        
            _trace("Unable to complete distribution from member " + memberFrom.getId(), 1);
            getDistributionStrategy().onDistributionCompleted(memberFrom, /*fSuccess*/ false);
            return;
            }
        
        // Fetch the local assignments after ensuring that our ownership matches
        // the primary sender's (as they may be changed by #assignPartitionOwner).
        int[][] aaiOwnerPrev = getPartitionAssignments();
        
        for (Iterator iterPending = ctrlTransfer.getQueuedTransfers(memberFrom).iterator();
            iterPending.hasNext(); )
            {
            PartitionedService.TransferRequest msgPending = (PartitionedService.TransferRequest) iterPending.next();
            _assert(msgPending.getStore() == 0); // should be only primary transfers
        
            iPartPrev = iPart;
            if ((iPart = msgPending.getPartition()) != iPartPrev)
                {
                // PartitionedService implementations may use multiple transfer
                // messages for each logical partition transfer.  Only run this
                // logic once (on the first message) per partition transferred.
        
                int     nMemberSender = msgPending.getFromMember().getId(); 
                Integer IPart         = Integer.valueOf(iPart);
                int[]   aiOwnerPrev   = aaiOwnerPrev[iPart]; // could be changed by assignPrimaryPartition
                
                if (aiOwnerPrev[0] == nMemberThis)
                    {
                    // soft assertion
                    _trace("Request to transfer already owned primary partition " +
                           iPart + " from member " + nMemberSender, 1);
                    }
        
                PartitionedService.PartitionControl ctrlPart = ensurePartitionControl(iPart);
        
                // since we don't own the partition yet, everyone should be
                // in and out quickly
                ctrlPart.lock(-1L, PartitionedService.PartitionControl.LOCK_PRIMARY_XFER_IN);
                partsLocked.add(iPart);
        
                // setting the partition version must be done *before* receiving the partition,
                // since it could generate evictions (backup messages)
                long lVersionNew = msgPending.getPartitionVersion() + 1;
                ctrlPart.getVersionCounter().set(lVersionNew);
        
                // get the ownership before the change
                VersionedOwnership ownersOld = msgPending.getOwners();
        
                // sync both the local assignments and the ownership version
                // to the previous primary's view; this will ensure that
                // assignPrimaryPartition monotonically increments the ownership version
                // and bases the returned VersionedOwnership on the previous primary's view
                assignPartitionOwners(iPart, ownersOld.getOwners());
                setOwnershipVersion(iPart, ownersOld.getVersion());
        
                VersionedOwnership owners = assignPrimaryPartition(iPart, 'r');
                mapOwners.put(IPart, owners);
        
                validateTransferStrength(ownersOld, owners, iPart);
        
                // we need to inform the sender whether or not it should release the
                // partition data or move it into backup (with a given index)
                int iResponse = PartitionedService.TransferRequest.RESPONSE_RELEASE;
                for (int iBackup = 1; iBackup <= cBackup; iBackup++)
                    {
                    if (owners.getOwner(iBackup) == nMemberSender)
                        {
                        iResponse = iBackup;
                        break;
                        }
                    }
        
                if (iResponse > 0)
                    {
                    // aiOwnerPrev here is a reference to the "old" assignments array
                    int    nPrevBackup = aiOwnerPrev[iResponse];
                    Member memberTo    = setMembers.getMember(nPrevBackup);
                    if (memberTo != null && memberTo != memberThis)
                        {
                        // need to send the old backup owner a RELEASE
                        ctrlTransfer.sendBackupRelease(
                            iPart, iResponse, nMemberThis, nMemberSender, memberTo, null);
                        }
                    }
        
                mapResponse.put(IPart, Integer.valueOf(iResponse));
        
                // prevent the partitions from being transferred again until the
                // PartitionedService.TransferResponse has been delivered to the previous owner.  If
                // the previous primary owner is becoming a backup, this guarantees
                // that it will be notified before the primary ownership could
                // change once again.  (See $TransferResponse#onSent)
                //
                // Note 1: must be called prior to posting the transfer response (COH-7259)
                // Note 2: must be called after locking partition for transfer, as lock
                //         promotion is disallowed by the Gate contract
                ctrlPart.preventTransfer();
                }
            }
        
        msgResponse.setPrimaryPartitions(partsLocked);
        msgResponse.setValue(mapResponse);
        
        // receive the partition data
        List listTransfers = ctrlTransfer.getQueuedTransfers(memberFrom);
        for (int iLeft = 0, c = listTransfers.size(); iLeft < c; )
            {
            // listTransfers is a list of PartitionedService.TransferRequest messages (grouped
            // by partition-id) that could span multiple partitions
            int iPartition = ((PartitionedService.TransferRequest) listTransfers.get(iLeft)).getPartition();
        
            // scan the list of transfers to find the range for this partition
            int iRight = iLeft + 1;
            for (; iRight < c; iRight++)
                {
                if (((PartitionedService.TransferRequest) listTransfers.get(iRight)).getPartition() != iPartition)
                    {
                    break;
                    }
                }
        
            firePartitionEvent(PartitionEvent.PARTITION_RECEIVE_BEGIN, iPartition, memberFrom, memberThis);
        
            // assignPrimaryPartition() should have already called preparePartition();
            // any exception here causes the service to terminate.
            //
            // The range [iLeft, iRight) covers all of the messages for the current partition
            List listXferRequests = listTransfers.subList(iLeft, iRight);
            receivePartition(iPartition, 0, listXferRequests);
        
            // finalize receive for the partition
            ctrlTransfer.finalizeReceivePartition(iPartition, listXferRequests);
        
            firePartitionEvent(PartitionEvent.PARTITION_RECEIVE_COMMIT, iPartition, memberFrom, memberThis);
           
            iLeft = iRight;
            }
        
        // notify the transfer-control that the transfers were committed
        ctrlTransfer.onReceiveCommitted(msgLastTransfer);
        
        // post the response to the sender
        //
        // Note1: response to the sender is sent only after the partition is
        //        fully received (and persisted); see COH-8371
        // Note2: even though we notify everyone afterwards, the corresponding messages
        //        could be reordered w.r.t. one another due to packet loss/delivery
        //        latencies along the different paths
        post(msgResponse);
        
        // sync the versions and unlock any partitions that were locked
        // for transfer.  This needs to be done only after the response is posted
        // as it could result in additional BM events (and associated backups) being
        // processed.  See $PartitionControl#unlock, $Storage$DeferredEvent
        //
        // Note: if there are multiple backups configured and the transfer sender is
        //       assigned to be a new backup, the sync message may arrive prior to the
        //       PartitionedService.TransferResponse above.  We cannot hold the partition locked until
        //       the response delivery is confirmed as it could mean breaking the
        //       unit-of-order guarantees for async requests (see COH-8382, COH-10474)
        PartitionedService.PartitionControl[] aCtrlPartition = getPartitionControl();
        for (iPart = partsLocked.next(0); iPart >= 0; iPart = partsLocked.next(iPart + 1))
            {
            PartitionedService.PartitionControl ctrlPart = aCtrlPartition[iPart];
        
            ctrlPart.doSyncBackups();
            ctrlPart.unlock();
            }
        
        // finally notify everyone of the new config
        // Note: we should update partition ownership only after the partition lock has
        //       been released; otherwise any local partition config listener may fail
        //       to enter the partition (see COH-10699)
        putPartitionConfig(mapOwners);
        
        // distribution is now successfully completed
        getDistributionStrategy().onDistributionCompleted(memberFrom, /*fSuccess*/ true);
        }
    
    /**
     * Finalizes the promotion of backed up partitions to primary. This method
    * is called at the conclusion of the ownership protocol which confirms
    * agreement of partition ownership and broadcast of this ownership.
    * Finalizing the restore process requires migrating backup data to primary
    * stores ultimately releasing partition locks.
     */
    public void onFinalizeRecoverPrimary(com.tangosol.net.internal.PartitionRecoverInfo info)
        {
        // import Component.Net.Member;
        // import Component.Net.Message;
        // import com.oracle.coherence.persistence.PersistenceManager;
        // import com.tangosol.net.partition.PartitionEvent;
        // import com.tangosol.net.partition.PartitionSet;
        // import java.util.Iterator;
        // import java.util.Map;
        
        PartitionedService.PartitionRecoverRequest msgRequest        = (PartitionedService.PartitionRecoverRequest) info.getRequest();;
        Map                      mapConfig         = info.getMapConfig();
        PersistenceManager       mgrRecover        = info.getManager();
        PartitionSet             partsRecovered    = info.getRecoveredPartitions();
        PartitionSet             partsFailed       = info.getFailedPartitions();
        PartitionSet             partsFailedEvents = info.getFailedEventPartitions();
        boolean                  fSnapshot         = mgrRecover != getPersistenceManager();
        PartitionedService.Response                msgResponse       = (PartitionedService.Response) instantiateMessage("Response");
        
        // release / revert local changes for failed partitions
        for (int iPart = partsFailed.next(0); iPart >= 0;
                 iPart = partsFailed.next(iPart + 1))
            {
            mapConfig.remove(Integer.valueOf(iPart));
            assignPartitionOwner(iPart, 0, 0);
            releasePartition(iPart, 0);
            getPartitionControl(iPart).unlock();
            releasePartitionControl(iPart);
            }
        
        msgResponse.respondTo(msgRequest);
        msgResponse.setValue(
            isVersionCompatible(msgRequest.getFromMember(), 21, 6, 0)
                ? new Object[] {partsFailed, partsFailedEvents}
                : (Object) partsFailed);
        
        if (mapConfig != null && !mapConfig.isEmpty())
            {
            Member memberThis = getThisMember();
            for (Iterator iter = mapConfig.keySet().iterator(); iter.hasNext(); )
               {
               int               iPartition = ((Integer) iter.next()).intValue();
               PartitionedService.PartitionControl control    = getPartitionControl(iPartition);
        
               firePartitionEvent(PartitionEvent.PARTITION_RECOVERED, iPartition, null, memberThis);
               control.setRecovered(false);
               control.unlock();
               }
           
            // publish the new (recovered) config
            //
            // Note: this must be sent prior to responding to the recover request in order
            //       to ensure that partitions that were not recovered successfully are
            //       retried during the next distribution cycle.
            //       See $PartitionRecoverRequest$Poll#onCompletion
            putPartitionConfig(mapConfig);
        
            _trace("Recovered " + partsRecovered + " from " + (fSnapshot ? "snapshot" : "active") + " persistent store", 3);
           }
        
        // post any requests created during recovery
        for (Iterator iter = info.getListRequests().iterator(); iter.hasNext(); )
            {
            post((Message) iter.next());
            }
        
        // now that recovery has been completed, release the recovery manager
        // if this was a snapshot recovery
        if (fSnapshot)
            {
            mgrRecover.release();
            }
        
        PartitionSet partsAssign = msgRequest.getPartsAssign();
        if (partsAssign.isEmpty())
            {
            // respond to the recovery request
            post(msgResponse);
            }
        else
            {
            Map mapAssigned = msgRequest.getMapAssigned();
        
            // the response will be sent after assigning the partitions
            PartitionSet partsLost = msgRequest.getPartsLost();
            if (partsLost != null)
                {   
                _trace("Assigned " + partsLost.cardinality() + " orphaned primary partitions: " + partsLost, 2);
        
                firePartitionEvent(PartitionEvent.PARTITION_LOST, partsLost, null, getThisMember());
                }
        
            PartitionSet partsAssigned = msgRequest.getPartsAssigned();
            if (partsAssigned != null)
                {
                firePartitionEvent(PartitionEvent.PARTITION_ASSIGNED, partsAssigned, null, getThisMember());
                }
        
            onPartitionsAssigned(partsAssigned, partsLost,
                getContinuations().instantiateFinalizeAssignPrimaries(msgRequest.getMapAssigned(), msgResponse));
            }
        }
    
    /**
     * Finalizes the promotion of backed up partitions to primary. This method
    * is called at the conclusion of the ownership protocol which confirms
    * agreement of partition ownership and broadcast of this ownership.
    * Finalizing the restore process requires migrating backup data to primary
    * stores ultimately releasing partition locks.
    * 
    * @param msgRequest  the originating OwnershipRequest message which will be
    * responded to
    * @param mapUpdate  an opetional Map<Integer, Ownership> containing
    * ownerhip updates that need to be published 
     */
    public void onFinalizeRestorePrimary(PartitionedService.OwnershipRequest msgRequest, java.util.Map mapUpdate)
        {
        // import com.oracle.coherence.persistence.ConcurrentAccessException;
        // import com.oracle.coherence.persistence.PersistenceException;
        // import com.oracle.coherence.persistence.PersistenceManager;
        // import com.oracle.coherence.persistence.PersistentStore;
        // import com.tangosol.net.partition.PartitionEvent;
        // import com.tangosol.net.partition.PartitionSet;
        // import com.tangosol.persistence.CachePersistenceHelper as com.tangosol.persistence.CachePersistenceHelper;
        // import com.tangosol.persistence.GUIDHelper;
        // import com.tangosol.persistence.GUIDHelper$GUIDResolver as com.tangosol.persistence.GUIDHelper.GUIDResolver;
        // import com.tangosol.util.Binary;
        // import java.util.ArrayList;
        // import java.util.Iterator;
        // import java.util.List;
        
        PartitionedService.OwnershipResponse msgResponse = (PartitionedService.OwnershipResponse) instantiateMessage("OwnershipResponse");
        msgResponse.respondTo(msgRequest);
        
        PartitionSet partsRecover = msgRequest.getRecoveryPartitions();
        if (partsRecover != null)
            {
            // collect the list of available GUIDs for the partitions that need to be recovered
            String sSnapshot = msgRequest.getSnapshotToRecover();
        
            PartitionedService.PersistenceControl ctrl = getPersistenceControl();
            PersistenceManager  mgr  = sSnapshot == null
                    ? getPersistenceManager()  // the active manager
                    : ctrl.openSnapshot(sSnapshot);
            PersistenceManager  backupMgr  = sSnapshot == null
                    ? ctrl.getBackupManager()  // the backup manager
                    : ctrl.openSnapshot(sSnapshot);
            if (mgr != null)
                {
                PartitionSet          partsGlobal  = com.tangosol.persistence.CachePersistenceHelper.getGlobalPartitions(this);
                PersistentStoreInfo[] aStoreInfo   = mgr.listStoreInfo();
                
                // if backups are persisted, add those, but only if there is no primary persisted
                PersistentStoreInfo[] aBackupStoreInfoAll = backupMgr != null ? backupMgr.listStoreInfo() : null;
                PersistentStoreInfo[] aBackupStoreInfo    = null;
                
                if (aBackupStoreInfoAll != null)
                    {
                    List listBackupGUIDs = new ArrayList();
                    
                    for (int i = 0; i < aBackupStoreInfoAll.length; i++)
                        {
                        String sGUID = aBackupStoreInfoAll[i].getId();
                        
                        int iPart = GUIDHelper.getPartition(sGUID);
                        if (GUIDHelper.getGUID(Arrays.asList(aStoreInfo), iPart) == null)
                            {
                            listBackupGUIDs.add(aBackupStoreInfoAll[i]);
                            }
                        }

                    aBackupStoreInfo = (PersistentStoreInfo[]) listBackupGUIDs.toArray(new PersistentStoreInfo[listBackupGUIDs.size()]);
                    Arrays.sort(aBackupStoreInfo, Comparator.comparing(PersistentStoreInfo::getId));
                    }

                PersistentStoreInfo[] aStoreInfoMerged = aBackupStoreInfo == null
                    ? aStoreInfo
                    : Base.mergeArray(aStoreInfo, aBackupStoreInfo);
        
                int  cParts      = getPartitionCount();
                int  cGUID       = aStoreInfoMerged.length;
                List listRecover = new ArrayList(cGUID);
                List listGlobal  = new ArrayList(1);
        
                for (int i = 0; i < cGUID; i++)
                    {
                    PersistentStoreInfo storeInfo = aStoreInfoMerged[i];
                    int                 iPart     = GUIDHelper.getPartition(storeInfo.getId());
        
                    if (iPart < cParts && ctrl.isAllowed(storeInfo.getId()))
                        {
                        if (partsRecover.contains(iPart))
                            {
                            listRecover.add(storeInfo);
                            }
        
                        // we only need the global partitions to facilitate the active persistence recovery
                        if (partsGlobal.contains(iPart) &&
                            sSnapshot == null &&
                            (aBackupStoreInfo == null ||
                             (aBackupStoreInfo != null &&
                              Arrays.binarySearch(aBackupStoreInfo, storeInfo) < 0)))
                            {
                            PartitionedService.PartitionControl ctrlPart = getPartitionControl(iPart);
        
                            // exclude the GUIDs for currently active stores
                            // also, exclude global partitions when from backup
                            PersistentStore store = ctrlPart == null ? null : ctrlPart.getPersistentStore();
                            if (store == null || !store.getId().equals(storeInfo.getId()))
                                {
                                listGlobal.add(storeInfo);
                                }
                            }
                        }
                    }
        
                com.tangosol.persistence.GUIDHelper.GUIDResolver resolver = new com.tangosol.persistence.GUIDHelper.GUIDResolver(cParts);
                resolver.registerStoreInfo(getThisMember(),
                    (PersistentStoreInfo[]) listRecover.toArray(new PersistentStoreInfo[listRecover.size()]));

                msgResponse.setStoreInfos(resolver.getNewestStoreInfos(partsRecover));
        
                if (sSnapshot == null)
                    {
                    PartitionSet partsOwned = collectOwnedPartitions(true);
                    Binary       binQuorum  = null;
        
                    if (partsOwned.intersects(partsGlobal))
                        {
                        // even if the global partitions do not need to be recovered
                        // their owners should still provide the quorum info
        
                        binQuorum = getPersistenceControl().getQuorumRaw();
                        }
        
                    if (binQuorum == null && !listGlobal.isEmpty())
                        {
                        resolver = new com.tangosol.persistence.GUIDHelper.GUIDResolver(cParts);
                        resolver.registerStoreInfo(getThisMember(),
                            (PersistentStoreInfo[]) listGlobal.toArray(new PersistentStoreInfo[listGlobal.size()]));
        
                        PersistentStore    storeGlobal = null;
                        PersistenceManager quorumMgr   = mgr;
                        String             sGUID       = resolver.getNewestGUIDs(partsGlobal)[0];
                        try
                            {
                            storeGlobal = quorumMgr.open(sGUID, /*storeFrom*/ null);
        
                            com.tangosol.persistence.CachePersistenceHelper.validate(storeGlobal, this);
        
                            binQuorum = com.tangosol.persistence.CachePersistenceHelper.readQuorumRaw(storeGlobal);
                            }
                        catch (ConcurrentAccessException e)
                            {
                            // some one else is reading it; leave it to them to provide the info
                            }
                        catch (PersistenceException e)
                            {
                            // TODO: how to proceed best?
                            _trace("Failed to open a global store: " + getStackTrace(e), 1);
                            }
                        finally
                            {
                            if (storeGlobal != null)
                                {
                                quorumMgr.close(storeGlobal.getId());
                                }
                            }
                        }
        
                    msgResponse.setQuorumRaw(binQuorum);
                    }
                else
                    {
                    mgr.release();
                    if (backupMgr != null)
                        {
                        backupMgr.release();
                        }
                    }
                }
            }
        
        if (mapUpdate != null && !mapUpdate.isEmpty())
            {
            PartitionSet parts = new PartitionSet(getPartitionCount());
        
            for (Iterator iter = mapUpdate.keySet().iterator(); iter.hasNext(); )
               {
               int iPart = ((Integer) iter.next()).intValue();
        
               // clear any deferred requests and ensure that the remaining backups
               // do the same and are synchronized to the same partition version
               PartitionedService.PartitionControl control = getPartitionControl(iPart);
               control.doSyncBackups();
        
               firePartitionEvent(PartitionEvent.PARTITION_RECEIVE_COMMIT, iPart, null, getThisMember());
               parts.add(iPart);
               control.unlock();
               }
        
            // update the partition config
            putPartitionConfig(mapUpdate);
        
            _trace("Restored from backup " + parts.cardinality() + " partitions: " + parts, 3);
            }
        
        setRestoreInProgress(false);
        
        msgResponse.setAssignments(getPartitionAssignments());
        msgResponse.setSuccess(true);
        post(msgResponse);
        }
    
    /**
     * Finalizes the outgoing partition transfer request process.  This method
    * is called after the specified set of partitions has been locked for
    * outgoing primary transfer and is responsible for initiating those
    * transfers.
    * 
    * @param parts    the set of partitions locked for outgoing transfer
     */
    public void onFinalizeSendPrimary(com.tangosol.net.partition.PartitionSet parts)
        {
        // import Component.Net.Member;
        // import com.tangosol.net.partition.PartitionEvent;
        
        PartitionedService.PartitionControl[]  aCtrlPartition = getPartitionControl();
        PartitionedService.Continuations       continuations  = getContinuations();
        PartitionedService.TransferControl     ctrlTransfer   = getTransferControl();
        PartitionedService.DistributionRequest msgRequest     = (PartitionedService.DistributionRequest) ctrlTransfer.getDistributionRequest();
        
        // all partitions have been locked (see #transferPrimary);
        // ensure that there are no outstanding backup requests
        for (int iPart = parts.next(0); iPart >= 0; iPart = parts.next(iPart + 1))
            {
            PartitionedService.PartitionControl ctrl = aCtrlPartition[iPart];
            synchronized (ctrl)
                {
                int cPolls = ctrl.getBackupPolls().get();
                if (cPolls > 0)
                    {
                    // COH-7312: this partition has outstanding backups; defer the
                    //           transfer snapshot until all backups have completed
                    _trace("Deferring primary transfer for " + parts + " to member "
                        + msgRequest.getFromMember().getId() + " due to " + cPolls
                        + " outsdanding backups", 3);
        
                    ctrl.addBackupsCompletedAction(
                        continuations.wrapAsMessage(
                            continuations.instantiateFinalizeSendPrimary(parts)));
                    return;
                    }
                }
            }
        
        // all partitions are clear; there are no outstanding backup requests
        Member memberTo = msgRequest.getFromMember();
        int    cParts   = parts.cardinality();
        int    cSent    = 0;
        for (int iPart = parts.next(0); iPart >= 0; iPart = parts.next(iPart + 1))
            {
            if (ctrlTransfer.isTransferFull())
                {
                // this partition is not going to be transferred, but since it was locked
                // to be ready for transfer, we could have already some deferred actions
                // that need to be taken care of
                ctrlTransfer.cancelTransmit(iPart);
        
                // unlock any partitions that were locked and were intended to be
                // transferred but could not be (e.g. if the transfer is full)
                aCtrlPartition[iPart].unlock(/*fRollBack*/ true);
                parts.remove(iPart);
                }
            else
                {
                firePartitionEvent(PartitionEvent.PARTITION_TRANSMIT_BEGIN,
                                   iPart, getThisMember(), memberTo);
                transferPartition(iPart, 0, (++cSent == cParts));
                }
            }
        
        _trace("Transferring primary " + parts + " to member " + memberTo.getId() + " requesting "
              + msgRequest.getPartitionCount()
              + (ctrlTransfer.isTransferFull() ? "; transfer threshold exceeded" : ""), 3);
        }
    
    /**
     * Called when the service is AcceptingOthers.
    * 
    * Note: specializations of this event *must* either call this implemenation
    * via super or call setAcceptingClients(true) to notify any clients waiting
    * for the service to start.
     */
    protected void onFinalizeStartup()
        {
        // perform the following actions in order:
        //   1) Dispatch JOINED MemberEvent
        //   2) Notify client threads waiting upon this service's readiness
        //   3) Inform others of our joined/readiness status
        
        setAcceptingClients(true);
        
        notifyServiceJoined();
        }
    
    // Declared at the super level
    /**
     * The "component has been initialized" method-notification (kind of
    * WM_NCCREATE event) called out of setConstructed() for the topmost
    * component and that in turn notifies all the children. <p>
    * 
    * This notification gets called before the control returns back to this
    * component instantiator (using <code>new Component.X()</code> or
    * <code>_newInstance(sName)</code>) and on the same thread. In addition,
    * visual components have a "posted" notification <code>onInitUI</code> that
    * is called after (or at the same time as)  the control returns back to the
    * instatiator and possibly on a different thread.
     */
    public void onInit()
        {
        // import com.oracle.coherence.common.util.MemorySize;
        // import com.tangosol.coherence.config.Config;
        // import java.util.concurrent.atomic.AtomicLong;
        
        super.onInit();
        
        String sScratch = Config.getProperty("coherence.distributed.scratchspace",
                                             String.valueOf("50M"));
        
        setScratchSpaceCounter(new AtomicLong(new MemorySize(sScratch).getByteCount()));
        setContinuations((PartitionedService.Continuations) _findChild("Continuations"));
        setPartitionConfigMap((PartitionedService.PartitionConfig.Map)
            ((PartitionedService.PartitionConfig) _findChild("PartitionConfig")).getMap());
        }
    
    // Declared at the super level
    /**
     * Event notification for performing low frequency periodic maintenance
    * tasks.  The interval is dictated by the WaitMillis property, 
    * 
    * This is used for tasks which have a high enough cost that it is not
    * reasonable to perform them on every call to onWait() since it could be
    * called with a high frequency in the presence of work-loads with fast
    * oscillation between onWait() and onNotify().  As an example a single
    * threaded client could produce such a load.
     */
    protected void onInterval()
        {
        if (isAcceptingClients() && isOwnershipEnabled() && getBackupCount() > 0)
            {
            // While it should not happen, because of the strict version checking
            // for backup updates, a failure of the primary to send any backup version
            // will cause the backup to defer all subsequent backup messages and thereby
            // blocking the clients and result in a virtually "deadlocked" partition.
            // Try to protect ourselves here by ensuring that partitions with updates
            // that are missing for a long time are recovered.
        
            int                 nMemberThis    = getThisMember().getId();
            int[][]             aaiOwner       = getPartitionAssignments();
            PartitionedService.PartitionControl[] actrlPartition = getPartitionControl();
            for (int iPart = 0, cParts = actrlPartition.length; iPart < cParts; iPart++)
                {
                PartitionedService.PartitionControl ctrlPartition = actrlPartition[iPart];
                if (ctrlPartition != null && aaiOwner[iPart][0] != nMemberThis)
                    {
                    ctrlPartition.checkDeferredBackups();
                    }
                }
            }
        
        super.onInterval();
        }
    
    // Declared at the super level
    /**
     * Event notification to perform a regular daemon activity. To get it
    * called, another thread has to set Notification to true:
    * <code>daemon.setNotification(true);</code>
    * 
    * @see #onWait
     */
    protected void onNotify()
        {
        // import com.tangosol.util.Base;
        
        super.onNotify();
        
        if (!isExiting())
            {
            if (isAcceptingOthers())
                {
                // we know that Grid#onNotify() just fetched the time; 
                // no need to do it twice
                long ldtNow = Base.getLastSafeTimeMillis();
        
                if (ldtNow >= getDistributionNextMillis())
                    {
                    checkDistribution();
                    }
                }
            else if (getServiceState() == SERVICE_STARTED && isFinalizing())
                {
                // finalize the startup sequence if we have been welcomed by others
                finalizeStartup();
                }
            }
        }
    
    /**
     * Called on the service thread only.
     */
    public void onNotifyServiceLeaving(com.tangosol.coherence.component.net.Member member)
        {
        // import com.tangosol.net.MemberEvent;
        
        if (isAcceptingClients() &&
            isOwnershipEnabled(getThisMember()) && isOwnershipEnabled(member))
            {
            // notify the distribution strategy and persistence control of the departing member
            getDistributionStrategy().onMembershipChanged(MemberEvent.MEMBER_LEAVING);
            getPersistenceControl().onMembershipChanged(MemberEvent.MEMBER_LEAVING);
            }
        }
    
    // Declared at the super level
    /**
     * Called to complete the "service-left" processing for the specified
    * member.  This notification is processed only after the associated
    * endpoint has been released by the message handler.  See
    * $NotifyServiceLeft#onReceived/#proceed.
    * Called on the service thread only.
    * Called on the service thread only.
     */
    public void onNotifyServiceLeft(com.tangosol.coherence.component.net.Member member)
        {
        // import com.tangosol.net.MemberEvent;
        
        // pull the original ownership-enabledness and whether 
        // the departed member was an ownership senior prior to calling super 
        // (which will remove it from the service member set)
        boolean fWasOwnershipSenior = member == getOwnershipSenior(/*fIsLeaving*/ true);
        boolean fOwner              = isOwnershipEnabled(member);
        
        super.onNotifyServiceLeft(member);
        
        if (fOwner)
            {
            // cleanup the partition assignments, transfer control and
            // partition-config only if the departed member was ownership
            // enabled
            if (isAcceptingClients())
                {
                validatePartitionAssignments(getOwnershipMemberSet(/*fIncludePending*/ true));
        
                if (isOwnershipEnabled(getThisMember()))
                    {
                    // notify the transfer control of the departed member
                    getTransferControl().onMemberLeft(member);
        
                    // notify the distribution strategy and persistence control of the departing member
                    getDistributionStrategy().onMembershipChanged(MemberEvent.MEMBER_LEFT);
                    getPersistenceControl().onMembershipChanged(MemberEvent.MEMBER_LEFT);
        
                    if (fWasOwnershipSenior && getOwnershipSenior(/*fIsLeaving*/ true) == getThisMember())
                        {
                        onOwnershipSeniority(member);
                        }
                    }
                }
        
            // notify the partition config map about the departed member
            getPartitionConfigMap().onServiceLeft(member, fWasOwnershipSenior);
            }
        }
    
    // Declared at the super level
    /**
     * Called to complete the "service-quiescence" processing for the local
    * member.
    * Called on the service thread only.
    * 
    * @param fResume                     false to suspend this service; true to
    * resume this service
    * @param fResumeOnFailover  whether the service should be automatically
    * resumed on failover
     */
    public void onNotifyServiceQuiescence(boolean fResume, boolean fResumeOnFailover)
        {
        super.onNotifyServiceQuiescence(fResume, fResumeOnFailover);
        
        if (isOwnershipEnabled() && isAcceptingClients())
            {
            // either schedule or disable the distribution
            if (fResume)
                {
                getDistributionStrategy().scheduleImmediate();
                getPersistenceControl().onServiceResume();
                }
            else
                {
                setDistributionNextMillis(Long.MAX_VALUE);
                getPersistenceControl().onServiceSuspend(fResumeOnFailover);
                }
            }
        }
    
    /**
     * Called on the service thread only.
     */
    public void onNotifyShutdown()
        {
        setServiceState(SERVICE_STOPPING);
        
        if (!isOwnershipEnabled())
            {
            stop();
            }
        else
            {
            // stop accepting ownership requests
            setOwnershipEnabled(false);
        
            // the service will be stopped when the last transfer is completed
            // the re-distribution process will be driven by other nodes, as soon as they
            // understand this node is leaving (see #onNotifyServiceLeaving)
            }
        }
    
    /**
     * Called (on the service thread) when a NotifySnapshotRecoverRequest
    * message is received.
     */
    public void onNotifySnapshotRecoverRequest(String sSnapshot)
        {
        if (getOwnershipInProgress() <= 0)
            {
            doOwnershipProtocol(getOwnershipMemberSet(), sSnapshot);
            }
        else
            {
            getPersistenceControl().getSnapshotController().
                onRecoveryCompleted(sSnapshot, instantiatePartitionSet(true), null);
            }
        }
    
    /**
     * Called on the service thread only.
     */
    public void onOwnershipRequest(PartitionedService.OwnershipRequest msgRequest)
        {
        // import Component.Net.Member;
        // import Component.Net.MemberSet;
        // import com.tangosol.net.partition.PartitionSet;
        
        MemberSet setMemberThis = getOwnershipMemberSet();
        MemberSet setMemberThat = msgRequest.getSenderMemberSet();
        
        PartitionedService.OwnershipResponse msgResponse = (PartitionedService.OwnershipResponse) instantiateMessage("OwnershipResponse");
        
        if (isOwnershipChangeInProgress() || isDistributionInProgress())
            {
            // there is currently an incomplete transfer; no reliable response
            _trace("Unable to determine the ownership due to in-progress transfer", 3);
            }
        else if (!setMemberThis.equals(setMemberThat))
            {
            // the sender's (ownership senior) view of the ownership member-set does
            // not match ours.  This could happen if MemberLeft notifications are delayed
            // on the wire (e.g. the senior heard of a member death that we have not yet
            // heard about).  We must defer the Ownership protocol until we have received
            // notification of the member's death.  (see COH-4834, COH-6393)
        
            StringBuilder sb       = new StringBuilder();
            MemberSet     setDelta = new MemberSet();
        
            setDelta.addAll(setMemberThis);
            setDelta.removeAll(setMemberThat);
            if (!setDelta.isEmpty())
                {
                sb.append("; requestor's member set is missing " + setDelta);
                }
        
            setDelta.clear();
            setDelta.addAll(setMemberThat);
            setDelta.removeAll(setMemberThis);
            if (!setDelta.isEmpty())
                {
                sb.append("; requestor's member set has extra " + setDelta);
                }
        
            _trace("Deferring the ownership reconciliation prematurely requested by member "
                 + msgRequest.getFromMember().getId() + " due to pending membership change"
                 + sb.toString(), 3);
            }
        else
            {
            int[][] aaiOwnerThat = msgRequest.getRequestAssignments();
            if (msgRequest.isQuery())
                {
                // phase 1 - synchronization
                if (aaiOwnerThat != null)
                    {
                    calculateOwnershipConflicts(
                        msgRequest.getFromMember().getId(), aaiOwnerThat,
                        msgRequest.getRequestCount());
                    }
        
                int[][] aaiOwner = getPartitionAssignments();
                if (msgRequest.getSnapshotToRecover() != null)
                    {
                    // recovering a snapshot must abandon partitions first
        
                    PartitionSet partsAbandon = collectOwnedPartitions(true);
                    partsAbandon.add(collectOwnedPartitions(false));
        
                    abandonPartitions(partsAbandon);
        
                    // report to the co-ordinator orphaned assignments to absolve
                    // the need for conflict resolution
                    aaiOwner = new int[getPartitionCount()][getBackupCount() + 1];
                    }
        
                msgResponse.setAssignments(aaiOwner);
                }
            else
                {
                // phase 2 - restore
                restoreOrphans(msgRequest);
        
                // message will be responded to when the restoreOrphans continuation
                // completes; see #onFinalizeRestorePrimary
                return;
                }
        
            msgResponse.setSuccess(true);
            }
        
        msgResponse.respondTo(msgRequest);
        post(msgResponse);
        }
    
    /**
     * Called on the service thread only.
     */
    public void onOwnershipRequestCompleted(PartitionedService.OwnershipRequest msgRequest, int cConflicts)
        {
        // import Component.Net.MemberSet;
        // import com.tangosol.net.partition.PartitionSet;
        // import com.tangosol.persistence.GUIDHelper$GUIDResolver as com.tangosol.persistence.GUIDHelper.GUIDResolver;
        // import com.tangosol.util.Base;
        // import java.util.Collections;
        // import java.util.Set;
        
        String sSnapshot = msgRequest.getSnapshotToRecover();
        long   ldtNow    = Base.getSafeTimeMillis();
        if (cConflicts == 0)
            {
            if (getServiceState() == SERVICE_STARTED)
                {
                _assert(getThisMember() == getOwnershipSenior());
        
                if (msgRequest.isQuery())
                    {
                    // synchronization (phase 1) has completed; start the restore phase
                    int[][]      aaiOwnersResolved = msgRequest.getConflictResolver().getResolvedAssignments();
                    int          cPartitions       = getPartitionCount();
                    int          cBackups          = getBackupCount();
                    PartitionSet partsRecover      = null;
        
                    // determine if there are orphans that remain that need to be recovered
                    for (int iPart = 0; iPart < cPartitions; iPart++)
                        {
                        int[]   aiOwners = aaiOwnersResolved[iPart];
                        boolean fOrphan  = true;
                        for (int iStore = 0; iStore <= cBackups; iStore++)
                            {
                            if (aiOwners[iStore] != 0)
                                {
                                fOrphan = false;
                                break;
                                }
                            }
        
                        if (fOrphan)
                            {
                            if (partsRecover == null)
                                {
                                partsRecover = instantiatePartitionSet(false);
                                }
        
                            partsRecover.add(iPart);
                            }
                        }
        
                    MemberSet         setOwners = getOwnershipMemberSet();
                    PartitionedService.OwnershipRequest msg       = (PartitionedService.OwnershipRequest)
                        instantiateMessage("OwnershipRequest");
        
                    msg.setSenderMemberSet(setOwners);
                    msg.setSnapshotToRecover(sSnapshot);
                    msg.setQuery(false);
                    msg.setRecoveryPartitions(partsRecover);
                    msg.setToMemberSet(setOwners);
                    msg.setRequestAssignments(aaiOwnersResolved);
        
                    post(msg);
                    }
                else
                    {
                    // the Ownership protocol (phase 2) has completed
                    setOwnershipInProgress(0);
        
                    // initiate recovery if needed
                    PartitionSet partsRecover = msgRequest.getRecoveryPartitions();
                    if (partsRecover == null)
                        {
                        // there were no orphans to recover; schedule an immediate distribution
                        setDistributionNextMillis(0);
                        }
                    else
                        {
                        com.tangosol.persistence.GUIDHelper.GUIDResolver resolver = msgRequest.getPersistentIdResolver();
        
                        // explicit recovery is always allowed; otherwise check the quorum
                        if (sSnapshot != null ||
                            isRecoverPartitionsAllowed(partsRecover, resolver, msgRequest.getQuorumInfo()))
                            {
                            MemberSet setOwners  = getOwnershipMemberSet();
                            Set       setLeaving = getOwnershipLeavingMembers(setOwners);
        
                            // ask the DistributionStrategy to recover/assign orphan partitions
                            //
                            // Note: the next distribution cycle will be scheduled when the
                            //       recovery process is complete
                            getDistributionStrategy().recoverOrphans(partsRecover, setOwners,
                                    setLeaving, resolver, sSnapshot);
                            }
                        else
                            {
                            // the quorum policy disallowed the recovery; check again in a bit
                            setDistributionNextMillis(ldtNow + getDistributionRepeatMillis());
                            return;
                            }
                        }
        
                    // cleanup persistence for restored partitions
                    if (isActivePersistence())
                        {
                        // calculate the set of partitions which were restored from backup
                        PartitionSet parts        = instantiatePartitionSet(false);
                        int[][]      aaiOwnersOld = msgRequest.getRequestAssignments();
                        int[][]      aaiOwnersNew = getPartitionAssignments();
                        for (int iPart = 0, cPart = aaiOwnersOld.length; iPart < cPart; ++iPart)
                            {
                            if (aaiOwnersOld[iPart][0] == 0 && aaiOwnersNew[iPart][0] != 0)
                                {
                                parts.add(iPart);
                                }
                            }
        
                        if (!parts.isEmpty())
                            {
                            // send a message to all storage members requesting them to delete old
                            // versions of persisted partitions that were restored from backup
                            PartitionedService.PartitionRecoverCleanup msg =
                                (PartitionedService.PartitionRecoverCleanup) instantiateMessage("PartitionRecoverCleanup");
        
                            msg.setPartitions(parts);
                            msg.setToMemberSet(getOwnershipMemberSet());
        
                            post(msg);
                            }
                        }
                    }
                }
            }
        else
            {
            if (sSnapshot == null)
                {
                setDistributionNextMillis(ldtNow + 500L); // let the things settle down for half a second
                setOwnershipInProgress(cConflicts <= 0 ? 0 : -getOwnershipInProgress());
                }
            else
                {
                // snapshot recovery should not be able to encounter ownership conflicts
                PartitionSet partsOrphan = collectOrphanPartitions();
                if (!partsOrphan.isEmpty())
                    {
                    _trace("Encountered " + cConflicts
                         + " unexpected ownership conflicts while attempting to recover "
                         + partsOrphan + " from snapshot", 2);
                    getPersistenceControl().getSnapshotController()
                        .onRecoveryCompleted(sSnapshot, partsOrphan, null);
                    }
                }
            }
        }
    
    /**
     * Called when this service member assumes the ownership seniority.
    * 
    * @param memberPreviousSenior    the (departed) member who was the previous
    * ownership senior member
     */
    public void onOwnershipSeniority(com.tangosol.coherence.component.net.Member memberPreviousSenior)
        {
        // import com.oracle.coherence.persistence.PersistenceEnvironment;
        // import com.tangosol.internal.net.service.grid.PersistenceDependencies;
        // import com.tangosol.persistence.SafePersistenceWrappers;
        // import com.tangosol.persistence.SnapshotArchiver;
        // import com.tangosol.run.xml.SimpleElement;
        // import com.tangosol.run.xml.XmlElement;
        
        PersistenceEnvironment env  = null;
        SnapshotArchiver       arch = null;
        
        PartitionedService.PersistenceControl ctrl = getPersistenceControl();
        if (ctrl.isValid())
            {
            env  = SafePersistenceWrappers.unwrap(ctrl.getPersistenceEnvironment());
            arch = ctrl.getSnapshotArchiver();
        
            // initialize the controller
            ctrl.onOwnershipSeniority();
            }
        
        // update our member config map with the persistence configuration
        // (see symmetric validation logic in #validateMemberConfig)
        XmlElement xmlConfig = new SimpleElement("persistence-config");
        xmlConfig.addAttribute("persistence-active-failure-mode").setString(
            isActivePersistence() && ctrl != null
                ? ctrl.getActiveFailureMode() == PersistenceDependencies.FAILURE_STOP_SERVICE
                    ? "stop-service" : "stop-persistence" : "none");
        xmlConfig.addAttribute("persistence-environment").setString(
            env == null ? "none" : env.getClass().getName());
        xmlConfig.addAttribute("persistence-mode").setString(
            isActivePersistence() ? "active" : "on-demand");
        xmlConfig.addAttribute("persistence-snapshot-archiver").setString(
            arch == null ? "none" : arch.getClass().getName());
        
        getThisMemberConfigMap().put("persistence-config", xmlConfig);
        }
    
    /**
     * Indicates that the ownership distribution has stabilized.
     */
    protected void onOwnershipStable()
        {
        // import com.tangosol.net.partition.PartitionSet;
        // import com.tangosol.persistence.CachePersistenceHelper as com.tangosol.persistence.CachePersistenceHelper;
        // import com.tangosol.util.Binary;
        
        if (isActivePersistence())
            {
            PartitionSet partsGlobal = com.tangosol.persistence.CachePersistenceHelper.getGlobalPartitions(this);
            PartitionSet partsOwned  = collectOwnedPartitions(true);
        
            partsGlobal.retain(partsOwned);
            for (int iPart = partsGlobal.next(0); iPart >= 0; iPart = partsGlobal.next(iPart + 1))
                {
                // save the "last well known quorum"
                Binary binQuorum = com.tangosol.persistence.CachePersistenceHelper.writeQuorum(
                    ensurePartitionControl(iPart).ensureOpenPersistentStore(), this);
        
                // prior to 12.2.1.1.0 Binary objects could not be placed in the PartitionConfig
                if (isVersionCompatible(getOwnershipMemberSet(), 12, 2, 1, 1, 0))
                    {
                    getPartitionConfigMap().put(PartitionedService.PartitionConfig.KEY_QUORUM, binQuorum);
                    }
                }
        
            // reset the manual override
            getPersistenceControl().setForceRecovery(false);
            }
        
        _trace("Partition ownership has stabilized with " + getOwnershipMemberSet().size() + " nodes", 3);
        }
    
    public void onPartitionAbandonRequest(PartitionedService.PartitionAbandonRequest msgRequest)
        {
        abandonPartitions(msgRequest.getPartitionSet());
        }
    
    /**
     * Called when a partition-configuration update is received in order to
    * reflect the (global) partition-config ownership changes in the (local)
    * partition-assignments views.
    * This method is also responsible for determining whether or not there is a
    * potential conflict in the ownership views, and for attempting corrective
    * action if appropriate.
    * 
    * Called on the service thread only.
     */
    public void onPartitionConfigUpdate(com.tangosol.util.MapEvent event)
        {
        // import Component.Net.Member;
        // import Component.Net.MemberSet;
        // import com.tangosol.net.partition.VersionedOwnership;
        // import com.tangosol.util.Base;
        
        // Prior to Coherence 3.2.2 we were using the StorageMemberSet to validate
        // the owner id. This was wrong, since the "storage-able" flag is delivered
        // via the MemberConfigMap (direct communication) and could be "delayed"
        // relative to the PartitionConfigUpdate delivered via PartitionConfigMap, which
        // always comes from the ownership senior, so the ServiceMemberSet should be used.
        //
        // As of Coherence 3.6, the concepts of storage and partition ownership have
        // been separated.
        //
        // As of Coherence 3.7, the partition config is no longer used as a command to
        // acquire or release ownership; partition config can only carry "third-party"
        // ownership information.
        //
        // Note that for events concerning this member, the assignment info may have
        // already been set as well as the local Ownership (which is a mutable object)
        
        MemberSet          setMembers   = getServiceMemberSet();
        int                nMemberThis  = getThisMember().getId();
        int                cBackups     = getBackupCount();
        int                iPartition   = ((Integer) event.getKey()).intValue();
        VersionedOwnership owners       = (VersionedOwnership) event.getNewValue();
        VersionedOwnership ownersPrev   = (VersionedOwnership) event.getOldValue();
        int[][]            aaiOwner     = getPartitionAssignments();
        int                nOwnedIndex  = getOwnedIndex(iPartition, nMemberThis);
        boolean            fPrimeOwner  = nOwnedIndex == 0;
        boolean            fBackupOwner = nOwnedIndex > 0;
        boolean            fRepublish   = false;
        
        for (int iStore = 0; iStore <= cBackups; iStore++)
            {
            int nOwnerLocal    = aaiOwner[iPartition][iStore];  // Note: aaiOwner may change
            int nOwnerGlobal   = ownersPrev == null ? 0 : ownersPrev.getOwner(iStore);
            int nOwnerNew      = owners.getOwner(iStore);
            int nVersionLocal  = getOwnershipVersion(iPartition);
            int nVersionGlobal = ownersPrev == null ? 0 : ownersPrev.getVersion();
            int nVersionNew    = owners.getVersion();
        
            if (fPrimeOwner)
                {
                // We are the primary owner thus we own all of the partition information.
                // The only allowable updates are:
                // primary owner - update affirming the local owner.  The local and
                //                 the global could disagree if we (the new primary
                //                 owner) are just finishing receiving the transfer.
                // backup owner  - update affirming the local or global owner.  The
                //                 local and the global could disagree if there is a
                //                 backup transfer in-progress.  In this case, an update
                //                 announcing the transfer would reflect the local owner,
                //                 whereas a "republished" update reflecting the current
                //                 global state would reflect the global owner.
                if ((nOwnerNew != nOwnerLocal && nOwnerNew != nOwnerGlobal) ||
                    (iStore == 0 && nVersionNew != nVersionLocal && nVersionNew != nVersionGlobal))
                    {
                    // this must be a ConfigSync from a new ownership senior;
                    // make sure everyone is up-to-date
                    _trace("Obsolete partition info; restoring "
                         + (iStore == 0 ? "primary" : "backup[" + iStore +"]")
                         + " owner for partition " + iPartition + " from member "
                         + nOwnerNew + " at version " + nVersionNew + " to " + nOwnerGlobal
                         + (nOwnerLocal == nOwnerGlobal ? "" : " (local=" + nOwnerLocal + ")")
                         + " at version " + nVersionGlobal + ""
                         + (nVersionLocal == nVersionGlobal ? "" : " (local=" + nVersionLocal + ")"), 3);
        
                    // Note: we must republish based on the old "global" picture
                    //       and not the local assignments, as those may contain
                    //       changes reflecting in-progress transfers
        
                    owners.setOwner(iStore, nOwnerGlobal);
                    owners.setVersion(nVersionGlobal);
                    fRepublish = true;
                    }
                else if (iStore == 0)
                    {
                    onPrimaryOwnershipChanged(iPartition);
                    }
                }
            else
                {
                if (iStore == 0 && nOwnerNew == nMemberThis)
                    {
                    // primary owner always assumes the ownership directly;
                    // this must be an ConfigSync from a new ownership senior.
                    _trace("Rejecting obsolete ownership update for partition " +
                           iPartition + "[" + nOwnerLocal + "]", 3);
        
                    if (nOwnerLocal == 0)
                        {
                        // we think the partition is un-owned; publish that fact
                        // which will cause the "real" owner to claim the ownership
                        // if we are wrong
                        owners.setPrimaryOwner(0);
                        fRepublish = true;
                        break;
                        }
                    else
                        {
                        // revert the change until the "other" owner republishes the
                        // ownership; don't pollute our local or global ownership view
                        // with this "bad" update
                        owners.setOwners(ownersPrev);
                        }
                    }
                else if (nOwnerNew > 0 && setMembers.getMember(nOwnerNew) == null)
                    {
                    // that member has left, ignore the change
                    _trace("Ignoring obsolete "
                         + (iStore == 0 ? "primary" : "backup[" + iStore + "]")
                         + " partition info for partition " + iPartition + "; member "
                         + nOwnerNew + " has departed", 3);
        
                    if (nOwnerLocal == nMemberThis)
                        {
                        // We can't add the dead member to the ownership, but setting
                        // the owner to 0 here would be wrong as well, as we must not
                        // treat the config update as a command.  Instead, leave the
                        // local assignments unchanged and revert the change to the
                        // global ownership.
                        // Note: it is also possible here that this member is (or was
                        //       recently) receiving transfer, so the local and global
                        //       assignments may differ
                        owners.setOwner(iStore, nOwnerGlobal);
                        }
                    else
                        {
                        // Don't add the dead owner's id to the assignments.
                        // We must set the owner to 0 here to ensure that members will
                        // reach the same state regardless of whether they receive the
                        // partition-config update first, or the member departure
                        // notification first (COH-5561)
                        owners.setOwner(iStore, 0);
                        aaiOwner = assignPartitionOwner(iPartition, iStore, 0);
                        if (iStore == 0)
                            {
                            onPrimaryOwnershipChanged(iPartition);
                            }
                        }
                    }
                else if (nOwnerNew != nOwnerLocal)
                    {
                    // TODO: we shouldn't just blindly accept "bad" updates even if
                    //       we are leaving.  However, the shutdown sequence currently
                    //       does not adhere strictly to the backup-release protocol.
                    //       (see #endangerLeavingBackups/#endangerPartitions)
                    if (getServiceState() != SERVICE_STOPPING)
                        {
                        if (nOwnerNew == nMemberThis)
                            {
                            // we can only get here for iStore > 0
                            _trace("Deferring " + "backup[" + iStore + "]"
                                 + " partition ownership for partition " + iPartition
                                 + " (owners=" + owners + ")", 3);
        
                            if (!isBackupOwner(iPartition))
                                {
                                // we cannot become a new backup owner via config;
                                // force a republish by the primary owner by publishing
                                // that the partition is orphaned
                                owners.setOwner(iStore, 0);
                                fRepublish = true;
        
                                PartitionedService.TransferControl ctrlTransfer = getTransferControl();
                                if (!ctrlTransfer.isTransferInProgress(iPartition))
                                    {
                                    // send a backup release to the primary owner, notifying it
                                    // that we no longer hold the backup ownership
                                    int    nOwner      = aaiOwner[iPartition][0];
                                    Member memberOwner = setMembers.getMember(nOwner);
                                    if (memberOwner != null)
                                        {
                                        ctrlTransfer.sendBackupRelease(iPartition, iStore,
                                            nOwner, 0, memberOwner, null);
                                        }
                                    }
                                }
                            continue;
                            }
                        else if (nOwnerLocal == nMemberThis)
                            {
                            // we can only get here for iStore > 0
                            _trace("Deferring backup[" + iStore + "] release for partition "
                                 + iPartition + " (owners=" + owners + ")", 3);
                            continue;
                            }
                        else if (iStore == 0 && nOwnerNew == 0 && nOwnerLocal != 0 && isOwnershipEnabled())
                            {
                            // a primary partition was declared as orphaned;
                            // activate the ownership protocol immediately
                            setDistributionNextMillis(0L);
                            }
                        }
        
                    setOwnershipVersion(iPartition, nVersionNew);
                    aaiOwner = assignPartitionOwner(iPartition, iStore, nOwnerNew);
                    if (iStore == 0)
                        {
                        onPrimaryOwnershipChanged(iPartition);
                        }
                    }
                else if (nVersionNew != nVersionLocal)
                    {
                    setOwnershipVersion(iPartition, nVersionNew);
                    onPrimaryOwnershipChanged(iPartition);
                    }
                }
            }
        
        if (fRepublish && isOwnershipEnabled())
            {
            putPartitionConfig(iPartition, owners);
            }
        }
    
    /**
     * Perform a cleanup of unused persistent stores following a partition
    * recovery.
    * 
    * Called on the service or worker threads.
     */
    public void onPartitionRecoverCleanup(PartitionedService.PartitionRecoverCleanup msg)
        {
        // import Component.Net.MemberSet.ActualMemberSet.ServiceMemberSet;
        // import com.oracle.coherence.persistence.PersistenceManager;
        // import com.tangosol.net.partition.PartitionSet;
        // import com.tangosol.net.partition.VersionedOwnership;
        // import com.tangosol.persistence.GUIDHelper;
        
        PersistenceManager mgrActive = getPersistenceManager();
        PersistenceManager mgrBackup = getPersistenceControl().getBackupManager();
        PersistenceManager mgrEvents = getPersistenceEventsManager();
        boolean            fPrimary  = msg.isPrimary();
        
        _assert(mgrActive != null);
        
        PartitionSet parts = msg.getPartitions();
        if (!parts.isEmpty())
            {
            // attempt to remove old versions of the specified partitions
            ServiceMemberSet      setMembers = getServiceMemberSet();
            PersistentStoreInfo[] aInfos     = mgrActive.listStoreInfo();
            for (int i = 0, c = aInfos == null ? 0 : aInfos.length; i < c; ++i)
                {
                String sGUID = aInfos[i].getId();
                int    iPart = GUIDHelper.getPartition(sGUID);
        
                if (iPart < getPartitionCount() && parts.contains(iPart))
                    {
                    VersionedOwnership owners = getPartitionConfig(iPart);
        
                    int    nMemberOwner = owners.getPrimaryOwner();
                    int    nMemberStore = GUIDHelper.getMemberId(sGUID);
                    int    nMemberThis  = getThisMember().getId();
                    long   ldtJoinStore = GUIDHelper.getServiceJoinTime(sGUID);
        
                    boolean fEligible = nMemberOwner > 0 &&
                        nMemberStore != nMemberOwner &&
                        ldtJoinStore != setMembers.getServiceJoinTime(nMemberOwner) &&
                        GUIDHelper.getVersion(sGUID) < owners.getVersion();
        
                    // only delete the persistent store if it is eligible
                    // and one of the following holds:
                    //   1. This member was the previous owner
                    //   2. The previous owner is no longer a member of the service
        
                    if (fEligible &&
                        (nMemberThis == nMemberStore &&
                         setMembers.getServiceJoinTime(nMemberThis) == ldtJoinStore ||
                         ldtJoinStore != setMembers.getServiceJoinTime(nMemberStore)))
                        {
                        String sSource = null;
        
                        // delete the old store
                        if (mgrActive.delete(sGUID, false))
                            {
                            sSource = "active";
                            }
        
                        if (mgrEvents != null && mgrEvents.delete(sGUID, false))
                            {
                            sSource = sSource == null ? "event" : (sSource + " and event");
                            }
        
                        if (sSource != null)
                            {
                            _trace("Removed old partition (" + sGUID +
                                ") from " + sSource + " persistent directory store", 7);
                            }
                        }
                    }
                }
        
            if (!msg.isPrimary() && mgrBackup != null)
                {
                PersistentStoreInfo[] aBackupInfos = mgrBackup.listStoreInfo();
                for (int i = 0, c = aBackupInfos == null ? 0 : aBackupInfos.length; i < c; ++i)
                    {
                    String sGUID = aBackupInfos[i].getId();
                    int    iPart = GUIDHelper.getPartition(sGUID);

                    // clean up all backups possible as not all are used to recover
                    if (iPart < getPartitionCount())
                        {
                        VersionedOwnership owners       = getPartitionConfig(iPart);
                        int                nMemberStore = GUIDHelper.getMemberId(sGUID);
                        if (isInOwnerMembers(nMemberStore, owners))
                            {
                            // a copy of the partition is still active in another backup index
                            continue;
                            }

                        int                nMemberThis  = getThisMember().getId();
                        long               ldtJoinStore = GUIDHelper.getServiceJoinTime(sGUID);

                        // delete the persistent store; backups can be a previous store
                        // not previously owned
                        if (nMemberStore != nMemberThis &&
                            ldtJoinStore != setMembers.getServiceJoinTime(nMemberThis) &&
                            ldtJoinStore != setMembers.getServiceJoinTime(nMemberStore))
                            {
                            // delete the old store
                            if (mgrBackup.delete(sGUID, false))
                                {
                                _trace("Removed old partition (" + sGUID +
                                       ") from backup persistent directory store", 7);
                                }
                            }
                        }
                    }
                }
            }
        }

    /**
     * Determine whether a given store owner is still in the owners list for
     * this partition, meaning that it may still be in use here or elsewhere.
     *
     * @param nMemberStore  the store to check
     * @param owners        the versioned ownership view config for the partition
     * @return true if this store is still owned by any of the listed members
     */
    private boolean isInOwnerMembers(int nMemberStore, VersionedOwnership owners)
        {
        for (int i = 1; i < owners.getBackupCount() + 1; i++)
            {
            if (owners.getOwner(i) == nMemberStore)
                {
                return true;
                }
            }

        return false;
        }

    /**
     * RecoverJob performs partition recovery for a sub set of partitions based
     * on the associated PartitionRecoverRequest to facilitate parallel recovery.
     */
    public void onPartitionRecoverJob(PartitionedService.PartitionRecoverRequest.RecoverJob job)
        {
        // import com.oracle.coherence.persistence.PersistenceException;
        // import com.oracle.coherence.persistence.PersistenceManager;
        // import com.oracle.coherence.persistence.PersistentStore;
        // import com.tangosol.net.internal.PartitionRecoverInfo;
        // import com.tangosol.net.partition.PartitionSet;
        // import com.tangosol.persistence.GUIDHelper;
        // import java.util.ArrayList;
        // import java.util.Iterator;
        // import java.util.List;
        // import java.util.HashMap;
        // import java.util.Map;
        // import java.util.Map$Entry as java.util.Map.Entry;
        
        PartitionRecoverInfo    info            = job.getRecoverInfo();
        List                    listGUID        = job.getListGUID();
        int                     cGUID           = listGUID.size();
        Map                     mapStoresFrom   = new HashMap(cGUID);
        PartitionSet            partsFail       = instantiatePartitionSet(false);
        PartitionSet            partsEventsFail = instantiatePartitionSet(false);
        PersistenceManager      mgrRecover      = info.getManager();
        PartitionRecoverRequest msgRequest      = (PartitionRecoverRequest) info.getRequest();
        String[]                asInvalidGUIDs  = msgRequest.getInvalidPersistentIds();
        String[]                asGUID          = (String[]) listGUID.toArray(new String[cGUID]);
        PartitionedService.PersistenceControl  ctrl            = getPersistenceControl();
        boolean                 fSnapshot       = ctrl.getActiveManager() != mgrRecover;

        if (mgrRecover != null)
            {
            // if recovering from persisted backup partitions
            PersistenceManager backupMgr         = fSnapshot
                ? null
                : ctrl.getBackupManager();  // the backup manager
            PersistentStoreInfo[] aBackupStores
                    = backupMgr == null ? null : backupMgr.listStoreInfo();
            PersistentStoreInfo[] aPrimaryStores   = null;
            MemberSet             ownershipMembers = getOwnershipMemberSet();

            // clean up stores the coordinator determined to be invalid
            if (asInvalidGUIDs != null)
                {
                for (int i = 0, c = asInvalidGUIDs.length; i < c; i++)
                    {
                    String sGUID = asInvalidGUIDs[i];
                    if (fSnapshot)
                        {
                        mgrRecover.close(sGUID);
                        }
                    else
                        {
                        mgrRecover.delete(sGUID, false);
                        }
                    }
                }

            // favor primary partitions
            if (aBackupStores != null)
                {
                Arrays.sort(aBackupStores, PersistentStoreInfo::compareTo);
                aPrimaryStores = mgrRecover.listStoreInfo();
                Arrays.sort(aPrimaryStores, PersistentStoreInfo::compareTo);
                }
            
            // collect valid stores and remove invalid to prevent an infinite protocol loop
            for (int i = 0; i < cGUID && getServiceState() < SERVICE_STOPPING; i++)
                {
                String sGUID     = asGUID[i];
                int    iPart     = GUIDHelper.getPartition(sGUID);
                long   lJoinTime = GUIDHelper.getServiceJoinTime(sGUID);
                int    nMember   = GUIDHelper.getMemberId(sGUID);
                if (!fSnapshot &&
                    getThisMember().getId() != nMember &&
                    ownershipMembers.contains(nMember) &&
                    lJoinTime == getServiceMemberSet().getServiceJoinTime(nMember))
                    {
                    // skip; list can return stores created concurrently by active members
                    partsFail.add(iPart);
                    onStoreOpenFailed(mgrRecover, iPart, sGUID, null);
                    continue;
                    }

                // mark store is primary or backup in order to close it with the correct
                // persistence manager
                boolean fBackup = aBackupStores != null &&
                                  Arrays.stream(aBackupStores).anyMatch(s -> sGUID.equals(s.getId())) &&
                                  !Arrays.stream(aPrimaryStores).anyMatch(s -> sGUID.equals(s.getId()));

                try
                    {
                    mapStoresFrom.put(Integer.valueOf(iPart),
                                       new Object[] {
                                          ctrl.openStoreForRead(fBackup ? backupMgr : mgrRecover, sGUID),
                                          Boolean.valueOf(fBackup)});

                    if ((i & 0xF) == 0xF)
                        {
                        // open persistent store can be expensive, make sure we notify the guardian
                        heartbeat();
                        }
                    }
                catch (PersistenceException e)
                    {
                    partsFail.add(iPart);
                    onStoreOpenFailed(mgrRecover, iPart, sGUID, e);
                    }
                }
            }
        
        Map mapStoresTo = openStores(mgrRecover, mapStoresFrom, partsFail, partsEventsFail);
        
        // the poll will be responded to when the all recovery job completes; see #onFinalizeRecoverPrimary
        recoverPartitions(job, mapStoresFrom, mapStoresTo, partsFail, partsEventsFail);
        }
    
    /**
     * Second phase of assigning empty partitions. This method will dispatch the
    * UEM event followed by finalizing the assignment process via
    * onFinalizeAssignPrimary. Called on the service thread only.
    * 
    * @param partsAssigned    the empty partitions that have just been assigned
    * (initially)
    * @param partsLost             the empty partitions that were lost
    * @param continuation       the continuation that calls
    * onFinalizeAssignPrimary on the service thread
     */
    protected void onPartitionsAssigned(com.tangosol.net.partition.PartitionSet partsAssigned, com.tangosol.net.partition.PartitionSet partsLost, com.oracle.coherence.common.base.Continuation continuation)
        {
        }
    
    /**
     * Second phase of partition recovery.
     */
    public void onPartitionsRecovered(com.tangosol.net.partition.PartitionSet partsRecovered, String sSnapshotName, com.oracle.coherence.common.base.Continuation continuation)
        {
        }
    
    /**
     * Post-phase of restoring orphaned partitions from backup. This method will
    * dispatch the UEM event followed by finalizing the restoration process via
    * onFinalizeRestorePrimary. Called on the service thread only.
    * 
    * @param parts               the partitions that have been restored
    * @param continuation  the continuation that calls onFinalizeRestorePrimary
    * on the service thread
     */
    protected void onPartitionsRestored(com.tangosol.net.partition.PartitionSet partsRestored, com.oracle.coherence.common.base.Continuation continuation)
        {
        }
    
    public void onPartitionSwapRequest(PartitionedService.PartitionSwapRequest msgRequest)
        {
        // this should only be sent to ownership-enabled members
        _assert(isOwnershipEnabled());
        
        int iPartition = msgRequest.getPartition();
        int iStoreLow  = msgRequest.getPromoteIndex();
        int iStoreHigh = iStoreLow + 1;
        
        // sync the local assignments to the primary's view
        assignPartitionOwners(iPartition, msgRequest.getOwners().getOwners());
        
        // swap the local assignments; the primary owner will publish on poll completion
        int[] aiOwner          = getPartitionAssignments()[iPartition];
        int   nMemberToPromote = aiOwner[iStoreHigh];
        aiOwner[iStoreHigh]    = aiOwner[iStoreLow];
        aiOwner[iStoreLow]     = nMemberToPromote;
        }
    
    /**
     * Called when this service member's view of the primary ownership has
    * changed, and client contexts (e.g. threads) may need to be updated.
     */
    public void onPrimaryOwnershipChanged(int nPartition)
        {
        if (getPartitionAssignments()[nPartition][0] != 0)
            {
            clearContention(nPartition);
            }
        
        if (isOwnershipEnabled(getThisMember()))
            {
            getPersistenceControl().onPrimaryOwnershipChanged(nPartition);
        
            setDistributionStable(false);
            }
        }
    
    /**
     * Called when partition recover failed after partition is locked and
    * assigned locally.
     */
    public void onRecoverFailed(com.oracle.coherence.persistence.PersistenceManager mgrRecover, String sGUID, boolean fDelete)
        {
        if (getServiceState() < SERVICE_STOPPING)
            {
            // move storeFrom into the trash area for manual diagnosis allowing
            // another iteration of the ownership protocol to attempt recovery
            // from a prior version
            if (isSnapshotManager(mgrRecover))
                {
                mgrRecover.close(sGUID);
                }
            else if (fDelete)
                {
                mgrRecover.delete(sGUID, true);
                }
            }
        // else some other member should attempt recovery using storeFrom
        }
    
    // Declared at the super level
    /**
     * The default implementation of this method sets AcceptingClients to true.
    * If the Service has not completed preparing at this point, then the
    * Service must override this implementation and only set AcceptingClients
    * to true when the Service has actually "finished starting".
     */
    public void onServiceStarted()
        {
        // import Component.Util.DaemonPool as com.tangosol.coherence.component.util.DaemonPool;
        // import com.oracle.coherence.common.internal.Platform;
        // import com.oracle.coherence.persistence.PersistenceEnvironment;
        // import com.oracle.coherence.persistence.PersistenceManager;
        // import com.tangosol.net.cache.LocalCache;
        // import com.tangosol.net.partition.KeyAssociator;
        // import com.tangosol.net.partition.KeyPartitioningStrategy;
        // import com.tangosol.persistence.AbstractPersistenceEnvironment;
        // import com.tangosol.persistence.SafePersistenceWrappers;
        
        // validate that the local service config is compatible with
        // the other service members
        if (!validateServiceConfig())
            {
            // turn off the ownership to accelerate the departure (see onNotifyShutdown)
            setOwnershipEnabled(false);
            post(instantiateMessage("NotifyShutdown"));
            return;
            }
        
        KeyAssociator           associator   = getKeyAssociator();
        KeyPartitioningStrategy partitioning = getKeyPartitioningStrategy();
        int                     cPartitions  = getPartitionCount();
        
        // initialize the contention array
        setPartitionContention(new PartitionedService.Contention[cPartitions]);
        
        // initialize the partition assignment array
        setPartitionAssignments(new int[cPartitions][getBackupCount() + 1]);
        
        // initialize the partition versions array
        setOwnershipVersion(new int[cPartitions]);
        
        // set up a KeyToBinary converter which will use the current context class 
        // loader and may also serve as a default KeyPartitioningStrategy
        // implementation
        PartitionedService.ConverterKeyToBinary convKeyDown = instantiateKeyToBinaryConverter(null, false);
        setKeyToBinaryConverter(convKeyDown);
        
        // per KeyAssociator contract: call init()
        associator.init(this);
        
        if (partitioning == null)
            {
            // this will only be used externally (see $ConverterKeyToBinary#convert)
            setKeyPartitioningStrategy(convKeyDown);
            }
        else
            {
            // per KeyPartitioningStrategy contract: call init()
            partitioning.init(this);
            }
        
        if (isOwnershipEnabled())
            {
            // allocate partition control array
            setPartitionControl(new PartitionedService.PartitionControl[cPartitions]);
        
            PartitionedService.PersistenceControl ctrlPersistence = getPersistenceControl();
        
            // re-read configuration to identify if thread-count is negative
            com.tangosol.coherence.component.util.DaemonPool pool     = null;
            int        cDaemons = getDependencies().getWorkerThreadCountMin();
        
            setConcurrent(cDaemons != 0);
            if (cDaemons > 0)
                {
                // start the daemon pool
                pool = getDaemonPool();
                pool.setThreadGroup(new ThreadGroup(getServiceName()));
        
                PersistenceEnvironment env = SafePersistenceWrappers.unwrap(
                    ctrlPersistence.getPersistenceEnvironment());
                if (env instanceof AbstractPersistenceEnvironment)
                    {
                    ((AbstractPersistenceEnvironment) env).setDaemonPool(pool);
                    }
                }
        
            //TODO: in the rare case of no daemon pool consider creating a daemon pool
            //      backed by the EventDispatcher thread to be used by persistence ops
        
            // set up the active manager if enabled
            PersistenceManager mgrActive = ctrlPersistence.openActiveManager();
        
            // with active persistence enabled increase the min thread count to
            // allow persistence (blocking on IO tasks) to execute in parallel
            if (mgrActive != null && cDaemons == 1)
                {
                int cDaemonsMax = pool.getDaemonCountMax();
                if (cDaemonsMax > 2)
                    {
                    pool.setDaemonCountMin(Math.min(
                        Math.max(Platform.getPlatform().getFairShareProcessors(), 2),
                        cDaemonsMax - 1));
                    }
                }
        
            if (pool != null) // start the daemon pool
                {
                pool.start();
                }
        
            // eagerly create the EventDispatcher thread
            ensureEventDispatcher();
            }
        
        // attach the service and partition config listeners
        getServiceConfigMap()  .getConfig().attachConfigListener();
        getPartitionConfigMap().getConfig().attachConfigListener();
        
        // initialize the distribution strategy
        getDistributionStrategy().initialize();
        
        // partition events monitoring cache; keep partition events for an hour
        setPartitionEvents(new LocalCache(LocalCache.DEFAULT_UNITS, 3600000));
        
        finalizeStartup();
        if (isActivePersistence())
            {
            scheduleEnvironmentMaintenance();
            }
        }
    
    // Declared at the super level
    /**
     * The default implementation of this method sets AcceptingClients to false.
     */
    protected void onServiceStopping()
        {
        if (getThisMember() == getOwnershipSenior())
            {
            // schedule a distribution to hasten our exit if we are the distribution coordinator
            setDistributionNextMillis(0L);
            }
        
        // don't call the super, since we use AcceptingClients property till the very end
        return;
        }
    
    /**
     * Called when a PersistentStore failed to open; either in opening an
    * existing store or a new store based on an existing store.
     */
    public void onStoreOpenFailed(com.oracle.coherence.persistence.PersistenceManager mgrRecover, int nPartition, String sGUID, com.oracle.coherence.persistence.PersistenceException e)
        {
        // import com.oracle.coherence.persistence.FatalAccessException;
        // import com.oracle.coherence.persistence.PersistenceManager;
        // import com.oracle.coherence.persistence.PersistentStore;
        // import com.tangosol.util.Base;
        
        String sMsg = "Failed to recover partition " + nPartition +
                   " from the persistent storage (GUID=" + sGUID + ')';
                   
        int nLogLevel = 2;
        if (e instanceof FatalAccessException)
            {
            sMsg += "; " + e.getMessage();
        
            if (getServiceState() < SERVICE_STOPPING)
                {
                if (isSnapshotManager(mgrRecover))
                    {
                    mgrRecover.close(sGUID);
                    }
                else
                    {
                    // COH-9914: move to trash instead of deleting
                    mgrRecover.delete(sGUID, true);
        
                    sMsg += "; reinstate persistent store from trash once validation errors have been resolved";
                    }
                }
            }
        else if (getServiceState() < SERVICE_STOPPING)
            {
            // encountered an unexpected exception in recovering from the
            // store; the store may be usable by other processes but not
            // us thus exclude it from the stores this member can recover
            if (isSnapshotManager(mgrRecover))
                {
                mgrRecover.close(sGUID);
                }
            else
                {
                // copy store to trash dir
                mgrRecover.writeSafe(sGUID);
                }
        
            getPersistenceControl().onTransientException(sGUID);
        
            sMsg += "; excluded from future recovery requests";
            nLogLevel = 3;
            }
        
        _trace(sMsg + (e == null ? "" : '\n' + Base.getStackTrace(e)), nLogLevel);
        }
    
    /**
     * This method dispatches the UEM events: DEPARTED if the primary transfer
    * was success or ROLLBACK if the transfer failed.
    * 
    * @param fSuccess  true if transfer was successful
    * @param parts  the partitions transferred out
     */
    public void onTransferCompleted(boolean fSuccess, Object oResult, PartitionedService.TransferRequest msg)
        {
        }
    
    /**
     * TransferRequests are sent in batches and are handled as follows:
    * 
    * primary transfers:
    *   1) queue TransferRequests as they arrive for batch-processing
    *   2) modify local ownership assignments and config to reflect ownership
    *      (note: final ownership changes are handled by
    *       onPartitionConfigUpdate() as a result of the new primary owner's
    * action)
    *   3) when the last transfer is received, process all of the
    *      queued TransferRequests and finish receiving in
    * #onFinalizeReceiveTransfer.
    * 
    * backup transfers: 
    *   1) insert backup partition data as TransferRequests are received
    *   2) update the local ownership assignments to reflect ownership
    *      (note: final ownership changes are handled by
    *       onPartitionConfigUpdate() as a result of primary owner action)
    *   3) respond to each TransferRequest with RESPONSE_INCOMPLETE
    *      except for the last transfer which is replied to with
    *      RESPONSE_RELEASE.
    * 
    * see also onTransferRequestCompleted() and onFinalizeReceiveTransfer()
    * 
    * Called on the service thread only.
     */
    public void onTransferRequest(PartitionedService.TransferRequest msgRequest)
        {
        // import Component.Net.Member;
        // import Component.Net.MemberSet;
        // import com.oracle.coherence.common.base.Continuation;
        // import com.tangosol.internal.tracing.Span;
        // import com.tangosol.internal.tracing.TracingHelper;
        // import com.tangosol.net.partition.VersionedOwnership;
        // import com.tangosol.util.Base;
        // import java.util.List;
        
        _assert(isDistributionInProgress() || msgRequest.getStore() > 0);
        
        //
        // see doc for transfer algorithm details
        //
        PartitionedService.TransferControl  ctrlTransfer     = getTransferControl();
        Member            memberThis       = getThisMember();
        MemberSet         setMembers       = getServiceMemberSet();
        boolean           fLastInPartition = msgRequest.isLastInPartition();
        boolean           fLastInTransfer  = msgRequest.isLastInTransfer();
        int               iPartition       = msgRequest.getPartition();
        PartitionedService.PartitionControl ctrlPart         = getPartitionControl(iPartition);
        
        if (isAcceptingClients() && isOwnershipEnabled() &&
            (ctrlPart == null || !ctrlPart.isLocked()))
            {
            int iStore = msgRequest.getStore();
        
            Span augmentSpan = TracingHelper.augmentSpan();
            augmentSpan.setMetadata("partition", Long.valueOf(iPartition).longValue());
            augmentSpan.setMetadata("replica", Long.valueOf(iStore).longValue());
        
            if (iStore == 0)
                {
                //
                // Received primary transfer
                //
                Continuation continuation = null;
                if (fLastInTransfer)
                    {
                    // capture the completion of primary transfer receipt as a continuation
                    continuation = getContinuations().instantiateFinalizeReceivePrimary(msgRequest);
                    }
                else
                    {
                    // There are more TransferRequests coming; respond with RESPONSE_INCOMPLETE
                    PartitionedService.TransferResponse msgResponse = (PartitionedService.TransferResponse) instantiateMessage("TransferResponse");
                    msgResponse.respondTo(msgRequest);
                    msgResponse.setValue(Integer.valueOf(PartitionedService.TransferRequest.RESPONSE_INCOMPLETE));
                    post(msgResponse);
                    }
        
                ctrlTransfer.onReceiveStarted(msgRequest, continuation);
                }
            else
                {
                //
                // Received backup transfer
                //
        
                // The received transfers are queued and processed one partition at a time.
                // Although we may be receiving a bulk transfer from one primary owner,
                // each partition may have a different "previous backup owner" which needs
                // to be sent a $BackupRelease in order to complete the backup transfer.
        
                // Fetch the local assignments after ensuring that our ownership
                // matches the primary sender's (as they may be changed by
                // #assignPartitionOwner).
                int[][] aaiOwner = getPartitionAssignments();
        
                ctrlTransfer.onReceiveStarted(msgRequest, null);
        
                if (fLastInPartition)
                    {
                    // prepare the partition and receive the transfers
                    preparePartition(iPartition, iStore);
        
                    Member memberPrimary = msgRequest.getFromMember();
                    List   listXfersIn   = ctrlTransfer.getQueuedTransfers(memberPrimary);
        
                    // allocation partition control for persistence
                    PartitionedService.PartitionControl ctrlPartition = ensurePartitionControl(iPartition);

                    receivePartition(iPartition, iStore, listXfersIn);

                    listXfersIn.clear();
        
                    // set the partition version
                    ctrlPartition.getVersionCounter().set(msgRequest.getPartitionVersion());
                    
                    // Update our local assignments to claim backup ownership;
                    // the primary owner will publish the global config.
                    aaiOwner[iPartition][iStore] = memberThis.getId();
        
                    // issue a PartitionedService.BackupAssignment release to the old backup owner (if exists),
                    // or to the primary owner if the partition was endangered
                    int    nPrevBackup = msgRequest.getOwners().getOwner(iStore);
                    Member memberPrev  = setMembers.getMember(nPrevBackup);
                    if (memberPrev == null)
                        {
                        // the partition was endangered, or the previous backup owner has left
                        ctrlTransfer.sendBackupAnnounce(iPartition, iStore, memberPrimary, null);
                        }
                    else
                        {
                        // tell the previous backup owner to release
                        ctrlTransfer.sendBackupRelease(
                            iPartition, iStore, memberPrimary.getId(), memberThis.getId(), memberPrev, null);
                        }
                    }
        
                if (fLastInTransfer)
                    {
                    // notify the transfer-control that the transfers were committed
                    ctrlTransfer.onReceiveCommitted(msgRequest);
                    }
        
                PartitionedService.TransferResponse msgResponse = (PartitionedService.TransferResponse) instantiateMessage("TransferResponse");
                msgResponse.respondTo(msgRequest);
                msgResponse.setValue(Integer.valueOf(
                    fLastInPartition ? PartitionedService.TransferRequest.RESPONSE_RELEASE :
                                       PartitionedService.TransferRequest.RESPONSE_INCOMPLETE));
                post(msgResponse);
                }
            }
        else
            {
            PartitionedService.TransferResponse msgResponse = (PartitionedService.TransferResponse) instantiateMessage("TransferResponse");
            msgResponse.respondTo(msgRequest);
            msgResponse.setValue(Integer.valueOf(PartitionedService.TransferRequest.RESPONSE_REJECT));
            post(msgResponse);
            }
        }
    
    /**
     * There are 3 responses to primary transfer:
    * - RESPONSE_REJECT
    *   The transfer recipient has left.  Rollback all of the transfers
    *   that were in-progress, and republish the ownership.
    * - RESPONSE_INCOMPLETE
    *   The transfer was received, but there are more transfer-requests
    *   in the logical distribution.  The forthcoming requests may or may
    *   not contain transfers for multiple partitions.
    * - a java.util.Map instance
    *   The batch of transfers was received successfully.  The new owner
    *   will inform everybody of the new ownership.  The map result describes
    *   whether each partition should be released, or moved to backup
    * ownership.
    * 
    * There are 3 responses to backup transfer:
    * - RESPONSE_REJECT
    *   The transfer recipient has left.  Rollback the local ownership-
    *   assignment for all of the transfers in-progress.
    * - RESPONSE_INCOMPLETE
    *   The transfer was received, but there are more transfer-requests
    *   in the logical distribution.  The forthcoming requests may or may
    *   not contain transfers for multiple partitions.
    * - RESPONSE_RELEASE
    *   The batch of transfers was received successfully.  Publish the
    *   config updates for the batch of transfers.
    * 
    * Called on the service thread only.
     */
    public void onTransferRequestCompleted(PartitionedService.TransferRequest msgRequest)
        {
        // import Component.Net.Member;
        // import Component.Net.MemberSet;
        // import com.tangosol.net.partition.VersionedOwnership;
        // import com.tangosol.net.partition.PartitionEvent;
        // import com.tangosol.net.partition.PartitionSet;
        // import com.tangosol.util.Base;
        // import java.util.HashMap;
        // import java.util.Iterator;
        // import java.util.Map;
        // import java.util.Map$Entry as java.util.Map.Entry;
        
        if (getServiceState() == SERVICE_STOPPED)
            {
            return;
            }
        
        //
        // see doc for transfer algorithm details
        //
        
        Object              oResult        = msgRequest.getResponse();
        int[][]             aaiOwner       = getPartitionAssignments();
        MemberSet           setMembers     = getServiceMemberSet();
        Member              memberThis     = getThisMember();
        int                 nMemberThis    = memberThis.getId();
        PartitionedService.TransferControl    ctrlTransfer   = getTransferControl();
        PartitionedService.PartitionControl[] aCtrlPartition = getPartitionControl();
        boolean             fPrimary;
        
        if (fPrimary = msgRequest.getStore() == 0)
            {
            //
            // primary partition transfer
            //
            if (oResult instanceof Integer)
                {
                int iResult = ((Integer) oResult).intValue();
                if (iResult == PartitionedService.TransferRequest.RESPONSE_REJECT)
                    {
                    // transfer failed, the recipient is leaving or has left;
                    // restore the ownership for all of the primary transfers
                    // in-progress and inform everybody of the rollback (COH-635)
                    //
                    // Note: only run this logic for the last-transfer message.
                    //       If there is a large batch of transfers, we may
                    //       receive multiple rejected polls.  Only process the
                    //       last one so we don't prematurely release the
                    //       transfer control.  We are guaranteed that on service
                    //       failure of the recipient, polls will be closed in-order.
                    
                    if (msgRequest.isLastInTransfer())
                        {
                        Map          mapOwners   = new HashMap();
                        PartitionSet partsLocked = new PartitionSet(getPartitionCount());
        
                        for (PartitionedService.TransferControl.TransferIterator iter = ctrlTransfer.iterateTransfersInProgress();
                             iter.hasNext(); )
                            {
                            iter.next();
        
                            int iPartition = iter.getPartition();
                            int iStore     = iter.getBackup();
                            int nOwner     = aaiOwner[iPartition][0];
        
                            // there should only be primary transfers in-progress
                            _assert(iStore == 0);
        
                            if (nOwner != nMemberThis)
                                {
                                int nMemberRecipient = msgRequest.getRecipient().getId();
        
                                _trace("Failed primary transfer for partition " + iPartition +
                                   " to member " + nMemberRecipient +
                                   "; reclaiming the ownership from member " + nOwner, 3);
        
                                // rejecting member may have created new persistence store with
                                // incremented partition version; need to double increment here
        
                                incrementOwnershipVersion(iPartition);
                                int nVersionNew = incrementOwnershipVersion(iPartition);
                                assignPartitionOwner(iPartition, 0, nMemberThis);
                            
                                if (isActivePersistence())
                                    {
                                    aCtrlPartition[iPartition].updatePersistentStoreVersion();
                                    }
        
                                firePartitionEvent(PartitionEvent.PARTITION_TRANSMIT_ROLLBACK,
                                    iPartition, null, memberThis);
        
                                VersionedOwnership owners = new VersionedOwnership(getPartitionConfig(iPartition));
                                owners.setOwner(0, nMemberThis);
                                owners.setVersion(nVersionNew);
        
                                mapOwners.put(Integer.valueOf(iPartition), owners);
        
                                ctrlTransfer.onTransmitRejected(iPartition, 0);
        
                                partsLocked.add(iPartition);
        
                                if (setMembers.contains(nMemberRecipient))
                                    {
                                    // the transfer was actively rejected by the intended recipient
                                    // (i.e. the member did not die).  No need to confirm the backup
                                    // ownership, as the recipient could not have initiated a RELEASE
                                    }
                                else
                                    {
                                    // COH-4734: the transfer recipient may have intended to
                                    //           assign us (the "old" primary) as a backup owner.
                                    //           if that is the case, we must "confirm" the old
                                    //           backup owners
                                    int cBackups = getBackupCount();
                                    for (int iBackup = 1; iBackup <= cBackups; iBackup++)
                                        {
                                        int    nBackupOwner = owners.getOwner(iBackup);
                                        Member memberBackup = setMembers.getMember(nBackupOwner);
                                        if (memberBackup != null)
                                            {
                                            ctrlTransfer.requestBackupConfirmation(
                                                    iPartition, iBackup, nMemberRecipient, memberBackup);
                                            }
                                        }
                                    }
                                }
                            }
        
                        // unlock the partitions in the failed transfer
                        for (int iPart = partsLocked.next(0); iPart >= 0; iPart = partsLocked.next(iPart + 1))
                            {
                            aCtrlPartition[iPart].unlock();
                            }
        
                        _assert(!isTransferInProgress());
        
                        // inform everyone about the rollback (see COH-635)
                        putPartitionConfig(mapOwners);
                        }
                    }
                else
                    {
                    // this must be RESPONSE_INCOMPLETE.  There are still outstanding
                    // TransferRequests in this distribution that haven't completed
                    // (or arrived) yet.
                    _assert(iResult == PartitionedService.TransferRequest.RESPONSE_INCOMPLETE);
                    }
                }
            else
                {
                // transfer succeeded.  Release or backup the data for each
                // partition transferred, according to the result Map.
        
                Map mapResponses = (Map) oResult;
        
                for (Iterator iter = mapResponses.entrySet().iterator(); iter.hasNext();)
                    {
                    java.util.Map.Entry entry      = (java.util.Map.Entry) iter.next();
                    int   iPartition = ((Integer) entry.getKey()).intValue();
                    int   iResult    = ((Integer) entry.getValue()).intValue();
        
                    if (iResult == PartitionedService.TransferRequest.RESPONSE_RELEASE)
                        {
                        releasePartition(iPartition, /*iBackup*/0);
                        }
                    else
                        {
                        // the only other allowable response is a backup ownership index
                        _assert(iResult > 0);
                        movePartition(iPartition, iResult);
        
                        // update the local ownership assignment to reflect the new
                        // backup storage.  The new primary owner should publish
                        // this and inform everyone right away.
                        aaiOwner[iPartition][iResult] = nMemberThis;
                        }
        
                    int nMemberTo = msgRequest.getRecipient().getId();
                    firePartitionEvent(PartitionEvent.PARTITION_TRANSMIT_COMMIT,
                        iPartition, memberThis, setMembers.getMember(nMemberTo));
        
                    ctrlTransfer.onTransmitCompleted(iPartition, 0);
        
                    PartitionedService.PartitionControl control = aCtrlPartition[iPartition];
        
                    control.flushDeferredBackups();
                    control.unlock();
        
                    if (iResult == PartitionedService.TransferRequest.RESPONSE_RELEASE)
                        {
                        releasePartitionControl(iPartition);
                        }
                    else
                        {
                        control.reset();
                        }
                    }
        
                // if we finished processing the last transfer, we should not have any
                // more transfers left in-progress
                _assert(!isTransferInProgress());
                }
            }
        else
            {
            //
            // backup partition transfer
            //
            int iPartition = msgRequest.getPartition();
            int iStore     = msgRequest.getStore();
            if (aaiOwner[iPartition][0] == nMemberThis)
                {
                int iResult = ((Integer) oResult).intValue();
                if (iResult == PartitionedService.TransferRequest.RESPONSE_REJECT)
                    {
                    // transfer failed, the recipient is leaving or has left;
                    // restore the ownership (we never told anyone)
                    if (msgRequest.isLastInPartition())
                        {
                        VersionedOwnership owners           = getPartitionConfig(iPartition);
                        int                nBackupLocal     = aaiOwner[iPartition][iStore];
                        int                nBackupGlobal    = owners.getOwner(iStore);
                        int                nMemberRecipient = msgRequest.getRecipient().getId();
        
                        _assert(nBackupLocal == nMemberRecipient);
        
                        _trace("Failed backup transfer for partition " + iPartition +
                               " to member " + nMemberRecipient, 3);
        
                        ctrlTransfer.onTransmitRejected(iPartition, iStore);
        
                        // failure of the backup transfer does not automatically revert
                        // ownership to the previous owner; we must validate that it still
                        // holds it (it may have received a RELEASE from the departed member).
                        if (nBackupLocal == nBackupGlobal)
                            {
                            // our local assignments match the global config (which advertise
                            // the new backup owner); we must have already received the ANNOUNCE
                            // and published the configuration.
                            // Nothing to do here; when we hear the NotifyServiceLeft, we will
                            // endanger the partition and make it eligible for distribution
                            // (see #validatePartitionAssignments)
                            }
                        else
                            {
                            Member memberOwnerPrev = setMembers.getMember(nBackupGlobal);
                            if (memberOwnerPrev == null)
                                {
                                // the previous backup owner has also left, and the transfer to 
                                // the new backup owner failed.
                                aaiOwner[iPartition][iStore] = 0;
                                publishPartitionOwnership(iPartition, iStore, 0);
        
                                getPartitionControl(iPartition).enableTransfer();
                                }
                            else
                                {
                                // update the local assignments to revert back to the old owner
                                // to ensure that we continue sending backup updates to it.
                                aaiOwner[iPartition][iStore] = nBackupGlobal;
        
                                if (setMembers.contains(nMemberRecipient))
                                    {
                                    // the transfer was actively rejected by the intended recipient
                                    // (i.e. the member did not die).  No need to confirm the backup
                                    // ownership, as the recipient could not have initiated a RELEASE
        
                                    getPartitionControl(iPartition).enableTransfer();
                                    }
                                else
                                    {
                                    // we need to confirm that the old backup still has the storage
                                    ctrlTransfer.requestBackupConfirmation(
                                            iPartition, iStore, nMemberRecipient, memberOwnerPrev);
                                    }
                                }
                            }
                        }
                    }
                else if (iResult == PartitionedService.TransferRequest.RESPONSE_RELEASE)
                    {
                    // transfer success
                    if (msgRequest.isLastInPartition())
                        {
                        // finished transmitting the backup snapshot to the new owner,
                        // but do not change or publish the Ownership until the transfer
                        // is confirmed by the old backup
                        ctrlTransfer.onTransmitCompleted(iPartition, iStore);
                        aCtrlPartition[iPartition].reset();
                        }
                    }
                else
                    {
                    // this must be RESPONSE_INCOMPLETE.  There are still outstanding
                    // TransferRequests in this distribution that haven't completed
                    // (or arrived) yet.
                    _assert(iResult == PartitionedService.TransferRequest.RESPONSE_INCOMPLETE);
                    }
        
                if (msgRequest.isLastInTransfer())
                    {
                    // everything in the PartitionedService.TransferControl should be cleaned up
                    _assert(!isTransferInProgress());
                    }
                }
            else
                {
                _trace("Partition " + iPartition +
                    " ownership was transferred to member " + aaiOwner[iPartition][0] +
                    " without consent:\n" + getPartitionConfig(iPartition), 1);
                }    
            }
        
        if (!isTransferInProgress())
            {
            // schedule the distribution check immediately for the primary
            // ownership and respecting the aggressiveness factor for the backup
            setDistributionNextMillis(Base.getSafeTimeMillis() +
                (fPrimary ? 0 : (getDistributionRepeatMillis() / getDistributionAggressiveness())));
                
            // wait for a second to allow further partition transfers (if any) to finish
            // before sending PartitionStats to senior
            getDistributionStrategy().setStatsSampleNextMillis(Base.getSafeTimeMillis() + 1000L);
            }
        }
    
    /**
     * Open a store for a given GUID for recovery.
     */
    protected com.oracle.coherence.persistence.PersistentStore openStoreForRead(com.oracle.coherence.persistence.PersistenceManager mgr, String sGUID, boolean fOpen)
        {
        // import com.oracle.coherence.persistence.ConcurrentAccessException;
        // import com.oracle.coherence.persistence.FatalAccessException;
        // import com.oracle.coherence.persistence.PersistentStore;
        // import com.tangosol.persistence.CachePersistenceHelper as com.tangosol.persistence.CachePersistenceHelper;
        
        // _assert(isRecovering());
        
        if (fOpen)
            {
            if (mgr.isEmpty(sGUID))
                {
                return mgr.createStore(sGUID);
                }

            for (int cRetry = 0; true; cRetry++)
                {
                try
                    {
                    PersistentStore store = mgr.open(sGUID, /*storeFrom*/ null);
        
                    com.tangosol.persistence.CachePersistenceHelper.validate(store, this);
        
                    return store;
                    }
                catch (ConcurrentAccessException e)
                    {
                    if (cRetry > 100) 
                        {
                        throw new FatalAccessException(e);
                        }
                    sleep(10L);
                    }
                }
            }
        
        return mgr.createStore(sGUID);
        }
    
    /**
     * Create new persistent stores from the specified map of PersistentStores
    * (indexed by partition-id).
    * 
    * @param mgrRecover    the PersistenceManager to recover from
    * @param mapStores       the map of PersistentStores, keyed by partition-id
    * @param partsFail           the set of partitions with invalid stores
     */
    public java.util.Map openStores(com.oracle.coherence.persistence.PersistenceManager mgrRecover, java.util.Map mapStores, com.tangosol.net.partition.PartitionSet partsFail, com.tangosol.net.partition.PartitionSet partsEventsFail)
        {
        // import com.oracle.coherence.persistence.PersistenceException;
        // import com.oracle.coherence.persistence.PersistentStore;
        // import com.tangosol.persistence.CachePersistenceHelper as com.tangosol.persistence.CachePersistenceHelper;
        // import com.tangosol.util.NullImplementation as com.tangosol.util.NullImplementation;
        // import java.util.HashMap;
        // import java.util.Iterator;
        // import java.util.Map;
        // import java.util.Map$Entry as java.util.Map.Entry;
        
        Map mapStoresTo = new HashMap(mapStores.size());
        
        if (!mapStores.isEmpty())
            {
            boolean fSnapshot = mgrRecover != getPersistenceManager();
        
            _trace("Recovering " + mapStores.size() + " partitions", 5);

            // iterate the persistent stores and recover from them as long as
            // the service is not stopping (which could happen in the case of a
            // cascading cluster-wide failure or shutdown)
            for (Iterator iter = mapStores.entrySet().iterator();
                 iter.hasNext() && getServiceState() < SERVICE_STOPPING; )
                {
                java.util.Map.Entry             entry      = (java.util.Map.Entry) iter.next();
                Integer           IPartition = ((Integer) entry.getKey());
                int               nPartition = IPartition.intValue();
                PersistentStore   storeFrom  = (PersistentStore) ((Object[]) entry.getValue())[0];
                String            sGUID      = storeFrom.getId();
                PartitionedService.PartitionControl ctrlPart   = getPartitionControl(nPartition);
        
                PartitionedService.PersistenceControl ctrlPersistence = getPersistenceControl();

                // recovery could be a relatively expensive I/O operation, so
                // heartbeat between each partition
                heartbeat();
        
                // if active persistence is configured, recover to the new
                // persistent store for this partition; use a null store otherwise
                PersistentStore storeTo = null;
                boolean         fFailed = false;
        
                if (isActivePersistence())
                    {
                    try
                        {
                        storeTo = ctrlPart.ensureOpenPersistentStore(storeFrom, false);

                        com.tangosol.persistence.CachePersistenceHelper.validate(storeTo, this);

                        com.tangosol.persistence.CachePersistenceHelper.unseal(storeTo);
                        }
                    catch (PersistenceException e)
                        {
                        // the exception must be from validation of storeFrom
                        partsFail.add(nPartition);
                        onStoreOpenFailed(mgrRecover, nPartition, sGUID, e);
        
                        if (storeTo == null)
                            {
                            PersistentStore storeFailed = e.getPersistentStore();
                            String          sGUIDFailed = storeFailed.getId();
                            if (!sGUIDFailed.equals(sGUID))
                                {
                                mgrRecover.delete(sGUIDFailed, false);
                                }
                            }
        
                        // do not put this invalid store in the returned Map
                        storeTo = null;
                        }
        
                    // persistent events requires active persistence
                    if (isPersistEvents())
                        {
                        PersistentStore storeEvents = null;
                        try
                            {
                            storeEvents = ctrlPart.getPersistentEventsStore();
        
                            if (storeEvents == null)
                                {
                                partsEventsFail.add(nPartition);
                                }
                            else
                                {
                                com.tangosol.persistence.CachePersistenceHelper.validate(storeEvents, this);
                                }
                            }
                        catch (PersistenceException e)
                            {
                            // the exception must be from validation of storeFrom
                            partsEventsFail.add(nPartition);
        
                            if (storeEvents == null)
                                {
                                PersistentStore storeFailed = e.getPersistentStore();
                                if (storeFailed != null)
                                    {
                                    ctrlPersistence.getEventsManager().
                                        delete(storeFailed.getId(), false);
                                    }
                                }
                            }
                        }
                    }
                else
                    {
                    storeTo = storeFrom;
                    }
        
                if (storeTo != null)
                    {
                    mapStoresTo.put(IPartition, storeTo);
                    }
                }
            }
        return mapStoresTo;
        }
    
    /**
     * Prevent distribution for specified partition by acquiring the
    * corresponding shared lock and ensuring that this node owns the partition.
    * 
    * @param nPartition   the partition to pin
    * 
    * @return true iff the partition was successfully entered (and is owned);
    * false otherwise
     */
    protected boolean pinOwnedPartition(int nPartition)
        {
        return pinOwnedPartition(nPartition, -1);
        }
    
    /**
     * Prevent distribution for specified partition by acquiring the
    * corresponding shared lock and ensuring that this node owns the partition.
    * 
    * @param nPartition   the partition to pin
    * 
    * @return true iff the partition was successfully entered (and is owned);
    * false otherwise
     */
    protected boolean pinOwnedPartition(int nPartition, int nVersion)
        {
        boolean fEntered = false;
        if ((!isConcurrent() || (fEntered = enterPartition(nPartition))) &&
            isPrimaryOwner(nPartition) &&
            (nVersion == -1 || nVersion == getOwnershipVersion(nPartition)))
            {
            return true;
            }
        else
            {
            if (fEntered)
                {
                exitPartition(nPartition);
                }
        
            return false;
            }
        }
    
    /**
     * Prevent distribution for specified partitions by acquiring corresponding
    * shared locks. The partitions that this node does not own will be removed
    * from the passed in PartitionSet. The only thing that this prevents is a
    * $PartitionControl.close() call that is used when a distribution process
    * attempts to transfer any of the pinned partitions.
    * 
    * @param partitions the PartitionSet to pin
    * 
    * @return a partition set representing partitions that could not be locked;
    * null otherwise
     */
    protected com.tangosol.net.partition.PartitionSet pinOwnedPartitions(com.tangosol.net.partition.PartitionSet partitions)
        {
        return pinOwnedPartitions(partitions, null);
        }
    
    /**
     * Prevent distribution for specified partitions by acquiring corresponding
    * shared locks. The partitions that this node does not own or do not match
    * the expected ownership version will be removed from the passed in
    * PartitionSet. The only thing that this prevents is a
    * $PartitionControl.close() call that is used when a distribution process
    * attempts to transfer any of the pinned partitions.
    * 
    * @param partitions the PartitionSet to pin
    * @param versions   the expected ownership versions of the partitions, may
    * be null
    * 
    * @return a partition set representing partitions that could not be locked;
    * null otherwise
     */
    protected com.tangosol.net.partition.PartitionSet pinOwnedPartitions(com.tangosol.net.partition.PartitionSet partitions, com.tangosol.net.internal.PartitionVersions versions)
        {
        // import com.tangosol.net.partition.PartitionSet;
        
        boolean      fConcurrent = isConcurrent();
        PartitionSet partsOther  = null; // lazy instantiation to optimize the most common case
        
        for (int nPartition = partitions.next(0); nPartition >= 0;
                 nPartition = partitions.next(nPartition + 1))
            {
            int nVersion = versions == null ? -1 : versions.getVersion(nPartition);
        
            if (!pinOwnedPartition(nPartition, nVersion))
                {
                if (partsOther == null)
                    {
                    partsOther = new PartitionSet(getPartitionCount());
                    }
                partsOther.add(nPartition);
                partitions.remove(nPartition);
                }
            }
        
        return partsOther;
        }
    
    /**
     * Ensure that the specified partition is prepared to store data. Called on
    * the service thread only. 
    *  
    * @param iPartition  the partition number to ensure 
    * @param iBackup   the partition to prepare
    *  
    * @see #releasePartition, movePartition, transferPartition, receivePartition
     */
    protected void preparePartition(int iPartition, int iBackup)
        {
        }
    
    /**
     * Called to process a BackupRequest.  The caller guarantees that the member
    * is a backup owner of the associated partition.
    * 
    * Called only on the service thread.
     */
    public void processBackup(com.tangosol.coherence.component.net.message.requestMessage.chainedRequest.backupRequest.BackupSingleRequest msgBackup)
        {
        // import java.util.concurrent.atomic.AtomicLong;
        
        // Note: the caller guarantees that we are a backup-owner for the corresponding partition
        
        int               iPartition = msgBackup.getPartition();
        PartitionedService.PartitionControl control    = getPartitionControl(iPartition);
        
        AtomicLong counter        = control.getVersionCounter();
        long       lVersionExpect = counter.get() + 1;
        long       lVersionNew    = msgBackup.getPartitionVersion();
        
        if (lVersionExpect > lVersionNew)
            {
            // we could get an older version if a backup message is being
            // repeated (due to member failure somewhere earlier in the
            // backup chain).  Since we have already processed the version,
            // we can safely ignore this message
            _trace("Ignoring repeated backup update (version " + lVersionNew + ") for partition "
                 + msgBackup.getPartition() + "; current version is " + lVersionExpect, 5);
            msgBackup.forwardOrReply(msgBackup);
            }
        else if (lVersionExpect < lVersionNew ||
                (!isBackupOwner(iPartition) && control.isTransferringOut()))
            {
            // we have a version gap or the backup arrive before finalizing send primary.
            // Queue the backup message to be replayed
            // at some later time after the gap is closed.
            // This is possible for several reasons:
            //   a) multiple threads on the primary concurrently queued backup
            //      requests for the same partition
            //   b) as a result of a change in backup delivery order (due to
            //      partition transfer/ownership change)
            control.deferBackup(msgBackup, lVersionNew);
            }
        else // lVersionExpect == lVersionNew
            {
            // common case: versions match; process the backup request
            msgBackup.forwardOrReply(msgBackup);    
            msgBackup.doBackup();
            counter.set(lVersionNew);
            control.flushDeferredBackups();
            }
        }
    
    /**
     * Called to process a BackupMultiRequest.  The caller guarantees that the
    * member is a backup owner of the associated partitions.
    * 
    * Called only on the service thread.
     */
    public void processBackupMulti(com.tangosol.coherence.component.net.message.requestMessage.chainedRequest.backupRequest.BackupMultiRequest msgBackup)
        {
        // import com.tangosol.net.partition.PartitionSet;
        // import com.tangosol.util.PrimitiveSparseArray;
        
        // Note: the caller guarantees that we are a backup-owner for the corresponding partitions
        
        PartitionSet         parts      = msgBackup.getPartitionSet();
        PartitionSet         partsDefer = null;
        PrimitiveSparseArray paVersions = msgBackup.getPartitionVersions();
        
        for (int iPartition = parts.next(0); iPartition >= 0;
                 iPartition = parts.next(iPartition + 1))
            {
            PartitionedService.PartitionControl control = getPartitionControl(iPartition);
        
            long lVersionExpect = control.getVersionCounter().get() + 1;
            long lVersionNew    = paVersions.getPrimitive(iPartition);
        
            if (lVersionExpect > lVersionNew)
                {
                // we could get an older version if a backup message is being
                // repeated (due to member failure somewhere earlier in the
                // backup chain).  Since we have already processed the version,
                // we can safely ignore this portion of the message
        
                _trace("Ignoring repeated backup update (version " + lVersionNew + ") for partition "
                     + iPartition + "; current version is " + lVersionExpect, 5);
        
                parts.remove(iPartition);
                msgBackup.skipPartition(iPartition);
                }
            else if (lVersionExpect < lVersionNew ||
                    (!isBackupOwner(iPartition) && control.isTransferringOut()))
                {
                // we have a version gap or the backup arrive before finalize send primary.
                // Queue the backup message to be replayed
                // at some later time after the gap is closed.
                // This is possible for several reasons:
                //   a) multiple threads on the primary concurrently queued backup
                //      requests for the same partition
                //   b) as a result of a change in backup delivery order (due to
                //      partition transfer/ownership change)
        
                if (partsDefer == null)
                    {
                    partsDefer = new PartitionSet(parts.getPartitionCount());
                    }
                partsDefer.add(iPartition);
                }
            }
        
        PartitionSet partsSkip = msgBackup.getSkipPartitions();
        
        if (partsDefer == null)
            {
            // nothing to defer; we can reply right away
            msgBackup.forwardOrReply(msgBackup);
            }
        else
            {
            parts.remove(partsDefer);
        
            // important: a deferred backup message should be held by no more than one partition control 
            int               iPartition = partsDefer.next(0);
            PartitionedService.PartitionControl control    = getPartitionControl(iPartition);
        
            control.deferBackup(msgBackup, paVersions.getPrimitive(iPartition));
        
            if (partsSkip != null)
                {
                // partsSkip refers to the message state; we must not mutate it
                partsDefer.add(partsSkip);
                }
            partsSkip = partsDefer;
            }
        
        // common case: versions match for all partitions; process the backup request
        
        if (!parts.isEmpty())
            {
            msgBackup.doBackup(partsSkip);
            msgBackup.skipPartitions(parts);
        
            // see the discussion about the algortihm in comments for COH-7577
            for (int iPartition = parts.next(0); iPartition >= 0;
                     iPartition = parts.next(iPartition + 1))
                {
                PartitionedService.PartitionControl control = getPartitionControl(iPartition);
        
                control.getVersionCounter().incrementAndGet();
                control.flushDeferredBackups();
                }
            }
        }
    
    /**
     * Update all nodes in regard to the specified partition's ownership.
     */
    public void publishPartitionOwnership(int iPartition, int iStore, int nOwner)
        {
        // import com.tangosol.net.partition.VersionedOwnership;
        
        VersionedOwnership owners = getPartitionConfig(iPartition);
        owners.setOwner(iStore, nOwner);
        putPartitionConfig(iPartition, owners);
        }
    
    /**
     * Update an Ownership descriptor for the specified partition.
     */
    public void putPartitionConfig(int iPartition, com.tangosol.net.partition.Ownership owners)
        {
        // Note: only a partition owner is allowed to update the partition configuration
        getPartitionConfigMap().put(Integer.valueOf(iPartition), owners);
        }
    
    /**
     * Update the partition ownership with the specified map of updates.
     */
    protected void putPartitionConfig(java.util.Map mapOwners)
        {
        // Note: only a partition owner is allowed to update the partition configuration
        
        getPartitionConfigMap().putAll(mapOwners);
        }
    
    /**
     * Receive the partition, and any associated data or state, as specified by
    * the $TransferRequest.
    * 
    * @param iPartition               the partition to receive
    * @param iBackup                 the backup index of the partition
    * @param listXferRequests  the list of partition transfer messages to
    * receive
    * 
    * @see #preparePartition, releasePartition, transferPartition, movePartition
     */
    protected void receivePartition(int iPartition, int iBackup, java.util.List listXferRequests)
        {
        // import com.oracle.coherence.persistence.PersistentStore as com.oracle.coherence.persistence.PersistentStore;
        // import com.tangosol.persistence.CachePersistenceHelper as com.tangosol.persistence.CachePersistenceHelper;
        
        if (isActivePersistence())
            {
            PartitionedService.PartitionControl ctrl  = getPartitionControl(iPartition);
            if (iBackup == 0)
                {
                com.oracle.coherence.persistence.PersistentStore store = ctrl.ensurePersistentStore();
        
                saveQuorum(iPartition);
        
                if (!isExiting() && getServiceState() != SERVICE_STOPPING)
                    {
                    // seal the events store first
                    com.oracle.coherence.persistence.PersistentStore storeEvents = ctrl.getPersistentEventsStore();
                    if (storeEvents != null)
                        {
                        com.tangosol.persistence.CachePersistenceHelper.seal(storeEvents, this, /*oToken*/ null);
                        }
        
                    com.tangosol.persistence.CachePersistenceHelper.seal(store, this, /*oToken*/ null);
                    }
                }
            else
                {
                if (isBackupPersistence())
                    {
                    // ensure backup store
                    com.oracle.coherence.persistence.PersistentStore store = ctrl.ensurePersistentStore(null, /*fEventsStore*/ false, /*fBackupStore*/ true);
        
                    saveQuorum(iPartition, true);
        
                    if (!isExiting() && getServiceState() != SERVICE_STOPPING)
                        {
                        com.tangosol.persistence.CachePersistenceHelper.seal(store, this, /*oToken*/ null);
                        }
                    }
                }
            }
        }
    
    /**
     * Recover the specified partition from the specified store (which is opened
    * for reading).
    * This method may only be called if a persistence manager is configured.
    * 
    * @param iPartition        the partition being recovered
    * @param storeFrom     the PersistentStore being recovered from
    * @param storeTo          the active PersistentStore to write recovered
    * contents into, or null if no active persistence is configured
    * @param listRequests  a list of requests that will be posted to the
    * service after recovery is complete
    * 
    * @return true iff the partition was successfully recovered
     */
    public boolean recoverPartition(int iPartition, com.oracle.coherence.persistence.PersistentStore storeFrom, com.oracle.coherence.persistence.PersistentStore storeTo, java.util.List listRequests)
        {
        // import com.oracle.coherence.persistence.PersistentStore as com.oracle.coherence.persistence.PersistentStore;
        // import com.tangosol.persistence.CachePersistenceHelper as com.tangosol.persistence.CachePersistenceHelper;
        // import com.tangosol.util.Binary;
        
        // only called if there is a persistence environment configured;
        // the recovery could be from either the active or snapshot store

        if (com.tangosol.persistence.CachePersistenceHelper.isGlobalPartitioningSchemePID(iPartition))
            {
            Binary binQuorum = com.tangosol.persistence.CachePersistenceHelper.readQuorumRaw(storeFrom);
            if (binQuorum != null)
                {
                // copy the quorum info in case this node fails before restore completes
                com.tangosol.persistence.CachePersistenceHelper.writeQuorumRaw(storeTo, binQuorum);

                // cache it for ease of use (see onFinalizeRestorePrimary())
                getPersistenceControl().setQuorumRaw(binQuorum);
                }
            }
        
        if (getServiceState() >= SERVICE_STOPPING)
            {
            return false;
            }
        
        // seal the events store
        PartitionedService.PartitionControl ctrl        = getPartitionControl(iPartition);
        com.oracle.coherence.persistence.PersistentStore             storeEvents = ctrl.getPersistentEventsStore();
        
        if (storeEvents != null)
            {
            com.tangosol.persistence.CachePersistenceHelper.seal(storeEvents, this, /*oToken*/ null);
            }
        
        com.tangosol.persistence.CachePersistenceHelper.seal(storeTo, this, /*oToken*/ null);
        
        ctrl.setRecovered(true);

        return true;
        }
    
    /**
     * Recover the orphaned partitions from the specified map of
    * PersistentStores (indexed by partition-id)
     */
    public void recoverPartitions(PartitionedService.PartitionRecoverRequest.RecoverJob job, java.util.Map mapStoresFrom, java.util.Map mapStoresTo, com.tangosol.net.partition.PartitionSet partsFail, com.tangosol.net.partition.PartitionSet partsFailEvents)
        {
        // import com.oracle.coherence.persistence.PersistenceException;
        // import com.oracle.coherence.persistence.PersistenceManager;
        // import com.oracle.coherence.persistence.PersistentStore;
        // import com.tangosol.net.internal.PartitionRecoverInfo;
        // import com.tangosol.net.partition.PartitionEvent;
        // import com.tangosol.net.partition.PartitionSet;
        // import com.tangosol.util.NullImplementation;
        // import java.util.ArrayList;
        // import java.util.HashMap;
        // import java.util.Iterator;
        // import java.util.List;
        // import java.util.Map;
        // import java.util.Map$Entry as java.util.Map.Entry;
        
        PartitionRecoverInfo info           = job.getRecoverInfo();
        List                 listGUID       = job.getListGUID();
        int                  cGUIDs         = listGUID.size();
        List                 listRequests   = new ArrayList();
        PartitionSet         partsRecovered = instantiatePartitionSet(false);
        PersistenceManager   mgrRecover     = info.getManager();
        PersistenceManager   mgrBackup      = getPersistenceControl().getBackupManager();
        
        if (!mapStoresTo.isEmpty())
            {
            for (Iterator iter = mapStoresTo.entrySet().iterator();
                 iter.hasNext() && !isExiting() && getServiceState() != SERVICE_STOPPING; )
                {
                java.util.Map.Entry           entry       = (java.util.Map.Entry) iter.next();
                Integer         IPartition  = ((Integer) entry.getKey());
                int             nPartition  = IPartition.intValue();
                PersistentStore storeFrom   = (PersistentStore) entry.getValue();
                String          sGUID       = ((PersistentStore) ((Object[]) mapStoresFrom.get(IPartition))[0]).getId();
                boolean         fFromBackup = ((Boolean) ((Object[]) mapStoresFrom.get(IPartition))[1]).booleanValue();

                _assert(getPartitionControl(nPartition).isLocked(), "Partition must be locked");

                try
                    {
                    // Note: recoverPartition can throw PersistenceException only due to
                    //       a failure on the recovering store

                    PersistentStore storeTo = isActivePersistence() ? storeFrom : NullImplementation.getPersistentStore();

                    if (recoverPartition(nPartition, storeFrom, storeTo, listRequests))
                        {
                        // finished with the recovery; close or delete the old store
                        if (isSnapshotManager(mgrRecover))
                            {
                            mgrRecover.close(sGUID);
                            }
                        else
                            {
                            if (mgrBackup != null && fFromBackup)
                                {
                                mgrBackup.delete(sGUID, false);
                                }
                            else
                                {
                                mgrRecover.delete(sGUID, false);
                                }
                            }
        
                        // add the now-recovered partition to the partition-config update
                        partsRecovered.add(nPartition);
        
                        // we shouldn't have any backups yet; but conceptually:
                        // doSyncBackups();
                        }
                    else
                        {
                        onRecoverFailed(mgrRecover, sGUID, /*fDelete*/ true);
                        partsFail.add(nPartition);
                        }
        
                    // heartbeat between each partition
                    heartbeat();
                    }
                catch (Throwable t)
                    {
                    // we hit an exception due to one of the following reasons:
                    //  1. PersistencExcetion - unable to read from store being recovered
                    //  2. PersistencExcetion - unable to write to store
                    //  3. Some other exception - unable to update anciliary data
                    //       structures (backing maps/index registration)
                    // in all cases revert the local-assignments to reflect the
                    // still-orphaned partition and drop storeTo
                   
                    onRecoverFailed(mgrRecover, sGUID, t instanceof PersistenceException);
                    partsFail.add(nPartition);
        
                    // Note: we do not output the stack as the ActiveFailureHandler will
                    //       output the real cause
                    _trace("Failed to recover partition " + nPartition + '\n' +
                            t.getMessage() + '\n' + getStackTrace(t), 2);
                    }
                }
            }
        
        synchronized (info)
            {
            info.getRecoveredPartitions().add(partsRecovered);
            info.getFailedPartitions().add(partsFail);
            info.getFailedEventPartitions().add(partsFailEvents);
            info.getListRequests().addAll(listRequests);   
            }
        
        PartitionedService.PartitionRecoverRequest request = (PartitionedService.PartitionRecoverRequest) info.getRequest();
        if (request.getRecoverJobs().decrementAndGet() == 0)
            {
            PartitionSet partsAssign = request.getPartsAssign();
            if (!partsAssign.isEmpty())
                {
                for (int iPartition = partsAssign.next(0), c = 0;
                     iPartition >= 0 && getServiceState() < SERVICE_STOPPING;
                     iPartition = partsAssign.next(iPartition + 1))
                    {
                    assignOrphan(iPartition);
            
                    if ((c++ & 0xF) == 0xF)
                        {
                        // persistence is more expensive during the assign
                        // thus make sure we notify the guardian
                        heartbeat();
                        }
                    }
        
                handlePartitionTrace(partsAssign,
                    PartitionedService.PartitionControl.getPartitionEventDescription(PartitionedService.PartitionControl.PARTITION_EVENT_ASSIGNED));
                }
        
            PartitionedService.Continuations continuations = getContinuations();
        
            onPartitionsRecovered(info.getRecoveredPartitions(),
                ((PartitionedService.PartitionRecoverRequest) info.getRequest()).getSnapshotToRecover(),
                continuations.thenOnServiceThread(continuations.instantiateFinalizeRecoverPrimary(info)));
            }
        }
    
    /**
     * Register the specified partition as contended.
    * 
    * @see #clearContention
     */
    public void registerContention(int iPartition)
        {
        // import com.tangosol.util.Base;
        
        PartitionedService.Contention[] aContention = getPartitionContention();
        Object        oMonitor    = Base.getCommonMonitor(
            System.identityHashCode(aContention) + iPartition);
        
        synchronized (oMonitor)
            {
            PartitionedService.Contention contention = aContention[iPartition];
            if (contention == null)
                {
                contention = aContention[iPartition] = new PartitionedService.Contention();
                contention.setPartition(iPartition);
                }
            else
                {
                contention.setAccessCount(contention.getAccessCount() + 1);
                }
            }
        }
    
    /**
     * Register the specified partitions as contented.
    * 
    * @see #clearContention
     */
    public void registerContention(com.tangosol.net.partition.PartitionSet partitions)
        {
        for (int iPartition = partitions.next(0); iPartition >= 0;
                 iPartition = partitions.next(iPartition + 1))
            {
            registerContention(iPartition);
            }
        }
    
    /**
     * Release the specified partition. Called on the service thread only.
    * 
    * @param iPartition  the partition number to release
    * @param iBackup   the backup index to release
    * 
    * @see #preparePartition, movePartition, transferPartition, receivePartition
     */
    protected void releasePartition(int iPartition, int iBackup)
        {
        if (isActivePersistence())
            {
            if (iBackup == 0)
                {
                // primary released: delete the persistent store
                getPartitionControl(iPartition).deletePersistentStore();
                }
            else
                {
                if (isBackupPersistence())
                    {
                    // backup released: delete the persistent store
                    getPartitionControl(iPartition).deleteBackupPersistentStore();
                    }
                }
            }
        }
    
    protected void releasePartitionControl(int nPartition)
        {
        // import com.tangosol.net.Guardian$GuardContext as com.tangosol.net.Guardian.GuardContext;
        
        PartitionedService.PartitionControl ctrlPartition = getPartitionControl(nPartition);
        if (ctrlPartition != null)
            {
            com.tangosol.net.Guardian.GuardContext ctx = ctrlPartition.getContext();
            if (ctx != null)
                {
                ctx.release();
                }
            }
        
        setPartitionControl(nPartition, null);
        }
    
    /**
     * Return the specified amount of the "scratch space" back to the
    * "available" state.
    * 
    * @see ScratchSpace property
     */
    public void releaseScratchSpace(long cb)
        {
        getScratchSpaceCounter().addAndGet(cb);
        }
    
    // From interface: com.tangosol.net.PartitionedService
    public void removePartitionListener(com.tangosol.net.partition.PartitionListener listener)
        {
        getPartitionListeners().remove(listener);
        }
    
    /**
     * For debugging purposes only.
     */
    public String reportContentions()
        {
        StringBuffer  sb          = new StringBuffer();
        PartitionedService.Contention[] aContention = getPartitionContention();
        
        for (int iPartition = 0, cPartitions = getPartitionCount();
             iPartition < cPartitions; iPartition++)
            {
            PartitionedService.Contention contention = aContention[iPartition];
            if (contention != null)
                {
                sb.append("\n*** ")
                  .append(contention);
                }
            }
        
        return sb.toString();
        }
    
    /**
     * For debugging purposes only.
     */
    public String reportOwnership(int nMember, boolean fVerbose)
        {
        // import com.tangosol.util.Base;
        // import java.util.Map;
        
        StringBuffer sb = new StringBuffer();
        
        int[][] aaiOwner    = getPartitionAssignments();
        int     cPartitions = aaiOwner.length;
        int     cBackups    = getBackupCount();
        int     nMemberThis = getThisMember().getId();
        
        for (int iStore = 0; iStore < 1 + cBackups; iStore++)
            {
            if (iStore == 0)
                {
                sb.append("Primary[]");
                }
            else
                {
                sb.append("\nBackup[")
                  .append(iStore)
                  .append("]");
                }
        
            StringBuffer sbStore = new StringBuffer();
            int          cDigits = cPartitions > 9999 ? 5 : cPartitions > 999 ? 4 : 3;
        
            int cOwned = 0;
            for (int iPartition = 0; iPartition < cPartitions; iPartition++)
                {
                int nOwnerLocal  = aaiOwner[iPartition][iStore];
                int nOwnerGlobal = getPartitionConfig(iPartition).getOwner(iStore);
        
                if (nOwnerLocal == nMember || nOwnerGlobal == nMember)
                    {
                    if (fVerbose)
                        {
                        sbStore.append(',')
                               .append(isPartitionVulnerable(iPartition, true) ? ' ' : '+');
        
                        String sCtrl = null;
                        if (nOwnerLocal == nMemberThis)
                            {
                            PartitionedService.PartitionControl ctrl = getPartitionControl(iPartition);
                            if (ctrl == null)
                                {
                                sCtrl = Base.toDecString(iPartition, cDigits) +
                                        "; missing control"; // should not happen
                                }
                            else if (ctrl.getLockType() != PartitionedService.PartitionControl.LOCK_NONE)
                                {
                                sCtrl = String.valueOf(ctrl);
                                }
                            }
        
                        sbStore.append(sCtrl == null
                            ? Base.toDecString(iPartition, cDigits) : sCtrl);
        
                        if (nOwnerLocal != nOwnerGlobal)
                            {
                            if (nOwnerLocal != nMember)
                                {
                                sbStore.append("?local=")
                                       .append(nOwnerLocal);
                                }
                            else
                                {
                                sbStore.append("?global=")
                                       .append(nOwnerGlobal);
                                }
                            }
                        }
                    cOwned++;
                    }
                }
        
            sb.append('#')
              .append(Base.toDecString(cOwned, cDigits));
        
            if (cOwned > 0 && fVerbose)
                {
                sb.append(':')
                  .append(sbStore.substring(1));
                }
            }
        
        return sb.toString();
        }
    
    /**
     * For debugging purposes only.
     */
    public String reportOwnership(boolean fVerbose)
        {
        // import Component.Net.Member;
        // import Component.Net.MemberSet as com.tangosol.coherence.component.net.MemberSet;
        // import java.util.Iterator;
        
        int cPartitions = getPartitionCount();
        int cBackups    = getBackupCount();
        com.tangosol.coherence.component.net.MemberSet setOwners   = getOwnershipMemberSet();
        int cMembers    = setOwners.size();
        
        if (cMembers == 0)
            {
            return "No ownership-enabled members";
            }
        
        int[] acPrimary  = calculateOwnership(setOwners, true);
        int[] acBackup   = calculateOwnership(setOwners, false);
        
        StringBuilder sb = new StringBuilder();
        
        sb.append(getDistributionStrategy().reportLocalDistributionState(fVerbose));
        
        for (Iterator iter = setOwners.iterator(); iter.hasNext();)
            {
            Member member  = (Member) iter.next();
            int    nMember = member.getId();
        
            sb.append("\n*** Member: ");
            if (nMember < 10)
                {
                sb.append(' ');
                }
            sb.append(nMember)
              .append(" total=")
              .append(acPrimary[nMember] + acBackup[nMember])
              .append(" (primary=")
              .append(acPrimary[nMember])
              .append(", backup=")
              .append(acBackup[nMember])
              .append(")\n")
              .append(reportOwnership(nMember, fVerbose))
              .append('\n');
            }
        
        sb.append("\n*** Orphans:\n")
          .append(reportOwnership(0, fVerbose))
          .append('\n');
        
        PartitionedService.PartitionControl[] aControl = getPartitionControl();
        if (aControl != null)
            {
            StringBuilder sbStates = null;
            for (int i = 0, c = aControl.length; i < c; i++)
                {
                PartitionedService.PartitionControl ctrl = aControl[i];
                if (ctrl != null && ctrl.getPartitionState() != 0)
                    {
                    if (sbStates == null)
                        {
                        sbStates = new StringBuilder("\n*** Partition States:\n");
                        }
        
                    sbStates.append(i).append(": ").append(ctrl).append(", ");
                    }
                }
        
            if (sbStates != null)
                {
                sb.append(sbStates);
                }
            }
        
        return sb.toString();
        }
    
    /**
     * For debugging purposes only
     */
    public String reportPartitionOwnership(int iPartition)
        {
        // import com.tangosol.net.partition.Ownership;
        
        StringBuffer sb = new StringBuffer("Partition " + iPartition + ": ");
        
        int[]     aiOwner      = getPartitionAssignments()[iPartition];
        Ownership owners       = getPartitionConfig(iPartition);
        int       nMemberThis  = getThisMember().getId();
        PartitionedService.PartitionControl ctrl = getPartitionControl(iPartition);
        
        for (int iStore = 0, c = 1 + getBackupCount(); iStore < c; iStore++)
            {
            int nOwnerLocal  = aiOwner[iStore];
            int nOwnerGlobal = owners.getOwner(iStore);
        
            if (iStore == 0)
                {
                sb.append("owner=");
                }
            else
                {
                sb.append(", backup[")
                  .append(iStore)
                  .append("]=");
                }
        
            sb.append(nOwnerLocal);
        
            if (nOwnerLocal != nOwnerGlobal)
                {
                sb.append("?global=")
                  .append(nOwnerGlobal);
                }
        
            if (nOwnerLocal == nMemberThis)
                {
                if (ctrl == null)
                    {
                    sb.append("; missing control"); // should not happen
                    }
                else if (ctrl.getLockType() != PartitionedService.PartitionControl.LOCK_NONE)
                    {
                    sb.append("; ").append(ctrl);
                    }
                }
            }
        
        return sb.toString();
        }
    
    /**
     * For debugging purposes only.
     */
    public String reportVulnerability(int nMember, boolean fVerbose)
        {
        if (getBackupCount() == 0)
            {
            return "No backup";
            }
        
        StringBuffer sbEndangered = new StringBuffer();
        StringBuffer sbVulnerable = new StringBuffer();
        int          cEndangered  = 0;
        int          cVulnerable  = 0;
        
        for (int iPartition = 0, cPartitions = getPartitionCount();
             iPartition < cPartitions; iPartition++)
            {
            if (getPrimaryOwner(iPartition).getId() == nMember)
                {
                if (getBackupOwners(iPartition).isEmpty())
                    {
                    sbEndangered.append(',')
                                .append(iPartition);
                    cEndangered++;
                    }
                else if (isPartitionVulnerable(iPartition, true))
                    {
                    sbVulnerable.append(',')
                                .append(iPartition);
                    cVulnerable++;
                    }
                }
            }
        
        StringBuffer sb = new StringBuffer();
        
        sb.append("*** Endangered partitions: (")
          .append(cEndangered)
          .append(") ");
        if (fVerbose && sbEndangered.length() > 0)
            {
            sb.append(sbEndangered.substring(1));
            }
        
        sb.append("\n*** Vulnerable partitions: (")
          .append(cVulnerable)
          .append(") ");
        if (fVerbose && sbVulnerable.length() > 0)
            {
            sb.append(sbVulnerable.substring(1));
            }
        
        return sb.toString();
        }
    
    /**
     * For debugging purposes only.
     */
    public String reportVulnerability(boolean fVerbose)
        {
        if (getBackupCount() == 0)
            {
            return "No backup";
            }
        
        StringBuffer sbEndangered = new StringBuffer();
        StringBuffer sbVulnerable = new StringBuffer();
        int          cEndangered  = 0;
        int          cVulnerable  = 0;
        
        for (int iPartition = 0, cPartitions = getPartitionCount();
             iPartition < cPartitions; iPartition++)
            {
            if (getPrimaryOwner(iPartition) == null || getBackupOwners(iPartition).isEmpty())
                {
                sbEndangered.append(',')
                            .append(iPartition);
                cEndangered++;
                }
            else if (isPartitionVulnerable(iPartition, true))
                {
                sbVulnerable.append(',')
                            .append(iPartition);
                cVulnerable++;
                }
            }
        
        StringBuffer sb = new StringBuffer();
        
        if (cVulnerable > 0)
            {
            sb.append("Vulnerability is ")
              .append(isVulnerabilityAvoidable(getOwnershipMemberSet()) ?
                      "avoidable" : "unavoidable");
            }
        
        sb.append("\n*** Endangered partitions: (")
          .append(cEndangered)
          .append(") ");
        if (fVerbose && sbEndangered.length() > 0)
            {
            sb.append(sbEndangered.substring(1));
            }
        
        sb.append("\n*** Vulnerable partitions: (")
          .append(cVulnerable)
          .append(") ");
        if (fVerbose && sbVulnerable.length() > 0)
            {
            sb.append(sbVulnerable.substring(1));
            }
        
        return sb.toString();
        }
    
    /**
     * Reserve a portion of the available "scratch space" for the caller. 
    * 
    * @see ScratchSpace property
     */
    public long reserveScratchSpace()
        {
        // import java.util.concurrent.atomic.AtomicLong;
        
        AtomicLong atomicScratch = getScratchSpaceCounter();
        
        while (true)
            {
            // reserve and return half of the available scratch or at least 2k
            long cbScratch = atomicScratch.get();
            long cbReserve = Math.max(cbScratch / 2, 2 * 1024);
        
            if (atomicScratch.compareAndSet(cbScratch, cbScratch - cbReserve))
                {
                return cbReserve;
                }
            }
        }
    
    // Declared at the super level
    /**
     * Reset the Service statistics.
    * Reset the statistics.
     */
    public void resetStats()
        {
        getPersistenceControl().resetStats();
        
        if (getPartitionEvents() != null)
            {
            getPartitionEvents().clear();
            }
        
        super.resetStats();
        }
    
    // Declared at the super level
    /**
     * Resolve the canonical EndPoint name for the specified member.
    * 
    * Important note: while it's possible that a service overrides this method
    * and chooses not to use the bus for communications with the specified
    * member, this logic must be commutative: if member M1 decides not to talk
    * to M2 over the bus, M2 must make an identical decision. Failure to do so
    * will cause the service join protocol to hang and the service start
    * timeout.
    * 
    * @param sEndPoint                  the service's endpoint name
    * @param member                     the associated member
    * @param mapMemberConfig  the MemberConfigMap for the associated member at
    * the time it joined the service
    * 
    * @return the EndPoint reference retrieved from the [local] Depot, or null
    * if the EndPoint name cannot be resolved or if the service prefers NOT to
    * communicate with the specified member over the bus
     */
    public com.oracle.coherence.common.net.exabus.EndPoint resolveEndPoint(String sEndPoint, com.tangosol.coherence.component.net.Member member, java.util.Map mapMemberConfig)
        {
        if (!isOwnershipEnabled() &&
            ((Integer) mapMemberConfig.get("ownership-enabled")).intValue() == OWNERSHIP_DISABLED)
            {
            // for client to client communication there is no need to create a bus and its
            // associated resource overhead, instead we can just communicate over the shared
            // datagram transport
            return null;
            }
        else
            {
            // only use a bus transport for communication to/from an ownership enabled member
            return super.resolveEndPoint(sEndPoint, member, mapMemberConfig);
            }
        }
    
    /**
     * Restore orphaned partitions from a backup. Called on the service thread
    * only.
    * 
    * @param msgRequest  OwnershipRequest message
     */
    protected void restoreOrphans(PartitionedService.OwnershipRequest msgRequest)
        {
        // import Component.Net.Member;
        // import com.tangosol.net.partition.Ownership;
        // import com.tangosol.net.partition.PartitionEvent;
        // import com.tangosol.net.partition.PartitionSet;
        // import com.tangosol.util.LiteMap;
        // import java.util.Map;
        
        int[][]      aaiOwner     = msgRequest.getRequestAssignments();
        Member       memberThis   = getThisMember();
        int          nMemberThis  = memberThis.getId();
        int          cPartitions  = aaiOwner.length;
        int          cBackups     = getBackupCount();
        PartitionSet partsRestore = new PartitionSet(cPartitions);
        
        setRestoreInProgress(true);
        
        for (int iPartition = 0; iPartition < cPartitions; ++iPartition)
            {
            int[] aiOwner = aaiOwner[iPartition];
            if (aiOwner[0] == 0)
                {
                for (int iBackup = 1; iBackup <= cBackups; iBackup++)
                    {
                    int nBackupOwner = aiOwner[iBackup];
                    if (nBackupOwner == nMemberThis)
                        {
                        // lock the partition while we are in transition.
                        // We don't own the partition yet, so we must be able to
                        // acquire the lock.  The consequences of proceeding without
                        // the lock are that we would drop the partition's data,
                        // so it is better to block here (see onBackingMapEvent)
        
                        PartitionedService.PartitionControl control = getPartitionControl(iPartition);
                        control.lock(-1L, control.LOCK_PRIMARY_XFER_IN);
        
                        firePartitionEvent(PartitionEvent.PARTITION_RECEIVE_BEGIN,
                            iPartition, null, memberThis);
        
                        // COH-6869: ensure that the local assignments reflect the
                        //           passed-in "resolved" assignments prior to restore.
                        //           The local assignments must already agree for iBackup
                        //           (see OwnershipConflictResolver).
                        while (++iBackup <= cBackups)
                            {
                            assignPartitionOwner(iPartition, iBackup, aiOwner[iBackup]);
                            }
        
                        partsRestore.add(iPartition);
        
                        break;
                        }
                    else if (nBackupOwner != 0)
                        {
                        // someone else is responsible for this partition
                        break;
                        }
                    }
                }
            }
        
        if (partsRestore.isEmpty())
            {
            onFinalizeRestorePrimary(msgRequest, null);
            }
        else
            {
            Map     mapUpdate = new LiteMap();
            boolean fActive   = isActivePersistence();
        
            for (int iPartition = partsRestore.next(0), c = 0; iPartition >= 0 &&
                    !isExiting() && getServiceState() != SERVICE_STOPPING;
                     iPartition = partsRestore.next(iPartition + 1))
                {
                // restore the partition data (assign the ownership and move from backup to primary)
                mapUpdate.put(Integer.valueOf(iPartition),
                    assignPrimaryPartition(iPartition, 'm'));
        
                // incrementing the partition version must be done *before* moving the partition,
                // since it could generate evictions (backup messages)
                getPartitionControl(iPartition).getVersionCounter().incrementAndGet();
        
                // Note: the partition ownership version has been incremented by the
                // assignPrimaryParition above, so the new persistent store GUID will
                // have the correct version
                movePartition(iPartition, 0);
        
                partsRestore.add(iPartition);
        
                if (fActive && ((c++ & 0xF) == 0xF))
                    {
                    // persistence is more expensive during the restore
                    // thus make sure we notify the guardian
                    heartbeat();
                    }
                }
            onPartitionsRestored(partsRestore,
                getContinuations().instantiateFinalizeRestorePrimaries(msgRequest, mapUpdate));
            }
        }

    /**
     * Save the quorum info if necessary.
     *
     * @since 24.09
     */
    public void saveQuorum(int iPartition)
        {
        saveQuorum(iPartition, false);
        }

    /**
     * Save the quorum info if necessary.
     *
     * @since 24.09
     */
    public void saveQuorum(int iPartition, boolean fBackup)
        {
        if (CachePersistenceHelper.isGlobalPartitioningSchemePID(iPartition))
            {
            PersistentStore store = fBackup
                ? getPartitionControl(iPartition).ensureOpenPersistentStore(null, false, true)
                : getPartitionControl(iPartition).ensureOpenPersistentStore();

            Binary binQuorum = getPersistenceControl().getQuorumRaw();
            if (binQuorum != null)
                {
                CachePersistenceHelper.writeQuorumRaw(store, binQuorum);
                }
            }
        }

    /**
     * Save the quorum info if necessary.
     */
    public void saveQuorum(int iPartition, com.oracle.coherence.persistence.PersistentStore store)
        {
        // import com.tangosol.persistence.GUIDHelper;
        // import com.tangosol.persistence.CachePersistenceHelper as com.tangosol.persistence.CachePersistenceHelper;
        // import com.tangosol.util.Binary;
        
        if (iPartition < 0)
            {
            iPartition = GUIDHelper.getPartition(store.getId());
            }
        
        if (com.tangosol.persistence.CachePersistenceHelper.isGlobalPartitioningSchemePID(iPartition))
            {
            Binary binQuorum = getPersistenceControl().getQuorumRaw();;
            if (binQuorum != null)
                {
                com.tangosol.persistence.CachePersistenceHelper.writeQuorumRaw(store, binQuorum);
                }
            }
        }
    
    // Accessor for the property "AsyncBackup"
    /**
     * Setter for property AsyncBackup.<p>
    * True if this member is configured to do async backup.
     */
    protected void setAsyncBackup(boolean fAsync)
        {
        __m_AsyncBackup = fAsync;
        }
    
    // Accessor for the property "AsyncBackupInterval"
    /**
     * Setter for property AsyncBackupInterval.<p>
    * The time interval to send periodic backups to backup copies of this
    * member's primiary partitions.
     */
    protected void setAsyncBackupInterval(long fAsync)
        {
        __m_AsyncBackupInterval = fAsync;
        }
    
    // Accessor for the property "BackupCount"
    /**
     * Setter for property BackupCount.<p>
    * Specifies the number of backups for each partition.
     */
    protected void setBackupCount(int cBackups)
        {
        _assert(!isAcceptingClients(),
            "The backup count is immutable once the service has started");
        
        __m_BackupCount = (cBackups);
        }
    
    // Accessor for the property "Concurrent"
    /**
     * Setter for property Concurrent.<p>
    * True if the service is configured such that it may concurrently process
    * requests.
     */
    public void setConcurrent(boolean fConcurrent)
        {
        __m_Concurrent = fConcurrent;
        }
    
    // Accessor for the property "ConfiguredKeyAssociator"
    /**
     * Setter for property ConfiguredKeyAssociator.<p>
    * Configured KeyAssociator implementation; never null.
     */
    protected void setConfiguredKeyAssociator(com.tangosol.net.partition.KeyAssociator associator)
        {
        if (isAcceptingClients())
            {
            throw new IllegalStateException("Service is already running");
            }
        
        __m_ConfiguredKeyAssociator = (associator);
        }
    
    // Accessor for the property "ConfiguredKeyPartitioningStrategy"
    /**
     * Setter for property ConfiguredKeyPartitioningStrategy.<p>
    * The configured KeyPartitioningStrategy implementation.
     */
    protected void setConfiguredKeyPartitioningStrategy(com.tangosol.net.partition.KeyPartitioningStrategy strategy)
        {
        if (isAcceptingClients())
            {
            throw new IllegalStateException("Service is already running");
            }
        
        __m_ConfiguredKeyPartitioningStrategy = (strategy);
        }
    
    // Accessor for the property "Continuations"
    /**
     * Setter for property Continuations.<p>
     */
    protected void setContinuations(PartitionedService.Continuations continuations)
        {
        __m_Continuations = continuations;
        }
    
    // Accessor for the property "DeferredBackupTimeoutMillis"
    /**
     * Setter for property DeferredBackupTimeoutMillis.<p>
    * The delay in milliseconds after which a missing backup version is
    * considered lost.
    * 
    * Controlled by the "coherence.distributed.deferredbackuptimeout" system
    * property.
     */
    protected void setDeferredBackupTimeoutMillis(long cMillis)
        {
        __m_DeferredBackupTimeoutMillis = cMillis;
        }
    
    // Accessor for the property "DistributionAggressiveness"
    /**
     * Setter for property DistributionAggressiveness.<p>
    * The DistributionAggressiveness factor specifies how aggressively the
    * failback operations will be scheduled. The factor of 1 means a lazy (pre-
    * Coherence 3.1) behavior. A  factor of 100 will attempt to finish the
    * failback distribution 100 times faster. Default value is 20.
    * 
    * @since Coherence 3.1
     */
    public void setDistributionAggressiveness(int iFactor)
        {
        __m_DistributionAggressiveness = (Math.max(iFactor, 1));
        }
    
    // Accessor for the property "DistributionNextMillis"
    /**
     * Setter for property DistributionNextMillis.<p>
    * The DistributionNextMillis value is the time (in local system millis) at
    * which the next cache distribution analysis will be performed.
    * 
    * Initial value is Long.MAX_VALUE.
    * 
    * @volatile
     */
    public void setDistributionNextMillis(long ldtNext)
        {
        __m_DistributionNextMillis = ldtNext;
        }
    
    // Accessor for the property "DistributionRepeatMillis"
    /**
     * Setter for property DistributionRepeatMillis.<p>
    * The DistributionRepeatMillis value specifies how many milliseconds
    * between repeatedly performed task of cache distribution analysis and
    * operations.
     */
    public void setDistributionRepeatMillis(int cMillis)
        {
        __m_DistributionRepeatMillis = cMillis;
        }
    
    // Accessor for the property "DistributionStable"
    /**
     * Setter for property DistributionStable.<p>
    * Specifies whether or not the ownership has stabilized.
     */
    protected void setDistributionStable(boolean fSync)
        {
        __m_DistributionStable = fSync;
        }
    
    // Accessor for the property "DistributionStrategy"
    /**
     * Setter for property DistributionStrategy.<p>
    * CentralDistribution component.
     */
    protected void setDistributionStrategy(PartitionedService.CentralDistribution strategy)
        {
        __m_DistributionStrategy = strategy;
        }
    
    // Accessor for the property "DistributionSynchronized"
    /**
     * Setter for property DistributionSynchronized.<p>
    * Specifies whether or not the re-distribution should be deferred until all
    * the configuration updates issued by the previous distribution requests
    * were confirmed by the service senior.
    * 
    * @since Coherence 3.2
     */
    protected void setDistributionSynchronized(boolean fSync)
        {
        __m_DistributionSynchronized = fSync;
        }
    
    // Accessor for the property "Finalizing"
    /**
     * Setter for property Finalizing.<p>
    * Set to true when the Service has been welcomed by other members of the
    * service but finalizing the startup must be deferred due to lack of member
    * or partition configuration.
    * 
    * @see onNotify()
     */
    protected void setFinalizing(boolean fFinalizing)
        {
        __m_Finalizing = fFinalizing;
        }
    
    // Accessor for the property "KeyAssociator"
    /**
     * Setter for property KeyAssociator.<p>
    * KeyAssociator implementation; never null.
     */
    protected void setKeyAssociator(com.tangosol.net.partition.KeyAssociator associator)
        {
        if (isAcceptingClients())
            {
            throw new IllegalStateException("Service is already running");
            }
        
        __m_KeyAssociator = (associator);
        }
    
    // Accessor for the property "KeyPartitioningStrategy"
    /**
     * Setter for property KeyPartitioningStrategy.<p>
    * KeyPartitioningStrategy implementation.
     */
    protected void setKeyPartitioningStrategy(com.tangosol.net.partition.KeyPartitioningStrategy strategy)
        {
        if (isAcceptingClients())
            {
            throw new IllegalStateException("Service is already running");
            }
        
        __m_KeyPartitioningStrategy = (strategy);
        }
    
    // Accessor for the property "KeyToBinaryConverter"
    /**
     * Setter for property KeyToBinaryConverter.<p>
    * The singleton converter used by this service to convert object keys to
    * binary form.
     */
    public void setKeyToBinaryConverter(PartitionedService.ConverterKeyToBinary pKeyToBinaryConverter)
        {
        __m_KeyToBinaryConverter = pKeyToBinaryConverter;
        }
    
    // Accessor for the property "MaxContendMillis"
    /**
     * Setter for property MaxContendMillis.<p>
    * Max wait time for a partition control lock.
     */
    public void setMaxContendMillis(long lMillis)
        {
        __m_MaxContendMillis = lMillis;
        }
    
    // Accessor for the property "MaxLockAttempt"
    /**
     * Setter for property MaxLockAttempt.<p>
    * The number of lock attempt for a partition control after which maximum
    * wait of MaxContendMillis is used to acquire the lock.
     */
    public void setMaxLockAttempt(int nAttempt)
        {
        __m_MaxLockAttempt = nAttempt;
        }
    
    // Accessor for the property "MsgCAE"
    /**
     * Setter for property MsgCAE.<p>
    * Coherence ApplicationEdition+ license support.
    * 
    * @see onEnter
     */
    private void setMsgCAE(String sMsg)
        {
        __m_MsgCAE = sMsg;
        }
    
    // Accessor for the property "OwnershipEnabled"
    /**
     * Setter for property OwnershipEnabled.<p>
    * Specifies whether or not the local ownership is enabled for this Member.
     */
    protected void setOwnershipEnabled(boolean fEnabled)
        {
        __m_OwnershipEnabled = fEnabled;
        }
    
    // Accessor for the property "OwnershipInProgress"
    /**
     * Setter for property OwnershipInProgress.<p>
    * Specifies how many times in a row this node (OwnershipSenior) had to
    * initiate the OwnershipRequest poll. A positive count indicates that there
    * is an active poll (sent but not yet answered). A negative count indicates
    * that currently there is no active poll, but the previous attempts fail to
    * reconcile the differences. Not more than one OwnershipRequest poll could
    * be active at any given time for the service. 
    * 
    * Note: Only the service thread uses this property.
     */
    public void setOwnershipInProgress(int c)
        {
        __m_OwnershipInProgress = c;
        }
    
    // Accessor for the property "OwnershipVersion"
    /**
     * Setter for property OwnershipVersion.<p>
    * The current "ownership version" of each partition.
     */
    public void setOwnershipVersion(int[] anVersion)
        {
        __m_OwnershipVersion = anVersion;
        }
    
    // Accessor for the property "OwnershipVersion"
    /**
     * Setter for property OwnershipVersion.<p>
    * The current "ownership version" of each partition.
     */
    public void setOwnershipVersion(int i, int nVersion)
        {
        getOwnershipVersion()[i] = nVersion;
        }
    
    // Accessor for the property "PartitionAssignments"
    /**
     * Setter for property PartitionAssignments.<p>
    * An array indexed by partition number. Each value is an array indexed by
    * backup index (zero being the primary index) of member ids.
    * 
    * As of Coherence 3.1, modifications to the primary partition ownership
    * should be done while holding a synchronization monitor for this array.
    * The reason for this is that during preparation for bulk operations, which
    * happens on client threads, we need to spilt a collection of keys across a
    * number of members. If the primary membership changes at that time, this
    * split would be inconsistent.
    * 
    * @volatile: As of Coherence 3.2, (by Mark's suggestion) we never
    * synchronize. Instead, every time the assignments change, we replace the
    * assignments array with a new clone.
    * 
    * @see #assignPartitionOwner
     */
    protected void setPartitionAssignments(int[][] aai)
        {
        __m_PartitionAssignments = aai;
        }
    
    // Accessor for the property "PartitionConfigMap"
    /**
     * Setter for property PartitionConfigMap.<p>
    * The PartitionConfig$Map.
     */
    protected void setPartitionConfigMap(PartitionedService.PartitionConfig.Map mapConfig)
        {
        __m_PartitionConfigMap = mapConfig;
        }
    
    // Accessor for the property "PartitionContention"
    /**
     * Setter for property PartitionContention.<p>
    * An array of $Contention objects indexed by the corresponding partition
    * number. Most of the time, all the entries are null. The $Contention
    * objects are instantiated only if one of the client side requests come
    * back with a response indicating an on-going distribution and client
    * threads need to wait for such a distribution to complete. Access to the
    * array elements is protected by the Common Monitors.
     */
    private void setPartitionContention(PartitionedService.Contention[] aContention)
        {
        __m_PartitionContention = aContention;
        }
    
    // Accessor for the property "PartitionControl"
    /**
     * Setter for property PartitionControl.<p>
    * An array of PartitionControl objects indexed by partition number.
     */
    protected void setPartitionControl(PartitionedService.PartitionControl[] control)
        {
        __m_PartitionControl = control;
        }
    
    // Accessor for the property "PartitionControl"
    /**
     * Setter for property PartitionControl.<p>
    * An array of PartitionControl objects indexed by partition number.
     */
    protected void setPartitionControl(int i, PartitionedService.PartitionControl control)
        {
        getPartitionControl()[i] = control;
        }
    
    // Accessor for the property "PartitionCount"
    /**
     * Setter for property PartitionCount.<p>
    * Specifies the number of partitions that a distributed cache will be
    * "chopped up" into.
     */
    protected void setPartitionCount(int cPartitions)
        {
        _assert(!isAcceptingClients(),
            "The partition count is immutable once the service has started");
        
        __m_PartitionCount = (cPartitions);
        }
    
    // Accessor for the property "PartitionEvents"
    /**
     * Setter for property PartitionEvents.<p>
    * Map of events keyed by partition that caused partition unavailability.
     */
    public void setPartitionEvents(java.util.Map mapEvents)
        {
        __m_PartitionEvents = mapEvents;
        }
    
    // Accessor for the property "PartitionListeners"
    /**
     * Setter for property PartitionListeners.<p>
     */
    protected void setPartitionListeners(com.tangosol.util.Listeners listeners)
        {
        __m_PartitionListeners = listeners;
        }
    
    // Accessor for the property "PartitionTraceEvents"
    /**
     * Setter for property PartitionTraceEvents.<p>
    * Bitmask containing setting for partition events tracing and/or storing.
     */
    public void setPartitionTraceEvents(int nEvents)
        {
        __m_PartitionTraceEvents = nEvents;
        }
    
    // Accessor for the property "PersistenceControl"
    /**
     * Setter for property PersistenceControl.<p>
    * The PersistenceControl for this service, if a persistence-environment is
    * configured.
     */
    protected void setPersistenceControl(PartitionedService.PersistenceControl control)
        {
        __m_PersistenceControl = control;
        }
    
    // Accessor for the property "PersistenceDependencies"
    /**
     * Setter for property PersistenceDependencies.<p>
    * The PersistenceDependencies, or null.
     */
    protected void setPersistenceDependencies(com.tangosol.internal.net.service.grid.PersistenceDependencies deps)
        {
        __m_PersistenceDependencies = deps;
        }
    
    // Accessor for the property "PreprocessingGate"
    /**
     * Setter for property PreprocessingGate.<p>
    * Gate governing if threads are actively preprocessing requets for this
    * service.
     */
    private void setPreprocessingGate(com.tangosol.util.ThreadGate gatePreprocessing)
        {
        __m_PreprocessingGate = gatePreprocessing;
        }
    
    public void setRecoveryThread(boolean fRecoveryThread)
        {
        getTLORecoveryThread().set(Boolean.valueOf(fRecoveryThread));
        }
    
    // Accessor for the property "RemainsOwnershipReport"
    /**
     * Setter for property RemainsOwnershipReport.<p>
    * This property is only used during graceful shutdown to report partitions
    * that remain to be transferred.
     */
    public void setRemainsOwnershipReport(String sReport)
        {
        __m_RemainsOwnershipReport = sReport;
        }
    
    // Accessor for the property "RestoreInProgress"
    /**
     * Setter for property RestoreInProgress.<p>
    * Indicates whether or not the service is in the process of restoring from
    * backup. 
    * 
    * Note:  Both the service thread and worker threads use this property (see
    * PC.onSizeRequest()).
     */
    protected void setRestoreInProgress(boolean fProgress)
        {
        __m_RestoreInProgress = fProgress;
        }
    
    // Accessor for the property "ScratchSpaceCounter"
    /**
     * Setter for property ScratchSpaceCounter.<p>
    * Some requests may need a significant amount of heap (scratch space) for
    * intermediate data structures. For example, aggregation requests routinely
    * create large number of entries to perform the calculations. This counter
    * is used to prevent the heap exhaustion caused by concurrent execution of
    * such requests.
    * 
    * In the beginning of the execution, a caller is supposed to call
    * reserveScratchSpace(), which "allocates" a portion of available space. It
    * is the responsibility of the caller to limit the heap usage according to
    * the returned value. At the end of the execution, the caller is supposed
    * to "return" the allocated space using the releaseScratchSpace() method.
    * 
    * While this facility is in no way connected to the actual heap statistics,
    * it assumes that the initial capacity is always available and basically
    * simulates a shared memory allocation pool. 
    * 
    * Currently, this counter is initialized to 50MB.
     */
    protected void setScratchSpaceCounter(java.util.concurrent.atomic.AtomicLong cbScratch)
        {
        __m_ScratchSpaceCounter = cbScratch;
        }
    
    // Accessor for the property "TLORecoveryThread"
    /**
     * Setter for property TLORecoveryThread.<p>
    * True if this thread is processing PartitionRecoverRequest, otherwise null
    * or false.
     */
    public void setTLORecoveryThread(ThreadLocal localThread)
        {
        __m_TLORecoveryThread = localThread;
        }
    
    // Accessor for the property "TransferControl"
    /**
     * Setter for property TransferControl.<p>
    * The transfer control for this service.
     */
    protected void setTransferControl(PartitionedService.TransferControl control)
        {
        __m_TransferControl = control;
        }
    
    // Accessor for the property "TransferThreshold"
    /**
     * Setter for property TransferThreshold.<p>
    * Threshold for the primary partition distribution.
    * 
    * Default value is 0.5MB
    * 
    * @see #transferPrimary()
     */
    protected void setTransferThreshold(int cbThreshold)
        {
        __m_TransferThreshold = cbThreshold;
        }
    
    // From interface: com.tangosol.net.PartitionedService
    // Declared at the super level
    /**
     * Stop the Controllable.
     */
    public void shutdown()
        {
        // import com.tangosol.util.Base;
        
        if (getThread() != Thread.currentThread())
            {
            long ldtTimeout = Base.getSafeTimeMillis() + 5000L; 
        
            while (isStarted() && !isAcceptingClients() && getServiceState() < SERVICE_STOPPED)
                {
                // let the startup sequence finish before continuing with an orderly shutdown;
                // if we have not reached the point were AcceptOthers is set then
                // redistribution will not occur and the ownership-enabled node will not
                // be able to stop
                Thread.yield();
        
                if (Base.getSafeTimeMillis() > ldtTimeout)
                    {
                    _trace("Timeout during shutdown; stopping service " + this, 2);
                    stop();
                    return;
                    }
                }
            }
        
        super.shutdown();
        }
    
    /**
     * Write a snapshot of the specified partition to the specified store (which
    * is opened for write).
    * This method may only be called if a persistence environment is configured
    * and the service is quiesced.
     */
    public void snapshotPartition(int iPartition, com.oracle.coherence.persistence.PersistentStore store, Object oToken)
        {
        // import com.tangosol.persistence.CachePersistenceHelper as com.tangosol.persistence.CachePersistenceHelper;
        
        // only called if there is a snapshot-configured persistence environment
        com.tangosol.persistence.CachePersistenceHelper.seal(store, this, oToken);
        }
    
    /**
     * Sort the members from the MemberSet into a List in such a way that:
    * 
    * 1) all the members from different machines precede the members from the
    * same machine as this member;
    * 2) the members with a lighter primary weight precede the members with
    * heavier primary weights
    * 3) the members with the same primary weight are ordered by secondary
    * weight (if secondary weights provided)
    * 4) the members with the same primary and secondary weight are arranged
    * randomly
    * 
    * A member's weight w  must be a positive unsigned 2-byte value ( 0 <= w <=
    * 0xFFFF).
    * 
    * Called on the service thread only.
    * 
    * @param setOthers set of all other ownership enabled members
    * @param aiPrimaryWeight  an array holding the primary weights to sort by
    * @param aiSecondaryWeight  an array holding the secondary weights to sort
    * by.  May be null.
     */
    public java.util.List sortMembers(com.tangosol.coherence.component.net.MemberSet setOthers, int[] aiPrimaryWeight, int[] aiSecondaryWeight)
        {
        // import Component.Net.Member;
        // import com.tangosol.util.Base;
        // import com.tangosol.util.ImmutableArrayList;
        // import java.util.Random;
        // import java.util.TreeMap;
        
        Member[] aMember = (Member[]) setOthers.toArray();
        int      cOthers = aMember.length;
        
        if (cOthers > 1)
            {
            // In addition to the sorting requirements, we are going to
            // ensure a random order of co-located members with equal load.
            // To do so the members are sorted according to three-part long value
            // the most significant part is MachineIdPart
            //     m = 0x4000000000000000 for this member's machine and 0x0 for any other
            // second is the primary weight
            //     p << 16 << 8   (p < 0x10000)
            // third is the secondary weight
            //     s << 8         (s < 0x10000)
            // and the fourth is a RandomPart
            //     r              (r < 0x100)
        
            Random  rand        = Base.getRandom();
            TreeMap mapSorted   = new TreeMap();
            int    nMachineThis = getThisMember().getMachineId();
            for (int i = 0; i < cOthers; i++)
                {
                Member member = aMember[i];
        
                int nId = member.getId();
                if (nId < aiPrimaryWeight.length)
                    {
                    long nM = member.getMachineId() == nMachineThis ?
                                0x1L << 62 : 0x0;
                    long nP = ((long) aiPrimaryWeight[nId]) << 24;
                    long nS = 0L;
                    if (aiSecondaryWeight != null &&
                        nId < aiSecondaryWeight.length)
                        {
                        nS = ((long) aiSecondaryWeight[nId]) << 8;
                        }
                    long nR = rand.nextInt() & 0xFF;
                    
                    mapSorted.put(Long.valueOf(nM | nP | nS | nR), member);
                    }
                }
            return new ImmutableArrayList(mapSorted.values());
            }
        else
            {
            return new ImmutableArrayList(aMember);
            }
        }
    
    /**
     * Split the partitions in the provided PartitionSet by their respective
    * backup ownership chains, represented as List<Member>.
    * 
    * Note: the set of endangered partitions is keyed by an empty list in the
    * resulting map
    * 
    * @param partitions  the specified PartitionSet which will not be changed
    * 
    * @return Map<List<Member>, PartitionSet>
     */
    public java.util.Map splitByBackupOwners(com.tangosol.net.partition.PartitionSet partitions)
        {
        // import com.tangosol.net.partition.PartitionSet;
        // import com.tangosol.util.LiteMap;
        // import java.util.HashMap;
        // import java.util.List;
        // import java.util.Map;
        
        Map mapByOwners = partitions.cardinality() > 1 ? new HashMap() : (Map) new LiteMap();
        int cPartitions = getPartitionCount();
        
        for (int iPartition = partitions.next(0); iPartition >= 0;
                 iPartition = partitions.next(iPartition + 1))
            {
            List listBackups = getBackupOwners(iPartition);
        
            // listBackups could be empty here, indicating that the partition is endangered
            PartitionSet partsOwners = (PartitionSet) mapByOwners.get(listBackups);
            if (partsOwners == null)
                {
                mapByOwners.put(listBackups,
                        partsOwners = new PartitionSet(cPartitions));
                }
            partsOwners.add(iPartition);
            }
        
        return mapByOwners;
        }
    
    /**
     * Split the partitions in the specified PartitionSet into the a map of
    * PartitionSets by owner for the specified store.
    * 
    * Note: the set of orphaned partitions is mapped to null in the resulting
    * map
    * 
    * @param partitions  the specified PartitionSet which will not be changed
    * @param iStore         the storage index
    * @param aaiOwner   the (optional) partition assignments array
    * 
    * @return Map<Member, PartitionSet>
     */
    public java.util.Map splitByOwner(com.tangosol.net.partition.PartitionSet partitions, int iStore, int[][] aaiOwner)
        {
        // import Component.Net.Member;
        // import Component.Net.MemberSet.ActualMemberSet.ServiceMemberSet as com.tangosol.coherence.component.net.memberSet.actualMemberSet.ServiceMemberSet;
        // import com.tangosol.net.partition.PartitionSet;
        // import com.tangosol.util.LiteMap;
        // import java.util.HashMap;
        // import java.util.Map;
        
        Map       mapByOwner  = partitions.cardinality() > 1 ? new HashMap() : (Map) new LiteMap();
        com.tangosol.coherence.component.net.memberSet.actualMemberSet.ServiceMemberSet setMembers  = getServiceMemberSet();
        int       cPartitions = getPartitionCount();
        
        if (aaiOwner == null)
            {
            aaiOwner = getPartitionAssignments();
            }
        
        for (int iPartition = partitions.next(0); iPartition >= 0;
                 iPartition = partitions.next(iPartition + 1))
            {
            int    nOwner = aaiOwner[iPartition][iStore];
            Member member = nOwner > 0 && !setMembers.isServiceLeaving(nOwner) ?
                                setMembers.getMember(nOwner) : null;
        
            // member could be null here, indicating that the partition is orphaned
            PartitionSet partMember = (PartitionSet) mapByOwner.get(member);
            if (partMember == null)
                {
                partMember = new PartitionSet(cPartitions);
                mapByOwner.put(member, partMember);
                }
            partMember.add(iPartition);
            }
        return mapByOwner;
        }
    
    /**
     * Split the entries from the given iterator into the a map of entries by
    * owner for the specified store.
    * 
    * Note: the set of orphaned entries is mapped to null in the resulting map
    * 
    * @param iterEntries  the iterator of entries to split
    * @param iStore          the storage index
    * @param aaiOwner    the (optional) partition assignments array
    * 
    * return Map<Member, Map<Binary, ?>>
     */
    public java.util.Map splitEntriesByOwner(java.util.Iterator iterEntries, int iStore, int[][] aaiOwner)
        {
        // import Component.Net.Member;
        // import Component.Net.MemberSet.ActualMemberSet.ServiceMemberSet as com.tangosol.coherence.component.net.memberSet.actualMemberSet.ServiceMemberSet;
        // import com.tangosol.util.Binary;
        // import java.util.HashMap;
        // import java.util.Map;
        // import java.util.Map$Entry as java.util.Map.Entry;
        
        Map       mapByOwner = new HashMap();
        com.tangosol.coherence.component.net.memberSet.actualMemberSet.ServiceMemberSet setMembers = getServiceMemberSet();
        
        if (aaiOwner == null)
            {
            aaiOwner = getPartitionAssignments();
            }
        
        while (iterEntries.hasNext())
            {
            java.util.Map.Entry  entry  = (java.util.Map.Entry) iterEntries.next();
            Binary binKey = (Binary) entry.getKey();
        
            int    iPartition = getKeyPartition(binKey);
            int    nOwner     = aaiOwner[iPartition][iStore];
            Member member     = nOwner > 0 && !setMembers.isServiceLeaving(nOwner) ?
                                    setMembers.getMember(nOwner) : null;
        
            // member could be null here, indicating that the owning partition is orphaned
            Map mapMember = (Map) mapByOwner.get(member);
            if (mapMember == null)
                {
                mapMember = new HashMap();
                mapByOwner.put(member, mapMember);
                }
            mapMember.put(binKey, entry.getValue());
            }
        return mapByOwner;
        }
    
    /**
     * Split the keys from the given iterator into the a map of key sets by
    * owner for the specified store.
    * 
    * Note: the set of orphaned keys is mapped to null in the resulting map
    * 
    * @param iterKeys     the iterator of keys to split
    * @param iStore         the storage index or -1 to indicate the closest
    * should be chosen
    * @param aaiOwner   the (optional) partition assignments array
    * 
    * @return Map<Member, Set<Binary>>
     */
    public java.util.Map splitKeysByOwner(java.util.Iterator iterKeys, int iStore, int[][] aaiOwner)
        {
        // import Component.Net.Member;
        // import Component.Net.MemberSet.ActualMemberSet.ServiceMemberSet as com.tangosol.coherence.component.net.memberSet.actualMemberSet.ServiceMemberSet;
        // import com.tangosol.util.Binary;
        // import java.util.HashMap;
        // import java.util.HashSet;
        // import java.util.Map;
        // import java.util.Set;
        
        Map       mapByOwner  = new HashMap();
        com.tangosol.coherence.component.net.memberSet.actualMemberSet.ServiceMemberSet setMembers  = getServiceMemberSet();
        
        if (aaiOwner == null)
            {
            aaiOwner = getPartitionAssignments();
            }
        
        while (iterKeys.hasNext())
            {
            Binary binKey = (Binary) iterKeys.next();
        
            int    iPartition = getKeyPartition(binKey);
            Member member     = null;
        
            if (iStore >= 0)
                {
                int nOwner = aaiOwner[iPartition][iStore];
        
                member = nOwner > 0 && !setMembers.isServiceLeaving(nOwner)
                            ? setMembers.getMember(nOwner) : null;
                }
            else
                {
                member = getClosestOwner(iPartition);
                }
        
            // member could be null here, indicating that the owning partition is orphaned
            Set setMember = (Set) mapByOwner.get(member);
            if (setMember == null)
                {
                setMember = new HashSet();
                mapByOwner.put(member, setMember);
                }
            setMember.add(binKey);
            }
        return mapByOwner;
        }
    
    /**
     * Split the keys from the given iterator into a map of key sets by
    * partition ID.
    * 
    * @return Map<nPID, Set<binKey>>
     */
    public java.util.Map splitKeysByPartition(java.util.Iterator iterKeys)
        {
        // import com.tangosol.util.Binary;
        // import java.util.HashMap;
        // import java.util.HashSet;
        // import java.util.Map;
        // import java.util.Set;
        
        Map mapByPID = new HashMap();
        while (iterKeys.hasNext())
            {
            Binary  binKey     = (Binary) iterKeys.next();
            Integer IPartition = Integer.valueOf(getKeyPartition(binKey));
        
            Set setPart = (Set) mapByPID.get(IPartition);
            if (setPart == null)
                {
                setPart = new HashSet();
                mapByPID.put(IPartition, setPart);
                }
            setPart.add(binKey);
            }
        
        return mapByPID;
        }
    
    /**
     * Swap the ownership of the specified backup indices.
    * Called on the service thread only.
    * 
    * @param iPartition    the partition to modify the backup index for
    * @param iStore0       the new backup index
    * @param iStore1       the currently owned index
    * 
    * @return true iff the partition change has been initiated
     */
    public boolean swapBackupIndex(int iPartition, int iStore0, int iStore1)
        {
        // import com.tangosol.net.partition.VersionedOwnership;
        
        PartitionedService.PartitionControl ctrlPartition = getPartitionControl(iPartition);
        if (ctrlPartition.isTransferDisallowed())
            {
            return false;
            }
        
        int[] aiOwner = getPartitionAssignments()[iPartition];
        int   iStoreLow;   // the "low" storage index (higher in the order of succession)
        int   iStoreHigh;  // the "high" storage index (lower in the order of succession)
        
        _assert(aiOwner[0] == getThisMember().getId(), "not a primary owner");
        _assert(iStore0 > 0 && iStore1 > 0);
        if (iStore0 == iStore1)
            {
            return true;
            }
        else if (iStore0 < iStore1)
            {
            iStoreLow  = iStore1 - 1;
            iStoreHigh = iStore1;
            }
        else // iStore0 > iStore1
            {
            iStoreLow  = iStore1;
            iStoreHigh = iStore1 + 1;
            }
        
        // disable the partition transfer; transfer is reenabled on poll
        // completion (see PartitionedService.PartitionSwapRequest.onRequestCompleted).
        ctrlPartition.preventTransfer();
        
        // update the local assignments
        int nMemberToPromote = aiOwner[iStoreHigh];
        aiOwner[iStoreHigh] = aiOwner[iStoreLow];
        aiOwner[iStoreLow]  = nMemberToPromote;
        
        VersionedOwnership owners = getPartitionConfig(iPartition);
        _trace("Exchanging the ownership for partition " + iPartition + " for backup indices "
             + iStoreLow + " and " + iStoreHigh + ", owners=" + owners, 3);
        
        // send the PartitionSwapRequest and publish the ownership once complete
        //   (see PartitionedService.PartitionSwapRequest.onRequestCompleted)
        // Note: we do not send the local assignments since if there are in-flight
        //       backup transfers it would prematurely update the backup owners
        PartitionedService.PartitionSwapRequest msg = (PartitionedService.PartitionSwapRequest) instantiateMessage("PartitionSwapRequest");
        msg.setPartition(iPartition);
        msg.setPromoteIndex(iStoreLow);
        msg.setOwners(owners);
        msg.setMemberList(getBackupOwners(iPartition, /*fIncludeTransitional*/ false));
        post(msg);
        
        // The swap operation can only operate on adjacent indices, so if
        // the desired and currently-owned indices are not "adjacent", then
        // the logical swap will require multiple pair-wise physical swaps.
        return Math.abs(iStore0 - iStore1) == 1;
        }
    
    /**
     * Attempt to transfer the specified partitions at the specified backup
    * index according to the TransferControl.
    * Called on the service thread only.
    * 
    * @param member               the member to transfer the partitions to
    * @param parts                    the set of partitions to transfer
    * @param iBackup                the backup index to transfer
    * @param cPartsLimit          the maximum number of partitions to transfer
    * 
    * @return the number of partition transfers that were sent
     */
    public int transferBackup(com.tangosol.coherence.component.net.Member member, com.tangosol.net.partition.PartitionSet parts, int iBackup, int cPartsLimit)
        {
        // import com.oracle.coherence.common.util.MemorySize;
        
        PartitionedService.TransferControl  ctrlTransfer     = getTransferControl();
        PartitionedService.PartitionControl aCtrlPartition[] = getPartitionControl();
        
        // lock the partition to change the ownership and take a transfer
        // snapshot; this will guarantee that any backup operation by
        // worker threads will always be sent to a correct backup owner
        // (COH-1191)
        long cContendMillis = getDistributionContendMillis();
        for (int iPart = parts.next(0); iPart >= 0; iPart = parts.next(iPart + 1))
            {
            PartitionedService.PartitionControl ctrl = aCtrlPartition[iPart];
            if (ctrl.lockWithAdaptiveTime(cContendMillis, PartitionedService.PartitionControl.LOCK_BACKUP_XFER_OUT, member.getId()))
                {
                // found a partition to transfer; no need to contend (blocking
                // the service thread) any more
                cContendMillis = 0L;
                }
            else
                {
                // couldn't lock the partition for transfer
                parts.remove(iPart);
                if (!isAdaptivePartitionLock())
                    {
                    cContendMillis >>= 1;
                    }
                }
            }
        
        int cPartitions = parts.cardinality();
        if (cPartitions == 0)
            {
            return 0;
            }
        
        // we have successfully locked some partitions for transfer;
        // prepare the TransferControl with the appropriate transfer limit
        ctrlTransfer.prepareBackupTransfer(member, getTransferThreshold(),
            Math.min(cPartsLimit, cPartitions));
        
        int cSent = 0;
        for (int iPart = parts.next(0); iPart >= 0; iPart = parts.next(iPart + 1))
            {
            PartitionedService.PartitionControl ctrlPart = aCtrlPartition[iPart];
            if (ctrlTransfer.isTransferFull())
                {
                parts.remove(iPart);
                ctrlPart.unlock(/*fRollBack*/ true);
                }
            else
                {
                validateTransferStrength(member, iPart, iBackup);       
        
                transferPartition(iPart, iBackup, (++cSent == cPartitions));
                ctrlPart.unlock();
        
                // block transfers until release notification is received (see #onBackupAssignment)
                ctrlPart.preventTransfer();
                }
            }
        
        _trace("Transferring " + new MemorySize(ctrlTransfer.getTransferredBytes()) +
               " of backup[" + iBackup + "] for " +
               parts + " to member " + member.getId() +
               (ctrlTransfer.isTransferFull() ? "; transfer threshold exceeded" : ""), 3);
        
        return cSent;
        }
    
    /**
     * Transfer the specified partition according to TransferControl. Called on
    * the service thread only.
    * 
    * @param iPartition          the partition to transfer
    * @param iStore                the backup index to transfer
    * @param fLastInTransfer  true if this is the last partition to be
    * transferred
    * 
    * @see #preparePartition, releasePartition, receivePartition, movePartition
     */
    protected void transferPartition(int iPartition, int iStore, boolean fLastInTransfer)
        {
        // update local assignments to reflect the new owner of the
        // partition whose transfer is in-progress
        assignPartitionOwner(iPartition, iStore, getTransferControl().getToMember().getId());
        }
    
    /**
     * Attempt to transfer the specified partitions at the primary index
    * according to the TransferControl.
    * Called on the service thread only.
    * 
    * @param member          the member to transfer the partitions to
    * @param msgRequest   the request for primary partition distribution
    * @param parts               the set of partitions to transfer.  Partitions
    * not locked will be removed from this set.
    * @param cPartsLimit     the maximum number of partitions to transfer
    * 
    * @return true iff a primary partition transfer is initiated
     */
    public boolean transferPrimary(com.tangosol.coherence.component.net.Member member, com.tangosol.coherence.component.net.message.RequestMessage msgRequest, com.tangosol.net.partition.PartitionSet parts, int cPartsLimit)
        {
        int                 cLocked        = 0;
        PartitionedService.PartitionControl[] aCtrlPartition = getPartitionControl();
        long                cContendMillis = getDistributionContendMillis();
        
        for (int iPart = parts.next(0); iPart >= 0; iPart = parts.next(iPart + 1))
            {
            PartitionedService.PartitionControl ctrl = aCtrlPartition[iPart];
            if (cLocked >= cPartsLimit)
                {
                parts.remove(iPart);
                }
            else if (ctrl.lockWithAdaptiveTime(cContendMillis, PartitionedService.PartitionControl.LOCK_PRIMARY_XFER_OUT, member.getId()))
                {
                ++cLocked;
        
                // found a partition to transfer; no need to contend (blocking
                // the service thread) anymore
                cContendMillis = 0L;
                }
            else
                {
                // we waited unsuccessfully
                parts.remove(iPart);
                if (!isAdaptivePartitionLock())
                    {
                    cContendMillis >>= 1;
                    }
                }
            }
        
        if (parts.isEmpty())
            {
            return false;
            }
        else
            {
            getTransferControl().preparePrimaryTransfer(msgRequest, getTransferThreshold());
        
            onFinalizeSendPrimary(parts);
            return true;
            }
        }
    
    public void unpinPartition(int iPartition)
        {
        if (isConcurrent() && isPrimaryOwner(iPartition))
            {
            exitPartition(iPartition);
            }
        }
    
    /**
     * Release a shared lock for the specified partitions allowing them to be
    * re-distributed.
     */
    public void unpinPartitions(com.tangosol.net.partition.PartitionSet partitions)
        {
        if (isConcurrent())
            {
            PartitionedService.PartitionControl[] aControl = getPartitionControl();
        
            for (int nPartition = partitions.next(0); nPartition >= 0;
                     nPartition = partitions.next(nPartition + 1))
                {
                aControl[nPartition].exit();
                }
            }
        }
    
    /**
     * Check that the member configuration is valid, or arrange to wait until it
    * does. Called on the service thread only.
    * 
    * Note: This method does not block itself, instead it delays the service
    * thread by resetting the distribution check time.
    * IMPORTANT: when called from onServiceStarted() and this node is the
    * senior service member, we hold the Service monitor.
     */
    protected boolean validateMemberConfig()
        {
        // import Component.Net.MemberSet.ActualMemberSet.ServiceMemberSet;
        // import com.oracle.coherence.persistence.PersistenceEnvironment;
        // import com.tangosol.internal.net.service.grid.PersistenceDependencies;
        // import com.tangosol.net.Member as com.tangosol.net.Member;
        // import com.tangosol.persistence.SafePersistenceWrappers;
        // import com.tangosol.persistence.SnapshotArchiver;
        // import com.tangosol.run.xml.XmlElement;
        // import java.util.Iterator;
        // import java.util.Map;
        
        // check to see that all ownership-enabled members older
        // than this one have finished starting up before we continue.
        // We need to wait for member config update messages to arrive
        // before continuing in order to avoid a situation where the
        // ownership seniority is revoked.  See COH-2507.
        
        int              nThisMember   = getThisMember().getId();
        boolean          fValid        = true;
        ServiceMemberSet setService    = getServiceMemberSet();
        long             ldtJoinedThis = setService.getServiceJoinTime(nThisMember);
        StringBuilder    sbMembers     = null;
        for (Iterator iter = setService.iterator(); iter.hasNext(); )
            {
            com.tangosol.net.Member memberThat    = (com.tangosol.net.Member) iter.next();
            int    nMemberThat   = memberThat.getId();
            long   ldtJoinedThat = setService.getServiceJoinTime(nMemberThat);
            if (ldtJoinedThat < ldtJoinedThis)
                {
                Integer IOwnership = (Integer)
                    setService.getMemberConfigMap(nMemberThat).get("ownership-enabled");
                if (IOwnership == null ||
                    IOwnership.intValue() == OWNERSHIP_PENDING)
                    {
                    if (sbMembers == null)
                        {
                        sbMembers = new StringBuilder();
                        }
                    else
                        {
                        sbMembers.append(", ");
                        }
                    sbMembers.append(nMemberThat);
                    fValid = false;
                    }
                }
            }
        
        // validate our persistence configuration
        // (see symmetric logic in #onOwnershipSeniority)
        if (fValid && isOwnershipEnabled())
            {
            com.tangosol.net.Member memberSenior = getOwnershipSenior();
            if (memberSenior != null)
                {
                Map        mapSenior = setService.getMemberConfigMap(memberSenior.getId());
                XmlElement xmlConfig = (XmlElement) mapSenior.get("persistence-config");
                if (xmlConfig == null)
                    {
                    sbMembers = new StringBuilder().append(memberSenior.getId());
                    fValid    = false;
                    }
                else
                    {
                    PersistenceEnvironment env  = null;
                    SnapshotArchiver       arch = null;
                    PartitionedService.PersistenceControl    ctrl = getPersistenceControl();
                    if (ctrl.isValid())
                        {
                        env  = SafePersistenceWrappers.unwrap(ctrl.getPersistenceEnvironment());
                        arch = ctrl.getSnapshotArchiver();
                        }
        
                    if (!verifyFeature("PersistenceActiveFailureMode",
                            !isActivePersistence() || ctrl == null
                                ? "none"
                                : ctrl.getActiveFailureMode() == PersistenceDependencies.FAILURE_STOP_SERVICE
                                    ? "stop-service" : "stop-persistence",
                            xmlConfig.getSafeAttribute("persistence-active-failure-mode").getString("none")) ||
                        !verifyFeature("PersistenceEnvironment",
                            env == null ? "none" : env.getClass().getName(),
                            xmlConfig.getSafeAttribute("persistence-environment").getString("none")) ||
                        !verifyFeature("PersistenceMode",
                            isActivePersistence() ? "active" : "on-demand",
                            xmlConfig.getSafeAttribute("persistence-mode").getString("none")) ||
                        !verifyFeature("PersistenceSnapshotArchiver",
                            arch == null ? "none" : arch.getClass().getName(),
                            xmlConfig.getSafeAttribute("persistence-snapshot-archiver").getString("none")))
                        {
                        // turn off the ownership to accelerate the departure
                        // (see onNotifyShutdown)
                        fValid = false;
                        setOwnershipEnabled(false);
                        post(instantiateMessage("NotifyShutdown"));
                        }
                    }
                }
            }
        
        if (sbMembers != null)
            {
            _trace("Waiting for member config update from members ["
                 + sbMembers.toString() + "] that are in the process of joining", 3);
            }
        
        return fValid;
        }
    
    /**
     * Validate the assignment array against the specified member-set.
    * 
    * @param setOwners   the ownership member-set
    * 
    * Called on the service thread only.
     */
    public void validatePartitionAssignments(com.tangosol.coherence.component.net.MemberSet setOwners)
        {
        // import Component.Net.Member;
        // import com.tangosol.net.partition.VersionedOwnership;
        
        int     nMemberThis = getThisMember().getId();
        int     cPartitions = getPartitionCount();
        int     cBackups    = getBackupCount();
        int[][] aaiOwner    = getPartitionAssignments();
        boolean fModified   = false;
        
        for (int iPartition = 0; iPartition < cPartitions; iPartition++)
            {
            int[]              aiOwner       = aaiOwner[iPartition];
            VersionedOwnership owners        = getPartitionConfig(iPartition);
            int                nPrimaryOwner = aiOwner[0];
            boolean            fPrimaryOwner = nPrimaryOwner == nMemberThis;
        
            for (int iStore = 0; iStore <= cBackups; iStore++)
                {
                int nOwnerLocal  = aiOwner[iStore];
                int nOwnerGlobal = owners.getOwner(iStore);
        
                boolean fLocalOwnerDeparted = nOwnerLocal > 0 && nOwnerLocal != nMemberThis &&
                        !setOwners.contains(nOwnerLocal);
                boolean fGlobalOwnerDeparted = nOwnerGlobal > 0 && nOwnerGlobal != nMemberThis &&
                        !setOwners.contains(nOwnerGlobal);
        
                // If our local and global pictures match, verify that any departed
                // members are removed from the assignments/ownership.
                //
                // Note: we may have already been informed of the member departure
                // and updated some assignments to reflect that (see #onTransferRequest)
                if (nOwnerLocal == nOwnerGlobal ||
                    nOwnerLocal == 0  && fGlobalOwnerDeparted ||
                    nOwnerGlobal == 0 && fLocalOwnerDeparted)
                    {
                    if (fLocalOwnerDeparted || fGlobalOwnerDeparted)
                        {
                        // update the local assignments to reflect that the partition owner
                        // at this storage index has left
        
                        if (!fModified)
                            {
                            aaiOwner  = (int[][]) aaiOwner.clone();
                            fModified = true;
                            }
                        aiOwner              = (int[]) aiOwner.clone();
                        aiOwner[iStore]      = 0;
                        aaiOwner[iPartition] = aiOwner;
        
                        // We need to update the "global" config, but don't want to
                        // do it globally at this time since the redistribution will
                        // take care of it in just a bit; however, that is wrong to
                        // leave it as is since if this node is the senior and there is
                        // a service that restarts on the same Member, we would issue
                        // a "ConfigSync" update that could lead the restarting node
                        // into a very dangerous data de-synchronization.
                        // It is important to remove any reference to the departed
                        // member in a safe way without causing any PartitionConfigUpdate,
                        // so we will use the fact that the PartitionConfigMap will not
                        // propagate any changes to a mutable object unless the reference
                        // itself changes. Since all this is happening on the service
                        // thread, no additional synchronization is required.
        
                        owners.setOwner(iStore, 0);
        
                        if (fPrimaryOwner && iStore > 0 &&
                            nOwnerLocal == 0 && fGlobalOwnerDeparted)
                            {
                            // This member (the primary owner) had intentionally endangered
                            // the backup ownership (see endangerLeavingBackups/endangerPartitions).
                            // Enable the partition transfer as that backup member has now left
                            getPartitionControl(iPartition).enableTransfer();
                            }
                        }
                    }
                else // nOwnerLocal != nOwnerGlobal
                    {
                    // local and global ownership don't match; the partition
                    // must be in the process of transfer (either incoming or outgoing)
        
                    if (iStore == 0)
                        {
                        if (fLocalOwnerDeparted)
                            {
                            if (nOwnerGlobal == nMemberThis)
                                {
                                // we were transferring a partition to 'nOwnerLocal' and
                                // they departed before publishing the change.  We must
                                // change the assignments to reflect that the partition is
                                // no longer owned.
                                // Note: we know that the transferee has already responded
                                //       to the transfer request successfully; we just have
                                //       not received any announcement.  If the transferree
                                //       had not already responded to the request, the poll
                                //       would be closed automatically before getting here
                                //       (see $NotifyServiceLeft#onReceived/#onNotifyServiceLeft)
                                if (!fModified)
                                    {
                                    aaiOwner  = (int[][]) aaiOwner.clone();
                                    fModified = true;
                                    }
                                aiOwner              = (int[]) aiOwner.clone();
                                aiOwner[0]           = 0;
                                aaiOwner[iPartition] = aiOwner;
                                publishPartitionOwnership(iPartition, 0, 0);
                                }
                            else
                                {
                                // this should not be possible as the local owner departure
                                // can only be a failure of a primary transfer recipient
                                // where we are the sender (and global owner)
                                throw new IllegalStateException(
                                        "Unrecoverable ownership de-synchronization for partition " +
                                        iPartition + "(" + nOwnerLocal + "!=" + nOwnerGlobal + ")");
                                }
                            }
                        }
                    else // iStore > 0
                        {
                        // The only possible scenarios when the local and global assignments
                        // differ for a backup partition are when:
                        //
                        // primary owner:    local  refers to the new backup owner
                        //                   global refers to the old backup owner
                        //     (must have started backup transfer)
                        // old backup owner: local  refers to the new backup owner
                        //                   global refers to me, or 0 (see COH-7503)
                        //                   global refers to me in any iStore (received BackupAssignment)
                        //     (must have received REQUEST_RELEASE)
                        // new backup owner: local  refers to me
                        //                   global refers to the old backup owner
                        //     (must have received backup transfer)
                        _assert(fPrimaryOwner ||
                                nOwnerLocal  == nMemberThis ||
                                nOwnerGlobal == nMemberThis ||
                                nOwnerGlobal == 0 ||
                                getOwnedIndex(iPartition, nMemberThis, /*fLocal*/ false) != -1, 
                                "Unrecoverable backup[" + iStore + "] ownership " +
                                "de-synchronization for partition " +
                                iPartition + "(" + nOwnerLocal + "!=" + nOwnerGlobal +
                                ", primary=" + nPrimaryOwner + ")");
        
                        if (fLocalOwnerDeparted)
                            {
                            boolean fEndanger = false;
                            if (fPrimaryOwner)
                                {
                                // we were transferring the backup to the departed
                                Member memberBackupPrev = setOwners.getMember(nOwnerGlobal);
                                if (memberBackupPrev == null)
                                    {
                                    // there was no previous backup owner, or it has also left
                                    fEndanger = true;
                                    }
                                else
                                    {
                                    // request confirmation from the old backup owner that it
                                    // still holds the backup storage (it could have received
                                    // a RELEASE) from the departed "new" backup owner.
                                    // Meanwhile, continue sending backup updates to it.
                                    aiOwner[iStore] = nOwnerGlobal;
                                    getTransferControl().requestBackupConfirmation(
                                            iPartition, iStore, nOwnerLocal, memberBackupPrev);
                                    }
                                }
                            else
                                {
                                // we must be the "old" backup owner and the new owner left;
                                // we cannot re-claim ownership, as we have already released
                                // the storage
                                fEndanger = true;
                                }
        
                            if (fEndanger)
                                {
                                aiOwner[iStore] = 0;
                                owners.setOwner(iStore, 0);
                                }
                            }
                        else if (fGlobalOwnerDeparted)
                            {
                            if (fPrimaryOwner)
                                {
                                PartitionedService.TransferControl ctrlTransfer = getTransferControl();
                                if (ctrlTransfer.isTransferInProgress(iPartition))
                                    {
                                    // we started transferring the partition to a new owner
                                    // (nOwnerLocal), but we have not received the
                                    // PartitionedService.TransferRequest response yet (and furthermore, the
                                    // new backup owner may not have received the transfer).
                                    // It would be wrong to publish the config at this point,
                                    // since the transfer protocol is still "in-progress".
                                    // On the other hand, it is also wrong to ignore this,
                                    // as the backup ANNOUNCE from the (now departed) old backup
                                    // may not arrive.  Instead, we send a backup confirmation
                                    // here to the new backup, which will force the "cycle"
                                    // to complete with an announcement.
        
                                    Member memberBackupNew = setOwners.getMember(nOwnerLocal);
                                    _assert(memberBackupNew != null);
        
                                    _trace("Transfer of partition " + iPartition
                                          + " (backup[" + iStore + "]) to member "
                                          + nOwnerLocal + " (previously owned by member "
                                          + nOwnerGlobal + ") is still in progress.", 3);
                                    ctrlTransfer.requestBackupConfirmation(
                                            iPartition, iStore, nOwnerGlobal, memberBackupNew);
                                    }
                                else
                                    {
                                    // we were transferring the backup to a new owner (nOwnerLocal)
                                    // when the old owner (nOwnerGlobal) departed.  We know the
                                    // new owner still exists, so treat this as an implicit release
                                    // from the old owner
                                    publishPartitionOwnership(iPartition, iStore, nOwnerLocal);
        
                                    getPartitionControl(iPartition).enableTransfer();
                                    }
                                }
                            else
                                {
                                // we are the new backup owner and the old backup died;
                                // there is nothing to do                        
                                }
                            }
                        }
                    }
                }
            }
        
        if (fModified)
            {
            setPartitionAssignments(aaiOwner);
            }
        }
    
    /**
     * Check that the partition configuration is valid, or arrange to wait until
    * it does. Called on the service thread only.
    * 
    * Note: This method does not block itself, instead it delays the service
    * thread by resetting the distribution check time.
    * IMPORTANT: when called from onServiceStarted() and this node is the
    * senior service member, we hold the Service monitor.
     */
    protected boolean validatePartitionConfig()
        {
        // import Component.Net.MemberSet;
        // import com.tangosol.net.Member as com.tangosol.net.Member;
        // import com.tangosol.net.partition.VersionedOwnership;
        
        // it is possible that partition data are obsolete,
        // referring to a phantom (after shutdown and re-join)
        // of this service as an owner and an update is in the wire
        
        com.tangosol.net.Member    memberThis    = getThisMember();
        int       nThisMember   = memberThis.getId();
        com.tangosol.net.Member    memberSenior  = getOwnershipSenior();
        int       nSeniorMember = memberSenior == null ?
                                      (isOwnershipEnabled() ? nThisMember : 0) :
                                      memberSenior.getId();
        MemberSet setOwners     = getOwnershipMemberSet();
        int       cPartitions   = getPartitionCount();
        int       cBackups      = getBackupCount();
        
        if (getPartitionConfigMap().isEmpty())
            {
            // Initialize the partition config. There are 3 cases:
            //
            // 1. We are the senior ownership member
            // 2. There are no ownership-enabled members
            // 3. We are joining a service that already has ownership-enabled members;
            //    a ConfigSync should have already been sent containing the Ownership
            //    for each partition; the partition config map should be non-empty
            //
            // Note: we do this after member config has been validated so that we can
            //       be sure that ownership-seniority will not be revoked.
            
            if (nSeniorMember == nThisMember || nSeniorMember == 0)
                {
                // there are no ownership-enabled members, or we are the first (and
                // therefore the ownership senior).  Initialize the partition-config
                // with an empty map.  If we are the ownership senior, the first
                // distribution cycle will initiate the orphan "assignment" protocol.
        
                initPartitionConfig();
                }
            else
                {
                // we are missing the partition config.
                //
                // The only possible (legal) case is that we are racing with the
                // ownership senior to join the service; in that case, it is possible
                // for the partition and member config messages to get interleaved
                // such that the member config arrives first (the partition config is
                // managed by a PartitionedService.PartitionConfig, whereas member config is maintained
                // point-to-point).  (COH-2693)
                _trace("Waiting for partition config from member " + nSeniorMember
                     + " that is in the process of joining", 3);
                return false;
                }
        
            return true;
            }
        
        boolean fValid     = true;
        int[][] aaiOwner   = getPartitionAssignments();
        int[]   aiVersions = getOwnershipVersion();
        for (int iPartition = 0; iPartition < cPartitions && fValid; ++iPartition)
            {
            VersionedOwnership owners = getPartitionConfig(iPartition);
            if (owners == null)
                {
                throw new IllegalStateException(
                    "Missing the ownership data for partition " + iPartition);
                }
        
            int[] aiOwner = aaiOwner[iPartition];
            for (int iStore = 0; iStore < 1 + cBackups; iStore++)
                {
                int nOwner = owners.getOwner(iStore);
                if (nOwner == nThisMember)
                    {
                    _trace("Waiting for ownership update from member " + nSeniorMember +
                           " for partition " + iPartition + " " + owners, 3);
                    fValid = false;
                    break;
                    }
                else
                    {
                    // no need to synchronize since we don't yet accept clients
                    aiOwner[iStore] = nOwner > 0 && setOwners.contains(nOwner)
                        ? nOwner : 0;
                    }
                }
        
            aiVersions[iPartition] = owners.getVersion();
            }
        
        return fValid;
        }
    
    // Declared at the super level
    /**
     * Validate the specified service config against this member.
    * 
    * @param xmlConfig   the service config
    * 
    * @return true  if this member is consistent with the specified config
     */
    protected boolean validateServiceConfig(com.tangosol.run.xml.XmlElement xmlConfig)
        {
        // import com.tangosol.net.ActionPolicy;
        // import com.tangosol.net.partition.KeyAssociator;
        // import com.tangosol.net.partition.KeyPartitioningStrategy;
        // import com.tangosol.run.xml.XmlElement;
        
        // extract service config values and validate the local values
        // see symmetric logic in #initServiceConfig
        int cPartitions = xmlConfig.getAttribute("partition-count").getInt();
        if (cPartitions != getPartitionCount())
            {
            _trace("This node is configured with a " + "'partition-count'"
                 + " value of " + getPartitionCount()
                 + ", but the service senior is using a value of " + cPartitions
                 + "; overriding the local configuration.", 2);
            setPartitionCount(cPartitions);
            }
        
        int cBackups = xmlConfig.getAttribute("redundancy-count").getInt();
        if (cBackups != getBackupCount())
            {
            _trace("This node is configured with a " + "'backup-count'"
                 + " value of " + getBackupCount()
                 + ", but the service senior is using a value of " + cBackups
                 + "; overriding the local configuration.", 2);
            setBackupCount(cBackups);
            }
        
        KeyAssociator           associator   = getConfiguredKeyAssociator();
        KeyPartitioningStrategy partitioning = getConfiguredKeyPartitioningStrategy();
        ActionPolicy            quorumPolicy = getActionPolicy();
        PartitionedService.CentralDistribution    strategy     = getDistributionStrategy();
        
        String sAssociator   = associator   == null ? "none" : associator.getClass().getName();
        String sPartitioning = partitioning == null ? "none" : partitioning.getClass().getName();
        String sQuorumPolicy = quorumPolicy == null ? "none" : quorumPolicy.getClass().getName();
        
        // 1) as of Coherence 12.2.1.1.0 the default quorum policy class has changed from
        //      com.tangosol.net.ConfigurableQuorumPolicy$WrapperQuorumPolicy
        // to
        //      com.tangosol.net.ConfigurableQuorumPolicy$PartitionedCacheQuorumPolicy
        //
        // 2) as of Coherence 12.2.1.1.0 we no longer publish or validate the PartitionAssignmentStrategy
        //
        
        // Even if all the nodes are of the current version now, there is a chance that
        // the original service senior was of an old version and we need to allow to proceed
        // with a legacy configuration elements
        
        final String QUORUM_DEFAULT_LEGACY = "com.tangosol.net.ConfigurableQuorumPolicy$WrapperQuorumPolicy";
        final String QUORUM_DEFAULT_12211  = "com.tangosol.net.ConfigurableQuorumPolicy$PartitionedCacheQuorumPolicy";
        
        String sQuorumGlobal = xmlConfig.getSafeAttribute("quorum-policy").getString();
        if (QUORUM_DEFAULT_LEGACY.equals(sQuorumGlobal))
            {
            // the new default is compatible with the legacy default
            sQuorumGlobal = QUORUM_DEFAULT_12211;
            }
            
        return super.validateServiceConfig(xmlConfig)
            && verifyFeature("QuorumPolicy", sQuorumPolicy, sQuorumGlobal)
            && verifyFeature("KeyAssociator", sAssociator, 
                    xmlConfig.getSafeAttribute("key-associator").getString())
            && verifyFeature("KeyPartitioningStrategy", sPartitioning, 
                    xmlConfig.getSafeAttribute("key-partitioning").getString());
        }
    
    /**
     * Check whether the proposed ownership transfer reduces the distribution
    * strength.
     */
    protected void validateTransferStrength(com.tangosol.net.partition.Ownership ownersOld, com.tangosol.net.partition.Ownership ownersNew, int iPartition)
        {
        PartitionedService.CentralDistribution dist = getDistributionStrategy();
        
        int nStrengthOld = Math.min(getBackupStrength(ownersOld.getOwners()), dist.getTargetStrength());;
        int nStrengthNew = getBackupStrength(ownersNew.getOwners());
        if (nStrengthNew < nStrengthOld && !getServiceMemberSet().isServiceLeaving(ownersOld.getPrimaryOwner()))
            {
            // soft assertion
            _trace("Initiating a transitional transfer for partition "  + iPartition
                + ": " + ownersOld + " -> " + ownersNew
                + " (strength " + nStrengthOld + " -> " + nStrengthNew + ")", 2);
            }
        }
    
    /**
     * Check whether the proposed ownership transfer reduces the distribution
    * strength.
     */
    protected void validateTransferStrength(com.tangosol.coherence.component.net.Member member, int iPartition, int iStore)
        {
        // import com.tangosol.net.partition.Ownership;
        
        Ownership ownersNew = getPartitionOwnership(iPartition);
        ownersNew.setOwner(iStore, member.getId());
        
        validateTransferStrength(getPartitionOwnership(iPartition), ownersNew, iPartition);
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService$BackupAssignment
    
    /**
     * BackupAssignment is used to coordinate the release/announcment of backup
     * ownership.
     * 
     * This message can be sent:
     * - from the new backup owner to the old backup owner to indicate that the
     * old owner may release the backup
     * - from the old backup owner to the primary owner to notify the primary
     * that the backup has been released and that to announce the ownership
     * change and to stop sending backup requests
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class BackupAssignment
            extends    com.tangosol.coherence.component.net.Message
        {
        // ---- Fields declarations ----
        
        /**
         * Property NewBackupOwner
         *
         * The member-id of the new backup owner.  Used only for
         * REQUEST_RELEASE and REQUEST_INDEX_CHANGE.
         */
        private int __m_NewBackupOwner;
        
        /**
         * Property Partition
         *
         * The partition id that this BackupRelease message relates to.
         */
        private int __m_Partition;
        
        /**
         * Property PrimaryOwner
         *
         * The member-id of the primary owner.  Used only for REQUEST_RELEASE
         * and REQUEST_INDEX_CHANGE.
         */
        private int __m_PrimaryOwner;
        
        /**
         * Property Release
         *
         * True iff this is a RELEASE command, otherwise it is an ANNOUNCE.
         */
        private boolean __m_Release;
        
        /**
         * Property Store
         *
         * The backup storage index that this BackupRelease relates to.
         */
        private int __m_Store;
        
        // Default constructor
        public BackupAssignment()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public BackupAssignment(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                setMessageType(37);
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.BackupAssignment();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/PartitionedService$BackupAssignment".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        // Accessor for the property "NewBackupOwner"
        /**
         * Getter for property NewBackupOwner.<p>
        * The member-id of the new backup owner.  Used only for REQUEST_RELEASE
        * and REQUEST_INDEX_CHANGE.
         */
        public int getNewBackupOwner()
            {
            return __m_NewBackupOwner;
            }
        
        // Accessor for the property "Partition"
        /**
         * Getter for property Partition.<p>
        * The partition id that this BackupRelease message relates to.
         */
        public int getPartition()
            {
            return __m_Partition;
            }
        
        // Accessor for the property "PrimaryOwner"
        /**
         * Getter for property PrimaryOwner.<p>
        * The member-id of the primary owner.  Used only for REQUEST_RELEASE
        * and REQUEST_INDEX_CHANGE.
         */
        public int getPrimaryOwner()
            {
            return __m_PrimaryOwner;
            }
        
        // Accessor for the property "Store"
        /**
         * Getter for property Store.<p>
        * The backup storage index that this BackupRelease relates to.
         */
        public int getStore()
            {
            return __m_Store;
            }
        
        // Accessor for the property "Release"
        /**
         * Getter for property Release.<p>
        * True iff this is a RELEASE command, otherwise it is an ANNOUNCE.
         */
        public boolean isRelease()
            {
            return __m_Release;
            }
        
        // Declared at the super level
        /**
         * This is the event that is executed when a Message is received.
        * <p>
        * It is the main processing event of the Message called by the
        * <code>Service.onMessage()</code> event. With regards to the use of
        * Message components within clustered Services, Services are designed
        * by dragging Message components into them as static children. These
        * Messages are the components that a Service can send to other running
        * instances of the same Service within a cluster. When the onReceived
        * event is invoked by a Service, it means that the Message has been
        * received; the code in the onReceived event is therefore the Message
        * specific logic for processing a received Message. For example, when
        * onReceived is invoked on a Message named FindData, the onReceived
        * event should do the work to "find the data", because it is being
        * invoked by the Service that received the "find the data" Message.
         */
        public void onReceived()
            {
            ((PartitionedService) get_Module()).onBackupAssignment(this);
            }
        
        // Declared at the super level
        public void read(com.tangosol.io.ReadBuffer.BufferInput input)
                throws java.io.IOException
            {
            // import com.tangosol.util.ExternalizableHelper as com.tangosol.util.ExternalizableHelper;
            
            setRelease(input.readBoolean());
            setPartition(com.tangosol.util.ExternalizableHelper.readInt(input));
            setStore(com.tangosol.util.ExternalizableHelper.readInt(input));
            setNewBackupOwner(com.tangosol.util.ExternalizableHelper.readInt(input));
            setPrimaryOwner(com.tangosol.util.ExternalizableHelper.readInt(input));
            }
        
        // Accessor for the property "NewBackupOwner"
        /**
         * Setter for property NewBackupOwner.<p>
        * The member-id of the new backup owner.  Used only for REQUEST_RELEASE
        * and REQUEST_INDEX_CHANGE.
         */
        public void setNewBackupOwner(int nOwner)
            {
            __m_NewBackupOwner = nOwner;
            }
        
        // Accessor for the property "Partition"
        /**
         * Setter for property Partition.<p>
        * The partition id that this BackupRelease message relates to.
         */
        public void setPartition(int nPartition)
            {
            __m_Partition = nPartition;
            }
        
        // Accessor for the property "PrimaryOwner"
        /**
         * Setter for property PrimaryOwner.<p>
        * The member-id of the primary owner.  Used only for REQUEST_RELEASE
        * and REQUEST_INDEX_CHANGE.
         */
        public void setPrimaryOwner(int nOwner)
            {
            __m_PrimaryOwner = nOwner;
            }
        
        // Accessor for the property "Release"
        /**
         * Setter for property Release.<p>
        * True iff this is a RELEASE command, otherwise it is an ANNOUNCE.
         */
        public void setRelease(boolean fRelease)
            {
            __m_Release = fRelease;
            }
        
        // Accessor for the property "Store"
        /**
         * Setter for property Store.<p>
        * The backup storage index that this BackupRelease relates to.
         */
        public void setStore(int iStore)
            {
            __m_Store = iStore;
            }
        
        // Declared at the super level
        public void write(com.tangosol.io.WriteBuffer.BufferOutput output)
                throws java.io.IOException
            {
            // import com.tangosol.util.ExternalizableHelper as com.tangosol.util.ExternalizableHelper;
            
            output.writeBoolean(isRelease());
            com.tangosol.util.ExternalizableHelper.writeInt(output, getPartition());
            com.tangosol.util.ExternalizableHelper.writeInt(output, getStore());
            com.tangosol.util.ExternalizableHelper.writeInt(output, getNewBackupOwner());
            com.tangosol.util.ExternalizableHelper.writeInt(output, getPrimaryOwner());
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService$BackupConfirmRequest
    
    /**
     * BackupConfirmRequest is sent by the primary owner to the old backup
     * owner to confirm the ownership as a result of a failure during the
     * backup transfer.
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class BackupConfirmRequest
            extends    com.tangosol.coherence.component.net.message.RequestMessage
            implements com.oracle.coherence.common.base.Continuation
        {
        // ---- Fields declarations ----
        
        /**
         * Property DepartedMemberId
         *
         * The id of the member whose departure initiated the request for a
         * backup confirmation.
         */
        private int __m_DepartedMemberId;
        
        /**
         * Property Partition
         *
         * The partition-id.
         */
        private int __m_Partition;
        
        /**
         * Property Store
         *
         * The storage-index.
         */
        private int __m_Store;
        private static com.tangosol.util.ListMap __mapChildren;
        
        // Static initializer
        static
            {
            __initStatic();
            }
        
        // Default static initializer
        private static void __initStatic()
            {
            // register child classes
            __mapChildren = new com.tangosol.util.ListMap();
            __mapChildren.put("Poll", PartitionedService.BackupConfirmRequest.Poll.get_CLASS());
            }
        
        // Default constructor
        public BackupConfirmRequest()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public BackupConfirmRequest(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                setMessageType(40);
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // containment initialization: children
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.BackupConfirmRequest();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/PartitionedService$BackupConfirmRequest".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        //++ getter for autogen property _ChildClasses
        /**
         * This is an auto-generated method that returns the map of design time
        * [static] children.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        protected java.util.Map get_ChildClasses()
            {
            return __mapChildren;
            }
        
        // Accessor for the property "DepartedMemberId"
        /**
         * Getter for property DepartedMemberId.<p>
        * The id of the member whose departure initiated the request for a
        * backup confirmation.
         */
        public int getDepartedMemberId()
            {
            return __m_DepartedMemberId;
            }
        
        // Accessor for the property "Partition"
        /**
         * Getter for property Partition.<p>
        * The partition-id.
         */
        public int getPartition()
            {
            return __m_Partition;
            }
        
        // Accessor for the property "Store"
        /**
         * Getter for property Store.<p>
        * The storage-index.
         */
        public int getStore()
            {
            return __m_Store;
            }
        
        // Declared at the super level
        protected com.tangosol.coherence.component.net.Poll instantiatePoll()
            {
            // import Component.Net.Poll as com.tangosol.coherence.component.net.Poll;
            
            return (com.tangosol.coherence.component.net.Poll) _newChild("Poll");
            }
        
        // Declared at the super level
        /**
         * This is the event that is executed when a Message is received.
        * <p>
        * It is the main processing event of the Message called by the
        * <code>Service.onMessage()</code> event. With regards to the use of
        * Message components within clustered Services, Services are designed
        * by dragging Message components into them as static children. These
        * Messages are the components that a Service can send to other running
        * instances of the same Service within a cluster. When the onReceived
        * event is invoked by a Service, it means that the Message has been
        * received; the code in the onReceived event is therefore the Message
        * specific logic for processing a received Message. For example, when
        * onReceived is invoked on a Message named FindData, the onReceived
        * event should do the work to "find the data", because it is being
        * invoked by the Service that received the "find the data" Message.
         */
        public void onReceived()
            {
            // import Component.Net.Member;
            
            PartitionedService service        = (PartitionedService) getService();
            Member  memberDeparted = service.getServiceMemberSet().getMember(getDepartedMemberId());
            if (memberDeparted == null)
                {
                // we have already heard about this member's death; answer
                // the confirmation request immediately
                proceed(null);
                }
            else
                {
                // this member has not yet detected the departure of the member;
                // defer the processing of this request until that membership change occurs
            
                _trace("Deferring BackupConfirmRequest for partition " + getPartition() + ", backup[" + getStore() + "]"
                     + " until member " + memberDeparted.getId() + " has departed.", 3);
                service.deferUntilServiceLeft(memberDeparted, this);
                }
            }
        
        // From interface: com.oracle.coherence.common.base.Continuation
        public void proceed(Object oResult)
            {
            ((PartitionedService) get_Module()).onBackupConfirmRequest(this);
            }
        
        // Declared at the super level
        public void read(com.tangosol.io.ReadBuffer.BufferInput input)
                throws java.io.IOException
            {
            // import com.tangosol.util.ExternalizableHelper as com.tangosol.util.ExternalizableHelper;
            
            setPartition       (com.tangosol.util.ExternalizableHelper.readInt(input));
            setStore           (com.tangosol.util.ExternalizableHelper.readInt(input));
            setDepartedMemberId(com.tangosol.util.ExternalizableHelper.readInt(input));
            }
        
        // Accessor for the property "DepartedMemberId"
        /**
         * Setter for property DepartedMemberId.<p>
        * The id of the member whose departure initiated the request for a
        * backup confirmation.
         */
        public void setDepartedMemberId(int nId)
            {
            __m_DepartedMemberId = nId;
            }
        
        // Accessor for the property "Partition"
        /**
         * Setter for property Partition.<p>
        * The partition-id.
         */
        public void setPartition(int nPartition)
            {
            __m_Partition = nPartition;
            }
        
        // Accessor for the property "Store"
        /**
         * Setter for property Store.<p>
        * The storage-index.
         */
        public void setStore(int nStore)
            {
            __m_Store = nStore;
            }
        
        // Declared at the super level
        public void write(com.tangosol.io.WriteBuffer.BufferOutput output)
                throws java.io.IOException
            {
            // import com.tangosol.util.ExternalizableHelper as com.tangosol.util.ExternalizableHelper;
            
            com.tangosol.util.ExternalizableHelper.writeInt(output, getPartition());
            com.tangosol.util.ExternalizableHelper.writeInt(output, getStore());
            com.tangosol.util.ExternalizableHelper.writeInt(output, getDepartedMemberId());
            }

        // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService$BackupConfirmRequest$Poll
        
        /**
         * The Poll contains information regarding a request sent to one or
         * more Cluster Members that require responses. A Service may poll
         * other Members that are running the same Service, and the Poll is
         * used to wait for and assemble the responses from each of those
         * Members. A client thread may also use the Poll to block on a
         * response or set of responses, thus waiting for the completion of the
         * Poll. In its simplest form, which is a Poll that is sent to one
         * Member of the Cluster, the Poll actually represents the
         * request/response model.
         */
        @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
        public static class Poll
                extends    com.tangosol.coherence.component.net.Poll
            {
            // ---- Fields declarations ----
            
            // Default constructor
            public Poll()
                {
                this(null, null, true);
                }
            
            // Initializing constructor
            public Poll(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                {
                super(sName, compParent, false);
                
                if (fInit)
                    {
                    __init();
                    }
                }
            
            // Main initializer
            public void __init()
                {
                // private initialization
                __initPrivate();
                
                
                // signal the end of the initialization
                set_Constructed(true);
                }
            
            // Private initializer
            protected void __initPrivate()
                {
                
                super.__initPrivate();
                }
            
            //++ getter for static property _Instance
            /**
             * Getter for property _Instance.<p>
            * Auto generated
             */
            public static com.tangosol.coherence.Component get_Instance()
                {
                return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.BackupConfirmRequest.Poll();
                }
            
            //++ getter for static property _CLASS
            /**
             * Getter for property _CLASS.<p>
            * Property with auto-generated accessor that returns the Class
            * object for a given component.
             */
            public static Class get_CLASS()
                {
                Class clz;
                try
                    {
                    clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/PartitionedService$BackupConfirmRequest$Poll".replace('/', '.'));
                    }
                catch (ClassNotFoundException e)
                    {
                    throw new NoClassDefFoundError(e.getMessage());
                    }
                return clz;
                }
            
            //++ getter for autogen property _Module
            /**
             * This is an auto-generated method that returns the global [design
            * time] parent component.
            * 
            * Note: the class generator will ignore any custom implementation
            * for this behavior.
             */
            private com.tangosol.coherence.Component get_Module()
                {
                return this.get_Parent().get_Parent();
                }
            
            // Declared at the super level
            /**
             * This is the event that is executed when all the Members that were
            * polled have responded or have left the Service.
             */
            protected void onCompletion()
                {
                PartitionedService.BackupConfirmRequest msg = (PartitionedService.BackupConfirmRequest) get_Parent();
                
                // re-enable transfer on CONFIRM completion
                ((PartitionedService) getService()).getPartitionControl(msg.getPartition()).enableTransfer();
                }
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService$CentralDistribution
    
    /**
     * This DistributionStrategy implements an centralized distribution that
     * uses a pluggable algorithm.  In this strategy, the distribution
     * coordinator member receives statistics updates and information from the
     * ownership-enabled members and provides that information to the pluggable
     * PartitionAssignmentStrategy.
     * 
     * The pluggable strategy is responsible for making distribution
     * recommendations, which the distribution coordinator will advertise to
     * the service members.
     * 
     * This distribution strategy was introduced in Coherence 3.7.
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class CentralDistribution
            extends    com.tangosol.coherence.component.util.DistributionStrategy
        {
        // ---- Fields declarations ----
        
        /**
         * Property AnalysisNextMillis
         *
         * The AnalysisNextMillis value is the time (in local clock) at which
         * the next strategy analysis will be performed.
         * 
         * @volatile
         */
        private volatile long __m_AnalysisNextMillis;
        
        /**
         * Property DistributionManager
         *
         * The DistributionManager used to communicate with pluggable
         * strategies.
         */
        private PartitionedService.CentralDistribution.DistributionManager __m_DistributionManager;
        
        /**
         * Property LastCoordinator
         *
         * The last distribution coordinator that offered advice still being
         * processed.
         */
        private com.tangosol.coherence.component.net.Member __m_LastCoordinator;
        
        /**
         * Property LastStorageSize
         *
         * Last measurment of the StorageSize. Used only to adjust the sampling
         * interval.
         */
        private long __m_LastStorageSize;
        
        /**
         * Property PartitionAssignmentStrategy
         *
         * PartitionAssigningStrategy implementation.
         */
        private transient com.tangosol.net.partition.PartitionAssignmentStrategy __m_PartitionAssignmentStrategy;
        
        /**
         * Property PartitionStatistics
         *
         * Array of last collected statistics. Not empty only if this node is
         * the distribution coordinator.
         */
        private com.tangosol.net.partition.PartitionStatistics[] __m_PartitionStatistics;
        
        /**
         * Property PendingChanges
         *
         * Indexed (by the storage index) array of Map<MemberId, PartitionSet>
         * containing the set of partitions to be transferred from (for primary
         * distribution) or to (for backup distribution) the associated member.
         */
        private java.util.Map[] __m_PendingChanges;
        
        /**
         * Property TargetStrength
         *
         * The target strength of the current suggestion; it gets recalculated
         * every time the new analysis is performed.
         */
        private int __m_TargetStrength;
        
        // Default constructor
        public CentralDistribution()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public CentralDistribution(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                setDistributionsPendingStart(0L);
                setTargetStrength(-1);
                setWarningNextMillis(0L);
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // containment initialization: children
            _addChild(new PartitionedService.CentralDistribution.DistributionManager("DistributionManager", this, true), "DistributionManager");
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.CentralDistribution();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/PartitionedService$CentralDistribution".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        // Declared at the super level
        /**
         * Perform the analysis of the partition distribution among the
        * partitioned service members and, if necessary, re-distribute the
        * partitions. Called on the service thread only.
        * 
        * @param setOwners  the set of ownership-enabled service members
        * (including any that might be leaving)
        * @param setLeaving  the set of ownership-enabled service members that
        * are in the process of leaving
         */
        public void checkDistribution(com.tangosol.coherence.component.net.MemberSet setOwners, java.util.Set setLeaving)
            {
            // import com.tangosol.net.partition.PartitionSet;
            // import com.tangosol.net.partition.PartitionStatistics;
            // import com.tangosol.util.Base;
            // import java.util.ArrayList;
            // import java.util.Iterator;
            // import java.util.List;
            // import java.util.Map;
            
            PartitionedService service = getService();
            
            long ldtNow          = Base.getSafeTimeMillis();
            long ldtNextCheck    = ldtNow + service.getDistributionRepeatMillis();
            long ldtNextSample   = getStatsSampleNextMillis();
            long ldtNextAnalysis = Long.MAX_VALUE; // meaningful only for the coordinator
            
            if (ldtNow > ldtNextSample)
                {
                // time to gather and send the partition stats to the coordinator
                PartitionedService.PartitionControl[]   actrl        = service.getPartitionControl();
                PartitionSet          parts        = service.collectOwnedPartitions(true);
                PartitionStatistics[] aStats       = getPartitionStatistics();
                List                  listStats    = new ArrayList(parts.cardinality());
                long                  cStorageSize = 0L;
            
                for (int nPartition = parts.next(0); nPartition >= 0;
                         nPartition = parts.next(nPartition + 1))
                    {
                    PartitionStatistics statsCtrl = actrl[nPartition].updateDirectStorageSize();
                    PartitionStatistics stats     = aStats[nPartition];
                    
                    cStorageSize += statsCtrl.getStorageSize();
            
                    if (isCoordinator())
                        {
                        if (stats == null)
                            {
                            aStats[nPartition] = stats = new PartitionStatistics();
                            }
                        stats.copyFrom(statsCtrl);
                        statsCtrl.reset();
                        }
                    else
                        {
                        listStats.add(statsCtrl);
                        }
                    }
            
                if (listStats.size() > 0)
                    {
                    // if the storage size change is over 10% - notify the coordinator
                    // TODO: should this be decided by each Statistics object itself?
                    if (Math.abs(cStorageSize - getLastStorageSize()) > 0.1 * cStorageSize)
                        {
                        PartitionedService.PartitionStatsUpdate msgUpdate = (PartitionedService.PartitionStatsUpdate)
                            service.instantiateMessage("PartitionStatsUpdate");
                        msgUpdate.setStatsList(listStats);
                        msgUpdate.addToMember(service.getOwnershipSenior(false));
                        service.post(msgUpdate);
            
                        for (Iterator iter = listStats.iterator(); iter.hasNext();)
                            {
                            ((PartitionStatistics) iter.next()).reset();
                            }
                        
                        setLastStorageSize(cStorageSize);
                        } 
                    }
            
                setStatsSampleNextMillis(ldtNextSample = ldtNow + getStatsSamplingInterval());
                }
            
            if (isCoordinator())
                {
                // Note: this has a side-effect of initializing the PAS, registering the MBean
                //       and resetting the AnalysisNextMillis
                PartitionedService.CentralDistribution.DistributionManager manager = getDistributionManager();
            
                ldtNextAnalysis = getAnalysisNextMillis();
            
                if (ldtNow >= ldtNextAnalysis)
                    {
                    // A sufficiently long time has passed since the last distribution;
                    // discard any remaining deferred suggestions and analyze again
                    try
                        {
                        manager.reset();
                        manager.setOwnershipMembers(setOwners);
                        manager.setOwnershipLeavingMembers(setLeaving);
            
                        long cAnalysisMillis = getPartitionAssignmentStrategy().analyzeDistribution();
            
                        if (setOwners.size() == 1)
                            {
                            ldtNextCheck = ldtNextAnalysis = ldtNextSample = Long.MAX_VALUE;
                            }
                        else
                            {
                            long cRepeatMillis = service.getDistributionRepeatMillis();
            
                            ldtNextAnalysis = ldtNow +
                                 (service.getServiceState() == PartitionedService.SERVICE_STOPPING
                                    // move a bit faster if we are leaving
                                    ? cRepeatMillis / service.getDistributionAggressiveness()
                                    : cAnalysisMillis == -1L ? cRepeatMillis : cAnalysisMillis);
                            }
                        setAnalysisNextMillis(ldtNextAnalysis);
                        }
                    catch (Throwable t)
                        {
                        _trace("Unexpected exception occurred while calculating the "
                             + "partition assignment: " + Base.printStackTrace(t), 1);
                        }
                    }
            
                // Note: we do not reset() the manager, as it may contain deferred suggestions
                //       necessary to maintain the backup-strength during the transfer process
                Map mapUpdate = manager.getSafeSuggestions();
                if (mapUpdate != null && !mapUpdate.isEmpty())
                    {
                    // send the update to the other ownership members
                    PartitionedService.DistributionPlanUpdate msgUpdate = (PartitionedService.DistributionPlanUpdate)
                        service.instantiateMessage("DistributionPlanUpdate");
            
                    msgUpdate.setUpdateMap(mapUpdate);
                    msgUpdate.setToMemberSet(service.getOwnershipOtherMemberSet(null));
                    msgUpdate.setTargetStrength(getTargetStrength());
            
                    service.post(msgUpdate);
            
                    // and process them locally
                    processUpdate(mapUpdate);
            
                    Map mapDeferredSuggestions = manager.getSuggestionMap();
                    if (mapDeferredSuggestions != null && !mapDeferredSuggestions.isEmpty())
                        {
                        // if there are deferred suggestions, check back relatively quickly
                        ldtNextCheck = ldtNow +
                            service.getDistributionRepeatMillis() / service.getDistributionAggressiveness();
                        }
                    }
                }
            
            if (service.isDistributionAllowed() && !processPendingChanges()
                || !service.isDistributionStable())
                {
                ldtNextCheck = ldtNow +
                    service.getDistributionRepeatMillis() / service.getDistributionAggressiveness();
                }
            
            service.setDistributionNextMillis(Math.min(Math.min(ldtNextCheck, ldtNextAnalysis), ldtNextSample));
            }
        
        /**
         * Remove the specified partitions from previous distribution suggestion
        * that are still in pending changeset.
         */
        public void clearAdvice(com.tangosol.net.partition.PartitionSet parts)
            {
            // import com.tangosol.net.partition.PartitionSet;
            // import java.util.Iterator;
            // import java.util.Map;
            
            for (int iStore = 0, cBackups = getBackupCount(); iStore <= cBackups; iStore++)
                {
                // discard any still pending advice in favor of the new update
                Map mapPending = getPendingChanges(iStore); // <nMember, PartitionSet>
                for (Iterator iterPending = mapPending.values().iterator(); iterPending.hasNext(); )
                    {
                    PartitionSet partsPending = (PartitionSet) iterPending.next();
                    partsPending.remove(parts);
                    }
                }
            }
        
        /**
         * Clear all advice received from previous plan updates.
         */
        protected void clearPendingChanges()
            {
            for (int iStore = 0, cBackups = getBackupCount(); iStore <= cBackups; ++iStore)
                {
                getPendingChanges(iStore).clear();
                }
            }
        
        /**
         * Check if a transfer of the suggested backup storage should be
        * deferred due to the fact that there is another endangered storage.
        * Note, that this can only occur for the backup-count greater than one.
         */
        protected boolean deferBackupTransfer(int iPart, int iStore, int nMember)
            {
            // import com.tangosol.net.partition.PartitionSet;
            // import java.util.Iterator;
            // import java.util.Map;
            // import java.util.Map$Entry as java.util.Map.Entry;
            
            int[] aiOwners = getPartitionAssignments()[iPart];
            
            for (int i = 1, c = aiOwners.length; i < c; i++)
                {
                if (aiOwners[i] == 0)
                    {
                    // if the partition is endangered, make sure that we skip
                    // potential transfers that do not address the endangered storage
            
                    return i != iStore;
                    }
                }
            
            // prioritize backup swaps of members with skin in the game to avoid removing those
            // members just to bring them back in the ownership ring
            for (int i =iStore + 1, c = getBackupCount(); i <= c; i++)
                {
                Map mapPending = getPendingChanges(i); // <nMember, PartitionSet>
              
                int          nMemberCur = aiOwners[iStore];
                PartitionSet parts      = (PartitionSet) mapPending.get(Integer.valueOf(nMemberCur));
            
                if (parts != null && parts.contains(iPart))
                    {
                    // defer the transfer until backup ownership swaps have completed
                    return true;
                    }
                }
            
            // defer the backup transfer for the given store if performing a xfer for another
            // store first results in a greater backup strength 
            PartitionedService service     = getService();
            int[]   aiOwnerTemp = (int[]) aiOwners.clone();
            int     nMemberCur  = aiOwners[iStore];
            
            aiOwnerTemp[iStore] = nMember;
            
            int nStrength = service.getBackupStrength(aiOwnerTemp);
            
            aiOwnerTemp[iStore] = nMemberCur; // reset
            
            if (nStrength < getTargetStrength())
                {
                for (int i = iStore + 1, c = getBackupCount(); i <= c; i++)
                    {
                    Map mapPending = getPendingChanges(i); // <nMember, PartitionSet>
            
                    for (Iterator iter = mapPending.entrySet().iterator(); iter.hasNext(); )
                        {
                        java.util.Map.Entry        entry = (java.util.Map.Entry) iter.next();
                        PartitionSet parts = (PartitionSet) entry.getValue();
                        if (parts != null && parts.contains(iPart))
                            {
                            nMemberCur     = aiOwnerTemp[i];
                            aiOwnerTemp[i] = ((Integer) entry.getKey()).intValue();
                            if (service.getBackupStrength(aiOwnerTemp) > nStrength)
                                {
                                return true;
                                }
                            aiOwnerTemp[i] = nMemberCur; // reset
                            }
                        }
                    }
                }
            return false;
            }
        
        protected void endangerPartitions(com.tangosol.net.partition.PartitionSet partsEndanger, int iStore)
            {
            // import Component.Net.Member;
            
            int[][]          aaiOwners    = getPartitionAssignments();
            int              nMemberThis  = getThisMember().getId();
            PartitionedService          service      = getService();
            PartitionedService.TransferControl ctrlTransfer = service.getTransferControl();
            
            for (int iPart = partsEndanger.next(0); iPart >= 0;
                 iPart = partsEndanger.next(iPart + 1))
                {
                if (aaiOwners[iPart][0] == nMemberThis)
                    {
                    int    nBackupOwner = aaiOwners[iPart][iStore];
                    Member memberBackup = service.getServiceMemberSet().getMember(nBackupOwner);
                    if (memberBackup != null)
                        {
                        // update the local assignments and send a backup release
                        aaiOwners[iPart][iStore] = 0;
            
                        service.getPartitionControl(iPart).preventTransfer();
                        ctrlTransfer.sendBackupRelease(iPart, iStore, nMemberThis, 0, memberBackup, null);
                        }
                    }
                }
            }
        
        // Accessor for the property "AnalysisNextMillis"
        /**
         * Getter for property AnalysisNextMillis.<p>
        * The AnalysisNextMillis value is the time (in local clock) at which
        * the next strategy analysis will be performed.
        * 
        * @volatile
         */
        public long getAnalysisNextMillis()
            {
            return __m_AnalysisNextMillis;
            }
        
        // Accessor for the property "DistributionManager"
        /**
         * Getter for property DistributionManager.<p>
        * The DistributionManager used to communicate with pluggable strategies.
         */
        public PartitionedService.CentralDistribution.DistributionManager getDistributionManager()
            {
            PartitionedService.CentralDistribution.DistributionManager mgr = __m_DistributionManager;
            
            // the DistributionManager is lazily initialized, as it must be deferred until
            // the ownership coordinator is positively identified (after AcceptingClients)
            if (mgr == null)
                {
                _assert(isCoordinator());
            
                PartitionedService service = getService();
            
                _trace("This member has become the distribution coordinator for "
                     + service.getOwnershipMemberSet(), 3);
            
                mgr = (PartitionedService.CentralDistribution.DistributionManager) _findChild("DistributionManager");
                mgr.initialize(getPartitionAssignmentStrategy());
            
                setDistributionManager(mgr);
                scheduleImmediate();
                }
            
            return mgr;
            }
        
        // Accessor for the property "LastCoordinator"
        /**
         * Getter for property LastCoordinator.<p>
        * The last distribution coordinator that offered advice still being
        * processed.
         */
        protected com.tangosol.coherence.component.net.Member getLastCoordinator()
            {
            return __m_LastCoordinator;
            }
        
        // Accessor for the property "LastStorageSize"
        /**
         * Getter for property LastStorageSize.<p>
        * Last measurment of the StorageSize. Used only to adjust the sampling
        * interval.
         */
        public long getLastStorageSize()
            {
            return __m_LastStorageSize;
            }
        
        // Accessor for the property "PartitionAssignmentStrategy"
        /**
         * Getter for property PartitionAssignmentStrategy.<p>
        * PartitionAssigningStrategy implementation.
         */
        public com.tangosol.net.partition.PartitionAssignmentStrategy getPartitionAssignmentStrategy()
            {
            return __m_PartitionAssignmentStrategy;
            }
        
        // Accessor for the property "PartitionStatistics"
        /**
         * Getter for property PartitionStatistics.<p>
        * Array of last collected statistics. Not empty only if this node is
        * the distribution coordinator.
         */
        public com.tangosol.net.partition.PartitionStatistics[] getPartitionStatistics()
            {
            return __m_PartitionStatistics;
            }
        
        // Accessor for the property "PartitionStatistics"
        /**
         * Getter for property PartitionStatistics.<p>
        * Array of last collected statistics. Not empty only if this node is
        * the distribution coordinator.
         */
        public com.tangosol.net.partition.PartitionStatistics getPartitionStatistics(int i)
            {
            return getPartitionStatistics()[i];
            }
        
        // Accessor for the property "PendingChanges"
        /**
         * Getter for property PendingChanges.<p>
        * Indexed (by the storage index) array of Map<MemberId, PartitionSet>
        * containing the set of partitions to be transferred from (for primary
        * distribution) or to (for backup distribution) the associated member.
         */
        protected java.util.Map[] getPendingChanges()
            {
            return __m_PendingChanges;
            }
        
        // Accessor for the property "PendingChanges"
        /**
         * Getter for property PendingChanges.<p>
        * Indexed (by the storage index) array of Map<MemberId, PartitionSet>
        * containing the set of partitions to be transferred from (for primary
        * distribution) or to (for backup distribution) the associated member.
         */
        public java.util.Map getPendingChanges(int iStore)
            {
            return getPendingChanges()[iStore];
            }
        
        // Accessor for the property "TargetStrength"
        /**
         * Getter for property TargetStrength.<p>
        * The target strength of the current suggestion; it gets recalculated
        * every time the new analysis is performed.
         */
        public int getTargetStrength()
            {
            return __m_TargetStrength;
            }
        
        // Declared at the super level
        /**
         * Initialize this DistributionStrategy based on the Service attributes.
         */
        public void initialize()
            {
            // import com.tangosol.coherence.config.Config;
            // import com.tangosol.net.partition.PartitionStatistics;
            // import java.util.HashMap;
            // import java.util.Map;
            
            // Note: this method is called only after we have finalized the startup
            //       sequence and can correctly identify the distribution coordinator.
            //       see #validateMemberConfig/#finalizeStartup
            
            super.initialize();
            
            PartitionedService service     = (PartitionedService) get_Module();
            int     cBackups    = service.getBackupCount();
            Map[]   aMapPending = new Map[cBackups + 1];
            
            for (int iStore = 0; iStore <= cBackups; iStore++)
                {
                aMapPending[iStore] = new HashMap();
                }
            setPendingChanges(aMapPending);
            
            // initialize the PartitionStatistics array
            setPartitionStatistics(new PartitionStatistics[service.getPartitionCount()]);
            
            setStatsSamplingInterval(Config.getLong("coherence.distributed.sampling.interval", 5000).longValue());
            }
        
        // Accessor for the property "Coordinator"
        /**
         * Getter for property Coordinator.<p>
        * True iff this member is the distribution coordinator.
         */
        public boolean isCoordinator()
            {
            PartitionedService service = getService();
            
            // the (non-leaving) ownership senior is the distribution coordinator
            return service.getOwnershipSenior(false) == service.getThisMember();
            }
        
        // Declared at the super level
        /**
         * Called on the service thread when the distribution from the specified
        * member has completed (either by finished the receive successfully, or
        * departure of the source member).
        * 
        * @param member    the source member we are receiving distribution from
        * @param fSuccess   true iff the distribution was successfully received
        * Called when a DistributionRequest has completed (or failed).
         */
        public void onDistributionCompleted(com.tangosol.coherence.component.net.Member member, boolean fSuccess)
            {
            // import com.tangosol.util.Base;
            
            setDistributionInProgress(false);
            
            PartitionedService service      = getService();
            int     nRetryMillis = (service.getDistributionRepeatMillis() /
                                    service.getDistributionAggressiveness());
            
            if (!fSuccess)
                {
                // The DistributionRequest that we issued was rejected because
                // the overloaded member that we asked for distribution has either
                // left or is in the process of another distribution or transfer.
                // Drop any queued transfer requests associated with the failed
                // distribution request.
                service.getTransferControl().onReceiveRollback(member);
                }
            
            _assert(!service.isTransferInProgress());
            service.setDistributionNextMillis(Base.getSafeTimeMillis() + nRetryMillis);
            
            // wait for a second to allow further partition transfers (if any) to finish
            // before sending PartitionStats to senior
            setStatsSampleNextMillis(Base.getSafeTimeMillis() + 1000L);
            }
        
        // Declared at the super level
        /**
         * Called to process the a DistributionPlanUpdate.
         */
        public void onDistributionPlanUpdate(PartitionedService.DistributionPlanUpdate msgUpdate)
            {
            // import Component.Net.Member;
            
            PartitionedService service = getService();
            
            Member memberPrev = getLastCoordinator();
            Member memberCurr = msgUpdate.getFromMember();
            
            if (memberCurr != memberPrev)
                {
                if (memberPrev != null)
                    {
                    _trace("Ignoring unprocessed distribution plan from " + memberPrev.getId() +
                       " due to advice from the new coordinator " + memberCurr.getId(), 6);
                    clearPendingChanges();
                    }
                setLastCoordinator(memberCurr);
                }
            
            setTargetStrength(msgUpdate.getTargetStrength());
            
            processUpdate(msgUpdate.getUpdateMap());
            }
        
        // Declared at the super level
        /**
         * Called on the service thread to process the specified distribution
        * request.
        * 
        * @param msgRequest    the distribution request
        * Called to process a DistributionRequest.
         */
        public void onDistributionRequest(com.tangosol.coherence.component.net.message.RequestMessage msgRequest)
            {
            // import Component.Net.Member;
            // import com.tangosol.net.partition.PartitionSet;
            
            PartitionedService.DistributionRequest msg     = (PartitionedService.DistributionRequest) msgRequest;
            PartitionedService              service = (PartitionedService) getService();
            
            if (!service.checkDeferredDistribution())
                {
                PartitionSet parts      = msg.getPartitions();
                int          cRequest   = msg.getPartitionCount();
                Member       memberFrom = msg.getFromMember();
            
                // only honor distribution requests for owned partitions
                parts.retain(service.collectOwnedPartitions(true));
            
                cRequest = Math.min(cRequest, parts.cardinality());
                if (cRequest > 0)
                    {
                    if (service.transferPrimary(memberFrom, msg, parts, cRequest))
                        {
                        // the DistributionRequest will be responded to by the last
                        // PartitionedService.TransferRequest.  See #transferPartition.
                        return;
                        }
                    else
                        {
                        // we could not lock anything to transfer
                        reportLateDistributions();
                        }
                    }
                }
            
            // this member has an active distribution request, is currently transfering
            // data or was not able to lock any of the partitions for transfer;
            // send a trivial response
            PartitionedService.Response msgResponse = (PartitionedService.Response) service.instantiateMessage("Response");
            msgResponse.respondTo(msg);
            
            service.post(msgResponse);
            }
        
        // Declared at the super level
        /**
         * Called to process the a PartitionStatsUpdate.
         */
        public void onPartitionStatsUpdate(PartitionedService.PartitionStatsUpdate msgUpdate)
            {
            // import com.tangosol.net.partition.PartitionStatistics;
            // import com.tangosol.util.Base;
            // import java.util.Iterator;
            
            PartitionStatistics[] aStats = getPartitionStatistics();
            for (Iterator iter = msgUpdate.getStatsList().iterator(); iter.hasNext(); )
                {
                PartitionStatistics stats = (PartitionStatistics) iter.next();
                aStats[stats.getPartition()] = stats;
                }
            
            long ldtNext = Base.getSafeTimeMillis() + 1000L;
            
            getService().setDistributionNextMillis(ldtNext);
            setAnalysisNextMillis(ldtNext);
            }
        
        /**
         * Process the pending changes for this members by enacting either
        * DistributionRequest (primary) or TransferRequest (backup).
        * 
        * @return true iff there are no scheduled transfers left
         */
        protected boolean processPendingChanges()
            {
            // import Component.Net.Member;
            // import Component.Net.MemberSet.ActualMemberSet.ServiceMemberSet;
            // import com.tangosol.net.partition.PartitionSet;
            // import com.tangosol.util.Base;
            // import java.util.Iterator;
            // import java.util.Map;
            // import java.util.Map$Entry as java.util.Map.Entry;
            
            PartitionedService          service     = getService();
            int[][]          aaiOwners   = getPartitionAssignments();
            int              nMemberThis = getThisMember().getId();
            ServiceMemberSet setMembers  = service.getServiceMemberSet();
            
            for (int iStore = 0, cBackups = getBackupCount(); iStore <= cBackups; iStore++)
                {
                boolean fPrimary   = iStore == 0;
                Map     mapPending = getPendingChanges(iStore); // <nMember, PartitionSet>
            
                PartitionSet partsEndanger = (PartitionSet) mapPending.remove(Integer.valueOf(0));
                if (partsEndanger != null)
                    {
                    _assert(iStore > 0); // must be a backup
            
                    // forced partitions to become endangered
                    endangerPartitions(partsEndanger, iStore);
                    }
            
                int cPending = mapPending.size();
                if (cPending == 0)
                    {
                    // nothing left to do for this storage index
                    continue;
                    }
            
                // Randomize the order of the pending set to reduce the tendency for
                // many members to bottleneck on distribution to/from the same members
                Integer[] aNMember = (Integer[])
                        mapPending.keySet().toArray(new Integer[cPending]);
                Base.randomize(aNMember);
            
                for (int i = 0; i < cPending; i++)
                    {
                    Integer      NMember   = aNMember[i];
                    int          nMember   = NMember.intValue();
                    PartitionSet partsPlan = (PartitionSet) mapPending.get(NMember);
                    Member       member    = setMembers.getMember(nMember);
            
                    // verify that the member is still in the service
                    if (member == null ||                                    // member is completely departed
                        (!fPrimary && setMembers.isServiceLeaving(nMember))) // don't push to departing members
                        {
                        mapPending.remove(NMember);
            
                        _trace("Ignoring obsolete distribution plan for " + partsPlan
                             + "; member " + nMember + (member == null ? " has left " : " is leaving ")
                             + "the service", 6);
                        continue;
                        }
            
                    // verify that the pending change is still valid; things may
                    // have moved around or changed since the plan update was recieved
            
                    PartitionSet partsDefer = null;
                    for (int iPart = partsPlan.next(0); iPart >= 0; iPart = partsPlan.next(iPart + 1))
                        {
                        int[] aiOwners     = aaiOwners[iPart];
                        int   nOwnerActual = aiOwners[0];
            
                        // check if the scheduled operation is still valid
                        if (fPrimary)
                        	{
                            // the plan is to take the primary ownership from nMember
                        	if (nOwnerActual != nMember)
                                {
                                // it is not an owner anymore; discard the intent
                                partsPlan.remove(iPart);
                                }
                            }
                        else
                            {
                            // the plan is to push the backup ownership to nMember 
                            int iStoreCur = service.getOwnedIndex(iPart, nMember);
                            if (nOwnerActual != nMemberThis ||  // not the primary owner anymore
                                iStore == iStoreCur ||          // change already occurred
                                (iStoreCur != -1 &&             // "swap" instead of transfer
                                 service.swapBackupIndex(iPart, iStore, iStoreCur)))
                                {
                                partsPlan.remove(iPart);
                                }
                            else if (cBackups > 1 && deferBackupTransfer(iPart, iStore, nMember))
                                {
                                _trace("Re-prioritizing transfer for backup[" + iStore
                                    + "] of " + service.reportPartitionOwnership(iPart) +" to member " + nMember, 3);
            
                                if (partsDefer == null)
                                    {
                                    partsDefer = new PartitionSet(partsPlan.getPartitionCount());
                                    }
                                partsDefer.add(iPart);
                                }
                            }
                        }
            
                    if (partsPlan.isEmpty())
                        {
                        mapPending.remove(NMember);
                        continue;
                        }
            
                    // Note: leave the pending change in the map so that in face of
                    //       (full or partial) rejection, it will be retried on the
                    //       next distribution cycle.
                    if (fPrimary)
                        {
                        PartitionedService.DistributionRequest msg = (PartitionedService.DistributionRequest)
                            service.instantiateMessage("DistributionRequest");
            
                        msg.addToMember(member);
                        msg.setSourceMember(member);
                        msg.setPartitionCount(partsPlan.cardinality());
                        msg.setPartitions(partsPlan);
            
                        _trace("Asking member " + member.getId()
                             + " for primary ownership of " + partsPlan, 3);
                   
                        setDistributionInProgress(true);
                        service.post(msg);
                        }
                    else
                        {
                        // Note: transferBackup mutates the partition set
                        partsPlan = new PartitionSet(partsPlan);
                        if (partsDefer != null)
                            {
                            partsPlan.remove(partsDefer);
                            if (partsPlan.isEmpty())
                                {
                                // all backups for this member were deferred
                                continue;
                                }
                            }
                        service.transferBackup(member, partsPlan, iStore, partsPlan.cardinality());
                        }
            
                    return false;
                    }
                }
            
            return true;
            }
        
        /**
         * Process the specified plan update into a worklist of intended
        * distribution changes.  The Map<Ownership, PartitionSet> contains the
        * suggested ownership for each set of partitions in the plan update
        * (distribution delta).
         */
        protected void processUpdate(java.util.Map mapUpdate)
            {
            // import com.tangosol.net.partition.Ownership;
            // import com.tangosol.net.partition.PartitionSet;
            // import java.util.Iterator;
            // import java.util.Map;
            // import java.util.Map$Entry as java.util.Map.Entry;
            
            int     nMemberThis = getThisMember().getId();
            int     cPartitions = getPartitionCount();
            int     cBackups    = getBackupCount();
            int[][] aaiOwners   = getPartitionAssignments();
            
            // first go through the new update-map and discard any contrary
            // recommendations that are still pending; do this in 2 passes
            // by first collecting all partitions in the new update, and then
            // removing those partitions from the pending changeset
            PartitionSet partsUpdated = new PartitionSet(cPartitions);
            for (Iterator iter = mapUpdate.values().iterator(); iter.hasNext(); )
                {
                PartitionSet parts = (PartitionSet) iter.next();
                partsUpdated.add(parts);
                }
            
            clearAdvice(partsUpdated);
            
            // incorporate the suggestions from the plan update into the pending
            // change lists per-storage-index/per-member
            for (Iterator iter = mapUpdate.entrySet().iterator(); iter.hasNext(); )
                {
                java.util.Map.Entry        entry  = (java.util.Map.Entry) iter.next();
                Ownership    owners = (Ownership) entry.getKey(); // suggested
                PartitionSet parts  = (PartitionSet) entry.getValue();
            
                if (owners.getPrimaryOwner() == nMemberThis)
                    {
                    PartitionSet partsIgnored = null;
            
                    for (int iPart = parts.next(0); iPart >= 0; iPart = parts.next(iPart + 1))
                        {
                        int[]   aiOwners     = aaiOwners[iPart];
                        boolean fPrimaryXfer = false;
                        for (int iStore = 0; iStore <= cBackups; iStore++)
                            {
                            int nOwnerPlan   = owners.getOwner(iStore);
                            int nOwnerActual = aiOwners[iStore];
            
                            if (iStore == 0 && nOwnerActual == 0)
                                {
                                // we received distribution advice for a partition that
                                // is orphaned; it must be out of date since we do not
                                // resolve orphaned partitions via distribution.
                                if (partsIgnored == null)
                                    {
                                    partsIgnored = new PartitionSet(cPartitions);
                                    }
            
                                partsIgnored.add(iPart);
                                break;
                                }
            
                            // If the planned owner differs from the actual owner,
                            // put it in the pending changes list.
                            //
                            // Put all suggested ownership for partitions that are
                            // undergoing primary transfer into the pending list to
                            // compensate for overly smart "local" logic in
                            // assignPrimaryPartition() which may override the intended
                            // backup distribution.
                            if (nOwnerPlan != nOwnerActual || fPrimaryXfer)
                                {
                                // either primary ownership is pulled from the current owner
                                // or the backup transfer is pushed to a new owner 
                                int     nMemberTarget = iStore == 0 ? nOwnerActual : nOwnerPlan;
                                Integer IMemberTarget = Integer.valueOf(nMemberTarget);
                                Map     mapPending    = getPendingChanges(iStore);
            
                                PartitionSet partsPending = (PartitionSet) mapPending.get(IMemberTarget);
                                if (partsPending == null)
                                    {
                                    partsPending = new PartitionSet(cPartitions);
                                    mapPending.put(IMemberTarget, partsPending);
                                    }
                                partsPending.add(iPart);
            
                                fPrimaryXfer = fPrimaryXfer || iStore == 0;
                                }
                            }
                        }
            
                    if (partsIgnored != null)
                        {
                        _trace("Ignoring obsolete distribution plan update "
                             + owners + " for endangered " + partsIgnored, 6);
                        }
                    }
                }
            
            getService().setDistributionNextMillis(0L);
            }
        
        // Declared at the super level
        /**
         * Perform the partition distribution analysis among the partitioned
        * service members for the purposes of recovering or assigning orphaned
        * partitions.
        * 
        * @param partsOrphan     the set of orphaned partitions
        * @param setOwners         the set of ownership-enabled service members
        * (including any that might be leaving)
        * @param setLeaving         the set of ownership-enabled service
        * members that are in the process of leaving
        * @param resolverGUID    the GUID resolver
        * @param sSnapshot          the name of the persistent snapshot to
        * recover from, or null to recover from the active persistence manager
         */
        public void recoverOrphans(com.tangosol.net.partition.PartitionSet partsOrphan, com.tangosol.coherence.component.net.MemberSet setOwners, java.util.Set setLeaving, com.tangosol.persistence.GUIDHelper.GUIDResolver resolverGUID, String sSnapshot)
            {
            // import Component.Net.Member;
            // import com.tangosol.net.partition.Ownership;
            // import com.tangosol.net.partition.PartitionSet;
            // import com.tangosol.util.Base;
            // import java.util.HashMap;
            // import java.util.Iterator;
            // import java.util.Map;
            // import java.util.Map$Entry as java.util.Map.Entry;
            // import java.util.concurrent.atomic.AtomicInteger;
            
            // we must be the distribution coordinator
            _assert(isCoordinator());

            PartitionedService service    = getService();
            Map     mapSuggest = null;
            
            PartitionedService.CentralDistribution.DistributionManager manager = getDistributionManager();
            try
                {
                // Note: while the manager could contain deferred distribution suggestions
                //       (see #getSafeSuggestions), we call reset() here and drop them as
                //       they are almost certainly invalid if we have partitions that require
                //       recovery
                manager.reset();
                manager.setOwnershipMembers(setOwners);
                manager.setOwnershipLeavingMembers(setLeaving);
            
                getPartitionAssignmentStrategy().analyzeOrphans(resolverGUID.resolve());
            
                mapSuggest = manager.getSuggestionMap();
                }
            catch (Throwable t)
                {
                // the assignment strategy blew while trying to determine the orphan assignments;
                // nothing we can do here except log the exception and assign the ownership
                _trace("Unexpected exception occurred while calculating the "
                     + "partition assignment: " + Base.printStackTrace(t), 1);
                }
            finally
                {
                manager.reset();
                }
            
            PartitionSet partsAssign = resolverGUID.getUnresolvedPartitions();
            partsAssign.retain(partsOrphan);

            Map          mapInvalidGUIDs = resolverGUID.getInvalidGUIDs();
            PartitionSet partsRecover    = service.instantiatePartitionSet(false);
            Map          mapMemberMsg    = new HashMap(); // <Member, $PartitionRecoverRequest>
            
            if (mapSuggest != null && !mapSuggest.isEmpty())
                {
                // first, walk the suggestion map and collect the partitions to be
                // to each member
                for (Iterator iter = mapSuggest.entrySet().iterator(); iter.hasNext(); )
                    {
                    java.util.Map.Entry        entry       = (java.util.Map.Entry) iter.next();
                    int          nOwner      = ((Ownership) entry.getKey()).getPrimaryOwner();
                    Member       memberOwner = setOwners.getMember(nOwner);
                    PartitionSet parts       = (PartitionSet) entry.getValue();
            
                    if (memberOwner == null)
                        {
                        // unknown member; skip the suggestion
                        continue;
                        }

                    // get a list of invalid empty persistentIds that need to be cleaned up
                    List     listGUIDs      = (List) mapInvalidGUIDs.get(memberOwner);
                    String[] asInvalidGUIDs = listGUIDs == null ? null :
                                              (String[]) listGUIDs.toArray(new String[listGUIDs.size()]);

                    parts.retain(partsOrphan);
            
                    for (int iPart = parts.next(0); iPart >= 0; iPart = parts.next(iPart + 1))
                        {
                        if (partsOrphan.contains(iPart))
                            {
                            PartitionedService.PartitionRecoverRequest msgRequest =
                                (PartitionedService.PartitionRecoverRequest) mapMemberMsg.get(memberOwner);
                            if (msgRequest == null)
                                {
                                msgRequest = (PartitionedService.PartitionRecoverRequest)
                                    service.instantiateMessage("PartitionRecoverRequest");
                                msgRequest.addToMember(memberOwner);
                                msgRequest.setPartsAssign(service.instantiatePartitionSet(false));
                                msgRequest.setPartsRecover(service.instantiatePartitionSet(false));
                                msgRequest.setInvalidPersistentIds(asInvalidGUIDs);
                                msgRequest.setEventsPartsFailed(service.instantiatePartitionSet(false));
            
                                mapMemberMsg.put(memberOwner, msgRequest);
                                }
            
                            if (partsAssign.contains(iPart))
                                {
                                msgRequest.getPartsAssign().add(iPart);
                                }
                            else
                                {
                                msgRequest.getPartsRecover().add(iPart);
                                partsRecover.add(iPart);
                                }
            
                            partsOrphan.remove(iPart);
                            }
                        }
                    }
                }
            
            boolean fActivePersistence = service.isActivePersistence();
            if (fActivePersistence && !partsAssign.isEmpty())
                {
                // warn about the failure to recover
                _trace("Failed to find a partition assignment for orphaned " + partsAssign, 2);
                }
            
            PartitionedService.PersistenceControl ctrlPersistence = service.getPersistenceControl();
            PartitionedService.PersistenceControl.SnapshotController ctrlSnapshot    = sSnapshot != null || fActivePersistence
                 ? ctrlPersistence.getSnapshotController() : null;
            
            if (ctrlSnapshot != null && !partsRecover.isEmpty())
                {
                ctrlSnapshot.onRecoveryStarted(sSnapshot, partsRecover);
                }
            
            if (!partsOrphan.isEmpty())
                {
                // should not happen; it means that PAS didn't suggest anything for those partitions
                // assign them to the coordinator (this member)
            
                Member memberThis = service.getThisMember();
            
                PartitionedService.PartitionRecoverRequest msgRequest =
                                (PartitionedService.PartitionRecoverRequest) mapMemberMsg.get(memberThis);
                if (msgRequest == null)
                    {
                    msgRequest = (PartitionedService.PartitionRecoverRequest)
                        service.instantiateMessage("PartitionRecoverRequest");
                    msgRequest.addToMember(memberThis);
                    msgRequest.setPartsAssign(service.instantiatePartitionSet(false));
                    msgRequest.setPartsRecover(service.instantiatePartitionSet(false));
            
                    if (service.isPersistEvents())
                        {
                        msgRequest.setEventsPartsFailed(service.instantiatePartitionSet(false));
                        }
            
                    mapMemberMsg.put(memberThis, msgRequest);
                    }
                msgRequest.getPartsAssign().add(partsOrphan);
                }
            
            int cRequests = mapMemberMsg.size();
            if (cRequests == 0)
                {
                // nothing to recover; signal the snapshot coordinator that the recovery
                // is complete
                if (ctrlSnapshot != null)
                    {
                    ctrlSnapshot.onRecoveryCompleted(sSnapshot, partsOrphan, null);
                    }
                }
            else
                {
                // defer the next distribution cycle until all of the recover requests complete
                // see $PartitionRecoverRequest$Poll#onCompletion
                service.setDistributionNextMillis(Long.MAX_VALUE);
            
                ctrlPersistence.getActiveRecoveryRequests().set(cRequests);
            
                PartitionSet partsRecovered = service.instantiatePartitionSet(false);
                for (Iterator iter = mapMemberMsg.values().iterator(); iter.hasNext(); )
                    {
                    PartitionedService.PartitionRecoverRequest msgRequest = (PartitionedService.PartitionRecoverRequest) iter.next();
            
                    msgRequest.setSnapshotToRecover(sSnapshot);
                    msgRequest.setGUIDs(resolverGUID.getNewestGUIDs(msgRequest.getPartsRecover()));
                    msgRequest.setPartsRecovered(partsRecovered);
            
                    service.post(msgRequest);
                    }
            
                // continuation of the Ownership protocol
                service.setOwnershipInProgress(1);
                }
            }
        
        // Declared at the super level
        /**
         * Report current state of the distribution on this service member in
        * human-readable form. Pending distributions are grouped by machine and
        * further by target or origin member Id. If fVerbose parameter is true,
        * specific partition Ids are also reported.
        * 
        * @return  a user-readable report
         */
        public String reportLocalDistributionState(boolean fVerbose)
            {
            // import Component.Net.Member;
            // import Component.Net.MemberSet;
            // import com.tangosol.net.partition.PartitionSet;
            // import java.util.Arrays;
            // import java.util.ConcurrentModificationException;
            // import java.util.HashMap;
            // import java.util.Map;
            
            StringBuilder sb = new StringBuilder();
            
            PartitionedService   service    = getService();
            MemberSet setMembers = service.getServiceMemberSet();
            int       cBackups   = getBackupCount();
            int       cChanges   = 0;
            
            for (int iStore = 0; iStore <= cBackups; iStore++)
                {
                Map mapPending = getPendingChanges(iStore);
                if (mapPending.isEmpty())
                    {
                    continue;
                    }
            
                // make a copy of mapPending, but remember we could get CME
                while (true)
                    {
                    try
                        {
                        mapPending = new HashMap(mapPending);
                        break;
                        }
                    catch (ConcurrentModificationException e)
                        {
                        }
                    }
            
                int       cPending = mapPending.size();
                Integer[] aNMember = (Integer[]) mapPending.keySet().toArray(new Integer[cPending]);
                Arrays.sort(aNMember);
                for (int i = 0; i < cPending; i++)
                    {
                    Integer      NMember = aNMember[i];
                    int          nMember = NMember.intValue();
                    PartitionSet parts   = (PartitionSet) mapPending.get(NMember);
            
                    cChanges += parts.cardinality();
            
                    if (fVerbose)
                        {
                        Member member = setMembers.getMember(nMember);
            
                        sb.append("  Transfer of ")
                          .append(iStore == 0 ? "Primary " : "Backup ")
                          .append(parts)
                          .append(iStore == 0 ? " from" : " to").append(" Member ")
                          .append(nMember).append('\n');
                        }
                    }
                }
            
            String sPending = displayPendingState(fVerbose);
            if (cChanges == 0)
                {
                return sPending.isEmpty() 
                    ? "There are currently no pending or scheduled distributions for this service."
                    : sPending  + "\nThere are no additional scheduled distributions for this service.";
                }
            
            return (sPending.isEmpty() ? sPending : sPending + "\n")
                + cChanges + " scheduled distributions remain to be processed"
                + (fVerbose ? (":\n" + sb.toString()) : ".");
            }
        
        // Declared at the super level
        /**
         * Schedule an immediate distribution check.
         */
        public void scheduleImmediate()
            {
            PartitionedService service = getService();
            
            setAnalysisNextMillis(0L);
            
            // this will call setDistributionNextMillis(0L)
            super.scheduleImmediate();
            }
        
        // Accessor for the property "AnalysisNextMillis"
        /**
         * Setter for property AnalysisNextMillis.<p>
        * The AnalysisNextMillis value is the time (in local clock) at which
        * the next strategy analysis will be performed.
        * 
        * @volatile
         */
        public void setAnalysisNextMillis(long ldtNext)
            {
            __m_AnalysisNextMillis = ldtNext;
            }
        
        // Accessor for the property "DistributionManager"
        /**
         * Setter for property DistributionManager.<p>
        * The DistributionManager used to communicate with pluggable strategies.
         */
        protected void setDistributionManager(PartitionedService.CentralDistribution.DistributionManager manager)
            {
            __m_DistributionManager = manager;
            }
        
        // Accessor for the property "LastCoordinator"
        /**
         * Setter for property LastCoordinator.<p>
        * The last distribution coordinator that offered advice still being
        * processed.
         */
        protected void setLastCoordinator(com.tangosol.coherence.component.net.Member member)
            {
            __m_LastCoordinator = member;
            }
        
        // Accessor for the property "LastStorageSize"
        /**
         * Setter for property LastStorageSize.<p>
        * Last measurment of the StorageSize. Used only to adjust the sampling
        * interval.
         */
        public void setLastStorageSize(long lSize)
            {
            __m_LastStorageSize = lSize;
            }
        
        // Accessor for the property "PartitionAssignmentStrategy"
        /**
         * Setter for property PartitionAssignmentStrategy.<p>
        * PartitionAssigningStrategy implementation.
         */
        public void setPartitionAssignmentStrategy(com.tangosol.net.partition.PartitionAssignmentStrategy strategy)
            {
            if (getService().isAcceptingClients())
                {
                throw new IllegalStateException("Service is already running");
                }
            
            __m_PartitionAssignmentStrategy = (strategy);
            }
        
        // Accessor for the property "PartitionStatistics"
        /**
         * Setter for property PartitionStatistics.<p>
        * Array of last collected statistics. Not empty only if this node is
        * the distribution coordinator.
         */
        public void setPartitionStatistics(com.tangosol.net.partition.PartitionStatistics[] aStats)
            {
            __m_PartitionStatistics = aStats;
            }
        
        // Accessor for the property "PartitionStatistics"
        /**
         * Setter for property PartitionStatistics.<p>
        * Array of last collected statistics. Not empty only if this node is
        * the distribution coordinator.
         */
        public void setPartitionStatistics(int i, com.tangosol.net.partition.PartitionStatistics stats)
            {
            getPartitionStatistics()[i] = stats;
            }
        
        // Accessor for the property "PendingChanges"
        /**
         * Setter for property PendingChanges.<p>
        * Indexed (by the storage index) array of Map<MemberId, PartitionSet>
        * containing the set of partitions to be transferred from (for primary
        * distribution) or to (for backup distribution) the associated member.
         */
        protected void setPendingChanges(java.util.Map[] aMapPending)
            {
            __m_PendingChanges = aMapPending;
            }
        
        // Accessor for the property "PendingChanges"
        /**
         * Setter for property PendingChanges.<p>
        * Indexed (by the storage index) array of Map<MemberId, PartitionSet>
        * containing the set of partitions to be transferred from (for primary
        * distribution) or to (for backup distribution) the associated member.
         */
        protected void setPendingChanges(int iStore, java.util.Map mapPending)
            {
            getPendingChanges()[iStore] = mapPending;
            }
        
        // Accessor for the property "TargetStrength"
        /**
         * Setter for property TargetStrength.<p>
        * The target strength of the current suggestion; it gets recalculated
        * every time the new analysis is performed.
         */
        public void setTargetStrength(int nStrength)
            {
            __m_TargetStrength = nStrength;
            }

        // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService$CentralDistribution$DistributionManager
        
        /**
         * Implementation of the com.tangosol.net.partition.DistributionManager
         * interface used by the centralized distribution.
         */
        @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
        public static class DistributionManager
                extends    com.tangosol.coherence.component.Util
                implements com.tangosol.net.partition.DistributionManager
            {
            // ---- Fields declarations ----
            
            /**
             * Property DeferredSuggestion
             *
             * Set to true when a safe suggestion is made and original
             * suggestion is deferred.
             */
            private boolean __m_DeferredSuggestion;
            
            /**
             * Property IgnoredAdvice
             *
             */
            private com.tangosol.net.partition.PartitionSet __m_IgnoredAdvice;
            
            /**
             * Property OwnershipLeavingMembers
             *
             */
            private java.util.Set __m_OwnershipLeavingMembers;
            
            /**
             * Property OwnershipMembers
             *
             */
            private java.util.Set __m_OwnershipMembers;
            
            /**
             * Property StrategyName
             *
             * The simple Class name of the configured
             * PartitionAssignmentStrategy.
             */
            private String __m_StrategyName;
            
            /**
             * Property SuggestionMap
             *
             * The Map<Ownership, PartitionSet> of distribution suggestions.
             */
            private java.util.Map __m_SuggestionMap;
            
            /**
             * Property TargetStrength
             *
             * The target strength of the current suggestion; it gets
             * recalculated every time the new analysis is performed.
             */
            private int __m_TargetStrength;
            
            // Default constructor
            public DistributionManager()
                {
                this(null, null, true);
                }
            
            // Initializing constructor
            public DistributionManager(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                {
                super(sName, compParent, false);
                
                if (fInit)
                    {
                    __init();
                    }
                }
            
            // Main initializer
            public void __init()
                {
                // private initialization
                __initPrivate();
                
                // state initialization: public and protected properties
                try
                    {
                    setTargetStrength(-1);
                    }
                catch (java.lang.Exception e)
                    {
                    // re-throw as a runtime exception
                    throw new com.tangosol.util.WrapperException(e);
                    }
                
                // signal the end of the initialization
                set_Constructed(true);
                }
            
            // Private initializer
            protected void __initPrivate()
                {
                
                super.__initPrivate();
                }
            
            //++ getter for static property _Instance
            /**
             * Getter for property _Instance.<p>
            * Auto generated
             */
            public static com.tangosol.coherence.Component get_Instance()
                {
                return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.CentralDistribution.DistributionManager();
                }
            
            //++ getter for static property _CLASS
            /**
             * Getter for property _CLASS.<p>
            * Property with auto-generated accessor that returns the Class
            * object for a given component.
             */
            public static Class get_CLASS()
                {
                Class clz;
                try
                    {
                    clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/PartitionedService$CentralDistribution$DistributionManager".replace('/', '.'));
                    }
                catch (ClassNotFoundException e)
                    {
                    throw new NoClassDefFoundError(e.getMessage());
                    }
                return clz;
                }
            
            //++ getter for autogen property _Module
            /**
             * This is an auto-generated method that returns the global [design
            * time] parent component.
            * 
            * Note: the class generator will ignore any custom implementation
            * for this behavior.
             */
            private com.tangosol.coherence.Component get_Module()
                {
                return this.get_Parent().get_Parent();
                }
            
            // Accessor for the property "BackupCount"
            /**
             * Getter for property BackupCount.<p>
             */
            public int getBackupCount()
                {
                return ((PartitionedService) getService()).getBackupCount();
                }
            
            // From interface: com.tangosol.net.partition.DistributionManager
            // Accessor for the property "IgnoredAdvice"
            /**
             * Getter for property IgnoredAdvice.<p>
             */
            public com.tangosol.net.partition.PartitionSet getIgnoredAdvice()
                {
                return __m_IgnoredAdvice;
                }
            
            // From interface: com.tangosol.net.partition.DistributionManager
            public com.tangosol.net.Member getMember(int nMemberId)
                {
                // import Component.Net.MemberSet;
                
                return ((MemberSet) getOwnershipMembers()).getMember(nMemberId);
                }
            
            // From interface: com.tangosol.net.partition.DistributionManager
            public com.tangosol.net.partition.PartitionSet getOwnedPartitions(com.tangosol.net.Member member, int iStore)
                {
                // import com.tangosol.net.partition.PartitionSet;
                
                int[][]      aiOwners    = getPartitionAssignments();
                int          cPartitions = getPartitionCount();
                int          nMemberId   = member.getId();
                PartitionSet parts       = new PartitionSet(cPartitions);
                
                for (int i = 0; i < cPartitions; i++)
                    {
                    if (aiOwners[i][iStore] == nMemberId)
                        {
                        parts.add(i);
                        }
                    }
                
                return parts;
                }
            
            // From interface: com.tangosol.net.partition.DistributionManager
            // Accessor for the property "OwnershipLeavingMembers"
            /**
             * Getter for property OwnershipLeavingMembers.<p>
             */
            public java.util.Set getOwnershipLeavingMembers()
                {
                return __m_OwnershipLeavingMembers;
                }
            
            // From interface: com.tangosol.net.partition.DistributionManager
            // Accessor for the property "OwnershipMembers"
            /**
             * Getter for property OwnershipMembers.<p>
             */
            public java.util.Set getOwnershipMembers()
                {
                return __m_OwnershipMembers;
                }
            
            // Accessor for the property "PartitionAssignments"
            /**
             * Getter for property PartitionAssignments.<p>
             */
            public int[][] getPartitionAssignments()
                {
                return ((PartitionedService) getService()).getPartitionAssignments();
                }
            
            // Accessor for the property "PartitionCount"
            /**
             * Getter for property PartitionCount.<p>
             */
            public int getPartitionCount()
                {
                return ((PartitionedService) getService()).getPartitionCount();
                }
            
            // From interface: com.tangosol.net.partition.DistributionManager
            public com.tangosol.net.partition.Ownership getPartitionOwnership(int nPartition)
                {
                return ((PartitionedService) get_Module()).getPartitionOwnership(nPartition);
                }
            
            // From interface: com.tangosol.net.partition.DistributionManager
            public com.tangosol.net.partition.PartitionStatistics[] getPartitionStats()
                {
                // stats are updated on the service-thread only, so we can reference
                // the data-structure directly and are guaranteed to present a
                // read-consistent view
                return ((PartitionedService.CentralDistribution) get_Parent()).getPartitionStatistics();
                }
            
            /**
             * Return the set of suggestions toward achieving the distribution
            * goal state as determined by the last analysis made by the
            * partition assignment strategy, ensuring that the intermediate
            * transfers will not reduce the backup-strength.
            * 
            * Distribution suggestions may be altered to ensure a specific
            * transfer order to avoid endangering the backup-strength while at
            * the same time avoiding extra unnecessary transfers.  For example,
            * suppose;
            * * members 1 and 2 are co-located
            * * members 3 and 4 are co-located
            * * members 5 and 6 are co-located
            * * a partition has ownership (1, 3) which was suggested to become
            * (4, 1) 
            * 
            * The "natural" transfer ordering (see #processPendingChanges)
            * would be (1, 3) -> (4, 3) -> (4, 1) which temporarily endangers
            * the backup-strength.  In this case, a "safe" suggestion is
            * provided to first achieve (3, 1) and deferring the goal (4, 1)
            * until that is achieved, ensuring a safe transition from (1, 3) ->
            * (3, 1) -> (4, 1).
             */
            public java.util.Map getSafeSuggestions()
                {
                // import Component.Net.MemberSet.ActualMemberSet.ServiceMemberSet;
                // import com.tangosol.net.partition.Ownership;
                // import com.tangosol.net.partition.PartitionSet;
                // import java.util.HashMap;
                // import java.util.Iterator;
                // import java.util.Map;
                // import java.util.Map$Entry as java.util.Map.Entry;
                
                Map mapSuggest = getSuggestionMap(); // <Ownership, PartitionSet>
                if (mapSuggest == null || mapSuggest.isEmpty())
                    {
                    return mapSuggest;
                    }
                
                PartitionedService      service         = (PartitionedService) get_Module();
                int          cBackups        = getBackupCount();
                int          nStrengthSvc    = service.getBackupStrength(/*fLocal*/ true);
                int          nStrengthTarget = PartitionedService.BACKUP_STRENGTH_SITE;
                PartitionSet partsUnchanged  = service.instantiatePartitionSet(/*fFill*/ true);
                int[]        aiOwners        = new int[cBackups + 1];
                
                PartitionedService.CentralDistribution dist = (PartitionedService.CentralDistribution) get_Parent();
                
                // if mapSuggest is for the deferred update, the target backup strength should not be recalculated
                if (isDeferredSuggestion())
                    {
                    nStrengthTarget = dist.getTargetStrength();
                    }
                else
                    {
                    // First, go through the suggestion map and calculate the backup-strength of
                    // the goal.  The backup-strength will be the minimum strength of the suggested
                    // suggestions and the current strength of the unchanged partitions
                    for (Iterator iter = mapSuggest.entrySet().iterator(); iter.hasNext(); )
                        {
                        java.util.Map.Entry        entry     = (java.util.Map.Entry) iter.next();
                        Ownership    ownersNew = (Ownership) entry.getKey(); // suggested
                        PartitionSet parts     = (PartitionSet) entry.getValue();
                
                        // strength of the goal state of the suggestions
                        nStrengthTarget = Math.min(nStrengthTarget,
                                                   service.getBackupStrength(ownersNew.getOwners(aiOwners)));
                        partsUnchanged.remove(parts);
                        }
                    for (int iPart = partsUnchanged.next(0); iPart >= 0; iPart = partsUnchanged.next(iPart + 1))
                        {
                        // strength of the current state of the unchanged partitions
                        nStrengthTarget = Math.min(nStrengthTarget, service.getBackupStrength(iPart, /*fLocal*/ true));
                        }
                
                    dist.setTargetStrength(nStrengthTarget);
                    }
                
                // check each of the suggestions to ensure that the path to achieving each of the
                // suggested distributions will not weaken the backup-strength
                
                ServiceMemberSet setMembers  = service.getServiceMemberSet();
                Map              mapDeferred = null;  // Map<Ownership, PartitionSet> of suggestions to defer
                Map              mapSafe     = null;  // Map<Ownership, PartitionSet> of safe "intermediate" suggestions
                
                for (Iterator iter = mapSuggest.entrySet().iterator(); iter.hasNext(); )
                    {
                    java.util.Map.Entry        entry        = (java.util.Map.Entry) iter.next();
                    Ownership    ownersNew    = (Ownership) entry.getKey(); // suggested
                    PartitionSet partsSuggest = (PartitionSet) entry.getValue();
                
                    for (int iPart = partsSuggest.next(0); iPart >= 0; iPart = partsSuggest.next(iPart + 1))
                        {
                        Ownership ownersOld     = getPartitionOwnership(iPart);  // the current ownership
                        Ownership ownersInterim = (Ownership) ownersOld.clone(); // the transitional ownership
                
                        if (setMembers.isServiceLeaving(ownersOld.getPrimaryOwner()) ||
                            service.getBackupStrength(ownersOld.getOwners(aiOwners)) < nStrengthTarget)
                            {
                            // do not reorder the suggestions if the primary is leaving
                            // or the current strength is weaker than the target
                            continue;
                            }
                
                        for (int iStore = 0; iStore <= cBackups; iStore++)
                            {
                            // simulate the order in which transfers would normally be performed;
                            // see #processPendingChanges
                            int nOwnerNew = ownersNew.getOwner(iStore);
                            int nOwnerOld = ownersInterim.getOwner(iStore);
                            if (nOwnerOld != nOwnerNew)
                                {
                                simulateTransfer(ownersInterim, iStore, nOwnerNew, true);
                
                                if (service.getBackupStrength(ownersInterim.getOwners(aiOwners)) < nStrengthTarget)
                                    {
                                    // the "natural" transfer order will lose backup-strength;
                                    // check to see if an "out-of-order" transfer path will allow
                                    // us to preserve strength
                                    Ownership ownersSafe = null;
                                    for (int i = cBackups + 1; i >= 0; i--)
                                        {
                                        Ownership ownersStep = (Ownership) ownersOld.clone();
                                        if (ownersOld.getOwner(i) != ownersNew.getOwner(i))
                                            {
                                            simulateTransfer(ownersStep, i, ownersNew.getOwner(i), false);
                                            if (service.getBackupStrength(ownersStep.getOwners(aiOwners)) >= nStrengthTarget)
                                                {
                                                ownersSafe = ownersStep;
                                                break;
                                                }
                                            }
                                        }
                
                                    if (ownersSafe == null)
                                        {
                                        // we could not find a convenient safe interim step by simply
                                        // reordering the transfers; this could only happen if there are
                                        // multiple transfers that were requested for the same partition.
                                        // In this case, we can proceed safely by "swapping" two storage
                                        // indices as a first step.  For example, suppose a partition
                                        // ownership of (1, 4, 5) to (3, 2, 5) where members 1 and 2 are
                                        // co-located and members 3 and 4 are co-located.  In this case,
                                        // neither transfer order (3, 4, 5) or (1, 2, 5) would be safe.  We
                                        // can proceed by inducing a transfer (4, 1, 5) first, which will
                                        // then allow a safe path.
                                        //
                                        // Check in "reverse" order in case we can proceed by inducing the
                                        // swap of 2 backup indices (as it is a "free" operation).
                                        int iStore1 = -1;
                                        int iStore2 = -1;
                                        for (int i = cBackups + 1; i >= 0; i--)
                                            {
                                            if (ownersOld.getOwner(i) != ownersNew.getOwner(i))
                                                {
                                                if (iStore1 == -1)
                                                    {
                                                    iStore1 = i;
                                                    }
                                                else if (iStore2 == -1)
                                                    {
                                                    iStore2 = i;
                                                    }
                                                }
                                            }
                
                                        if (iStore1 == -1 && iStore2 == -1)
                                            {
                                            // this shouldn't be possible; give up
                                            break;
                                            }
                
                                        ownersSafe = (Ownership) ownersOld.clone();
                                        ownersSafe.setOwner(iStore1, ownersOld.getOwner(iStore2));
                                        ownersSafe.setOwner(iStore2, ownersOld.getOwner(iStore1));
                                        }
                
                                    if (setMembers.isServiceLeaving(ownersSafe.getPrimaryOwner()))
                                        {
                                        // don't re-order a transfer to a new primary that is leaving
                                        }
                                    else
                                        {
                                        if (mapDeferred == null)
                                            {
                                            mapDeferred = new HashMap();
                                            mapSafe     = new HashMap();
                                            }
                
                                        PartitionSet partsDeferred = (PartitionSet) mapDeferred.get(ownersNew);
                                        if (partsDeferred == null)
                                            {
                                            partsDeferred = service.instantiatePartitionSet(/*fFill*/ false);
                                            mapDeferred.put(ownersNew, partsDeferred);
                                            }
                                        PartitionSet partsSafe = (PartitionSet) mapSafe.get(ownersSafe);
                                        if (partsSafe == null)
                                            {
                                            partsSafe = service.instantiatePartitionSet(/*fFill*/ false);
                                            mapSafe.put(ownersSafe, partsSafe);
                                            }
                
                                        partsSafe.add(iPart);
                                        partsDeferred.add(iPart);
                
                                        partsSuggest.remove(iPart);  // remove it from the suggestion map
                
                                        if (_isTraceEnabled(6))
                                            {
                                            _trace("Re-ordering the suggested transfer of partition " + iPart
                                                 + " from " + ownersOld + " to " + ownersNew
                                                 + " to maintain the backup-strength by prioritizing the transfer to "
                                                 + ownersSafe, 3);
                                            }
                                        }
                
                                    break;
                                    }
                                }
                            }
                        }
                
                    if (partsSuggest.isEmpty())
                        {
                        // it is possible that all partitions have been deferred
                        iter.remove();
                        }
                    }
                
                if (mapDeferred == null)
                    {
                    setSuggestionMap(null);
                    }
                else
                    {
                    // save the deferred suggestions for later, and fold the "safe" suggestions
                    // into the return map
                    setSuggestionMap(mapDeferred);
                    setDeferredSuggestion(true);
                
                    for (Iterator iter = mapSafe.entrySet().iterator(); iter.hasNext(); )
                        {
                        java.util.Map.Entry        entry        = (java.util.Map.Entry) iter.next();
                        Ownership    ownersSafe   = (Ownership) entry.getKey();
                        PartitionSet partsSafe    = (PartitionSet) entry.getValue();
                        PartitionSet partsSuggest = (PartitionSet) mapSuggest.get(ownersSafe);
                        if (partsSuggest == null)
                            {
                            mapSuggest.put(ownersSafe, partsSafe);
                            }
                        else
                            {
                            partsSuggest.add(partsSafe);
                            }
                        }
                    }
                
                return mapSuggest;
                }
            
            // From interface: com.tangosol.net.partition.DistributionManager
            public long getSamplingPeriod()
                {
                return ((PartitionedService.CentralDistribution) get_Parent()).getStatsSamplingInterval();
                }
            
            // From interface: com.tangosol.net.partition.DistributionManager
            public com.tangosol.net.PartitionedService getService()
                {
                return (PartitionedService) get_Module();
                }
            
            public long getStatsSamplingInterval()
                {
                return 0L;
                }
            
            // Accessor for the property "StrategyName"
            /**
             * Getter for property StrategyName.<p>
            * The simple Class name of the configured
            * PartitionAssignmentStrategy.
             */
            public String getStrategyName()
                {
                return __m_StrategyName;
                }
            
            // Accessor for the property "SuggestionMap"
            /**
             * Getter for property SuggestionMap.<p>
            * The Map<Ownership, PartitionSet> of distribution suggestions.
             */
            public java.util.Map getSuggestionMap()
                {
                return __m_SuggestionMap;
                }
            
            // Accessor for the property "TargetStrength"
            /**
             * Getter for property TargetStrength.<p>
            * The target strength of the current suggestion; it gets
            * recalculated every time the new analysis is performed.
             */
            public int getTargetStrength()
                {
                return __m_TargetStrength;
                }
            
            /**
             * Initialize the DistributionManager with the specified
            * PartitionAssignmentStrategy.
             */
            public void initialize(com.tangosol.net.partition.PartitionAssignmentStrategy strategy)
                {
                // import com.tangosol.util.ClassHelper;
                
                strategy.init(this);
                setStrategyName(ClassHelper.getSimpleName(strategy.getClass()));
                }
            
            // Accessor for the property "DeferredSuggestion"
            /**
             * Getter for property DeferredSuggestion.<p>
            * Set to true when a safe suggestion is made and original
            * suggestion is deferred.
             */
            public boolean isDeferredSuggestion()
                {
                return __m_DeferredSuggestion;
                }
            
            public void reset()
                {
                // import com.tangosol.net.partition.PartitionSet;
                // import java.util.Iterator;
                // import java.util.Map;
                
                setOwnershipLeavingMembers(null);
                setOwnershipMembers(null);
                
                Map mapSuggest = getSuggestionMap(); // <Ownership, PartitionSet>
                setSuggestionMap(null);
                setDeferredSuggestion(false);
                
                // collect the ignored partitions
                if (mapSuggest != null && !mapSuggest.isEmpty())
                    {
                    PartitionSet partsIgnored = getIgnoredAdvice();
                
                    for (Iterator iter = mapSuggest.values().iterator(); iter.hasNext();)
                        {
                        PartitionSet parts = (PartitionSet) iter.next();
                
                        if (partsIgnored == null)
                            {
                            partsIgnored = new PartitionSet(parts);
                            }
                        else
                            {
                            partsIgnored.add(parts);
                            }
                        }
                    setIgnoredAdvice(partsIgnored);
                    }
                }
            
            // From interface: com.tangosol.net.partition.DistributionManager
            public void scheduleNextAnalysis(long cMillis)
                {
                // import com.tangosol.util.Base;
                
                PartitionedService.CentralDistribution dist = (PartitionedService.CentralDistribution) get_Parent();
                if (dist.isCoordinator() && cMillis >= 0L)
                    {
                    long ldtNow = Base.getSafeTimeMillis();
                
                    dist.setAnalysisNextMillis(ldtNow + cMillis);
                
                    PartitionedService service = (PartitionedService) getService();
                
                    if (!service.isDistributionStable())
                        {
                        cMillis = Math.min(cMillis,
                            service.getDistributionRepeatMillis() / service.getDistributionAggressiveness());
                        }
                
                    service.setDistributionNextMillis(ldtNow + cMillis);
                    }
                }
            
            // Accessor for the property "DeferredSuggestion"
            /**
             * Setter for property DeferredSuggestion.<p>
            * Set to true when a safe suggestion is made and original
            * suggestion is deferred.
             */
            protected void setDeferredSuggestion(boolean fSuggestion)
                {
                __m_DeferredSuggestion = fSuggestion;
                }
            
            // Accessor for the property "IgnoredAdvice"
            /**
             * Setter for property IgnoredAdvice.<p>
             */
            protected void setIgnoredAdvice(com.tangosol.net.partition.PartitionSet parts)
                {
                __m_IgnoredAdvice = parts;
                }
            
            // Accessor for the property "OwnershipLeavingMembers"
            /**
             * Setter for property OwnershipLeavingMembers.<p>
             */
            public void setOwnershipLeavingMembers(java.util.Set setLeaving)
                {
                __m_OwnershipLeavingMembers = setLeaving;
                }
            
            // Accessor for the property "OwnershipMembers"
            /**
             * Setter for property OwnershipMembers.<p>
             */
            public void setOwnershipMembers(java.util.Set setOwners)
                {
                __m_OwnershipMembers = setOwners;
                }
            
            // Accessor for the property "StrategyName"
            /**
             * Setter for property StrategyName.<p>
            * The simple Class name of the configured
            * PartitionAssignmentStrategy.
             */
            public void setStrategyName(String sName)
                {
                __m_StrategyName = sName;
                }
            
            // Accessor for the property "SuggestionMap"
            /**
             * Setter for property SuggestionMap.<p>
            * The Map<Ownership, PartitionSet> of distribution suggestions.
             */
            protected void setSuggestionMap(java.util.Map partsUpdated)
                {
                __m_SuggestionMap = partsUpdated;
                }
            
            // Accessor for the property "TargetStrength"
            /**
             * Setter for property TargetStrength.<p>
            * The target strength of the current suggestion; it gets
            * recalculated every time the new analysis is performed.
             */
            protected void setTargetStrength(int nStrength)
                {
                __m_TargetStrength = nStrength;
                }
            
            /**
             * Update the specified ownership to simulate the transfer of the
            * specified storage index to the specified new owner.
            * If the new owner is already a current owner, the transfer will
            * result in a "swap" of the ownership of the specified storage
            * indices.  For example, if the partition's ownership is (1, 2, 3)
            * and backup[2] is being transfered to member 1, the resulting
            * ownership will be (3, 2, 1).
            * 
            * If fForward is specified, seach larger storage indices to
            * determine if the "transfer" is really a swap operation,
            * otherwise, search smaller storage indices.
             */
            protected void simulateTransfer(com.tangosol.net.partition.Ownership owners, int iStore, int nOwnerNew, boolean fForward)
                {
                int nOwnerPrev = owners.getOwner(iStore);
                int cBackups   = getBackupCount();
                
                owners.setOwner(iStore, nOwnerNew);
                
                // check if the new owner was already a current owner;
                // if so, the two owners will "switch" positions.  See
                // #assignPrimaryPartition/#processPendingChanges
                if (fForward)
                    {
                    for (int i = iStore + 1; i <= cBackups; i++)
                        {
                        if (owners.getOwner(i) == nOwnerNew)
                            {
                            owners.setOwner(i, nOwnerPrev);
                            }
                        }
                    }
                else
                    {
                    for (int i = iStore - 1; i >= 0; i--)
                        {
                        if (owners.getOwner(i) == nOwnerNew)
                            {
                            owners.setOwner(i, nOwnerPrev);
                            }
                        }
                    }
                }
            
            // From interface: com.tangosol.net.partition.DistributionManager
            public void suggest(com.tangosol.net.partition.PartitionSet parts, com.tangosol.net.partition.Ownership owners)
                {
                // import com.tangosol.net.partition.PartitionSet;
                // import java.util.HashMap;
                // import java.util.Map;
                
                if (_isTraceEnabled(6))
                    {
                    _trace(getStrategyName() + " suggested the ownership of " + owners
                         + " for " + parts, 3);
                    }
                
                if (!validateSuggestion(parts, owners))
                    {
                    PartitionSet partsIgnored = getIgnoredAdvice();
                    if (partsIgnored == null)
                        {
                        partsIgnored = new PartitionSet(parts);
                        }
                    else
                        {
                        partsIgnored.add(parts);
                        }
                    return;
                    }
                
                setIgnoredAdvice(null);
                
                Map mapSuggestions = getSuggestionMap();
                if (mapSuggestions == null)
                    {
                    setSuggestionMap(mapSuggestions = new HashMap());
                    }
                
                PartitionSet partsSuggest = (PartitionSet) mapSuggestions.get(owners);
                if (partsSuggest == null)
                    {
                    mapSuggestions.put(owners, new PartitionSet(parts));
                    }
                else
                    {
                    partsSuggest.add(parts);
                    }
                }
            
            /**
             * Validate the distribution suggestion made by the distribution
            * strategy.
            * Return true iff the distribution suggestion is valid, false
            * otherwise.
             */
            protected boolean validateSuggestion(com.tangosol.net.partition.PartitionSet parts, com.tangosol.net.partition.Ownership owners)
                {
                // import Component.Net.Member;
                // import Component.Net.MemberSet;
                // import java.util.Set;
                
                MemberSet setSuggest = new MemberSet();
                MemberSet setOwners  = (MemberSet) getOwnershipMembers();
                Set       setLeaving = getOwnershipLeavingMembers();
                int       cBackups   = getBackupCount();
                
                for (int iStore = 0; iStore <= cBackups; iStore++)
                    {
                    int    nOwner = owners.getOwner(iStore);
                    Member member = setOwners.getMember(nOwner);
                
                    if (member == null)
                        {
                        if (nOwner == 0 && iStore > 0)
                            {
                            // the strategy is allowed to endanger the backup ownership
                            continue;
                            }
                
                        _trace("Distribution suggestion (" + owners + ") for " + parts
                              + " contains unknown member " + nOwner
                              + "; ignoring suggested distribution", 1);
                        return false;
                        }
                    if (setLeaving.contains(member))
                        {
                        _trace("Distribution suggestion (" + owners + ") for " + parts
                              + " contains member " + nOwner + " which is leaving the service;"
                              + " ignoring suggested distribution", 1);
                        return false;
                        }
                    if (!setSuggest.add(member))
                        {
                        _trace("Distribution suggestion (" + owners + ") for " + parts
                              + " contains duplicate storage indices for " + nOwner + ";"
                              + " ignoring suggested distribution", 1);
                        return false;
                        }
                    }
                
                return true;
                }
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService$Contention
    
    /**
     * Component representing a partition contention info. These objects exist
     * only at times when there is an on-going partition redistribution and the
     * client view is known to be temporarily out of sync.
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class Contention
            extends    com.tangosol.coherence.component.Util
        {
        // ---- Fields declarations ----
        
        /**
         * Property AccessCount
         *
         * The number of times this contention was accessed - indicating a
         * failed request attempt. Used for debugging only.
         */
        private int __m_AccessCount;
        
        /**
         * Property Cleared
         *
         * Indicates that this Contention has been explicitly cleared (reset).
         */
        private boolean __m_Cleared;
        
        /**
         * Property Partition
         *
         * The partition this Contention is for.
         */
        private int __m_Partition;
        
        /**
         * Property WaitingThreads
         *
         * A list of Threads that are currently waiting for the re-distribution
         * completion of the corresponding partition.
         */
        private java.util.List __m_WaitingThreads;
        
        // Default constructor
        public Contention()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public Contention(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                setPartition(-1);
                setWaitingThreads(new java.util.LinkedList());
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.Contention();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/PartitionedService$Contention".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        /**
         * Notify all the contending threads that this contention is cleared.
         */
        public synchronized void clear()
            {
            // import java.util.List;
            
            setCleared(true);
            
            List listThreads = getWaitingThreads();
            listThreads.remove(Thread.currentThread());
            if (!listThreads.isEmpty())
                {
                notifyAll();
                }
            }
        
        // Accessor for the property "AccessCount"
        /**
         * Getter for property AccessCount.<p>
        * The number of times this contention was accessed - indicating a
        * failed request attempt. Used for debugging only.
         */
        public int getAccessCount()
            {
            return __m_AccessCount;
            }
        
        // Accessor for the property "Partition"
        /**
         * Getter for property Partition.<p>
        * The partition this Contention is for.
         */
        public int getPartition()
            {
            return __m_Partition;
            }
        
        // Accessor for the property "WaitingThreads"
        /**
         * Getter for property WaitingThreads.<p>
        * A list of Threads that are currently waiting for the re-distribution
        * completion of the corresponding partition.
         */
        public java.util.List getWaitingThreads()
            {
            return __m_WaitingThreads;
            }
        
        // Accessor for the property "Cleared"
        /**
         * Getter for property Cleared.<p>
        * Indicates that this Contention has been explicitly cleared (reset).
         */
        public boolean isCleared()
            {
            return __m_Cleared;
            }
        
        // Accessor for the property "AccessCount"
        /**
         * Setter for property AccessCount.<p>
        * The number of times this contention was accessed - indicating a
        * failed request attempt. Used for debugging only.
         */
        public void setAccessCount(int c)
            {
            __m_AccessCount = c;
            }
        
        // Accessor for the property "Cleared"
        /**
         * Setter for property Cleared.<p>
        * Indicates that this Contention has been explicitly cleared (reset).
         */
        protected void setCleared(boolean fClear)
            {
            __m_Cleared = fClear;
            }
        
        // Accessor for the property "Partition"
        /**
         * Setter for property Partition.<p>
        * The partition this Contention is for.
         */
        public void setPartition(int iBucket)
            {
            __m_Partition = iBucket;
            }
        
        // Accessor for the property "WaitingThreads"
        /**
         * Setter for property WaitingThreads.<p>
        * A list of Threads that are currently waiting for the re-distribution
        * completion of the corresponding partition.
         */
        protected void setWaitingThreads(java.util.List list)
            {
            __m_WaitingThreads = list;
            }
        
        // Declared at the super level
        public String toString()
            {
            // for debugging only
            return "Contention for partition " + getPartition() +
                   " among " + getWaitingThreads().size() + " threads; count " + getAccessCount();
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService$Continuations
    
    /**
     * Continuations-related support.
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class Continuations
            extends    com.tangosol.coherence.component.Util
        {
        // ---- Fields declarations ----
        private static com.tangosol.util.ListMap __mapChildren;
        
        // Static initializer
        static
            {
            __initStatic();
            }
        
        // Default static initializer
        private static void __initStatic()
            {
            // register child classes
            __mapChildren = new com.tangosol.util.ListMap();
            __mapChildren.put("Continuation", PartitionedService.Continuations.Continuation.get_CLASS());
            __mapChildren.put("Message", PartitionedService.Continuations.Message.get_CLASS());
            __mapChildren.put("Task", PartitionedService.Continuations.Task.get_CLASS());
            }
        
        // Default constructor
        public Continuations()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public Continuations(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            
            // containment initialization: children
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.Continuations();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/PartitionedService$Continuations".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        //++ getter for autogen property _ChildClasses
        /**
         * This is an auto-generated method that returns the map of design time
        * [static] children.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        protected java.util.Map get_ChildClasses()
            {
            return __mapChildren;
            }
        
        /**
         * Instantiate a $Continuation of the specified type with the specified
        * context.
         */
        protected com.oracle.coherence.common.base.Continuation instantiate(int nType, Object oContext, com.oracle.coherence.common.base.Continuation contNext)
            {
            PartitionedService.Continuations.Continuation continuation = new PartitionedService.Continuations.Continuation();
            
            _linkChild(continuation);
            
            continuation.setType(nType);
            continuation.setContext(oContext);
            continuation.setNext(contNext);
            
            return continuation;
            }
        
        /**
         * Return a Continuation that calls
        * $PersistenceControl.onActivePersistenceFailure().
         */
        public com.oracle.coherence.common.base.Continuation instantiateActivePersistenceError()
            {
            return instantiate(PartitionedService.Continuations.Continuation.TYPE_ACTIVE_PERSISTENCE_ERROR, null, null);
            }
        
        /**
         * Return a Continuation to finalize assigning (empty) primaries
        * (#onFinalizeAssignPrimary).
         */
        public com.oracle.coherence.common.base.Continuation instantiateFinalizeAssignPrimaries(java.util.Map mapConfig, com.tangosol.coherence.component.net.Message msgResponse)
            {
            return instantiate(PartitionedService.Continuations.Continuation.TYPE_FINALIZE_ASSIGN_PRIMARY, mapConfig,
                instantiateMessagePost(msgResponse));
            }
        
        /**
         * Return a Continuation to finalize receiving primary transfer
        * (#onFinalizeRecieveTransfer).
         */
        public com.oracle.coherence.common.base.Continuation instantiateFinalizeReceivePrimary(PartitionedService.TransferRequest msgTransfer)
            {
            return instantiate(PartitionedService.Continuations.Continuation.TYPE_FINALIZE_RECEIVE_PRIMARY, msgTransfer, null);
            }
        
        /**
         * Return a Continuation to finalize recovering primaries from
        * persistence store (#onFinalizeRecoverPrimary).
         */
        public com.oracle.coherence.common.base.Continuation instantiateFinalizeRecoverPrimary(com.tangosol.net.internal.PartitionRecoverInfo info)
            {
            return instantiate(PartitionedService.Continuations.Continuation.TYPE_FINALIZE_RECOVER_PRIMARY, info, null);
            }
        
        /**
         * Return a Continuation to finalize restoring primaries from backup
        * (#onFinalizeRestorePrimary).
         */
        public com.oracle.coherence.common.base.Continuation instantiateFinalizeRestorePrimaries(PartitionedService.OwnershipRequest msgRequest, java.util.Map mapConfig)
            {
            return instantiate(PartitionedService.Continuations.Continuation.TYPE_FINALIZE_RESTORE_PRIMARY,
                new Object[] {msgRequest, mapConfig}, null);
            }
        
        /**
         * Return a Continuation to finalize sending primary transfer
        * (#onFinalizeSendTransfer).
         */
        public com.oracle.coherence.common.base.Continuation instantiateFinalizeSendPrimary(com.tangosol.net.partition.PartitionSet parts)
            {
            return instantiate(PartitionedService.Continuations.Continuation.TYPE_FINALIZE_SEND_PRIMARY, parts, null);
            }
        
        /**
         * Return a Continuation to complete primary transfer request
        * (#onTransferRequestCompleted).
         */
        public com.oracle.coherence.common.base.Continuation instantiateFinalizeTransferPrimary(PartitionedService.TransferRequest msgRequest)
            {
            return instantiate(PartitionedService.Continuations.Continuation.TYPE_FINALIZE_TRANSFER_PRIMARY, msgRequest, null);
            }
        
        /**
         * Return a Continuation that will post the specified message.
         */
        public com.oracle.coherence.common.base.Continuation instantiateMessagePost(java.util.List listMessage)
            {
            return instantiate(PartitionedService.Continuations.Continuation.TYPE_MESSAGE_POST, listMessage, null);
            }
        
        /**
         * Return a Continuation that will post the specified message.
         */
        public com.oracle.coherence.common.base.Continuation instantiateMessagePost(com.tangosol.coherence.component.net.Message msg)
            {
            return instantiate(PartitionedService.Continuations.Continuation.TYPE_MESSAGE_POST, msg, null);
            }
        
        /**
         * Return a Continuation that either call
        * $PersistenceControl.onActivePersistenceFailure()  directly or on the
        * service thread.
         */
        public com.oracle.coherence.common.base.Continuation instantiatePersistenceErrorHandler(com.oracle.coherence.common.base.Continuation continuation)
            {
            return instantiate(PartitionedService.Continuations.Continuation.TYPE_PERSISTENCE_ERROR_HANDLER, null, continuation);
            }
        
        /**
         * Return a Continuation that will post the specified runnable task to
        * the EventDispatcher.
         */
        public com.oracle.coherence.common.base.Continuation instantiateTaskDispatch(Runnable task)
            {
            return instantiate(PartitionedService.Continuations.Continuation.TYPE_TASK_DISPATCH, task, null);
            }
        
        /**
         * Return a Continuation that ensures the provided Continuation is
        * invoked on the service thread.
         */
        public com.oracle.coherence.common.base.Continuation thenOnServiceThread(com.oracle.coherence.common.base.Continuation continuation)
            {
            return instantiate(PartitionedService.Continuations.Continuation.TYPE_INVOKE_ON_SERVICE_THREAD, null, continuation);
            }
        
        /**
         * Return a Continuation that will post a local message to run the
        * specified continuation.
         */
        public com.oracle.coherence.common.base.Continuation wrapAsMessage(com.oracle.coherence.common.base.Continuation continuation)
            {
            PartitionedService.Continuations.Message msg = new PartitionedService.Continuations.Message();
            msg.setContinuation(continuation);
            msg.addToMember(((PartitionedService) get_Module()).getThisMember());
            
            return instantiateMessagePost(msg);
            }
        
        /**
         * Return a continuation that will post a runnable task to the
        * EventDispatcher to run the specified continuation.
         */
        public com.oracle.coherence.common.base.Continuation wrapAsTask(com.oracle.coherence.common.base.Continuation continuation)
            {
            PartitionedService.Continuations.Task task = new PartitionedService.Continuations.Task();
            task.setContinuation(continuation);
            
            return instantiateTaskDispatch(task);
            }

        // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService$Continuations$Continuation
        
        /**
         * Assorted continuation actions used by PartitionedService, collected
         * into a single multi-purpose implementation.
         * 
         * This implementation is a "workaround" for the lack of anonymous
         * inner-class support in TDE.
         */
        @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
        public static class Continuation
                extends    com.tangosol.coherence.component.Util
                implements com.oracle.coherence.common.base.Continuation
            {
            // ---- Fields declarations ----
            
            /**
             * Property Context
             *
             * The opaque context is polymorphic and specific to each
             * continuation type.
             * 
             * @volatile
             */
            private volatile Object __m_Context;
            
            /**
             * Property Next
             *
             * The "next" continuation, to proceed with, after the operation is
             * complete.
             */
            private com.oracle.coherence.common.base.Continuation __m_Next;
            
            /**
             * Property Type
             *
             * The type of this continuation (one of the TYPE_* constants)
             */
            private int __m_Type;
            
            /**
             * Property TYPE_ACTIVE_PERSISTENCE_ERROR
             *
             */
            public static final int TYPE_ACTIVE_PERSISTENCE_ERROR = 9;
            
            /**
             * Property TYPE_FINALIZE_ASSIGN_PRIMARY
             *
             */
            public static final int TYPE_FINALIZE_ASSIGN_PRIMARY = 6;
            
            /**
             * Property TYPE_FINALIZE_RECEIVE_PRIMARY
             *
             * Finalize receiving primary transfer.
             */
            public static final int TYPE_FINALIZE_RECEIVE_PRIMARY = 1;
            
            /**
             * Property TYPE_FINALIZE_RECOVER_PRIMARY
             *
             */
            public static final int TYPE_FINALIZE_RECOVER_PRIMARY = 7;
            
            /**
             * Property TYPE_FINALIZE_RESTORE_PRIMARY
             *
             * Finalize restoring primary partitions.
             */
            public static final int TYPE_FINALIZE_RESTORE_PRIMARY = 5;
            
            /**
             * Property TYPE_FINALIZE_SEND_PRIMARY
             *
             * Finalize sending primary transfer.
             */
            public static final int TYPE_FINALIZE_SEND_PRIMARY = 4;
            
            /**
             * Property TYPE_FINALIZE_TRANSFER_PRIMARY
             *
             */
            public static final int TYPE_FINALIZE_TRANSFER_PRIMARY = 12;
            
            /**
             * Property TYPE_INVOKE_ON_SERVICE_THREAD
             *
             */
            public static final int TYPE_INVOKE_ON_SERVICE_THREAD = 8;
            
            /**
             * Property TYPE_MESSAGE_POST
             *
             * Post a message.
             */
            public static final int TYPE_MESSAGE_POST = 2;
            
            /**
             * Property TYPE_PERSISTENCE_ERROR_HANDLER
             *
             */
            public static final int TYPE_PERSISTENCE_ERROR_HANDLER = 10;
            
            /**
             * Property TYPE_TASK_DISPATCH
             *
             * Dispatch a runnable task to the EventDispatcher.
             */
            public static final int TYPE_TASK_DISPATCH = 3;
            
            // Default constructor
            public Continuation()
                {
                this(null, null, true);
                }
            
            // Initializing constructor
            public Continuation(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                {
                super(sName, compParent, false);
                
                if (fInit)
                    {
                    __init();
                    }
                }
            
            // Main initializer
            public void __init()
                {
                // private initialization
                __initPrivate();
                
                
                // signal the end of the initialization
                set_Constructed(true);
                }
            
            // Private initializer
            protected void __initPrivate()
                {
                
                super.__initPrivate();
                }
            
            //++ getter for static property _Instance
            /**
             * Getter for property _Instance.<p>
            * Auto generated
             */
            public static com.tangosol.coherence.Component get_Instance()
                {
                return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.Continuations.Continuation();
                }
            
            //++ getter for static property _CLASS
            /**
             * Getter for property _CLASS.<p>
            * Property with auto-generated accessor that returns the Class
            * object for a given component.
             */
            public static Class get_CLASS()
                {
                Class clz;
                try
                    {
                    clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/PartitionedService$Continuations$Continuation".replace('/', '.'));
                    }
                catch (ClassNotFoundException e)
                    {
                    throw new NoClassDefFoundError(e.getMessage());
                    }
                return clz;
                }
            
            //++ getter for autogen property _Module
            /**
             * This is an auto-generated method that returns the global [design
            * time] parent component.
            * 
            * Note: the class generator will ignore any custom implementation
            * for this behavior.
             */
            private com.tangosol.coherence.Component get_Module()
                {
                return this.get_Parent().get_Parent();
                }
            
            // Accessor for the property "Context"
            /**
             * Getter for property Context.<p>
            * The opaque context is polymorphic and specific to each
            * continuation type.
            * 
            * @volatile
             */
            public Object getContext()
                {
                return __m_Context;
                }
            
            // Accessor for the property "Next"
            /**
             * Getter for property Next.<p>
            * The "next" continuation, to proceed with, after the operation is
            * complete.
             */
            public com.oracle.coherence.common.base.Continuation getNext()
                {
                return __m_Next;
                }
            
            // Accessor for the property "Type"
            /**
             * Getter for property Type.<p>
            * The type of this continuation (one of the TYPE_* constants)
             */
            public int getType()
                {
                return __m_Type;
                }
            
            // From interface: com.oracle.coherence.common.base.Continuation
            public void proceed(Object oResult)
                {
                // import Component.Net.Message as com.tangosol.coherence.component.net.Message;
                // import com.oracle.coherence.persistence.PersistenceException;
                // import com.tangosol.persistence.GUIDHelper;
                // import com.oracle.coherence.persistence.PersistentStore;
                // import com.tangosol.net.internal.PartitionRecoverInfo;
                // import com.tangosol.net.partition.PartitionSet;
                // import java.util.Iterator;
                // import java.util.List;
                // import java.util.Map;
                
                PartitionedService service  = (PartitionedService) get_Module();
                Object  oContext = getContext();
                
                switch (getType())
                    {
                    case TYPE_PERSISTENCE_ERROR_HANDLER:
                        PersistenceException e     = (PersistenceException) oResult;
                        PersistentStore      store = e == null ? null : e.getPersistentStore();
                        if (store != null && !service.isRecovering(GUIDHelper.getPartition(store.getId())))
                            {
                            if (Thread.currentThread() != service.getThread())
                                {
                                setNext(((PartitionedService.Continuations) get_Parent()).wrapAsMessage(getNext()));
                                }
                            proceedNext(oResult);
                            break;
                           }
                        // else fall-through
                         
                    case TYPE_ACTIVE_PERSISTENCE_ERROR:
                        service.getPersistenceControl()
                            .onActivePersistenceFailure((PersistenceException) oResult);
                        proceedNext(oResult);
                        break;
                
                    case TYPE_FINALIZE_ASSIGN_PRIMARY:
                        // should only be called on service thread
                        service.onFinalizeAssignPrimary((Map) oContext);
                        proceedNext(oResult);
                        break;
                
                    case TYPE_FINALIZE_RECEIVE_PRIMARY:
                        // should only be called on service thread
                        service.onFinalizeReceivePrimary((PartitionedService.TransferRequest) oContext);
                        proceedNext(oResult);
                        break;
                
                    case TYPE_FINALIZE_RESTORE_PRIMARY:
                        Object[] aoResult = (Object[]) oContext;
                        // should only be called on service thread
                        service.onFinalizeRestorePrimary((PartitionedService.OwnershipRequest) aoResult[0], (Map) aoResult[1]);
                        break;
                
                    case TYPE_FINALIZE_RECOVER_PRIMARY:
                        // should only be called on service thread
                        PartitionRecoverInfo info = (PartitionRecoverInfo) oContext;
                        service.onFinalizeRecoverPrimary(info);
                        break;
                
                    case TYPE_FINALIZE_SEND_PRIMARY:
                        // should only be called on service thread
                        service.onFinalizeSendPrimary((PartitionSet) oContext);
                        proceedNext(oResult);
                        break;
                
                    case TYPE_FINALIZE_TRANSFER_PRIMARY:
                        // should only be called on service thread
                        service.onTransferRequestCompleted((PartitionedService.TransferRequest) oContext);
                        proceedNext(oResult);
                        break;
                
                    case TYPE_INVOKE_ON_SERVICE_THREAD:
                        if (Thread.currentThread() != service.getThread())
                            {
                            setNext(((PartitionedService.Continuations) get_Parent()).wrapAsMessage(getNext()));
                            }
                        proceedNext(oResult);
                        break;
                
                    case TYPE_MESSAGE_POST:
                        if (oContext instanceof com.tangosol.coherence.component.net.Message)
                            {
                            if (oContext instanceof PartitionedService.Continuations.Message)
                                {
                                // if it is a "continuation" message, pass the result
                                ((PartitionedService.Continuations.Message) oContext).setResult(oResult);
                                }
                
                            service.send((com.tangosol.coherence.component.net.Message) oContext);
                            }
                        else if (oContext instanceof List)
                            {
                            for (Iterator iter = ((List) oContext).iterator(); iter.hasNext(); )
                                {
                                com.tangosol.coherence.component.net.Message msg = (com.tangosol.coherence.component.net.Message) iter.next();
                                service.post(msg);
                                }
                
                            service.flush();
                            }
                        break;
                
                    case TYPE_TASK_DISPATCH:
                        if (oContext instanceof PartitionedService.Continuations.Task)
                            {
                            // if it is a "continuation" task, pass the result
                            ((PartitionedService.Continuations.Task) oContext).setResult(oResult);
                            }
                        service.ensureEventDispatcher().getQueue().add(oContext);
                        break;
                
                    default:
                        _assert(false);
                    }
                }
            
            /**
             * Proceed with the "next" continuation, if it exists.
             */
            protected void proceedNext(Object oResult)
                {
                // import com.oracle.coherence.common.base.Continuation as com.oracle.coherence.common.base.Continuation;
                
                com.oracle.coherence.common.base.Continuation contNext = getNext();
                if (contNext != null)
                    {
                    contNext.proceed(oResult);
                    }
                }
            
            // Accessor for the property "Context"
            /**
             * Setter for property Context.<p>
            * The opaque context is polymorphic and specific to each
            * continuation type.
            * 
            * @volatile
             */
            public void setContext(Object oContext)
                {
                __m_Context = oContext;
                }
            
            // Accessor for the property "Next"
            /**
             * Setter for property Next.<p>
            * The "next" continuation, to proceed with, after the operation is
            * complete.
             */
            public void setNext(com.oracle.coherence.common.base.Continuation continuationNext)
                {
                __m_Next = continuationNext;
                }
            
            // Accessor for the property "Type"
            /**
             * Setter for property Type.<p>
            * The type of this continuation (one of the TYPE_* constants)
             */
            public void setType(int nType)
                {
                __m_Type = nType;
                }
            }

        // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService$Continuations$Message
        
        /**
         * Local message that (when received) runs a continuation.
         */
        @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
        public static class Message
                extends    com.tangosol.coherence.component.net.Message
            {
            // ---- Fields declarations ----
            
            /**
             * Property Continuation
             *
             * The continuation to finish when this message is received.
             */
            private com.oracle.coherence.common.base.Continuation __m_Continuation;
            
            /**
             * Property Result
             *
             * The result to feed to continuation.
             */
            private Object __m_Result;
            
            // Default constructor
            public Message()
                {
                this(null, null, true);
                }
            
            // Initializing constructor
            public Message(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                {
                super(sName, compParent, false);
                
                if (fInit)
                    {
                    __init();
                    }
                }
            
            // Main initializer
            public void __init()
                {
                // private initialization
                __initPrivate();
                
                
                // signal the end of the initialization
                set_Constructed(true);
                }
            
            // Private initializer
            protected void __initPrivate()
                {
                
                super.__initPrivate();
                }
            
            //++ getter for static property _Instance
            /**
             * Getter for property _Instance.<p>
            * Auto generated
             */
            public static com.tangosol.coherence.Component get_Instance()
                {
                return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.Continuations.Message();
                }
            
            //++ getter for static property _CLASS
            /**
             * Getter for property _CLASS.<p>
            * Property with auto-generated accessor that returns the Class
            * object for a given component.
             */
            public static Class get_CLASS()
                {
                Class clz;
                try
                    {
                    clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/PartitionedService$Continuations$Message".replace('/', '.'));
                    }
                catch (ClassNotFoundException e)
                    {
                    throw new NoClassDefFoundError(e.getMessage());
                    }
                return clz;
                }
            
            //++ getter for autogen property _Module
            /**
             * This is an auto-generated method that returns the global [design
            * time] parent component.
            * 
            * Note: the class generator will ignore any custom implementation
            * for this behavior.
             */
            private com.tangosol.coherence.Component get_Module()
                {
                return this.get_Parent().get_Parent();
                }
            
            // Accessor for the property "Continuation"
            /**
             * Getter for property Continuation.<p>
            * The continuation to finish when this message is received.
             */
            public com.oracle.coherence.common.base.Continuation getContinuation()
                {
                return __m_Continuation;
                }
            
            // Accessor for the property "Result"
            /**
             * Getter for property Result.<p>
            * The result to feed to continuation.
             */
            public Object getResult()
                {
                return __m_Result;
                }
            
            // Declared at the super level
            /**
             * This is the event that is executed when a Message is received.
            * <p>
            * It is the main processing event of the Message called by the
            * <code>Service.onMessage()</code> event. With regards to the use
            * of Message components within clustered Services, Services are
            * designed by dragging Message components into them as static
            * children. These Messages are the components that a Service can
            * send to other running instances of the same Service within a
            * cluster. When the onReceived event is invoked by a Service, it
            * means that the Message has been received; the code in the
            * onReceived event is therefore the Message specific logic for
            * processing a received Message. For example, when onReceived is
            * invoked on a Message named FindData, the onReceived event should
            * do the work to "find the data", because it is being invoked by
            * the Service that received the "find the data" Message.
             */
            public void onReceived()
                {
                // import com.oracle.coherence.common.base.Continuation as com.oracle.coherence.common.base.Continuation;
                
                com.oracle.coherence.common.base.Continuation continuation = getContinuation();
                if (continuation != null)
                    {
                    continuation.proceed(getResult());
                    }
                }
            
            // Accessor for the property "Continuation"
            /**
             * Setter for property Continuation.<p>
            * The continuation to finish when this message is received.
             */
            public void setContinuation(com.oracle.coherence.common.base.Continuation continuation)
                {
                __m_Continuation = continuation;
                }
            
            // Accessor for the property "Result"
            /**
             * Setter for property Result.<p>
            * The result to feed to continuation.
             */
            public void setResult(Object oResult)
                {
                __m_Result = oResult;
                }
            }

        // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService$Continuations$Task
        
        /**
         * Runnable task that runs a continuation.
         */
        @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
        public static class Task
                extends    com.tangosol.coherence.component.Util
                implements Runnable
            {
            // ---- Fields declarations ----
            
            /**
             * Property Continuation
             *
             * The continuation to finish when this task is executed on the
             * event dispatcher thread.
             */
            private com.oracle.coherence.common.base.Continuation __m_Continuation;
            
            /**
             * Property Result
             *
             * The result to feed to the continuation.
             */
            private Object __m_Result;
            
            // Default constructor
            public Task()
                {
                this(null, null, true);
                }
            
            // Initializing constructor
            public Task(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                {
                super(sName, compParent, false);
                
                if (fInit)
                    {
                    __init();
                    }
                }
            
            // Main initializer
            public void __init()
                {
                // private initialization
                __initPrivate();
                
                
                // signal the end of the initialization
                set_Constructed(true);
                }
            
            // Private initializer
            protected void __initPrivate()
                {
                
                super.__initPrivate();
                }
            
            //++ getter for static property _Instance
            /**
             * Getter for property _Instance.<p>
            * Auto generated
             */
            public static com.tangosol.coherence.Component get_Instance()
                {
                return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.Continuations.Task();
                }
            
            //++ getter for static property _CLASS
            /**
             * Getter for property _CLASS.<p>
            * Property with auto-generated accessor that returns the Class
            * object for a given component.
             */
            public static Class get_CLASS()
                {
                Class clz;
                try
                    {
                    clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/PartitionedService$Continuations$Task".replace('/', '.'));
                    }
                catch (ClassNotFoundException e)
                    {
                    throw new NoClassDefFoundError(e.getMessage());
                    }
                return clz;
                }
            
            //++ getter for autogen property _Module
            /**
             * This is an auto-generated method that returns the global [design
            * time] parent component.
            * 
            * Note: the class generator will ignore any custom implementation
            * for this behavior.
             */
            private com.tangosol.coherence.Component get_Module()
                {
                return this.get_Parent().get_Parent();
                }
            
            // Accessor for the property "Continuation"
            /**
             * Getter for property Continuation.<p>
            * The continuation to finish when this task is executed on the
            * event dispatcher thread.
             */
            public com.oracle.coherence.common.base.Continuation getContinuation()
                {
                return __m_Continuation;
                }
            
            // Accessor for the property "Result"
            /**
             * Getter for property Result.<p>
            * The result to feed to the continuation.
             */
            public Object getResult()
                {
                return __m_Result;
                }
            
            // From interface: java.lang.Runnable
            public void run()
                {
                // import com.oracle.coherence.common.base.Continuation as com.oracle.coherence.common.base.Continuation;
                
                com.oracle.coherence.common.base.Continuation continuation = getContinuation();
                if (continuation != null)
                    {
                    continuation.proceed(getResult());
                    }
                }
            
            // Accessor for the property "Continuation"
            /**
             * Setter for property Continuation.<p>
            * The continuation to finish when this task is executed on the
            * event dispatcher thread.
             */
            public void setContinuation(com.oracle.coherence.common.base.Continuation continuation)
                {
                __m_Continuation = continuation;
                }
            
            // Accessor for the property "Result"
            /**
             * Setter for property Result.<p>
            * The result to feed to the continuation.
             */
            public void setResult(Object oResult)
                {
                __m_Result = oResult;
                }
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService$ConverterKeyToBinary
    
    /**
     * Serializable Object to Binary converter. Used for keys only.
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class ConverterKeyToBinary
            extends    com.tangosol.coherence.component.util.Converter
            implements com.tangosol.net.partition.KeyPartitioningStrategy
        {
        // ---- Fields declarations ----
        
        /**
         * Property PassThrough
         *
         * A boolean flag indicating that this key converter is used by the
         * pass through optimization and both the incoming and outgoing keys
         * are Binary objects.
         */
        private boolean __m_PassThrough;
        
        // Default constructor
        public ConverterKeyToBinary()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public ConverterKeyToBinary(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.ConverterKeyToBinary();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/PartitionedService$ConverterKeyToBinary".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        // Declared at the super level
        public Object convert(Object o)
            {
            // import com.tangosol.net.partition.DefaultKeyPartitioningStrategy as com.tangosol.net.partition.DefaultKeyPartitioningStrategy;
            // import com.tangosol.net.partition.KeyPartitioningStrategy as com.tangosol.net.partition.KeyPartitioningStrategy;
            // import com.tangosol.net.partition.KeyPartitioningStrategy$PartitionAwareKey as com.tangosol.net.partition.KeyPartitioningStrategy.PartitionAwareKey;
            // import com.tangosol.util.Binary;
            // import com.tangosol.util.ExternalizableHelper as com.tangosol.util.ExternalizableHelper;
            // import com.tangosol.util.HashEncoded;
            
            PartitionedService service      = (PartitionedService) get_Module();
            com.tangosol.net.partition.KeyPartitioningStrategy     partitioning = service.getKeyPartitioningStrategy();
            int     nHash;
            
            if (isPassThrough())
                {
                Binary binKey = (Binary) o;
                _assert(binKey != null);
            
                boolean fDeco = com.tangosol.util.ExternalizableHelper.isIntDecorated(binKey);
            
                if (partitioning instanceof PartitionedService.ConverterKeyToBinary)
                    {
                    if (fDeco)
                        {
                        // hash code for partitioning has already been calculated and decorated
                        nHash = binKey.getEncodedHash();
                        }
                    else
                        {
                        o = com.tangosol.util.ExternalizableHelper.fromBinary(binKey, getSerializer());
            
                        Object oAssocKey = service.getKeyAssociator().getAssociatedKey(o);
                        if (oAssocKey == null)
                            {
                            // inlined com.tangosol.net.partition.DefaultKeyPartitioningStrategy implementation to avoid unnecessary re-serialization
                            nHash = o instanceof com.tangosol.net.partition.KeyPartitioningStrategy.PartitionAwareKey
                                ? ((com.tangosol.net.partition.KeyPartitioningStrategy.PartitionAwareKey) o).getPartitionId()
                                : binKey.calculateNaturalPartition(0);
                            }
                        else
                            {
                            nHash = com.tangosol.net.partition.DefaultKeyPartitioningStrategy.calculateBasePartitionHash(service, oAssocKey);
                            }
                        }
                    }
                else
                    {
                    o = com.tangosol.util.ExternalizableHelper.fromBinary(binKey, getSerializer());
                    nHash = partitioning.getKeyPartition(o);
                    }
            
                // ensure the hash is not a reserved value
                int nHashNew = service.convertHash(nHash);
            
                // the int decoration may need to be updated,
                // e.g. if it was decorated by an extend client
                if (fDeco)
                    {
                    if (nHash == nHashNew)
                        {
                        return binKey;
                        }
                    binKey = com.tangosol.util.ExternalizableHelper.removeIntDecoration(binKey).toBinary();
                    }
            
                return com.tangosol.util.ExternalizableHelper.decorateBinary(binKey, nHashNew).toBinary();
                }
            else
                {
                if (partitioning instanceof PartitionedService.ConverterKeyToBinary)
                    {
                    Object oAssocKey = service.getKeyAssociator().getAssociatedKey(o);
                    if (oAssocKey == null)
                        {
                        // common-case: inlined com.tangosol.net.partition.DefaultKeyPartitioningStrategy implementation to avoid double serialization
                        Binary binKey = com.tangosol.util.ExternalizableHelper.toBinary(o, getSerializer());
            
                        nHash = o instanceof com.tangosol.net.partition.KeyPartitioningStrategy.PartitionAwareKey
                            ? ((com.tangosol.net.partition.KeyPartitioningStrategy.PartitionAwareKey) o).getPartitionId()
                            : binKey.calculateNaturalPartition(0);
            
                        return com.tangosol.util.ExternalizableHelper.decorateBinary(binKey, service.convertHash(nHash)).toBinary();
                        }
                    else
                        {
                        nHash = com.tangosol.net.partition.DefaultKeyPartitioningStrategy.calculateBasePartitionHash(service, oAssocKey);
                        }
                    }
                else
                    {
                    // as of Coherence 3.6, the partitioning needs to take care of the association
                    nHash = partitioning.getKeyPartition(o);
                    }
            
                return com.tangosol.util.ExternalizableHelper.toBinary(com.tangosol.util.ExternalizableHelper.decorate(o, service.convertHash(nHash)), getSerializer());
                }
            }
        
        // From interface: com.tangosol.net.partition.KeyPartitioningStrategy
        public com.tangosol.net.partition.PartitionSet getAssociatedPartitions(Object oKey)
            {
            // import com.tangosol.net.partition.PartitionSet;
            
            PartitionedService service = (PartitionedService) get_Module();
            
            PartitionSet parts = new PartitionSet(service.getPartitionCount());
            parts.add(getKeyPartition(oKey));
            return parts;
            }
        
        // From interface: com.tangosol.net.partition.KeyPartitioningStrategy
        /**
         * Calculate a partition number for the specified key.
         */
        public int getKeyPartition(Object oKey)
            {
            // import com.tangosol.net.partition.DefaultKeyPartitioningStrategy as com.tangosol.net.partition.DefaultKeyPartitioningStrategy;
            
            return com.tangosol.net.partition.DefaultKeyPartitioningStrategy.calculateKeyPartition((PartitionedService) get_Module(), oKey);
            }
        
        // From interface: com.tangosol.net.partition.KeyPartitioningStrategy
        public void init(com.tangosol.net.PartitionedService service)
            {
            }
        
        // Accessor for the property "PassThrough"
        /**
         * Getter for property PassThrough.<p>
        * A boolean flag indicating that this key converter is used by the pass
        * through optimization and both the incoming and outgoing keys are
        * Binary objects.
         */
        public boolean isPassThrough()
            {
            return __m_PassThrough;
            }
        
        // Accessor for the property "PassThrough"
        /**
         * Setter for property PassThrough.<p>
        * A boolean flag indicating that this key converter is used by the pass
        * through optimization and both the incoming and outgoing keys are
        * Binary objects.
         */
        public void setPassThrough(boolean fPass)
            {
            __m_PassThrough = fPass;
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService$DaemonPool
    
    /**
     * DaemonPool is a class thread pool implementation for processing queued
     * operations on one or more daemon threads.
     * 
     * The designable properties are:
     *     AutoStart
     *     DaemonCount
     * 
     * The simple API for the DaemonPool is:
     *     public void start()
     *     public boolean isStarted()
     *     public void add(Runnable task)
     *     public void stop()
     * 
     * The advanced API for the DaemonPool is:
     *     DaemonCount property
     *     Daemons property
     *     Queues property
     *     ThreadGroup property
     * 
     * The DaemonPool is composed of two key components:
     * 
     * 1) An array of WorkSlot components that may or may not share Queues with
     * other WorkSlots. 
     * 
     * 2) An array of Daemon components feeding off the Queues. This collection
     * is accessed by the DaemonCount and Daemons properties, and is managed by
     * the DaemonCount mutator.
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class DaemonPool
            extends    com.tangosol.coherence.component.util.daemon.queueProcessor.service.Grid.DaemonPool
        {
        // ---- Fields declarations ----
        private static com.tangosol.util.ListMap __mapChildren;
        
        // Static initializer
        static
            {
            __initStatic();
            }
        
        // Default static initializer
        private static void __initStatic()
            {
            // register child classes
            __mapChildren = new com.tangosol.util.ListMap();
            __mapChildren.put("Daemon", com.tangosol.coherence.component.util.daemon.queueProcessor.service.Grid.DaemonPool.Daemon.get_CLASS());
            __mapChildren.put("ResizeTask", com.tangosol.coherence.component.util.daemon.queueProcessor.Service.DaemonPool.ResizeTask.get_CLASS());
            __mapChildren.put("ScheduleTask", com.tangosol.coherence.component.util.daemon.queueProcessor.Service.DaemonPool.ScheduleTask.get_CLASS());
            __mapChildren.put("StartTask", com.tangosol.coherence.component.util.daemon.queueProcessor.Service.DaemonPool.StartTask.get_CLASS());
            __mapChildren.put("StopTask", com.tangosol.coherence.component.util.daemon.queueProcessor.Service.DaemonPool.StopTask.get_CLASS());
            __mapChildren.put("WorkSlot", com.tangosol.coherence.component.util.daemon.queueProcessor.Service.DaemonPool.WorkSlot.get_CLASS());
            __mapChildren.put("WrapperTask", PartitionedService.DaemonPool.WrapperTask.get_CLASS());
            }
        
        // Default constructor
        public DaemonPool()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public DaemonPool(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                setAbandonThreshold(8);
                setDaemonCountMax(2147483647);
                setDaemonCountMin(1);
                setScheduledTasks(new java.util.HashSet());
                setStatsTaskAddCount(new java.util.concurrent.atomic.AtomicLong());
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // containment initialization: children
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.DaemonPool();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/PartitionedService$DaemonPool".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        //++ getter for autogen property _ChildClasses
        /**
         * This is an auto-generated method that returns the map of design time
        * [static] children.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        protected java.util.Map get_ChildClasses()
            {
            return __mapChildren;
            }
        
        // Declared at the super level
        /**
         * Factory method: create a new WrapperTask component.
         */
        protected com.tangosol.coherence.component.util.DaemonPool.WrapperTask instantiateWrapperTask()
            {
            // override the super, as it does not use virtual construction
            
            // instantiate directly to avoid reflection
            PartitionedService.DaemonPool.WrapperTask task = new PartitionedService.DaemonPool.WrapperTask();
            _linkChild(task);
            return task;
            }

        // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService$DaemonPool$WrapperTask
        
        /**
         * A task that is used to wrap the actual tasks.
         */
        @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
        public static class WrapperTask
                extends    com.tangosol.coherence.component.util.daemon.queueProcessor.Service.DaemonPool.WrapperTask
            {
            // ---- Fields declarations ----
            
            // Default constructor
            public WrapperTask()
                {
                this(null, null, true);
                }
            
            // Initializing constructor
            public WrapperTask(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                {
                super(sName, compParent, false);
                
                if (fInit)
                    {
                    __init();
                    }
                }
            
            // Main initializer
            public void __init()
                {
                // private initialization
                __initPrivate();
                
                
                // signal the end of the initialization
                set_Constructed(true);
                }
            
            // Private initializer
            protected void __initPrivate()
                {
                
                super.__initPrivate();
                }
            
            //++ getter for static property _Instance
            /**
             * Getter for property _Instance.<p>
            * Auto generated
             */
            public static com.tangosol.coherence.Component get_Instance()
                {
                return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.DaemonPool.WrapperTask();
                }
            
            //++ getter for static property _CLASS
            /**
             * Getter for property _CLASS.<p>
            * Property with auto-generated accessor that returns the Class
            * object for a given component.
             */
            public static Class get_CLASS()
                {
                Class clz;
                try
                    {
                    clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/PartitionedService$DaemonPool$WrapperTask".replace('/', '.'));
                    }
                catch (ClassNotFoundException e)
                    {
                    throw new NoClassDefFoundError(e.getMessage());
                    }
                return clz;
                }
            
            //++ getter for autogen property _Module
            /**
             * This is an auto-generated method that returns the global [design
            * time] parent component.
            * 
            * Note: the class generator will ignore any custom implementation
            * for this behavior.
             */
            private com.tangosol.coherence.Component get_Module()
                {
                return this.get_Parent().get_Parent();
                }
            
            // Declared at the super level
            public void run()
                {
                super.run();
                
                updatePartitionStats();
                }
            
            protected void updatePartitionStats()
                {
                // import Component.Net.Message.RequestMessage.DistributedCacheKeyRequest as com.tangosol.coherence.component.net.message.requestMessage.DistributedCacheKeyRequest;
                // import Component.Net.Message.RequestMessage.DistributedCacheRequest as com.tangosol.coherence.component.net.message.requestMessage.DistributedCacheRequest;
                // import Component.Util.PartialJob;
                // import com.tangosol.net.partition.PartitionSet;
                // import com.tangosol.util.Base;
                
                Runnable     task       = getTask();
                int          nPartition = -1;
                PartitionSet parts      = null;
                long         ldtArrived = 0L;
                
                if (task instanceof PartialJob)
                    {
                    nPartition = ((PartialJob) task).getPartition();
                    ldtArrived = getPostTime();
                    }
                else if (task instanceof com.tangosol.coherence.component.net.message.requestMessage.DistributedCacheKeyRequest)
                    {
                    nPartition = ((com.tangosol.coherence.component.net.message.requestMessage.DistributedCacheKeyRequest) task).getProcessedPartition();
                    ldtArrived = getPostTime();
                    }
                else if (task instanceof com.tangosol.coherence.component.net.message.requestMessage.DistributedCacheRequest)
                    {
                    parts      = ((com.tangosol.coherence.component.net.message.requestMessage.DistributedCacheRequest) task).getProcessedPartitions();
                    ldtArrived = getPostTime();;
                    }
                else
                    {
                    return;
                    }
                
                PartitionedService service     = (PartitionedService) get_Module();
                long    ldtNow      = Base.getLastSafeTimeMillis();
                long    cExecMillis = ldtNow - getStartTime();
                long    cWaitMillis = ldtNow - ldtArrived;
                
                if (nPartition >= 0)
                    {
                    PartitionedService.PartitionControl ctrl = service.getPartitionControl(nPartition);
                    if (ctrl != null)
                        {
                        ctrl.getStatistics().recordRequest(cWaitMillis, cExecMillis);
                        }
                    }
                else if (parts != null)
                    {
                    PartitionedService.PartitionControl[] actrlPartition = service.getPartitionControl();
                    for (nPartition = parts.next(0); nPartition >= 0;
                         nPartition = parts.next(nPartition + 1))
                        {
                        PartitionedService.PartitionControl ctrl = actrlPartition[nPartition];
                        if (ctrl != null)
                            {
                            ctrl.getStatistics().recordRequest(cWaitMillis, cExecMillis);
                            }
                        }
                    }
                }
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService$DispatchEvent
    
    /**
     * Runnable event.
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class DispatchEvent
            extends    com.tangosol.coherence.component.util.daemon.queueProcessor.service.Grid.DispatchEvent
        {
        // ---- Fields declarations ----
        
        // Default constructor
        public DispatchEvent()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public DispatchEvent(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.DispatchEvent();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/PartitionedService$DispatchEvent".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService$DistributionPlanUpdate
    
    /**
     * DistributionPlanUpdate is sent by the distribution coordinator to all
     * ownership-enabled members to communicate a change/update to the
     * distribution plan.
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class DistributionPlanUpdate
            extends    com.tangosol.coherence.component.net.Message
        {
        // ---- Fields declarations ----
        
        /**
         * Property TargetStrength
         *
         */
        private int __m_TargetStrength;
        
        /**
         * Property UpdateMap
         *
         * The Map<Ownership, PartitionSet> holding the distribution plan
         * update (delta).
         */
        private java.util.Map __m_UpdateMap;
        
        // Default constructor
        public DistributionPlanUpdate()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public DistributionPlanUpdate(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                setMessageType(36);
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.DistributionPlanUpdate();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/PartitionedService$DistributionPlanUpdate".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        // Declared at the super level
        /**
         * Getter for property Description.<p>
        * Used for debugging purposes (from toString). Create a human-readable
        * description of the specific Message data.
         */
        public String getDescription()
            {
            // import com.tangosol.net.partition.Ownership;
            // import com.tangosol.net.partition.PartitionSet;
            // import java.util.Iterator;
            // import java.util.Map;
            // import java.util.Map$Entry as java.util.Map.Entry;
            
            StringBuilder sb        = new StringBuilder();
            Map           mapUpdate = getUpdateMap();
            
            sb.append("\nOwnership Assignments={");
            for (Iterator iter = mapUpdate.entrySet().iterator(); iter.hasNext(); )
                {
                java.util.Map.Entry        entry  = (java.util.Map.Entry) iter.next();
                Ownership    owners = (Ownership) entry.getKey();
                PartitionSet parts  = (PartitionSet) entry.getValue();
            
                sb.append("\n  ")
                  .append(parts)
                  .append("=")
                  .append(owners);
                }
            sb.append("}");
            
            return sb.toString();
            }
        
        // Accessor for the property "TargetStrength"
        /**
         * Getter for property TargetStrength.<p>
         */
        public int getTargetStrength()
            {
            return __m_TargetStrength;
            }
        
        // Accessor for the property "UpdateMap"
        /**
         * Getter for property UpdateMap.<p>
        * The Map<Ownership, PartitionSet> holding the distribution plan update
        * (delta).
         */
        public java.util.Map getUpdateMap()
            {
            return __m_UpdateMap;
            }
        
        // Declared at the super level
        /**
         * This is the event that is executed when a Message is received.
        * <p>
        * It is the main processing event of the Message called by the
        * <code>Service.onMessage()</code> event. With regards to the use of
        * Message components within clustered Services, Services are designed
        * by dragging Message components into them as static children. These
        * Messages are the components that a Service can send to other running
        * instances of the same Service within a cluster. When the onReceived
        * event is invoked by a Service, it means that the Message has been
        * received; the code in the onReceived event is therefore the Message
        * specific logic for processing a received Message. For example, when
        * onReceived is invoked on a Message named FindData, the onReceived
        * event should do the work to "find the data", because it is being
        * invoked by the Service that received the "find the data" Message.
         */
        public void onReceived()
            {
            PartitionedService service = (PartitionedService) get_Module();
            service.getDistributionStrategy().onDistributionPlanUpdate(this);
            }
        
        // Declared at the super level
        public void read(com.tangosol.io.ReadBuffer.BufferInput input)
                throws java.io.IOException
            {
            // import com.tangosol.net.partition.Ownership;
            // import com.tangosol.net.partition.PartitionSet;
            // import com.tangosol.util.ExternalizableHelper;
            // import java.util.HashMap;
            // import java.util.Map;
            
            super.read(input);
            
            setTargetStrength(ExternalizableHelper.readInt(input));
            
            int cEntries  = ExternalizableHelper.readInt(input);
            Map mapUpdate = new HashMap();
            for (int i = 0; i < cEntries; i++)
                {
                Ownership    owners = new Ownership();
                PartitionSet parts  = new PartitionSet();
            
                owners.readExternal(input);
                parts .readExternal(input);
            
                mapUpdate.put(owners, parts);
                }
            
            setUpdateMap(mapUpdate);
            }
        
        // Accessor for the property "TargetStrength"
        /**
         * Setter for property TargetStrength.<p>
         */
        public void setTargetStrength(int nStrength)
            {
            __m_TargetStrength = nStrength;
            }
        
        // Accessor for the property "UpdateMap"
        /**
         * Setter for property UpdateMap.<p>
        * The Map<Ownership, PartitionSet> holding the distribution plan update
        * (delta).
         */
        public void setUpdateMap(java.util.Map mapUpdate)
            {
            __m_UpdateMap = mapUpdate;
            }
        
        // Declared at the super level
        public void write(com.tangosol.io.WriteBuffer.BufferOutput output)
                throws java.io.IOException
            {
            // import com.tangosol.net.partition.Ownership;
            // import com.tangosol.net.partition.PartitionSet;
            // import com.tangosol.util.ExternalizableHelper;
            // import java.util.Iterator;
            // import java.util.Map;
            // import java.util.Map$Entry as java.util.Map.Entry;
            
            super.write(output);
            
            PartitionedService service   = (PartitionedService) getService();
            Map     mapUpdate = getUpdateMap();
            
            ExternalizableHelper.writeInt(output, getTargetStrength());
            ExternalizableHelper.writeInt(output, mapUpdate.size());
            for (Iterator iter = mapUpdate.entrySet().iterator(); iter.hasNext(); )
                {
                java.util.Map.Entry        entry  = (java.util.Map.Entry) iter.next();
                Ownership    owners = (Ownership) entry.getKey();
                PartitionSet parts  = (PartitionSet) entry.getValue();
            
                owners.writeExternal(output);
                parts .writeExternal(output);
                }
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService$DistributionRequest
    
    /**
     * Suggest a redistribution of PartitionCount partitions from the message
     * receipient to the message sender.
     * 
     * In response to this message the recepient is expected to send
     * partitions' data using TransferRequests.
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class DistributionRequest
            extends    com.tangosol.coherence.component.net.message.RequestMessage
        {
        // ---- Fields declarations ----
        
        /**
         * Property PartitionCount
         *
         */
        private int __m_PartitionCount;
        
        /**
         * Property Partitions
         *
         */
        private com.tangosol.net.partition.PartitionSet __m_Partitions;
        
        /**
         * Property SourceMember
         *
         * The member that this DistributionRequest is requesting distribution
         * from.
         */
        private transient com.tangosol.coherence.component.net.Member __m_SourceMember;
        private static com.tangosol.util.ListMap __mapChildren;
        
        // Static initializer
        static
            {
            __initStatic();
            }
        
        // Default static initializer
        private static void __initStatic()
            {
            // register child classes
            __mapChildren = new com.tangosol.util.ListMap();
            __mapChildren.put("Poll", PartitionedService.DistributionRequest.Poll.get_CLASS());
            }
        
        // Default constructor
        public DistributionRequest()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public DistributionRequest(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                setMessageType(35);
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // containment initialization: children
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.DistributionRequest();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/PartitionedService$DistributionRequest".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        //++ getter for autogen property _ChildClasses
        /**
         * This is an auto-generated method that returns the map of design time
        * [static] children.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        protected java.util.Map get_ChildClasses()
            {
            return __mapChildren;
            }
        
        // Accessor for the property "PartitionCount"
        /**
         * Getter for property PartitionCount.<p>
         */
        public int getPartitionCount()
            {
            return __m_PartitionCount;
            }
        
        // Accessor for the property "Partitions"
        /**
         * Getter for property Partitions.<p>
         */
        public com.tangosol.net.partition.PartitionSet getPartitions()
            {
            return __m_Partitions;
            }
        
        // Accessor for the property "SourceMember"
        /**
         * Getter for property SourceMember.<p>
        * The member that this DistributionRequest is requesting distribution
        * from.
         */
        public com.tangosol.coherence.component.net.Member getSourceMember()
            {
            return __m_SourceMember;
            }
        
        // Declared at the super level
        protected com.tangosol.coherence.component.net.Poll instantiatePoll()
            {
            // import Component.Net.Poll as com.tangosol.coherence.component.net.Poll;
            
            return (com.tangosol.coherence.component.net.Poll) _newChild("Poll");
            }
        
        // Declared at the super level
        /**
         * This is the event that is executed when a Message is received.
        * <p>
        * It is the main processing event of the Message called by the
        * <code>Service.onMessage()</code> event. With regards to the use of
        * Message components within clustered Services, Services are designed
        * by dragging Message components into them as static children. These
        * Messages are the components that a Service can send to other running
        * instances of the same Service within a cluster. When the onReceived
        * event is invoked by a Service, it means that the Message has been
        * received; the code in the onReceived event is therefore the Message
        * specific logic for processing a received Message. For example, when
        * onReceived is invoked on a Message named FindData, the onReceived
        * event should do the work to "find the data", because it is being
        * invoked by the Service that received the "find the data" Message.
         */
        public void onReceived()
            {
            super.onReceived();
            
            ((PartitionedService) getService()).getDistributionStrategy().onDistributionRequest(this);
            }
        
        // Declared at the super level
        public void read(com.tangosol.io.ReadBuffer.BufferInput input)
                throws java.io.IOException
            {
            // import com.tangosol.net.partition.PartitionSet;
            // import com.tangosol.util.ExternalizableHelper;
            
            super.read(input);
            
            setPartitionCount(ExternalizableHelper.readInt(input));
            
            PartitionSet parts = new PartitionSet();
            parts.readExternal(input);
            setPartitions(parts);
            }
        
        // Accessor for the property "PartitionCount"
        /**
         * Setter for property PartitionCount.<p>
         */
        public void setPartitionCount(int cBuckets)
            {
            __m_PartitionCount = cBuckets;
            }
        
        // Accessor for the property "Partitions"
        /**
         * Setter for property Partitions.<p>
         */
        public void setPartitions(com.tangosol.net.partition.PartitionSet pPartitions)
            {
            __m_Partitions = pPartitions;
            }
        
        // Accessor for the property "SourceMember"
        /**
         * Setter for property SourceMember.<p>
        * The member that this DistributionRequest is requesting distribution
        * from.
         */
        public void setSourceMember(com.tangosol.coherence.component.net.Member member)
            {
            __m_SourceMember = member;
            }
        
        // Declared at the super level
        public void write(com.tangosol.io.WriteBuffer.BufferOutput output)
                throws java.io.IOException
            {
            // import com.tangosol.util.ExternalizableHelper;
            
            super.write(output);
            
            ExternalizableHelper.writeInt(output, getPartitionCount());
            getPartitions().writeExternal(output);
            }

        // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService$DistributionRequest$Poll
        
        /**
         * The Poll contains information regarding a request sent to one or
         * more Cluster Members that require responses. A Service may poll
         * other Members that are running the same Service, and the Poll is
         * used to wait for and assemble the responses from each of those
         * Members. A client thread may also use the Poll to block on a
         * response or set of responses, thus waiting for the completion of the
         * Poll. In its simplest form, which is a Poll that is sent to one
         * Member of the Cluster, the Poll actually represents the
         * request/response model
         */
        @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
        public static class Poll
                extends    com.tangosol.coherence.component.net.Poll
            {
            // ---- Fields declarations ----
            
            // Default constructor
            public Poll()
                {
                this(null, null, true);
                }
            
            // Initializing constructor
            public Poll(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                {
                super(sName, compParent, false);
                
                if (fInit)
                    {
                    __init();
                    }
                }
            
            // Main initializer
            public void __init()
                {
                // private initialization
                __initPrivate();
                
                
                // signal the end of the initialization
                set_Constructed(true);
                }
            
            // Private initializer
            protected void __initPrivate()
                {
                
                super.__initPrivate();
                }
            
            //++ getter for static property _Instance
            /**
             * Getter for property _Instance.<p>
            * Auto generated
             */
            public static com.tangosol.coherence.Component get_Instance()
                {
                return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.DistributionRequest.Poll();
                }
            
            //++ getter for static property _CLASS
            /**
             * Getter for property _CLASS.<p>
            * Property with auto-generated accessor that returns the Class
            * object for a given component.
             */
            public static Class get_CLASS()
                {
                Class clz;
                try
                    {
                    clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/PartitionedService$DistributionRequest$Poll".replace('/', '.'));
                    }
                catch (ClassNotFoundException e)
                    {
                    throw new NoClassDefFoundError(e.getMessage());
                    }
                return clz;
                }
            
            //++ getter for autogen property _Module
            /**
             * This is an auto-generated method that returns the global [design
            * time] parent component.
            * 
            * Note: the class generator will ignore any custom implementation
            * for this behavior.
             */
            private com.tangosol.coherence.Component get_Module()
                {
                return this.get_Parent().get_Parent();
                }
            
            // Declared at the super level
            /**
             * This is the event that is executed when all the Members that were
            * polled have responded or have left the Service.
             */
            protected void onCompletion()
                {
                Integer IResult = (Integer) getResult();
                int     iResult = IResult == null ? PartitionedService.Response.RESULT_FAILURE : IResult.intValue();
                
                if (iResult == PartitionedService.Response.RESULT_FAILURE)
                    {
                    ((PartitionedService) getService()).getDistributionStrategy().onDistributionCompleted(
                            ((PartitionedService.DistributionRequest) get_Parent()).getSourceMember(), /*fSuccess*/ false);
                    }
                else
                    {
                    // as of Coherence 3.7.1, successful completion of the distribution request
                    // is deferred until after event interceptors are fired
                    // (see #onFinalizeReceiveTransfer)
                    }
                
                super.onCompletion();
                }
            
            // Declared at the super level
            /**
             * This event occurs for each response Message from each polled
            * Member.
             */
            public void onResponse(com.tangosol.coherence.component.net.Message msg)
                {
                if (msg instanceof PartitionedService.TransferRequest)
                    {
                    PartitionedService.TransferRequest msgTransfer = (PartitionedService.TransferRequest) msg;
                    if (!msgTransfer.isLastInTransfer())
                        {
                        // keep the poll open (and defer setting the "result")
                        // until the last transfer
                        return;
                        }
                
                    if (((PartitionedService) getService()).isOwnershipEnabled())
                        {
                        setResult(Integer.valueOf(PartitionedService.Response.RESULT_SUCCESS));
                        }
                    else
                        {
                        // this member has stopped accepting ownership (see #shutdown);
                        // mark the distribution as failed
                        setResult(Integer.valueOf(PartitionedService.Response.RESULT_FAILURE));
                        }
                    }
                else
                    {
                    // this is just a trivial response indicating a rejection
                    // by the source member
                    setResult(Integer.valueOf(PartitionedService.Response.RESULT_FAILURE));
                    }
                
                // close the poll
                super.onResponse(msg);
                }
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService$MemberConfigListener
    
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class MemberConfigListener
            extends    com.tangosol.coherence.component.util.daemon.queueProcessor.service.Grid.MemberConfigListener
        {
        // ---- Fields declarations ----
        
        // Default constructor
        public MemberConfigListener()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public MemberConfigListener(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.MemberConfigListener();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/PartitionedService$MemberConfigListener".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        // Declared at the super level
        public void onEvent(com.tangosol.util.MapEvent event)
            {
            super.onEvent(event);
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService$MemberConfigUpdate
    
    /**
     * This Message is sent to all other Members running this service to inform
     * them of a change to this Member's ConfigMap for this Service.
     * 
     * Attributes:
     *     Key
     *     Value
     *     Remove
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class MemberConfigUpdate
            extends    com.tangosol.coherence.component.util.daemon.queueProcessor.service.Grid.MemberConfigUpdate
        {
        // ---- Fields declarations ----
        
        // Default constructor
        public MemberConfigUpdate()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public MemberConfigUpdate(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                setMessageType(-3);
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.MemberConfigUpdate();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/PartitionedService$MemberConfigUpdate".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        // Declared at the super level
        /**
         * This is the event that is executed when a Message is received.
        * <p>
        * It is the main processing event of the Message called by the
        * <code>Service.onMessage()</code> event. With regards to the use of
        * Message components within clustered Services, Services are designed
        * by dragging Message components into them as static children. These
        * Messages are the components that a Service can send to other running
        * instances of the same Service within a cluster. When the onReceived
        * event is invoked by a Service, it means that the Message has been
        * received; the code in the onReceived event is therefore the Message
        * specific logic for processing a received Message. For example, when
        * onReceived is invoked on a Message named FindData, the onReceived
        * event should do the work to "find the data", because it is being
        * invoked by the Service that received the "find the data" Message.
         */
        public void onReceived()
            {
            // import com.tangosol.net.MemberEvent;
            // import com.tangosol.util.Base;
            
            super.onReceived();
            
            PartitionedService service = (PartitionedService) getService();
            
            if (service.isAcceptingClients() &&
                service.isOwnershipEnabled() &&
                Base.equals("ownership-enabled", getKey()) &&
                Base.equals(Integer.valueOf(PartitionedService.OWNERSHIP_ENABLED), getValue()))
                {
                // the sending member has finished starting up and has declared
                // itself ownership-enabled (ready to receive distribution);
                // notify the distribution strategy and persistence control
            
                service.getDistributionStrategy().onMembershipChanged(MemberEvent.MEMBER_JOINED);
                service.getPersistenceControl().onMembershipChanged(MemberEvent.MEMBER_JOINED);
                }
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService$MemberWelcome
    
    /**
     * This Message is used to welcome a new member into this Service.
     * 
     * Attributes:
     *     MemberConfigMap
     *     ServiceConfigMap  (optional)
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class MemberWelcome
            extends    com.tangosol.coherence.component.util.daemon.queueProcessor.service.Grid.MemberWelcome
        {
        // ---- Fields declarations ----
        
        /**
         * Property PartitionConfigMap
         *
         * The partition configuration, sent by the partition configuration
         * coordinator.  May be null.
         */
        private java.util.Map __m_PartitionConfigMap;
        
        // Default constructor
        public MemberWelcome()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public MemberWelcome(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                setMessageType(-2);
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.MemberWelcome();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/PartitionedService$MemberWelcome".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        // Declared at the super level
        /**
         * Getter for property Description.<p>
        * Used for debugging purposes (from toString). Create a human-readable
        * description of the specific Message data.
         */
        public String getDescription()
            {
            return super.getDescription() + ", PartitionConfig=" + getPartitionConfigMap();
            }
        
        // Accessor for the property "PartitionConfigMap"
        /**
         * Getter for property PartitionConfigMap.<p>
        * The partition configuration, sent by the partition configuration
        * coordinator.  May be null.
         */
        public java.util.Map getPartitionConfigMap()
            {
            return __m_PartitionConfigMap;
            }
        
        // Declared at the super level
        /**
         * This is the event that is executed when a Message is received.
        * <p>
        * It is the main processing event of the Message called by the
        * <code>Service.onMessage()</code> event. With regards to the use of
        * Message components within clustered Services, Services are designed
        * by dragging Message components into them as static children. These
        * Messages are the components that a Service can send to other running
        * instances of the same Service within a cluster. When the onReceived
        * event is invoked by a Service, it means that the Message has been
        * received; the code in the onReceived event is therefore the Message
        * specific logic for processing a received Message. For example, when
        * onReceived is invoked on a Message named FindData, the onReceived
        * event should do the work to "find the data", because it is being
        * invoked by the Service that received the "find the data" Message.
         */
        public void onReceived()
            {
            // import java.util.Map;
            
            super.onReceived();
            
            PartitionedService service   = (PartitionedService) getService();
            Map     mapConfig = getPartitionConfigMap();
            
            _trace("Received MemberWelcome from member " + getFromMember().getId() +
                   ", memberConfigMap: " + getMemberConfigMap() +
                   ", serviceConfigMap: " + getServiceConfigMap() +
                   ", partitionConfigMap: " + mapConfig, 7);
            
            if (mapConfig != null)
                {
                // set the PartitionConfigMap contents
                service.getPartitionConfigMap().updateInternal(mapConfig, false);
                }
            }
        
        // Declared at the super level
        public void read(com.tangosol.io.ReadBuffer.BufferInput input)
                throws java.io.IOException
            {
            // import Component.Util.ServiceConfig as com.tangosol.coherence.component.util.ServiceConfig;
            // import java.io.IOException;
            // import java.util.HashMap;
            // import java.util.Map;
            
            super.read(input);
            
            if (isRejected())
                {
                return;
                }
            
            PartitionedService service = (PartitionedService) getService();
            
            try
                {
                Map     mapConfig        = null;
                boolean fPartitionConfig = input.readBoolean();
                if (fPartitionConfig)
                    {
                    com.tangosol.coherence.component.util.ServiceConfig cfgPartition = service.getPartitionConfigMap().getConfig();
            
                    mapConfig = new HashMap();
            
                    // read the partition config map
                    for (int i = 0, c = input.readInt(); i < c; ++i)
                        {
                        // Note: we use the PartitionedService.PartitionConfig to deserialize the contents,
                        //       but we read the map contents into a temporary map for 
                        //       later processing (see #onReceived())
                        Object oKey   = cfgPartition.readObject(input);
                        Object oValue = cfgPartition.readObject(input);
                        mapConfig.put(oKey, oValue);
                        }
                    }
            
                setPartitionConfigMap(mapConfig);
                }
            catch (IOException e)
                {
                service.onConfigIOException(e, getFromMember());
                }
            }
        
        // Accessor for the property "PartitionConfigMap"
        /**
         * Setter for property PartitionConfigMap.<p>
        * The partition configuration, sent by the partition configuration
        * coordinator.  May be null.
         */
        public void setPartitionConfigMap(java.util.Map mapConfig)
            {
            __m_PartitionConfigMap = mapConfig;
            }
        
        // Declared at the super level
        public void write(com.tangosol.io.WriteBuffer.BufferOutput output)
                throws java.io.IOException
            {
            // import Component.Util.ServiceConfig as com.tangosol.coherence.component.util.ServiceConfig;
            // import java.util.Iterator;
            // import java.util.Map;
            // import java.util.Map$Entry as java.util.Map.Entry;
            
            super.write(output);
            
            if (isRejected())
                {
                return;
                }
            
            PartitionedService service   = (PartitionedService) getService();
            Map     mapConfig = getPartitionConfigMap();
            
            // write the partition config map
            if (mapConfig == null)
                {
                output.writeBoolean(false);
                }
            else
                {
                com.tangosol.coherence.component.util.ServiceConfig cfgPartition = service.getPartitionConfigMap().getConfig();
            
                output.writeBoolean(true);
                output.writeInt(mapConfig.size());
                for (Iterator iter = mapConfig.entrySet().iterator(); iter.hasNext(); )
                    {
                    java.util.Map.Entry entry = (java.util.Map.Entry) iter.next();
            
                    cfgPartition.writeObject(output, entry.getKey());
                    cfgPartition.writeObject(output, entry.getValue());
                    }
                }
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService$MemberWelcomeRequest
    
    /**
     * This Message is sent to all other Members running this service to
     * request their up-to-date Member ConfigMap for this Service.
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class MemberWelcomeRequest
            extends    com.tangosol.coherence.component.util.daemon.queueProcessor.service.Grid.MemberWelcomeRequest
        {
        // ---- Fields declarations ----
        private static com.tangosol.util.ListMap __mapChildren;
        
        // Static initializer
        static
            {
            __initStatic();
            }
        
        // Default static initializer
        private static void __initStatic()
            {
            // register child classes
            __mapChildren = new com.tangosol.util.ListMap();
            __mapChildren.put("Poll", com.tangosol.coherence.component.util.daemon.queueProcessor.service.Grid.MemberWelcomeRequest.Poll.get_CLASS());
            }
        
        // Default constructor
        public MemberWelcomeRequest()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public MemberWelcomeRequest(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                setMessageType(-1);
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // containment initialization: children
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.MemberWelcomeRequest();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/PartitionedService$MemberWelcomeRequest".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        //++ getter for autogen property _ChildClasses
        /**
         * This is an auto-generated method that returns the map of design time
        * [static] children.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        protected java.util.Map get_ChildClasses()
            {
            return __mapChildren;
            }
        
        // Declared at the super level
        /**
         * Populate and return the WelcomeMember message to respond to this
        * welcome request with.
         */
        protected com.tangosol.coherence.component.util.daemon.queueProcessor.service.Grid.MemberWelcome populateWelcomeMessage()
            {
            // import Component.Util.ServiceConfig$Map as com.tangosol.coherence.component.util.ServiceConfig.Map;
            // import java.util.HashMap;
            
            PartitionedService.MemberWelcome msgWelcome = (PartitionedService.MemberWelcome) super.populateWelcomeMessage();
            if (!msgWelcome.isRejected())
                {
                PartitionedService   service            = (PartitionedService) getService();
                com.tangosol.coherence.component.util.ServiceConfig.Map mapPartitionConfig = service.getPartitionConfigMap();
            
                if (service.getThisMember() == mapPartitionConfig.getConfigCoordinator())
                    {
                    // if we are the partition config coordinator, send the partition config as well
            
                    if (service.isVersionCompatible(msgWelcome.getToMemberSet(), 12, 2, 1, 1, 0))
                        {
                        msgWelcome.setPartitionConfigMap(mapPartitionConfig);
                        }
                    else
                        {
                        // prior to 12.2.1.1.0 Binary objects could not be placed in the PartitionConfig
                        // so we need to remove it before sending out
            
                        HashMap mapClone = new HashMap(mapPartitionConfig);
            
                        mapClone.remove(PartitionedService.PartitionConfig.KEY_QUORUM);
            
                        msgWelcome.setPartitionConfigMap(mapClone);
                        }
                    }
                }
            
            return msgWelcome;
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService$NotifyServiceLeaving
    
    /**
     * This internal Message is sent to a service when a cluster Member that
     * previously exposed the same service will no longer expose the same
     * service (potentially because the Member is leaving the cluster). In
     * other words, if cluster Members are (A, B, C) and each has a service #3,
     * and C subsequently announces that it is leaving the cluster, then the
     * service #3 on (A, B) will be notified that C will no longer have a
     * service #3.
     * 
     * Attributes:
     *     NotifyMember
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class NotifyServiceLeaving
            extends    com.tangosol.coherence.component.util.daemon.queueProcessor.service.Grid.NotifyServiceLeaving
        {
        // ---- Fields declarations ----
        
        // Default constructor
        public NotifyServiceLeaving()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public NotifyServiceLeaving(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                setMessageType(-11);
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.NotifyServiceLeaving();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/PartitionedService$NotifyServiceLeaving".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        // Declared at the super level
        /**
         * This is the event that is executed when a Message is received.
        * <p>
        * It is the main processing event of the Message called by the
        * <code>Service.onMessage()</code> event. With regards to the use of
        * Message components within clustered Services, Services are designed
        * by dragging Message components into them as static children. These
        * Messages are the components that a Service can send to other running
        * instances of the same Service within a cluster. When the onReceived
        * event is invoked by a Service, it means that the Message has been
        * received; the code in the onReceived event is therefore the Message
        * specific logic for processing a received Message. For example, when
        * onReceived is invoked on a Message named FindData, the onReceived
        * event should do the work to "find the data", because it is being
        * invoked by the Service that received the "find the data" Message.
         */
        public void onReceived()
            {
            super.onReceived();
            
            ((PartitionedService) getService()).onNotifyServiceLeaving(getNotifyMember());
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService$NotifyServiceQuiescence
    
    /**
     * This internal Message is sent to a service when a cluster Member has
     * requested this service to be suspended or resumed (cluster-wide).
     * 
     * This notification is a poll that is sent by the ClusterService.  The
     * service quiescence protocol will be blocked until this service closes
     * the underlying poll.
     * 
     * Attributes:
     *     ContinuationMessage
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class NotifyServiceQuiescence
            extends    com.tangosol.coherence.component.util.daemon.queueProcessor.service.Grid.NotifyServiceQuiescence
        {
        // ---- Fields declarations ----
        private static com.tangosol.util.ListMap __mapChildren;
        
        // Static initializer
        static
            {
            __initStatic();
            }
        
        // Default static initializer
        private static void __initStatic()
            {
            // register child classes
            __mapChildren = new com.tangosol.util.ListMap();
            __mapChildren.put("Poll", com.tangosol.coherence.component.util.daemon.queueProcessor.service.Grid.NotifyServiceQuiescence.Poll.get_CLASS());
            }
        
        // Default constructor
        public NotifyServiceQuiescence()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public NotifyServiceQuiescence(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                setMessageType(-22);
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // containment initialization: children
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.NotifyServiceQuiescence();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/PartitionedService$NotifyServiceQuiescence".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        //++ getter for autogen property _ChildClasses
        /**
         * This is an auto-generated method that returns the map of design time
        * [static] children.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        protected java.util.Map get_ChildClasses()
            {
            return __mapChildren;
            }
        
        // Declared at the super level
        /**
         * Getter for property ResumeOnFailover.<p>
        * Flag that indicates whether the target service(s) should be resumed
        * upon failover.
        * 
        * Specifically this indicates that the suspension of a service was
        * synthetically induced and therefore should be automatically resumed
        * in the case of senior departure.
         */
        public boolean isResumeOnFailover()
            {
            return super.isResumeOnFailover();
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService$NotifyShutdown
    
    /**
     * This internal Message is sent to a Service it is supposed to shut down.
     * The Service must clean up and unregister itself. Note that the only task
     * of the shut-down is to begin the process of shutting down the service;
     * technically the Service does not have to be stopped by the time the
     * shutdown Message completes its processing, although the default
     * implementation does stop it immediately.
     * 
     * Attributes:
     *     n/a
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class NotifyShutdown
            extends    com.tangosol.coherence.component.util.daemon.queueProcessor.service.Grid.NotifyShutdown
        {
        // ---- Fields declarations ----
        
        // Default constructor
        public NotifyShutdown()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public NotifyShutdown(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                setMessageType(-13);
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.NotifyShutdown();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/PartitionedService$NotifyShutdown".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        // Declared at the super level
        /**
         * This is the event that is executed when a Message is received.
        * <p>
        * It is the main processing event of the Message called by the
        * <code>Service.onMessage()</code> event. With regards to the use of
        * Message components within clustered Services, Services are designed
        * by dragging Message components into them as static children. These
        * Messages are the components that a Service can send to other running
        * instances of the same Service within a cluster. When the onReceived
        * event is invoked by a Service, it means that the Message has been
        * received; the code in the onReceived event is therefore the Message
        * specific logic for processing a received Message. For example, when
        * onReceived is invoked on a Message named FindData, the onReceived
        * event should do the work to "find the data", because it is being
        * invoked by the Service that received the "find the data" Message.
         */
        public void onReceived()
            {
            ((PartitionedService) getService()).onNotifyShutdown();
            
            // do not call super.onReceived() to prevent stopping
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService$NotifySnapshotRecoverRequest
    
    /**
     * This internal Message initiates the Ownership protocol on the service
     * thread for the associated service.
     * 
     * Attributes:
     *     SnapshotName
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class NotifySnapshotRecoverRequest
            extends    com.tangosol.coherence.component.net.Message
        {
        // ---- Fields declarations ----
        
        /**
         * Property SnapshotName
         *
         * The name of snapshot to recover from.
         */
        private String __m_SnapshotName;
        
        // Default constructor
        public NotifySnapshotRecoverRequest()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public NotifySnapshotRecoverRequest(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                setMessageType(44);
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.NotifySnapshotRecoverRequest();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/PartitionedService$NotifySnapshotRecoverRequest".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        // Accessor for the property "SnapshotName"
        /**
         * Getter for property SnapshotName.<p>
        * The name of snapshot to recover from.
         */
        public String getSnapshotName()
            {
            return __m_SnapshotName;
            }
        
        // Declared at the super level
        /**
         * This is the event that is executed when a Message is received.
        * <p>
        * It is the main processing event of the Message called by the
        * <code>Service.onMessage()</code> event. With regards to the use of
        * Message components within clustered Services, Services are designed
        * by dragging Message components into them as static children. These
        * Messages are the components that a Service can send to other running
        * instances of the same Service within a cluster. When the onReceived
        * event is invoked by a Service, it means that the Message has been
        * received; the code in the onReceived event is therefore the Message
        * specific logic for processing a received Message. For example, when
        * onReceived is invoked on a Message named FindData, the onReceived
        * event should do the work to "find the data", because it is being
        * invoked by the Service that received the "find the data" Message.
         */
        public void onReceived()
            {
            ((PartitionedService) getService()).onNotifySnapshotRecoverRequest(getSnapshotName());
            }
        
        // Accessor for the property "SnapshotName"
        /**
         * Setter for property SnapshotName.<p>
        * The name of snapshot to recover from.
         */
        public void setSnapshotName(String sName)
            {
            __m_SnapshotName = sName;
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService$OwnershipRequest
    
    /**
     * Poll message that requests an ownership info. This poll can only come
     * from the ownership senior member.
     * 
     * First, the senior issues this request with Query flag set to true.
     * Recipients respond to this message with the local copy of the partition
     * assignment array.  Any response that is showing discrepancies in
     * understanding what orphan partitions are will force another poll.
     * 
     * When everyone agrees on what the orphaned partitions are (or timeout
     * occurs), the senior member issues another request with Query flag set
     * false, at which point everyone 
     * assumes the ownership for all the backed up partitions. The senior then
     * takes over all the partitions that are still orphaned.
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class OwnershipRequest
            extends    com.tangosol.coherence.component.net.message.RequestMessage
        {
        // ---- Fields declarations ----
        
        /**
         * Property ConflictResolver
         *
         * The ownership conflict resolver.  The (transient) resolver is used
         * to record and resolve conflicts between the partition assignments
         * reported by each member.
         */
        private transient com.tangosol.internal.util.OwnershipConflictResolver __m_ConflictResolver;
        
        /**
         * Property PersistentIdResolver
         *
         * The GUID resolver.  The (transient) resolver is used only if
         * RecoveryRequested to register and resolve the sets of PersistentIds
         * reported by each member.
         */
        private transient com.tangosol.persistence.GUIDHelper.GUIDResolver __m_PersistentIdResolver;
        
        /**
         * Property Query
         *
         * True iff this $OwnershipRequest represents the "query" phase of the
         * protocol, requiring recipients to respond to this message with their
         * local copy of the partition assignment array.
         * 
         * If false, this $OwnershipRequest represents the "restore" phase of
         * the protocol, which instructs recipients to retore partitions from
         * backup.
         */
        private boolean __m_Query;
        
        /**
         * Property QuorumInfo
         *
         * The "last good" view of the ownership data.  This QuorumInfo is only
         * used for active persistence with "no-orphan" mode and retrieved from
         * the "global" partitoin during the recovery phase.
         */
        private com.tangosol.net.internal.QuorumInfo __m_QuorumInfo;
        
        /**
         * Property RecoveryPartitions
         *
         * The set of partitions that need to be recovered.  Recipients of this
         * OwnershipRequest should reply with the persistent GUIDs for these
         * partitions in order to determine how to recover (or assign) the
         * partition ownership.
         */
        private com.tangosol.net.partition.PartitionSet __m_RecoveryPartitions;
        
        /**
         * Property REQUEST_COUNT_THRESHOLD
         *
         * How many Ownsership request cycles should be attempted before we
         * force the re-publishing by responder.
         * 
         * As of Coherence 3.2 (2006.08.19), all available tests show that this
         * logic is never invoked, but we keep it as a safety against
         * re-occurences of COH-635 type syndrom.
         */
        public static final int REQUEST_COUNT_THRESHOLD = 4;
        
        /**
         * Property RequestAssignments
         *
         * Requestor's partition assignments.
         * 
         * The RequestAssignments are used in the request phase (if the number
         * of attempts exceeds the threshold) in order to force a conflict
         * resolution.  During the restore phase, they are used to ensure that
         * the resolved assignments are properly restored (see COH-6421).
         */
        private int[][] __m_RequestAssignments;
        
        /**
         * Property RequestCount
         *
         * Requestor's OwnershipInProgress count.
         */
        private transient int __m_RequestCount;
        
        /**
         * Property RestorePartitions
         *
         * The (transient) set of partitions that need to be restored.
         * 
         * see #onFinalizeRestorePrimary
         */
        private com.tangosol.net.partition.PartitionSet __m_RestorePartitions;
        
        /**
         * Property SenderMemberSet
         *
         * The sender's view of the ownership member-set.  This is used to
         * enforce a "synchronized" view of the ownership member-set during the
         * ownership protocol.
         */
        private com.tangosol.coherence.component.net.MemberSet __m_SenderMemberSet;
        
        /**
         * Property SnapshotToRecover
         *
         * The name of the persistent snapshot to recover from, or null to
         * recover from the "active" persistence manager.
         */
        private String __m_SnapshotToRecover;
        private static com.tangosol.util.ListMap __mapChildren;
        
        // Static initializer
        static
            {
            __initStatic();
            }
        
        // Default static initializer
        private static void __initStatic()
            {
            // register child classes
            __mapChildren = new com.tangosol.util.ListMap();
            __mapChildren.put("Poll", PartitionedService.OwnershipRequest.Poll.get_CLASS());
            }
        
        // Default constructor
        public OwnershipRequest()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public OwnershipRequest(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                setMessageType(33);
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // containment initialization: children
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.OwnershipRequest();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/PartitionedService$OwnershipRequest".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        //++ getter for autogen property _ChildClasses
        /**
         * This is an auto-generated method that returns the map of design time
        * [static] children.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        protected java.util.Map get_ChildClasses()
            {
            return __mapChildren;
            }
        
        // Accessor for the property "ConflictResolver"
        /**
         * Getter for property ConflictResolver.<p>
        * The ownership conflict resolver.  The (transient) resolver is used to
        * record and resolve conflicts between the partition assignments
        * reported by each member.
         */
        public com.tangosol.internal.util.OwnershipConflictResolver getConflictResolver()
            {
            // import com.tangosol.internal.util.OwnershipConflictResolver;
            
            OwnershipConflictResolver resolver = __m_ConflictResolver;
            if (resolver == null)
                {
                PartitionedService service = (PartitionedService) getService();
            
                resolver = new OwnershipConflictResolver(
                        service.getPartitionCount(), service.getBackupCount());
                setConflictResolver(resolver);
                }
            
            return resolver;
            }
        
        // Accessor for the property "PersistentIdResolver"
        /**
         * Getter for property PersistentIdResolver.<p>
        * The GUID resolver.  The (transient) resolver is used only if
        * RecoveryRequested to register and resolve the sets of PersistentIds
        * reported by each member.
         */
        public com.tangosol.persistence.GUIDHelper.GUIDResolver getPersistentIdResolver()
            {
            // import com.tangosol.persistence.GUIDHelper$GUIDResolver as com.tangosol.persistence.GUIDHelper.GUIDResolver;
            
            com.tangosol.persistence.GUIDHelper.GUIDResolver resolver = __m_PersistentIdResolver;
            if (resolver == null)
                {
                resolver = new com.tangosol.persistence.GUIDHelper.GUIDResolver(((PartitionedService) getService()).getPartitionCount());
                setPersistentIdResolver(resolver);
                }
            
            return resolver;
            }
        
        // Accessor for the property "QuorumInfo"
        /**
         * Getter for property QuorumInfo.<p>
        * The "last good" view of the ownership data.  This QuorumInfo is only
        * used for active persistence with "no-orphan" mode and retrieved from
        * the "global" partitoin during the recovery phase.
         */
        public com.tangosol.net.internal.QuorumInfo getQuorumInfo()
            {
            return __m_QuorumInfo;
            }
        
        // Accessor for the property "RecoveryPartitions"
        /**
         * Getter for property RecoveryPartitions.<p>
        * The set of partitions that need to be recovered.  Recipients of this
        * OwnershipRequest should reply with the persistent GUIDs for these
        * partitions in order to determine how to recover (or assign) the
        * partition ownership.
         */
        public com.tangosol.net.partition.PartitionSet getRecoveryPartitions()
            {
            return __m_RecoveryPartitions;
            }
        
        // Accessor for the property "RequestAssignments"
        /**
         * Getter for property RequestAssignments.<p>
        * Requestor's partition assignments.
        * 
        * The RequestAssignments are used in the request phase (if the number
        * of attempts exceeds the threshold) in order to force a conflict
        * resolution.  During the restore phase, they are used to ensure that
        * the resolved assignments are properly restored (see COH-6421).
         */
        public int[][] getRequestAssignments()
            {
            return __m_RequestAssignments;
            }
        
        // Accessor for the property "RequestCount"
        /**
         * Getter for property RequestCount.<p>
        * Requestor's OwnershipInProgress count.
         */
        public int getRequestCount()
            {
            return __m_RequestCount;
            }
        
        // Accessor for the property "RestorePartitions"
        /**
         * Getter for property RestorePartitions.<p>
        * The (transient) set of partitions that need to be restored.
        * 
        * see #onFinalizeRestorePrimary
         */
        public com.tangosol.net.partition.PartitionSet getRestorePartitions()
            {
            return __m_RestorePartitions;
            }
        
        // Accessor for the property "SenderMemberSet"
        /**
         * Getter for property SenderMemberSet.<p>
        * The sender's view of the ownership member-set.  This is used to
        * enforce a "synchronized" view of the ownership member-set during the
        * ownership protocol.
         */
        public com.tangosol.coherence.component.net.MemberSet getSenderMemberSet()
            {
            return __m_SenderMemberSet;
            }
        
        // Accessor for the property "SnapshotToRecover"
        /**
         * Getter for property SnapshotToRecover.<p>
        * The name of the persistent snapshot to recover from, or null to
        * recover from the "active" persistence manager.
         */
        public String getSnapshotToRecover()
            {
            return __m_SnapshotToRecover;
            }
        
        // Declared at the super level
        protected com.tangosol.coherence.component.net.Poll instantiatePoll()
            {
            // import Component.Net.Poll as com.tangosol.coherence.component.net.Poll;
            
            return (com.tangosol.coherence.component.net.Poll) _newChild("Poll");
            }
        
        // Accessor for the property "Query"
        /**
         * Getter for property Query.<p>
        * True iff this $OwnershipRequest represents the "query" phase of the
        * protocol, requiring recipients to respond to this message with their
        * local copy of the partition assignment array.
        * 
        * If false, this $OwnershipRequest represents the "restore" phase of
        * the protocol, which instructs recipients to retore partitions from
        * backup.
         */
        public boolean isQuery()
            {
            return __m_Query;
            }
        
        // Declared at the super level
        /**
         * This is the event that is executed when a Message is received.
        * <p>
        * It is the main processing event of the Message called by the
        * <code>Service.onMessage()</code> event. With regards to the use of
        * Message components within clustered Services, Services are designed
        * by dragging Message components into them as static children. These
        * Messages are the components that a Service can send to other running
        * instances of the same Service within a cluster. When the onReceived
        * event is invoked by a Service, it means that the Message has been
        * received; the code in the onReceived event is therefore the Message
        * specific logic for processing a received Message. For example, when
        * onReceived is invoked on a Message named FindData, the onReceived
        * event should do the work to "find the data", because it is being
        * invoked by the Service that received the "find the data" Message.
         */
        public void onReceived()
            {
            super.onReceived();
            
            ((PartitionedService) getService()).onOwnershipRequest(this);
            }
        
        // Declared at the super level
        public void read(com.tangosol.io.ReadBuffer.BufferInput input)
                throws java.io.IOException
            {
            // import Component.Net.MemberSet;
            // import com.tangosol.net.partition.PartitionSet;
            // import com.tangosol.util.ExternalizableHelper;
            
            super.read(input);
            
            // deserialize the sender's memberset
            MemberSet setMembers = new MemberSet();
            setMembers.readExternal(input);
            setSenderMemberSet(setMembers);
            
            boolean fQuery = input.readBoolean();
            setQuery(fQuery);
            
            if (input.readBoolean()) // snapshot
                {
                setSnapshotToRecover(input.readUTF());
                }
            
            // request assignments are sent if we are in the restore phase,
            // or if we are repeating the request phase for too many attmepts
            boolean fAssignments = !fQuery;
            if (fQuery)
                {
                int cAttempt = ExternalizableHelper.readInt(input);
                setRequestCount(cAttempt);
            
                fAssignments = cAttempt > REQUEST_COUNT_THRESHOLD;
                }
            else
                {
                if (input.readBoolean()) // recover
                    {
                    PartitionSet parts = new PartitionSet();
                    parts.readExternal(input);
            
                    setRecoveryPartitions(parts);
                    }
                }
            
            if (fAssignments)
                {
                setRequestAssignments(ExternalizableHelper.readIntArray2d(input));
                }
            }
        
        // Accessor for the property "ConflictResolver"
        /**
         * Setter for property ConflictResolver.<p>
        * The ownership conflict resolver.  The (transient) resolver is used to
        * record and resolve conflicts between the partition assignments
        * reported by each member.
         */
        protected void setConflictResolver(com.tangosol.internal.util.OwnershipConflictResolver resolver)
            {
            __m_ConflictResolver = resolver;
            }
        
        // Accessor for the property "PersistentIdResolver"
        /**
         * Setter for property PersistentIdResolver.<p>
        * The GUID resolver.  The (transient) resolver is used only if
        * RecoveryRequested to register and resolve the sets of PersistentIds
        * reported by each member.
         */
        protected void setPersistentIdResolver(com.tangosol.persistence.GUIDHelper.GUIDResolver resolver)
            {
            __m_PersistentIdResolver = resolver;
            }
        
        // Accessor for the property "Query"
        /**
         * Setter for property Query.<p>
        * True iff this $OwnershipRequest represents the "query" phase of the
        * protocol, requiring recipients to respond to this message with their
        * local copy of the partition assignment array.
        * 
        * If false, this $OwnershipRequest represents the "restore" phase of
        * the protocol, which instructs recipients to retore partitions from
        * backup.
         */
        public void setQuery(boolean fQuery)
            {
            __m_Query = fQuery;
            }
        
        // Accessor for the property "QuorumInfo"
        /**
         * Setter for property QuorumInfo.<p>
        * The "last good" view of the ownership data.  This QuorumInfo is only
        * used for active persistence with "no-orphan" mode and retrieved from
        * the "global" partitoin during the recovery phase.
         */
        public void setQuorumInfo(com.tangosol.net.internal.QuorumInfo infoQuorum)
            {
            __m_QuorumInfo = infoQuorum;
            }
        
        // Accessor for the property "RecoveryPartitions"
        /**
         * Setter for property RecoveryPartitions.<p>
        * The set of partitions that need to be recovered.  Recipients of this
        * OwnershipRequest should reply with the persistent GUIDs for these
        * partitions in order to determine how to recover (or assign) the
        * partition ownership.
         */
        public void setRecoveryPartitions(com.tangosol.net.partition.PartitionSet setPartitions)
            {
            __m_RecoveryPartitions = setPartitions;
            }
        
        // Accessor for the property "RequestAssignments"
        /**
         * Setter for property RequestAssignments.<p>
        * Requestor's partition assignments.
        * 
        * The RequestAssignments are used in the request phase (if the number
        * of attempts exceeds the threshold) in order to force a conflict
        * resolution.  During the restore phase, they are used to ensure that
        * the resolved assignments are properly restored (see COH-6421).
         */
        public void setRequestAssignments(int[][] aai)
            {
            __m_RequestAssignments = aai;
            }
        
        // Accessor for the property "RequestCount"
        /**
         * Setter for property RequestCount.<p>
        * Requestor's OwnershipInProgress count.
         */
        public void setRequestCount(int c)
            {
            __m_RequestCount = c;
            }
        
        // Accessor for the property "RestorePartitions"
        /**
         * Setter for property RestorePartitions.<p>
        * The (transient) set of partitions that need to be restored.
        * 
        * see #onFinalizeRestorePrimary
         */
        public void setRestorePartitions(com.tangosol.net.partition.PartitionSet setPartitions)
            {
            __m_RestorePartitions = setPartitions;
            }
        
        // Accessor for the property "SenderMemberSet"
        /**
         * Setter for property SenderMemberSet.<p>
        * The sender's view of the ownership member-set.  This is used to
        * enforce a "synchronized" view of the ownership member-set during the
        * ownership protocol.
         */
        public void setSenderMemberSet(com.tangosol.coherence.component.net.MemberSet setMember)
            {
            __m_SenderMemberSet = setMember;
            }
        
        // Accessor for the property "SnapshotToRecover"
        /**
         * Setter for property SnapshotToRecover.<p>
        * The name of the persistent snapshot to recover from, or null to
        * recover from the "active" persistence manager.
         */
        public void setSnapshotToRecover(String sSnapshot)
            {
            __m_SnapshotToRecover = sSnapshot;
            }
        
        // Declared at the super level
        public void write(com.tangosol.io.WriteBuffer.BufferOutput output)
                throws java.io.IOException
            {
            // import com.tangosol.net.partition.PartitionSet;
            // import com.tangosol.util.ExternalizableHelper;
            
            super.write(output);
            
            PartitionedService service = (PartitionedService) getService();
            
            // COH-6393: serialize the sender's service member set for comparison
            getSenderMemberSet().writeExternal(output);
            
            boolean fQuery = isQuery();
            output.writeBoolean(fQuery);
            
            String sSnapshot = getSnapshotToRecover();
            if (sSnapshot == null)
                {
                output.writeBoolean(false);
                }
            else
                {
                output.writeBoolean(true);
                output.writeUTF(sSnapshot);
                }
            
            int[][] aaiOwners = null;
            if (fQuery)
                {
                int cAttempt = service.getOwnershipInProgress();
                ExternalizableHelper.writeInt(output, cAttempt);
            
                if (cAttempt > REQUEST_COUNT_THRESHOLD)
                    {
                    aaiOwners = service.getPartitionAssignments();
                    }
                }
            else
                {
                PartitionSet partsRecover = getRecoveryPartitions();
                if (partsRecover == null)
                    {
                    output.writeBoolean(false);
                    }
                else
                    {
                    output.writeBoolean(true);
                    partsRecover.writeExternal(output);
                    }
            
                // COH-6421: always send the resolved request assignments
                aaiOwners = getRequestAssignments();
                }
            
            if (aaiOwners != null)
                {
                // Note: POF is not aware of the (int[][]) type
                ExternalizableHelper.writeIntArray2d(output, aaiOwners);
                }
            }

        // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService$OwnershipRequest$Poll
        
        /**
         * The Poll contains information regarding a request sent to one or
         * more Cluster Members that require responses. A Service may poll
         * other Members that are running the same Service, and the Poll is
         * used to wait for and assemble the responses from each of those
         * Members. A client thread may also use the Poll to block on a
         * response or set of responses, thus waiting for the completion of the
         * Poll. In its simplest form, which is a Poll that is sent to one
         * Member of the Cluster, the Poll actually represents the
         * request/response model.
         */
        @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
        public static class Poll
                extends    com.tangosol.coherence.component.net.Poll
            {
            // ---- Fields declarations ----
            
            /**
             * Property ConflictCount
             *
             * A number of partition ownership conflicts discovered during the
             * OwnershipRequest poll. Value of -1 indicates that some modes are
             * in still active transfer and the count cannot be collected
             * reliable.
             */
            private transient int __m_ConflictCount;
            
            // Default constructor
            public Poll()
                {
                this(null, null, true);
                }
            
            // Initializing constructor
            public Poll(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                {
                super(sName, compParent, false);
                
                if (fInit)
                    {
                    __init();
                    }
                }
            
            // Main initializer
            public void __init()
                {
                // private initialization
                __initPrivate();
                
                
                // signal the end of the initialization
                set_Constructed(true);
                }
            
            // Private initializer
            protected void __initPrivate()
                {
                
                super.__initPrivate();
                }
            
            //++ getter for static property _Instance
            /**
             * Getter for property _Instance.<p>
            * Auto generated
             */
            public static com.tangosol.coherence.Component get_Instance()
                {
                return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.OwnershipRequest.Poll();
                }
            
            //++ getter for static property _CLASS
            /**
             * Getter for property _CLASS.<p>
            * Property with auto-generated accessor that returns the Class
            * object for a given component.
             */
            public static Class get_CLASS()
                {
                Class clz;
                try
                    {
                    clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/PartitionedService$OwnershipRequest$Poll".replace('/', '.'));
                    }
                catch (ClassNotFoundException e)
                    {
                    throw new NoClassDefFoundError(e.getMessage());
                    }
                return clz;
                }
            
            //++ getter for autogen property _Module
            /**
             * This is an auto-generated method that returns the global [design
            * time] parent component.
            * 
            * Note: the class generator will ignore any custom implementation
            * for this behavior.
             */
            private com.tangosol.coherence.Component get_Module()
                {
                return this.get_Parent().get_Parent();
                }
            
            /**
             * This event occurs for each response Message from each polled
            * Member.
             */
            private static com.tangosol.net.internal.QuorumInfo deserializeQuorumInfo(com.tangosol.util.Binary binQuorum)
                {
                // import com.tangosol.net.internal.QuorumInfo;
                // import com.tangosol.util.ExternalizableHelper;
                // import com.tangosol.util.NullImplementation;
                
                return (QuorumInfo) ExternalizableHelper.fromBinary(
                    binQuorum, NullImplementation.getClassLoader());
                }
            
            // Accessor for the property "ConflictCount"
            /**
             * Getter for property ConflictCount.<p>
            * A number of partition ownership conflicts discovered during the
            * OwnershipRequest poll. Value of -1 indicates that some modes are
            * in still active transfer and the count cannot be collected
            * reliable.
             */
            public int getConflictCount()
                {
                return __m_ConflictCount;
                }
            
            // Declared at the super level
            /**
             * This is the event that is executed when all the Members that were
            * polled have responded or have left the Service.
             */
            protected void onCompletion()
                {
                // import com.tangosol.util.Binary;
                // import com.tangosol.net.partition.Ownership;
                // import com.tangosol.net.partition.PartitionSet;
                
                PartitionedService           service    = (PartitionedService) getService();
                PartitionedService.OwnershipRequest msgRequest = (PartitionedService.OwnershipRequest) get_Parent();
                
                if (service.getServiceState() != PartitionedService.SERVICE_STOPPED)
                    {
                    if (!getLeftMemberSet().isEmpty() ||
                        !service.getOwnershipMemberSet().equals(getRespondedMemberSet()))
                        {
                        // we must repeat, as some ownership-enabled members left during the poll.
                        //
                        // Note: we must compare the responded set against the current service
                        //       member-set here (in addition to checking for a non-empty
                        //       LeftMemberSet), as a member may respond and then die before this
                        //       poll completes
                
                        setConflictCount(-1);
                        }
                
                    int cConflicts = getConflictCount();
                    if (cConflicts == 0 && msgRequest.isQuery())
                        {
                        // resolve the ownership assignments/conflicts now that everybody has answered
                        PartitionSet partsConflict = msgRequest.getConflictResolver().resolveConflicts();
                
                        setConflictCount(cConflicts = partsConflict.cardinality());
                        }
                
                    // if the persistence control has the copy of the last QuorumInfo, use it instead
                    // of anything we got from the outside
                    Binary binQuorum = service.getPersistenceControl().getQuorumRaw();
                    if (binQuorum != null)
                        {
                        msgRequest.setQuorumInfo(deserializeQuorumInfo(binQuorum));
                        }
                
                    // Note: in phase 2, cConflicts can only be 0, or -1 (due to member-set skew)
                    service.onOwnershipRequestCompleted(msgRequest, cConflicts);
                    }
                
                super.onCompletion();
                }
            
            // Declared at the super level
            /**
             * This event occurs for each response Message from each polled
            * Member.
             */
            public void onResponse(com.tangosol.coherence.component.net.Message msg)
                {
                // import com.tangosol.net.internal.QuorumInfo;
                // import com.tangosol.net.partition.PartitionSet;
                // import com.tangosol.persistence.CachePersistenceHelper as com.tangosol.persistence.CachePersistenceHelper;
                // import com.tangosol.persistence.GUIDHelper$GUIDResolver as com.tangosol.persistence.GUIDHelper.GUIDResolver;
                // import com.tangosol.util.Binary;
                // import com.tangosol.util.ExternalizableHelper as com.tangosol.util.ExternalizableHelper;
                // import com.tangosol.util.NullImplementation;
                // import java.util.Map;
                
                if (isClosed())
                    {
                    return;
                    }
                
                PartitionedService.OwnershipResponse msgResponse = (PartitionedService.OwnershipResponse) msg;
                if (msgResponse.isSuccess())
                    {
                    PartitionedService           service    = (PartitionedService) getService();
                    PartitionedService.OwnershipRequest msgRequest = (PartitionedService.OwnershipRequest) get_Parent();
                    if (msgRequest.isQuery())
                        {
                        // phase 1 (synchronization) - calculate the ownership conflict for ownership
                        int     nMemberFrom   = msg.getFromMember().getId();
                        int[][] aaiOwnersThat = msgResponse.getAssignments();
                
                        service.calculateOwnershipConflicts(
                            nMemberFrom, aaiOwnersThat, service.getOwnershipInProgress());
                
                        msgRequest.getConflictResolver().registerOwnership(nMemberFrom, aaiOwnersThat);
                        }
                    else
                        {
                        // phase 2 (resolve)
                        com.tangosol.persistence.GUIDHelper.GUIDResolver resolver = msgRequest.getPersistentIdResolver();
                
                        if (msgRequest.getRecoveryPartitions() != null)
                            {
                            PersistentStoreInfo[] aInfo = msgResponse.getStoreInfos();
                            if (aInfo != null)
                                {
                                resolver.registerStoreInfo(msg.getFromMember(), aInfo);
                                }
                            }
                
                        Binary binQuorum = msgResponse.getQuorumRaw();
                        if (binQuorum != null)
                            {
                            if (msgRequest.getQuorumInfo() == null)
                                {
                                // the only one so far; use DefaultSerializer unconditionally
                                msgRequest.setQuorumInfo(deserializeQuorumInfo(binQuorum));
                                }
                            else
                                {
                                // another member has already provided the quorum info;
                                // sort it out and retain the newest
                
                                Map mapResolved = resolver.resolve(); // Map<Member, PartitionSet>
                
                                PartitionSet partsNew = (PartitionSet) mapResolved.get(msg.getFromMember());
                                if (partsNew != null && partsNew.intersects(com.tangosol.persistence.CachePersistenceHelper.getGlobalPartitions(service)))
                                    {
                                    // this one is newer; override
                                    msgRequest.setQuorumInfo(deserializeQuorumInfo(binQuorum));
                                    }
                                }
                            }
                        }
                
                    super.onResponse(msg);
                    }
                else
                    {
                    // the responder has an active transfer;
                    // we cannot expect to synchronize reliably
                    setConflictCount(-1);
                    close();
                    }
                }
            
            // Accessor for the property "ConflictCount"
            /**
             * Setter for property ConflictCount.<p>
            * A number of partition ownership conflicts discovered during the
            * OwnershipRequest poll. Value of -1 indicates that some modes are
            * in still active transfer and the count cannot be collected
            * reliable.
             */
            protected void setConflictCount(int c)
                {
                __m_ConflictCount = c;
                }
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService$OwnershipResponse
    
    /**
     * Response to the OwnershipRequest message.
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class OwnershipResponse
            extends    com.tangosol.coherence.component.net.Message
        {
        // ---- Fields declarations ----
        
        /**
         * Property Assignments
         *
         * The partition-assignments, as known to the responding member.
         */
        private int[][] __m_Assignments;
        
        /**
         * Property StoreInfos
         *
         * The PersistentStoreInfos with the corresponding store ids that are available to the responding member.
         */
        private PersistentStoreInfo[] __m_StoreInfos;
        
        /**
         * Property QuorumRaw
         *
         * Binary that contains the ownership quorum.
         */
        private com.tangosol.util.Binary __m_QuorumRaw;
        
        /**
         * Property Success
         *
         * True iff this represents a successful response to the
         * $OwnershipRequest.
         * 
         * See #onOwnershipRequest
         */
        private boolean __m_Success;
        
        // Default constructor
        public OwnershipResponse()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public OwnershipResponse(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                setMessageType(42);
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.OwnershipResponse();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/PartitionedService$OwnershipResponse".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        // Accessor for the property "Assignments"
        /**
         * Getter for property Assignments.<p>
        * The partition-assignments, as known to the responding member.
         */
        public int[][] getAssignments()
            {
            return __m_Assignments;
            }
        
        // Accessor for the property "PersistentIds"
        /**
         * Getter for property StoreInfos.<p>
        * The PersistentStoreInfos with the corresponding store ids that are available to the responding member.
         */
        public PersistentStoreInfo[] getStoreInfos()
            {
            return __m_StoreInfos;
            }
        
        // Accessor for the property "QuorumRaw"
        /**
         * Getter for property QuorumRaw.<p>
        * Binary that contains the ownership quorum.
         */
        public com.tangosol.util.Binary getQuorumRaw()
            {
            return __m_QuorumRaw;
            }
        
        // Accessor for the property "Success"
        /**
         * Getter for property Success.<p>
        * True iff this represents a successful response to the
        * $OwnershipRequest.
        * 
        * See #onOwnershipRequest
         */
        public boolean isSuccess()
            {
            return __m_Success;
            }
        
        // Declared at the super level
        public void read(com.tangosol.io.ReadBuffer.BufferInput input)
                throws java.io.IOException
            {
            // import com.tangosol.util.ExternalizableHelper as com.tangosol.util.ExternalizableHelper;
            
            boolean fSuccess = input.readBoolean();
            
            setSuccess(fSuccess);
            if (fSuccess)
                {
                Grid    service      = getService();
                boolean fAssignments = input.readBoolean();
                if (fAssignments)
                    {
                    setAssignments(ExternalizableHelper.readIntArray2d(input));
                    }
            
                // read the persistent store ids
                boolean fStores = input.readBoolean();
                if (fStores)
                    {
                    boolean               fStoresCompat = service.isVersionCompatible(OwnershipResponse::isLazyOpenCompatible);
                    int                   cStores       = input.readInt();
                    PersistentStoreInfo[] aInfo         = new PersistentStoreInfo[cStores];
                    for (int i = 0; i < cStores; i++)
                        {
                        if (fStoresCompat)
                            {
                            aInfo[i] = ExternalizableHelper.readObject(input);
                            }
                        else
                            {
                            aInfo[i] = new PersistentStoreInfo(input.readUTF(), false);
                            }
                        }

                    setStoreInfos(aInfo);
                    }
            
                if (service.isVersionCompatible(getFromMember(), 12, 2, 1, 1, 0))
                    {
                    // the quorum info exchange was introduced in 12.2.1.1
                    int cb = input.readInt();
                    if (cb > 0)
                        {
                        setQuorumRaw(input.readBuffer(cb).toBinary());
                        }
                    }
                }
            }
        
        // Accessor for the property "Assignments"
        /**
         * Setter for property Assignments.<p>
        * The partition-assignments, as known to the responding member.
         */
        public void setAssignments(int[][] aanAssignments)
            {
            __m_Assignments = aanAssignments;
            }
        
        // Accessor for the property "PersistentIds"
        /**
         * Setter for property PersistentIds.<p>
        * The PersistentStoreInfos with the corresponding store ids that are available to the responding member.
         */
        public void setStoreInfos(PersistentStoreInfo[] aInfos)
            {
            __m_StoreInfos = aInfos;
            }
        
        // Accessor for the property "QuorumRaw"
        /**
         * Setter for property QuorumRaw.<p>
        * Binary that contains the ownership quorum.
         */
        public void setQuorumRaw(com.tangosol.util.Binary bin)
            {
            __m_QuorumRaw = bin;
            }
        
        // Accessor for the property "Success"
        /**
         * Setter for property Success.<p>
        * True iff this represents a successful response to the
        * $OwnershipRequest.
        * 
        * See #onOwnershipRequest
         */
        public void setSuccess(boolean fSuccess)
            {
            __m_Success = fSuccess;
            }
        
        // Declared at the super level
        public void write(com.tangosol.io.WriteBuffer.BufferOutput output)
                throws java.io.IOException
            {
            // import com.tangosol.util.Binary;
            // import com.tangosol.util.ExternalizableHelper as com.tangosol.util.ExternalizableHelper;
            
            boolean fSuccess = isSuccess();
            
            output.writeBoolean(fSuccess);
            if (fSuccess)
                {
                Grid service = getService();

                int[][] aaiOwner = getAssignments();
                if (aaiOwner == null)
                    {
                    output.writeBoolean(false);
                    }
                else
                    {
                    output.writeBoolean(true);
                    ExternalizableHelper.writeIntArray2d(output, aaiOwner);
                    }

                PersistentStoreInfo[] aInfo   = getStoreInfos();
                boolean               fStores = aInfo != null;

                output.writeBoolean(fStores);
                if (fStores)
                    {
                    boolean fStoresCompat = service.isVersionCompatible(OwnershipResponse::isLazyOpenCompatible);
                    // write the persistent store ids
                    int cStores = aInfo.length;

                    output.writeInt(cStores);
                    for (int i = 0; i < cStores; i++)
                        {
                        if (fStoresCompat)
                            {
                            ExternalizableHelper.writeObject(output, aInfo[i]);
                            }
                        else
                            {
                            output.writeUTF(aInfo[i].getId());
                            }
                        }
                    }
            
                if (service.isVersionCompatible(getToMemberSet(), 12, 2, 1, 1, 0))
                    {
                    // the quorum info exchange was introduced in 12.2.1.1
            
                    Binary  bin = getQuorumRaw();
                    int     cb  = bin == null ? 0 : bin.length();
            
                    output.writeInt(cb);
                    if (cb > 0)
                        {
                        output.writeBuffer(bin);
                        }
                    }
                }
            }

            protected static boolean isLazyOpenCompatible(int nVersion)
                {
                return VersionHelper.isVersionCompatible(VERSION_14_1_2_0, nVersion)
                    || VersionHelper.isVersionCompatible(VERSION_24_09, nVersion);
                }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService$PartitionAbandonRequest
    
    /**
     * PartitionAbandonRequest is sent to the ownership "chain" of members to
     * "abandon" or intentionally "orphan" one or more partitions.  The request
     * is sent as a ChainedRequest to all owners of this partition set, in the
     * order of storage index (e.g. Primary, backup1, backup2, ...)
     * 
     * Note: This message is currenlty not used but is retained for future use.
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class PartitionAbandonRequest
            extends    com.tangosol.coherence.component.net.message.requestMessage.ChainedRequest
        {
        // ---- Fields declarations ----
        
        /**
         * Property PartitionSet
         *
         */
        private com.tangosol.net.partition.PartitionSet __m_PartitionSet;
        private static com.tangosol.util.ListMap __mapChildren;
        
        // Static initializer
        static
            {
            __initStatic();
            }
        
        // Default static initializer
        private static void __initStatic()
            {
            // register child classes
            __mapChildren = new com.tangosol.util.ListMap();
            __mapChildren.put("Poll", PartitionedService.PartitionAbandonRequest.Poll.get_CLASS());
            }
        
        // Default constructor
        public PartitionAbandonRequest()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public PartitionAbandonRequest(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                setMessageType(46);
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // containment initialization: children
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.PartitionAbandonRequest();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/PartitionedService$PartitionAbandonRequest".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        //++ getter for autogen property _ChildClasses
        /**
         * This is an auto-generated method that returns the map of design time
        * [static] children.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        protected java.util.Map get_ChildClasses()
            {
            return __mapChildren;
            }
        
        // Declared at the super level
        /**
         * Instantiate a copy of this message. This is quite different from the
        * standard "clone" since only the "transmittable" portion of the
        * message (and none of the internal) state should be cloned.
         */
        public com.tangosol.coherence.component.net.Message cloneMessage()
            {
            PartitionedService.PartitionAbandonRequest msgRequest = (PartitionedService.PartitionAbandonRequest) super.cloneMessage();
            
            msgRequest.setPartitionSet(getPartitionSet());
            
            return msgRequest;
            }
        
        // Accessor for the property "PartitionSet"
        /**
         * Getter for property PartitionSet.<p>
         */
        public com.tangosol.net.partition.PartitionSet getPartitionSet()
            {
            return __m_PartitionSet;
            }
        
        // Declared at the super level
        /**
         * This method is called on by member when the request has been fully
        * delivered to all members after it on the delivery chain (or upon
        * receiving the request if this is the last member in the chain).
        * 
        * This event could be used to perform logic in "reverse" chain order,
        * as it guarantees that all successors in the delivery chain have
        * received (and processed) the message.
        * 
        * @param msgResponse    the response
         */
        public void onRequestDelivered()
            {
            // Note: we do the request processing on the chain delivery completion to
            //       ensure that backups drop their ownership *before* the primary does
            //       so as to avoid the possibility of a partition-config update from the
            //       primary owner reaching a backup owner prior to the command being
            //       processed
            ((PartitionedService) get_Module()).onPartitionAbandonRequest(this);
            
            super.onRequestDelivered();
            }
        
        // Declared at the super level
        public void read(com.tangosol.io.ReadBuffer.BufferInput input)
                throws java.io.IOException
            {
            // import com.tangosol.net.partition.PartitionSet;
            
            super.read(input);
            
            PartitionSet parts = new PartitionSet();
            parts.readExternal(input);
            
            setPartitionSet(parts);
            }
        
        // Accessor for the property "PartitionSet"
        /**
         * Setter for property PartitionSet.<p>
         */
        public void setPartitionSet(com.tangosol.net.partition.PartitionSet sProperty)
            {
            __m_PartitionSet = sProperty;
            }
        
        // Declared at the super level
        public void write(com.tangosol.io.WriteBuffer.BufferOutput output)
                throws java.io.IOException
            {
            super.write(output);
            
            getPartitionSet().writeExternal(output);
            }

        // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService$PartitionAbandonRequest$Poll
        
        /**
         * The Poll contains information regarding a request sent to one or
         * more Cluster Members that require responses. A Service may poll
         * other Members that are running the same Service, and the Poll is
         * used to wait for and assemble the responses from each of those
         * Members. A client thread may also use the Poll to block on a
         * response or set of responses, thus waiting for the completion of the
         * Poll. In its simplest form, which is a Poll that is sent to one
         * Member of the Cluster, the Poll actually represents the
         * request/response model.
         */
        @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
        public static class Poll
                extends    com.tangosol.coherence.component.net.message.requestMessage.ChainedRequest.Poll
            {
            // ---- Fields declarations ----
            
            // Default constructor
            public Poll()
                {
                this(null, null, true);
                }
            
            // Initializing constructor
            public Poll(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                {
                super(sName, compParent, false);
                
                if (fInit)
                    {
                    __init();
                    }
                }
            
            // Main initializer
            public void __init()
                {
                // private initialization
                __initPrivate();
                
                
                // signal the end of the initialization
                set_Constructed(true);
                }
            
            // Private initializer
            protected void __initPrivate()
                {
                
                super.__initPrivate();
                }
            
            // Getter for virtual constant Preprocessable
            public boolean isPreprocessable()
                {
                return false;
                }
            
            //++ getter for static property _Instance
            /**
             * Getter for property _Instance.<p>
            * Auto generated
             */
            public static com.tangosol.coherence.Component get_Instance()
                {
                return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.PartitionAbandonRequest.Poll();
                }
            
            //++ getter for static property _CLASS
            /**
             * Getter for property _CLASS.<p>
            * Property with auto-generated accessor that returns the Class
            * object for a given component.
             */
            public static Class get_CLASS()
                {
                Class clz;
                try
                    {
                    clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/PartitionedService$PartitionAbandonRequest$Poll".replace('/', '.'));
                    }
                catch (ClassNotFoundException e)
                    {
                    throw new NoClassDefFoundError(e.getMessage());
                    }
                return clz;
                }
            
            //++ getter for autogen property _Module
            /**
             * This is an auto-generated method that returns the global [design
            * time] parent component.
            * 
            * Note: the class generator will ignore any custom implementation
            * for this behavior.
             */
            private com.tangosol.coherence.Component get_Module()
                {
                return this.get_Parent().get_Parent();
                }
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService$PartitionConfig
    
    /**
     * ServiceConfig provides a service-wide configuration map.  All updates to
     * a service config are published service-wide by the configuration
     * coordinator.
     * The Service-wide config map for partition ownership related state.
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class PartitionConfig
            extends    com.tangosol.coherence.component.util.ServiceConfig
        {
        // ---- Fields declarations ----
        
        /**
         * Property KEY_QUORUM
         *
         * The key for the QuorumInfo.
         */
        public static final Integer KEY_QUORUM;
        
        /**
         * Property TYPE_ANY
         *
         * A generic (not well-known) type.
         */
        public static final int TYPE_ANY = 0;
        
        /**
         * Property TYPE_BINARY
         *
         * com.tangosol.util.Binary
         */
        public static final int TYPE_BINARY = 3;
        
        /**
         * Property TYPE_INT
         *
         * java.lang.Integer
         */
        public static final int TYPE_INT = 1;
        
        /**
         * Property TYPE_OWNERSHIP
         *
         * com.tangosol.net.partition.Ownership
         */
        public static final int TYPE_OWNERSHIP = 2;
        
        // Static initializer
        static
            {
            try
                {
                KEY_QUORUM = new java.lang.Integer(-1);
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            }
        
        // Default constructor
        public PartitionConfig()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public PartitionConfig(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                // identified pendingPolls required thread-safe data structure and
                // verified that pendingConfigUpdates only accessed on single service thread, see details in COH-30132.
                setPendingConfigUpdates(new java.util.LinkedList());
                setPendingPolls(new ConcurrentHashMap<>());
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // containment initialization: children
            _addChild(new PartitionedService.PartitionConfig.ConfigListener("ConfigListener", this, true), "ConfigListener");
            _addChild(new PartitionedService.PartitionConfig.Map("Map", this, true), "Map");
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.PartitionConfig();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/PartitionedService$PartitionConfig".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        // Declared at the super level
        /**
         * Getter for property ConfigCoordinator.<p>
        * The configuration coordinator is the service member that serves as a
        * point of serialization for configuration updates.
         */
        public com.tangosol.coherence.component.net.Member getConfigCoordinator()
            {
            // partition-configuration is only controlled by ownership-enabled
            // members; return the ownership senior, or null.
            //
            // Note: before we have been welcomed by all members (senior to us at least),
            //       there is no way to be sure who is the ownership senior/config
            //       coordinator (COH-3487); return null in this case.  When COH-2713 is
            //       addressed, this will become a non-issue, as the possibility of receiving
            //       "early" updates from the config coordinator before being "welcomed" will
            //       disappear.
            
            PartitionedService service = (PartitionedService) getService();
            return service.isAcceptingOthers() ? service.getOwnershipSenior(true) : null;
            }
        
        /**
         * Return whether the provided integer is a valid partition.
         */
        public boolean isPartition(int iPart)
            {
            return iPart >= 0;
            }
        
        // Declared at the super level
        /**
         * Called when no config coordinator member is found to receive config
        * requests to update the map.
         */
        public void onMissingCoordinator()
            {
            // Missing coordinator can only mean that there are
            // no ownership enabled members in the service
            }
        
        // Declared at the super level
        /**
         * Deserialize a ConfigMap related object from the specified DataInput.
        * 
        * @param in  the DataInput containing a serialized object
        * 
        * @return the deserialized object
         */
        public Object readObject(java.io.DataInput in)
                throws java.io.IOException
            {
            // import com.tangosol.net.partition.VersionedOwnership;
            // import com.tangosol.util.Binary;
            // import java.io.IOException;
            
            // we only store Integer, Ownership and Binary objects in the PartitionConfig
            int nType;
            switch (nType = in.readByte())
                {
                case TYPE_OWNERSHIP:
                    {
                    VersionedOwnership owners = new VersionedOwnership();
                    owners.readExternal(in);
                    return owners;
                    }
            
                case TYPE_INT:
                    {
                    return Integer.valueOf(in.readInt());
                    }
            
                case TYPE_BINARY:
                    return new Binary(in);
            
                case TYPE_ANY:
                    return super.readObject(in);
            
                default:
                    throw new IOException("invalid type: " + nType);
                }
            }
        
        // Declared at the super level
        /**
         * Serialize a ConfigMap related object to the specified DataOutput.
        * 
        * @param out  the DataOutput
        * @param o  the object to serialize
         */
        public void writeObject(java.io.DataOutput out, Object o)
                throws java.io.IOException
            {
            // import com.tangosol.net.partition.Ownership;
            // import com.tangosol.util.Binary;
            
            // we only store Integer, Ownership and Binary objects in the PartitionConfig
            if (o instanceof Ownership)
                {
                out.write(TYPE_OWNERSHIP);
                ((Ownership) o).writeExternal(out);
                }
            else if (o instanceof Integer)
                {
                out.write(TYPE_INT);
                out.writeInt(((Integer) o).intValue());
                }
            else if (o instanceof Binary)
                {
                out.write(TYPE_BINARY);
                ((Binary) o).writeExternal(out);
                }
            else
                {
                out.write(TYPE_ANY);
                super.writeObject(out, o);
                }
            }

        // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService$PartitionConfig$ConfigListener
        
        /**
         * ConfigListener is used to receive config map updates for this
         * ServiceConfig.
         */
        @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
        public static class ConfigListener
                extends    com.tangosol.coherence.component.util.ServiceConfig.ConfigListener
            {
            // ---- Fields declarations ----
            
            // Default constructor
            public ConfigListener()
                {
                this(null, null, true);
                }
            
            // Initializing constructor
            public ConfigListener(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                {
                super(sName, compParent, false);
                
                if (fInit)
                    {
                    __init();
                    }
                }
            
            // Main initializer
            public void __init()
                {
                // private initialization
                __initPrivate();
                
                
                // signal the end of the initialization
                set_Constructed(true);
                }
            
            // Private initializer
            protected void __initPrivate()
                {
                
                super.__initPrivate();
                }
            
            //++ getter for static property _Instance
            /**
             * Getter for property _Instance.<p>
            * Auto generated
             */
            public static com.tangosol.coherence.Component get_Instance()
                {
                return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.PartitionConfig.ConfigListener();
                }
            
            //++ getter for static property _CLASS
            /**
             * Getter for property _CLASS.<p>
            * Property with auto-generated accessor that returns the Class
            * object for a given component.
             */
            public static Class get_CLASS()
                {
                Class clz;
                try
                    {
                    clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/PartitionedService$PartitionConfig$ConfigListener".replace('/', '.'));
                    }
                catch (ClassNotFoundException e)
                    {
                    throw new NoClassDefFoundError(e.getMessage());
                    }
                return clz;
                }
            
            //++ getter for autogen property _Module
            /**
             * This is an auto-generated method that returns the global [design
            * time] parent component.
            * 
            * Note: the class generator will ignore any custom implementation
            * for this behavior.
             */
            private com.tangosol.coherence.Component get_Module()
                {
                return this.get_Parent().get_Parent();
                }
            
            // Declared at the super level
            public void entryDeleted(com.tangosol.util.MapEvent evt)
                {
                Object oKey = evt.getKey();
                
                if (oKey instanceof Integer)
                    {
                    int iKey = ((Integer) oKey).intValue();
                    if (iKey >= 0) // partition info
                        {
                        throw new IllegalStateException("Partition info is not removable:" + evt);
                        }
                    }
                }
            
            // Declared at the super level
            public void entryInserted(com.tangosol.util.MapEvent evt)
                {
                onInsertOrUpdate(evt);
                }
            
            // Declared at the super level
            public void entryUpdated(com.tangosol.util.MapEvent evt)
                {
                onInsertOrUpdate(evt);
                }
            
            protected void onInsertOrUpdate(com.tangosol.util.MapEvent evt)
                {
                // import com.tangosol.util.Base;
                // import com.tangosol.util.Binary;
                
                PartitionedService service = (PartitionedService) get_Module();
                Object  oKey    = evt.getKey();
                
                if (oKey instanceof Integer)
                    {
                    int iKey = ((Integer) oKey).intValue();
                    if (iKey >= 0) // partition info
                        {
                        // suppress identical "updates"
                        if (!Base.equals(evt.getOldValue(), evt.getNewValue()))
                            {
                            service.onPartitionConfigUpdate(evt);
                            }
                        }
                    else
                        {
                        if (iKey == PartitionedService.PartitionConfig.KEY_QUORUM.intValue() && service.isOwnershipEnabled())
                            {
                            Binary binQuorum = (Binary) evt.getNewValue();
                            if (binQuorum != null)
                                {
                                service.getPersistenceControl().setQuorumRaw(binQuorum);
                                }
                            }
                        }
                    }
                // forward compatibility
                }
            }

        // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService$PartitionConfig$Map
        
        /**
         * The "live" configuration map.  Mutations on this Map through the
         * java.util.Map interface will be published to all members sharing the
         * ServiceConfig.
         */
        @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
        public static class Map
                extends    com.tangosol.coherence.component.util.ServiceConfig.Map
            {
            // ---- Fields declarations ----
            
            /**
             * Property InitializedPartitions
             *
             * The set of partitions whose initial assignment has been
             * completed.
             */
            private com.tangosol.net.partition.PartitionSet __m_InitializedPartitions;
            private static com.tangosol.util.ListMap __mapChildren;
            
            // Static initializer
            static
                {
                __initStatic();
                }
            
            // Default static initializer
            private static void __initStatic()
                {
                // register child classes
                __mapChildren = new com.tangosol.util.ListMap();
                __mapChildren.put("EntrySet", PartitionedService.PartitionConfig.Map.EntrySet.get_CLASS());
                __mapChildren.put("KeySet", PartitionedService.PartitionConfig.Map.KeySet.get_CLASS());
                __mapChildren.put("Values", PartitionedService.PartitionConfig.Map.Values.get_CLASS());
                }
            
            // Default constructor
            public Map()
                {
                this(null, null, true);
                }
            
            // Initializing constructor
            public Map(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                {
                super(sName, compParent, false);
                
                if (fInit)
                    {
                    __init();
                    }
                }
            
            // Main initializer
            public void __init()
                {
                // private initialization
                __initPrivate();
                
                
                // containment initialization: children
                
                // signal the end of the initialization
                set_Constructed(true);
                }
            
            // Private initializer
            protected void __initPrivate()
                {
                
                super.__initPrivate();
                }
            
            //++ getter for static property _Instance
            /**
             * Getter for property _Instance.<p>
            * Auto generated
             */
            public static com.tangosol.coherence.Component get_Instance()
                {
                return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.PartitionConfig.Map();
                }
            
            //++ getter for static property _CLASS
            /**
             * Getter for property _CLASS.<p>
            * Property with auto-generated accessor that returns the Class
            * object for a given component.
             */
            public static Class get_CLASS()
                {
                Class clz;
                try
                    {
                    clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/PartitionedService$PartitionConfig$Map".replace('/', '.'));
                    }
                catch (ClassNotFoundException e)
                    {
                    throw new NoClassDefFoundError(e.getMessage());
                    }
                return clz;
                }
            
            //++ getter for autogen property _Module
            /**
             * This is an auto-generated method that returns the global [design
            * time] parent component.
            * 
            * Note: the class generator will ignore any custom implementation
            * for this behavior.
             */
            private com.tangosol.coherence.Component get_Module()
                {
                return this.get_Parent().get_Parent();
                }
            
            //++ getter for autogen property _ChildClasses
            /**
             * This is an auto-generated method that returns the map of design
            * time [static] children.
            * 
            * Note: the class generator will ignore any custom implementation
            * for this behavior.
             */
            protected java.util.Map get_ChildClasses()
                {
                return __mapChildren;
                }
            
            // Accessor for the property "InitializedPartitions"
            /**
             * Getter for property InitializedPartitions.<p>
            * The set of partitions whose initial assignment has been completed.
             */
            protected com.tangosol.net.partition.PartitionSet getInitializedPartitions()
                {
                // import com.tangosol.net.partition.PartitionSet;
                
                PartitionSet parts = __m_InitializedPartitions;
                if (parts == null)
                    {
                    PartitionedService service = (PartitionedService) get_Module();
                    setInitializedPartitions(parts = new PartitionSet(service.getPartitionCount()));
                    }
                
                return parts;
                }
            
            // Declared at the super level
            /**
             * Getter for property MapType.<p>
            * An integer value, unique to the Service using this map, that
            * defines the type of this config map.
            * 
            * @see Grid#getConfigMap(int)
             */
            public int getMapType()
                {
                return PartitionedService.CONFIG_MAP_PARTITION;
                }
            
            /**
             * Track all known non-orphaned partitions.
             */
            public void initializePartitions()
                {
                // import com.tangosol.net.partition.Ownership;
                // import com.tangosol.net.partition.PartitionSet;
                // import java.util.Iterator;
                // import java.util.Map$Entry as java.util.Map.Entry;
                
                PartitionSet partsInit = getInitializedPartitions();
                
                for (Iterator iter = entrySet().iterator(); iter.hasNext(); )
                    {
                    java.util.Map.Entry     entry  = (java.util.Map.Entry) iter.next();
                    int       iPart  = ((Integer) entry.getKey()).intValue();
                
                    if (iPart >= 0)
                        {
                        Ownership owners = (Ownership) entry.getValue();
                
                        if (owners.getPrimaryOwner() != 0)
                            {
                            partsInit.add(iPart);
                            }
                        }
                    }
                }
            
            public boolean isAssignmentCompleted()
                {
                return getInitializedPartitions().isFull();
                }
            
            public boolean isAssignmentCompleted(int nPartition)
                {
                return getInitializedPartitions().contains(nPartition);
                }
            
            // Accessor for the property "InitializedPartitions"
            /**
             * Setter for property InitializedPartitions.<p>
            * The set of partitions whose initial assignment has been completed.
             */
            protected void setInitializedPartitions(com.tangosol.net.partition.PartitionSet parts)
                {
                __m_InitializedPartitions = parts;
                }
            
            // Declared at the super level
            /**
             * Update the local contents of the config map, returning the
            * previously associated value.  Called only on the service thread.
            * 
            * @param oKey         the key to update
            * @param oValue      the associated value (or null if fRemove)
            * @param fRemove   true iff the specified key should be removed
             */
            public Object updateInternal(Object oKey, Object oValue, boolean fRemove)
                {
                // import com.tangosol.net.partition.Ownership;
                
                if (getService().isAcceptingClients() && !isAssignmentCompleted())
                    {
                    PartitionedService.PartitionConfig config = (PartitionedService.PartitionConfig) get_Parent();
                    int              iPart  = ((Integer) oKey).intValue();
                
                    // COH-7489: only update if we are accepting clients; defer all earlier
                    // updates because we may not yet have the "correct" partition-count
                    if (config.isPartition(iPart) && ((Ownership) oValue).getPrimaryOwner() != 0)
                        {
                        getInitializedPartitions().add(iPart);
                        }
                    }
                
                return super.updateInternal(oKey, oValue, fRemove);
                }

            // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService$PartitionConfig$Map$EntrySet
            
            @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
            public static class EntrySet
                    extends    com.tangosol.coherence.component.util.ServiceConfig.Map.EntrySet
                {
                // ---- Fields declarations ----
                private static com.tangosol.util.ListMap __mapChildren;
                
                // Static initializer
                static
                    {
                    __initStatic();
                    }
                
                // Default static initializer
                private static void __initStatic()
                    {
                    // register child classes
                    __mapChildren = new com.tangosol.util.ListMap();
                    __mapChildren.put("Entry", PartitionedService.PartitionConfig.Map.EntrySet.Entry.get_CLASS());
                    __mapChildren.put("Iterator", PartitionedService.PartitionConfig.Map.EntrySet.Iterator.get_CLASS());
                    }
                
                // Default constructor
                public EntrySet()
                    {
                    this(null, null, true);
                    }
                
                // Initializing constructor
                public EntrySet(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                    {
                    super(sName, compParent, false);
                    
                    if (fInit)
                        {
                        __init();
                        }
                    }
                
                // Main initializer
                public void __init()
                    {
                    // private initialization
                    __initPrivate();
                    
                    
                    // containment initialization: children
                    
                    // signal the end of the initialization
                    set_Constructed(true);
                    }
                
                // Private initializer
                protected void __initPrivate()
                    {
                    
                    super.__initPrivate();
                    }
                
                //++ getter for static property _Instance
                /**
                 * Getter for property _Instance.<p>
                * Auto generated
                 */
                public static com.tangosol.coherence.Component get_Instance()
                    {
                    return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.PartitionConfig.Map.EntrySet();
                    }
                
                //++ getter for static property _CLASS
                /**
                 * Getter for property _CLASS.<p>
                * Property with auto-generated accessor that returns the Class
                * object for a given component.
                 */
                public static Class get_CLASS()
                    {
                    Class clz;
                    try
                        {
                        clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/PartitionedService$PartitionConfig$Map$EntrySet".replace('/', '.'));
                        }
                    catch (ClassNotFoundException e)
                        {
                        throw new NoClassDefFoundError(e.getMessage());
                        }
                    return clz;
                    }
                
                //++ getter for autogen property _Module
                /**
                 * This is an auto-generated method that returns the global
                * [design time] parent component.
                * 
                * Note: the class generator will ignore any custom
                * implementation for this behavior.
                 */
                private com.tangosol.coherence.Component get_Module()
                    {
                    return this.get_Parent().get_Parent().get_Parent();
                    }
                
                //++ getter for autogen property _ChildClasses
                /**
                 * This is an auto-generated method that returns the map of
                * design time [static] children.
                * 
                * Note: the class generator will ignore any custom
                * implementation for this behavior.
                 */
                protected java.util.Map get_ChildClasses()
                    {
                    return __mapChildren;
                    }

                // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService$PartitionConfig$Map$EntrySet$Entry
                
                @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
                public static class Entry
                        extends    com.tangosol.coherence.component.util.ServiceConfig.Map.EntrySet.Entry
                    {
                    // ---- Fields declarations ----
                    
                    // Default constructor
                    public Entry()
                        {
                        this(null, null, true);
                        }
                    
                    // Initializing constructor
                    public Entry(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                        {
                        super(sName, compParent, false);
                        
                        if (fInit)
                            {
                            __init();
                            }
                        }
                    
                    // Main initializer
                    public void __init()
                        {
                        // private initialization
                        __initPrivate();
                        
                        
                        // signal the end of the initialization
                        set_Constructed(true);
                        }
                    
                    // Private initializer
                    protected void __initPrivate()
                        {
                        
                        super.__initPrivate();
                        }
                    
                    //++ getter for static property _Instance
                    /**
                     * Getter for property _Instance.<p>
                    * Auto generated
                     */
                    public static com.tangosol.coherence.Component get_Instance()
                        {
                        return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.PartitionConfig.Map.EntrySet.Entry();
                        }
                    
                    //++ getter for static property _CLASS
                    /**
                     * Getter for property _CLASS.<p>
                    * Property with auto-generated accessor that returns the
                    * Class object for a given component.
                     */
                    public static Class get_CLASS()
                        {
                        Class clz;
                        try
                            {
                            clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/PartitionedService$PartitionConfig$Map$EntrySet$Entry".replace('/', '.'));
                            }
                        catch (ClassNotFoundException e)
                            {
                            throw new NoClassDefFoundError(e.getMessage());
                            }
                        return clz;
                        }
                    
                    //++ getter for autogen property _Module
                    /**
                     * This is an auto-generated method that returns the global
                    * [design time] parent component.
                    * 
                    * Note: the class generator will ignore any custom
                    * implementation for this behavior.
                     */
                    private com.tangosol.coherence.Component get_Module()
                        {
                        return this.get_Parent().get_Parent().get_Parent().get_Parent();
                        }
                    }

                // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService$PartitionConfig$Map$EntrySet$Iterator
                
                @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
                public static class Iterator
                        extends    com.tangosol.coherence.component.util.ServiceConfig.Map.EntrySet.Iterator
                    {
                    // ---- Fields declarations ----
                    
                    // Default constructor
                    public Iterator()
                        {
                        this(null, null, true);
                        }
                    
                    // Initializing constructor
                    public Iterator(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                        {
                        super(sName, compParent, false);
                        
                        if (fInit)
                            {
                            __init();
                            }
                        }
                    
                    // Main initializer
                    public void __init()
                        {
                        // private initialization
                        __initPrivate();
                        
                        
                        // signal the end of the initialization
                        set_Constructed(true);
                        }
                    
                    // Private initializer
                    protected void __initPrivate()
                        {
                        
                        super.__initPrivate();
                        }
                    
                    //++ getter for static property _Instance
                    /**
                     * Getter for property _Instance.<p>
                    * Auto generated
                     */
                    public static com.tangosol.coherence.Component get_Instance()
                        {
                        return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.PartitionConfig.Map.EntrySet.Iterator();
                        }
                    
                    //++ getter for static property _CLASS
                    /**
                     * Getter for property _CLASS.<p>
                    * Property with auto-generated accessor that returns the
                    * Class object for a given component.
                     */
                    public static Class get_CLASS()
                        {
                        Class clz;
                        try
                            {
                            clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/PartitionedService$PartitionConfig$Map$EntrySet$Iterator".replace('/', '.'));
                            }
                        catch (ClassNotFoundException e)
                            {
                            throw new NoClassDefFoundError(e.getMessage());
                            }
                        return clz;
                        }
                    
                    //++ getter for autogen property _Module
                    /**
                     * This is an auto-generated method that returns the global
                    * [design time] parent component.
                    * 
                    * Note: the class generator will ignore any custom
                    * implementation for this behavior.
                     */
                    private com.tangosol.coherence.Component get_Module()
                        {
                        return this.get_Parent().get_Parent().get_Parent().get_Parent();
                        }
                    }
                }

            // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService$PartitionConfig$Map$KeySet
            
            @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
            public static class KeySet
                    extends    com.tangosol.coherence.component.util.ServiceConfig.Map.KeySet
                {
                // ---- Fields declarations ----
                private static com.tangosol.util.ListMap __mapChildren;
                
                // Static initializer
                static
                    {
                    __initStatic();
                    }
                
                // Default static initializer
                private static void __initStatic()
                    {
                    // register child classes
                    __mapChildren = new com.tangosol.util.ListMap();
                    __mapChildren.put("Iterator", PartitionedService.PartitionConfig.Map.KeySet.Iterator.get_CLASS());
                    }
                
                // Default constructor
                public KeySet()
                    {
                    this(null, null, true);
                    }
                
                // Initializing constructor
                public KeySet(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                    {
                    super(sName, compParent, false);
                    
                    if (fInit)
                        {
                        __init();
                        }
                    }
                
                // Main initializer
                public void __init()
                    {
                    // private initialization
                    __initPrivate();
                    
                    
                    // containment initialization: children
                    
                    // signal the end of the initialization
                    set_Constructed(true);
                    }
                
                // Private initializer
                protected void __initPrivate()
                    {
                    
                    super.__initPrivate();
                    }
                
                //++ getter for static property _Instance
                /**
                 * Getter for property _Instance.<p>
                * Auto generated
                 */
                public static com.tangosol.coherence.Component get_Instance()
                    {
                    return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.PartitionConfig.Map.KeySet();
                    }
                
                //++ getter for static property _CLASS
                /**
                 * Getter for property _CLASS.<p>
                * Property with auto-generated accessor that returns the Class
                * object for a given component.
                 */
                public static Class get_CLASS()
                    {
                    Class clz;
                    try
                        {
                        clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/PartitionedService$PartitionConfig$Map$KeySet".replace('/', '.'));
                        }
                    catch (ClassNotFoundException e)
                        {
                        throw new NoClassDefFoundError(e.getMessage());
                        }
                    return clz;
                    }
                
                //++ getter for autogen property _Module
                /**
                 * This is an auto-generated method that returns the global
                * [design time] parent component.
                * 
                * Note: the class generator will ignore any custom
                * implementation for this behavior.
                 */
                private com.tangosol.coherence.Component get_Module()
                    {
                    return this.get_Parent().get_Parent().get_Parent();
                    }
                
                //++ getter for autogen property _ChildClasses
                /**
                 * This is an auto-generated method that returns the map of
                * design time [static] children.
                * 
                * Note: the class generator will ignore any custom
                * implementation for this behavior.
                 */
                protected java.util.Map get_ChildClasses()
                    {
                    return __mapChildren;
                    }

                // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService$PartitionConfig$Map$KeySet$Iterator
                
                @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
                public static class Iterator
                        extends    com.tangosol.coherence.component.util.ServiceConfig.Map.KeySet.Iterator
                    {
                    // ---- Fields declarations ----
                    
                    // Default constructor
                    public Iterator()
                        {
                        this(null, null, true);
                        }
                    
                    // Initializing constructor
                    public Iterator(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                        {
                        super(sName, compParent, false);
                        
                        if (fInit)
                            {
                            __init();
                            }
                        }
                    
                    // Main initializer
                    public void __init()
                        {
                        // private initialization
                        __initPrivate();
                        
                        
                        // signal the end of the initialization
                        set_Constructed(true);
                        }
                    
                    // Private initializer
                    protected void __initPrivate()
                        {
                        
                        super.__initPrivate();
                        }
                    
                    //++ getter for static property _Instance
                    /**
                     * Getter for property _Instance.<p>
                    * Auto generated
                     */
                    public static com.tangosol.coherence.Component get_Instance()
                        {
                        return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.PartitionConfig.Map.KeySet.Iterator();
                        }
                    
                    //++ getter for static property _CLASS
                    /**
                     * Getter for property _CLASS.<p>
                    * Property with auto-generated accessor that returns the
                    * Class object for a given component.
                     */
                    public static Class get_CLASS()
                        {
                        Class clz;
                        try
                            {
                            clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/PartitionedService$PartitionConfig$Map$KeySet$Iterator".replace('/', '.'));
                            }
                        catch (ClassNotFoundException e)
                            {
                            throw new NoClassDefFoundError(e.getMessage());
                            }
                        return clz;
                        }
                    
                    //++ getter for autogen property _Module
                    /**
                     * This is an auto-generated method that returns the global
                    * [design time] parent component.
                    * 
                    * Note: the class generator will ignore any custom
                    * implementation for this behavior.
                     */
                    private com.tangosol.coherence.Component get_Module()
                        {
                        return this.get_Parent().get_Parent().get_Parent().get_Parent();
                        }
                    }
                }

            // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService$PartitionConfig$Map$Values
            
            @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
            public static class Values
                    extends    com.tangosol.coherence.component.util.ServiceConfig.Map.Values
                {
                // ---- Fields declarations ----
                private static com.tangosol.util.ListMap __mapChildren;
                
                // Static initializer
                static
                    {
                    __initStatic();
                    }
                
                // Default static initializer
                private static void __initStatic()
                    {
                    // register child classes
                    __mapChildren = new com.tangosol.util.ListMap();
                    __mapChildren.put("Iterator", PartitionedService.PartitionConfig.Map.Values.Iterator.get_CLASS());
                    }
                
                // Default constructor
                public Values()
                    {
                    this(null, null, true);
                    }
                
                // Initializing constructor
                public Values(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                    {
                    super(sName, compParent, false);
                    
                    if (fInit)
                        {
                        __init();
                        }
                    }
                
                // Main initializer
                public void __init()
                    {
                    // private initialization
                    __initPrivate();
                    
                    
                    // containment initialization: children
                    
                    // signal the end of the initialization
                    set_Constructed(true);
                    }
                
                // Private initializer
                protected void __initPrivate()
                    {
                    
                    super.__initPrivate();
                    }
                
                //++ getter for static property _Instance
                /**
                 * Getter for property _Instance.<p>
                * Auto generated
                 */
                public static com.tangosol.coherence.Component get_Instance()
                    {
                    return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.PartitionConfig.Map.Values();
                    }
                
                //++ getter for static property _CLASS
                /**
                 * Getter for property _CLASS.<p>
                * Property with auto-generated accessor that returns the Class
                * object for a given component.
                 */
                public static Class get_CLASS()
                    {
                    Class clz;
                    try
                        {
                        clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/PartitionedService$PartitionConfig$Map$Values".replace('/', '.'));
                        }
                    catch (ClassNotFoundException e)
                        {
                        throw new NoClassDefFoundError(e.getMessage());
                        }
                    return clz;
                    }
                
                //++ getter for autogen property _Module
                /**
                 * This is an auto-generated method that returns the global
                * [design time] parent component.
                * 
                * Note: the class generator will ignore any custom
                * implementation for this behavior.
                 */
                private com.tangosol.coherence.Component get_Module()
                    {
                    return this.get_Parent().get_Parent().get_Parent();
                    }
                
                //++ getter for autogen property _ChildClasses
                /**
                 * This is an auto-generated method that returns the map of
                * design time [static] children.
                * 
                * Note: the class generator will ignore any custom
                * implementation for this behavior.
                 */
                protected java.util.Map get_ChildClasses()
                    {
                    return __mapChildren;
                    }

                // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService$PartitionConfig$Map$Values$Iterator
                
                @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
                public static class Iterator
                        extends    com.tangosol.coherence.component.util.ServiceConfig.Map.Values.Iterator
                    {
                    // ---- Fields declarations ----
                    
                    // Default constructor
                    public Iterator()
                        {
                        this(null, null, true);
                        }
                    
                    // Initializing constructor
                    public Iterator(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                        {
                        super(sName, compParent, false);
                        
                        if (fInit)
                            {
                            __init();
                            }
                        }
                    
                    // Main initializer
                    public void __init()
                        {
                        // private initialization
                        __initPrivate();
                        
                        
                        // signal the end of the initialization
                        set_Constructed(true);
                        }
                    
                    // Private initializer
                    protected void __initPrivate()
                        {
                        
                        super.__initPrivate();
                        }
                    
                    //++ getter for static property _Instance
                    /**
                     * Getter for property _Instance.<p>
                    * Auto generated
                     */
                    public static com.tangosol.coherence.Component get_Instance()
                        {
                        return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.PartitionConfig.Map.Values.Iterator();
                        }
                    
                    //++ getter for static property _CLASS
                    /**
                     * Getter for property _CLASS.<p>
                    * Property with auto-generated accessor that returns the
                    * Class object for a given component.
                     */
                    public static Class get_CLASS()
                        {
                        Class clz;
                        try
                            {
                            clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/PartitionedService$PartitionConfig$Map$Values$Iterator".replace('/', '.'));
                            }
                        catch (ClassNotFoundException e)
                            {
                            throw new NoClassDefFoundError(e.getMessage());
                            }
                        return clz;
                        }
                    
                    //++ getter for autogen property _Module
                    /**
                     * This is an auto-generated method that returns the global
                    * [design time] parent component.
                    * 
                    * Note: the class generator will ignore any custom
                    * implementation for this behavior.
                     */
                    private com.tangosol.coherence.Component get_Module()
                        {
                        return this.get_Parent().get_Parent().get_Parent().get_Parent();
                        }
                    }
                }
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService$PartitionControl
    
    /**
     * PartitionControl provides the means to control access to a partition's
     * contents across multiple threads.
     * 
     * Note: Since a PartitionControl component is created for each partition,
     * we are using the _Feed and _Sink properties to hold partition state as a
     * storage optimization.
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static abstract class PartitionControl
            extends    com.tangosol.coherence.Component
            implements com.tangosol.net.Guardable
        {
        // ---- Fields declarations ----
        
        /**
         * Property BackupPolls
         *
         * Count of pending backup request msgs for the partition.
         */
        private transient java.util.concurrent.atomic.AtomicInteger __m_BackupPolls;
        
        /**
         * Property BackupsCompletedActions
         *
         * List of continuations to complete when all outstanding backup polls
         * have completed.  Used only while the partition is locked.
         */
        private java.util.List __m_BackupsCompletedActions;
        
        /**
         * Property Context
         *
         * The PartitionControl's GuardContext or null if it is not currently
         * guarded.
         * 
         * This is used by the service thread only.
         */
        private com.tangosol.net.Guardian.GuardContext __m_Context;
        
        /**
         * Property DeferredBackup
         *
         * The deferred backup of ExpectedVersion for this partition. This node
         * must be the primary owner previously; and is in the process of
         * transferring the partition out; and it is assigned as backup owner.
         * The message will be processed right before the partition is
         * unlocked. 
         * see #onTransferRequestCompleted.
         */
        private com.tangosol.coherence.component.net.Message __m_DeferredBackup;
        
        /**
         * Property DeferredBackups
         *
         * The list of deferred backups messages for this partition that remain
         * to be processed.  The elements of the list are indexed in the order
         * of the corresponding partition version, starting with the first
         * "skipped" version.  More formally, the element at index k holds the
         * BackupRequest representing the partition version of (ExpectedVersion
         * + k + 1) where (ExpectedVersion=VersionCounter + 1) until we have
         * received the backup for ExpectedVersion.
         * 
         * Used by the backup partition owner only.
         */
        private java.util.List __m_DeferredBackups;
        
        /**
         * Property EventStartTime
         *
         * Event start time, to keep track of partition unavailability times.
         * Only set when a partition is locked.
         */
        private long __m_EventStartTime;
        
        /**
         * Property LOCK_BACKUP_XFER_OUT
         *
         * Lock for Backup partition transfer.
         */
        public static final int LOCK_BACKUP_XFER_OUT = 1;
        
        /**
         * Property LOCK_NONE
         *
         * Lock type for an unlocked partition.
         */
        public static final int LOCK_NONE = 0;
        
        /**
         * Property LOCK_PENDING
         *
         * Lock is pending.
         */
        public static final int LOCK_PENDING = 8;
        
        /**
         * Property LOCK_PERSISTENCE
         *
         * Lock for partition persistence snapshot.
         */
        public static final int LOCK_PERSISTENCE = 4;
        
        /**
         * Property LOCK_PRIMARY_XFER_IN
         *
         * Lock type for incoming primary partition transfer (or partition
         * recovery).
         */
        public static final int LOCK_PRIMARY_XFER_IN = 2;
        
        /**
         * Property LOCK_PRIMARY_XFER_OUT
         *
         * Lock type for outgoing primary partition transfer.
         */
        public static final int LOCK_PRIMARY_XFER_OUT = 3;
        
        /**
         * Property LockAttempt
         *
         * A counter on the number of attempts to lock the partition.
         */
        private int __m_LockAttempt;
        
        /**
         * Property LockId
         *
         * An Id that identify a lock action;  a combination of lock type and
         * member id.
         */
        private int __m_LockId;
        
        /**
         * Property PARTITION_EVENT_ASSIGNED
         *
         * Id for the assigned partition event.
         */
        public static final int PARTITION_EVENT_ASSIGNED = 10;
        
        /**
         * Property PARTITION_EVENT_INDEX_BUILD
         *
         * Id for index build partition log message.
         */
        public static final int PARTITION_EVENT_INDEX_BUILD = 11;
        
        /**
         * Property PARTITION_EVENT_RESTORE
         *
         * Id for restore partition log message.
         */
        public static final int PARTITION_EVENT_RESTORE = 12;
        
        /**
         * Property PartitionId
         *
         * The partition id.
         */
        private int __m_PartitionId;
        
        /**
         * Property PartitionState
         *
         * General-purpose bit-vector used to describe the state of the
         * associated partition.  Currently this is used for tracking the
         * partition-lock type as well as the transfer state.
         * 
         * The bits are reserved as follows:
         * 
         * 1-3: Used to describe the lock type (LOCK_*)
         * 4    : Lock is pending (LOCK_PENDING)
         * 5-6: Transfer status (XFER_*)
         * 7    : Partition is pinned (transfer prevented)
         * 
         * @volatile
         */
        private volatile int __m_PartitionState;
        
        /**
         * Property PendingBackups
         *
         * A LongArray keyed by cache id of map entries that have been modified
         * and need to be backed up.
         */
        private com.tangosol.util.LongArray __m_PendingBackups;
        
        /**
         * Property PendingBackupTotalSize
         *
         */
        private java.util.Map __m_PendingBackupTotalSize;
        
        /**
         * Property PersistenceTasks
         *
         * Count of pending persistence tasks for the partition.
         */
        private transient java.util.concurrent.atomic.AtomicInteger __m_PersistenceTasks;
        
        /**
         * Property PersistentBackupExtents
         *
         * A 'list' of backup persistent extents (cache ids) that have been
         * registered with this member, either directly via storage creation or
         * transitively by partition transfer, but have not been ensured with
         * this PartitionControl's PersistentBackupStore.
         */
        private com.tangosol.net.internal.CopyOnWriteLongList __m_PersistentBackupExtents;
        
        /**
         * Property PersistentBackupStore
         *
         * The backup persistent store associated with this partition.
         */
        private transient com.oracle.coherence.persistence.PersistentStore __m_PersistentBackupStore;
        
        /**
         * Property PersistentEventsStore
         *
         * The persistent store associated with this partition.
         */
        private transient com.oracle.coherence.persistence.PersistentStore __m_PersistentEventsStore;
        
        /**
         * Property PersistentExtents
         *
         * A 'list' of persistent extents (cache ids) that have been registered
         * with this member, either directly via storage creation or
         * transitively by partition transfer, but have not been ensured with
         * this PartitionControl's PersistentStore.
         */
        private com.tangosol.net.internal.CopyOnWriteLongList __m_PersistentExtents;
        
        /**
         * Property PersistentStore
         *
         * The persistent store associated with this partition.
         * 
         * @volatile
         */
        private volatile transient PersistentStore __m_PersistentStore;
        
        /**
         * Property Recovered
         *
         * Flag used to indicate whether a partition has been recovered from
         * the PersistentStore. This flag must be used in combination with
         * LockType == LOCK_PERSISTENCE. @see #isRecovering method.
         */
        private boolean __m_Recovered;
        
        /**
         * Property STATE_MASK_LOCK
         *
         * Bit mask selecting the bits of the PartitionState that pertain to
         * the LockType.
         * 
         * 0x0F (bits 1-3)
         */
        public static final int STATE_MASK_LOCK = 15;
        
        /**
         * Property STATE_MASK_PIN
         *
         * Bit mask selecting the bit of the PartitionState that pertains to a
         * transfer prevention.
         * 
         * 0x40 (bit 6)
         */
        public static final int STATE_MASK_PIN = 64;
        
        /**
         * Property STATE_MASK_SYNC
         *
         * Bit mask selecting the bit of the PartitionState (partition is 
         * waiting for a version sync request to complete) that pertains to a
         * transfer prevention.
         * 
         * 0x80 (bit 8)
         */
        public static final int STATE_MASK_SYNC = 128;
        
        /**
         * Property STATE_MASK_XFER
         *
         * Bit mask selecting the bits of the PartitionState that pertain to
         * the TransferState.
         * 
         * 0x30 (bits 4-5)
         */
        public static final int STATE_MASK_XFER = 48;
        
        /**
         * Property STATE_SHIFT_LOCK
         *
         * The number of bits that the LockType is shifted by in the
         * PartitionState.
         */
        public static final int STATE_SHIFT_LOCK = 0;
        
        /**
         * Property STATE_SHIFT_PIN
         *
         * The number of bits that the transfer prevention bit is shifted by in
         * the PartitionState.
         */
        public static final int STATE_SHIFT_PIN = 6;
        
        /**
         * Property STATE_SHIFT_SYNC
         *
         * The number of bits that the corrsponding bit (partition is waiting
         * for a version sync request to complete) is shifted by in the
         * PartitionState.
         */
        public static final int STATE_SHIFT_SYNC = 7;
        
        /**
         * Property STATE_SHIFT_XFER
         *
         * The number of bits that the TransferState is shifted by in the
         * PartitionState.
         */
        public static final int STATE_SHIFT_XFER = 4;
        
        /**
         * Property Statistics
         *
         * The statistics for this partition.
         */
        private com.tangosol.net.partition.PartitionStatistics __m_Statistics;
        
        /**
         * Property TLOEnterCounter
         *
         * A thread local to track the number of times this thread has 'enter'd
         * this partition.
         */
        private ThreadLocal __m_TLOEnterCounter;
        
        /**
         * Property VersionBackup
         *
         * The latest partition version known to have been "committed" by the
         * backups.
         * 
         * @since 12.1.3
         */
        private long __m_VersionBackup;
        
        /**
         * Property VersionCounter
         *
         * The partition version represents a transactional change unit.
         * 
         * This is used for backup-message ordering of changes, and does not
         * necessarily reflect changes of ownership information.
         * 
         * @since 12.1.2
         */
        private java.util.concurrent.atomic.AtomicLong __m_VersionCounter;
        
        /**
         * Property VersionIncrementer
         *
         * The supplier that increments and returns the partition version.
         */
        private java.util.function.LongSupplier __m_VersionIncrementer;
        
        /**
         * Property XFER_NONE
         *
         * Transfer state constant indicating that this partition is not
         * involved in transfer.
         */
        public static final int XFER_NONE = 0;
        
        /**
         * Property XFER_SENT
         *
         * Transfer state constant indicating that this partition has been sent.
         */
        public static final int XFER_SENT = 2;
        
        /**
         * Property XFER_STARTED
         *
         * Transfer state constant indicating that this partition has started
         * to be sent.
         */
        public static final int XFER_STARTED = 1;
        private static com.tangosol.util.ListMap __mapChildren;
        
        // Static initializer
        static
            {
            __initStatic();
            }
        
        // Default static initializer
        private static void __initStatic()
            {
            // register child classes
            __mapChildren = new com.tangosol.util.ListMap();
            __mapChildren.put("GuardContinuation", PartitionedService.PartitionControl.GuardContinuation.get_CLASS());
            }
        
        // Initializing constructor
        public PartitionControl(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/PartitionedService$PartitionControl".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        //++ getter for autogen property _ChildClasses
        /**
         * This is an auto-generated method that returns the map of design time
        * [static] children.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        protected java.util.Map get_ChildClasses()
            {
            return __mapChildren;
            }
        
        /**
         * Add the specified continuation to the list of actions to run once all
        * pending backup requests have completed.
        * 
        * Called from the service thread only while the control is locked.
         */
        public synchronized void addBackupsCompletedAction(com.oracle.coherence.common.base.Continuation continuation)
            {
            // import java.util.LinkedList;
            // import java.util.List;
            
            _assert(isLocked());
            
            List list = getBackupsCompletedActions();
            if (list == null)
                {
                list = new LinkedList();
                setBackupsCompletedActions(list);
                }
            
            list.add(continuation);
            }
        
        /**
         * Add a continuation action to be run immediately prior to unlocking
        * this partition.
        * The action will be run by the thread that holds the partition lock
        * (and is about to release it).
         */
        public synchronized void addUnlockAction(com.oracle.coherence.common.base.Continuation continuation)
            {
            // import java.util.Queue as java.util.Queue;
            // import java.util.concurrent.ConcurrentLinkedQueue;
            
            java.util.Queue queueActions = getUnlockActions();
            if (queueActions == null)
                {
                set_Sink(queueActions = new ConcurrentLinkedQueue());
                }
            queueActions.offer(continuation);
            }
        
        /**
         * Marks the beginning of a partition event that generally suggests that
        * partition will be inaccessible for a period of time.
         */
        public void beginEvent()
            {
            // import com.tangosol.util.Base;
            
            setEventStartTime(Base.getSafeTimeMillis());
            }
        
        /**
         * Check if there are outstanding backup versions and ensure that the
        * partition control is guarded if there are.
        * 
        * Called on the serivce thread only.
         */
        public void checkDeferredBackups()
            {
            if (getContext() == null && !getDeferredBackups().isEmpty())
                {
                PartitionedService service = getService();
            
                service.guard(this, service.getDeferredBackupTimeoutMillis(), 0.9F);
                }
            }
        
        /**
         * Put the specified message at the DeferredBackup list accoridng to the
        * specified version values.
        * 
        * @param msgBackup either BackupMutliRequest or BackupRequest
        * 
        * @see DeferredBackups property documentation for the list index
        * semantics
         */
        public void deferBackup(com.tangosol.coherence.component.net.Message msgBackup, long lVersionNew)
            {
            // import java.util.List;
            
            List listDefer    = getDeferredBackups();
            long lVersionNext = getVersionCounter().get() + 1;
            int  iNew         = (int) (lVersionNew - lVersionNext - 1); // index of the new msg to defer
            int  iMax         = listDefer.size();                       // max index of the deferred array
            
            if (lVersionNew == lVersionNext)
                {
                // received a backup of the expected version which is only possible if we
                // are finalizing transferring-out; see #onTransferRequestCompleted
                setDeferredBackup(msgBackup);
                }
            else if (iNew >= iMax)
                {
                // add empty "gap" entries
                for (int i = iMax; i < iNew; i++)
                    {
                    listDefer.add(null);
                    }
            
                listDefer.add(msgBackup);
                }
            else
                {
                listDefer.set(iNew, msgBackup);
                }
            }
        
        /**
         * Defer sending the specified response message until the partition is
        * unlocked.
        * 
        * @return true if the deferred action was registered; false otherwise
        * (partition has just been unlocked)
         */
        public synchronized boolean deferResponse(com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.partitionedService.PartitionedCache.Response msgResponse)
            {
            if (getLockType() == LOCK_NONE)
                {
                // this must be a transient condition as state is changing; try again
                return false;
                }
            else
                {
                // the partition must be locked for transfer; defer the processing
                // until the transfer lock is released
                msgResponse.setResult(PartitionedService.Response.RESULT_RETRY);
            
                addUnlockAction(getService().getContinuations().
                    instantiateMessagePost(msgResponse));
                return true;
                }
            }
        
        /**
         * Delete the persistent store associated with this control, and
        * disassociate it from this partition.
         */
        public void deleteBackupPersistentStore()
            {
            // import com.oracle.coherence.persistence.PersistentStore;
            
            PersistentStore store = getPersistentBackupStore();
            
            if (store != null)
                {
                String sStoreId = store.getId();
                if (sStoreId != null)
                    {
                    getService().getPersistenceControl().getBackupManager().delete(sStoreId, false);
                    _trace("Deleted persistent backup store " + sStoreId, 7);
                    }
                }
            
            setPersistentBackupStore(null);
            }
        
        /**
         * Delete the persistent information for the provided cache id.
        * 
        * @param lExtentId  the extent to delete
        * @param laCaches  the caches (id -> name) to store in the
        * PersistentStore
         */
        public void deletePersistentExtent(long lExtentId, com.tangosol.util.LongArray laCaches)
            {
            }
        
        /**
         * Delete the persistent store associated with this control, and
        * disassociate it from this partition.
         */
        public void deletePersistentStore()
            {
            // import com.oracle.coherence.persistence.PersistentStore;
            
            PersistentStore[] aStore = new PersistentStore[] {getPersistentStore(), getPersistentEventsStore()};
            
            for (int i = 0, c = aStore.length; i < c; ++i)
                {
                PersistentStore store = aStore[i];
                if (store != null)
                    {
                    String sStoreId = store.getId();
                    if (sStoreId != null)
                        {
                        getService().getPersistenceManager().delete(sStoreId, false);
                        _trace("Deleted persistent store " + sStoreId, 7);
                        }
                    }
                }
            
            
            setPersistentStore(null);
            setPersistentEventsStore(null);
            }
        
        /**
         * Disable the active persistent store associated with this partition
        * control.
        * This method is called on the service thread only.
         */
        public void disablePersistentStore()
            {
            // import com.tangosol.util.NullImplementation;
            
            setPersistentStore(NullImplementation.getPersistentStore());
            setPersistentEventsStore(NullImplementation.getPersistentStore());
            }
        
        /**
         * Ensure that the backup owners for the specified partition are
        * synchronized to the specified partition version.
        * Called on the service thread by the primary owner only.
         */
        public void doSyncBackups()
            {
            // import java.util.List;
            
            flushDeferredBackups();
            
            PartitionedService service     = (PartitionedService) get_Module();
            int     nPartition  = getPartitionId();
            List    listBackups = service.getBackupOwners(nPartition, /*fIncludeTransitional*/ false);
            if (!listBackups.isEmpty())
                {
                // prevent transfer
                markVersionInSync();
            
                // ensure that the backups synchronize the partition version
                // and drop any deferred backups as well
                PartitionedService.PartitionVersionSyncRequest msg =
                        (PartitionedService.PartitionVersionSyncRequest) service.instantiateMessage("PartitionVersionSyncRequest");
            
                msg.setPartition(nPartition);
                msg.setPartitionVersion(getVersionCounter().get());
                msg.setMemberList(listBackups);
            
                service.post(msg);
                }
            }
        
        /**
         * Enable (primary and/or backup) transfers for this partition.
        * 
        * This method is only called on the service thread.
         */
        public void enableTransfer()
            {
            // import com.tangosol.util.Gate;
            
            Gate gate = getGate();
            if (gate.isEnteredByCurrentThread())
                {
                gate.exit();
                setPartitionState(getPartitionState() & ~STATE_MASK_PIN);
                }
            else if (getLockType() != LOCK_NONE)
                {
                // soft assert
                _trace("Unexpected enableTransfer() call for " + this + "\n" + get_StackTrace(), 2);
                }
            }
        
        /**
         * Marks the end of a partition event that generally suggests that
        * partition will be inaccesible for a period of time.
         */
        public void endEvent(int iPartition, int nLockType, boolean fRollBack)
            {
            // import com.tangosol.util.Base;
            
            if (!fRollBack)
                {
                getService().handlePartitionTrace(iPartition, getPartitionEventDescription(nLockType),
                    Base.getSafeTimeMillis() - getEventStartTime());
                }
            
            setEventStartTime(0L);
            }
        
        /**
         * Ensure that a LongArray<CacheId, Map<K, K>> that stores the pending
        * backup changes associated to this partition is created.
         */
        public com.tangosol.util.LongArray ensurePendingBackups()
            {
            // import com.tangosol.util.LongArray;
            // import com.tangosol.util.CopyOnWriteLongArray;
            
            LongArray laBackups = getPendingBackups();
            
            if (laBackups == null)
                {
                synchronized (this)
                    {
                    laBackups = getPendingBackups();
                    if (laBackups == null)
                        {
                        setPendingBackups(laBackups = new CopyOnWriteLongArray());
                        }
                    }
                }
            
            return laBackups;
            }
        
        public java.util.Map ensurePendingBackupTotalSize()
            {
            // import java.util.concurrent.ConcurrentHashMap;
            
            ConcurrentHashMap map = (ConcurrentHashMap) getPendingBackupTotalSize();
            
            if (map == null)
                {
                synchronized (this)
                    {
                    map = (ConcurrentHashMap) getPendingBackupTotalSize();
                    if (map == null)
                        {
                        setPendingBackupTotalSize(map = new ConcurrentHashMap());
                        }
                    }
                }
            
            return map;
            }
        
        /**
         * Ensure a persistent extent is created in the PersistentStore
        * associated with this PartitionControl.
        * 
        * @param lExtentId  the extent to ensure is createad
        * 
        * @see persistChanges
         */
        public boolean ensurePersistentExtent(long lExtentId)
            {
            return false;
            }

        /**
         * Ensure that a persistent store is opened for the partition associated with this control,
         * opening a new store if one does not already exist.
         * This method is called on the service thread only.
         *
         * @return the open persistent sotre
         */
        public PersistentStore ensureOpenPersistentStore()
            {
            return ensureOpenPersistentStore(null, false);
            }

        /**
         * Ensure that a persistent store is opened for the partition associated with this control,
         * opening a new store if one does not already exist.
         * This method is called on the service thread only.
         *
         * @return the open persistent store
         */
        public PersistentStore ensureOpenPersistentStore(PersistentStore storeFrom, boolean fSeal)
            {
            return ensureOpenPersistentStore(storeFrom, fSeal, false);
            }

        /**
         * Ensure that a persistent store is opened for the partition associated with this control,
         * opening a new store if one does not already exist.
         * This method is called on the service thread only.
         *
         * @return the open persistent store
         */
        public PersistentStore ensureOpenPersistentStore(PersistentStore storeFrom, boolean fSeal, boolean fBackupStore)
            {
            PersistentStore store = fBackupStore ? getPersistentBackupStore() : getPersistentStore();

            if (store == null || !store.isOpen() || storeFrom != null)
                {
                synchronized (this)
                    {
                    store = fBackupStore ? getPersistentBackupStore() : getPersistentStore();

                    PartitionedService service = getService();
                    String             sGUID   = null;
                    if (store == null || storeFrom != null)
                        {
                        int     nPartition = getPartitionId();
                        Member  member     = service.getThisMember();
                        long    ldtJoin    = service.getServiceMemberSet().getServiceJoinTime(member.getId());

                        sGUID = GUIDHelper.generateGUID(nPartition,
                                                        service.getOwnershipVersion(nPartition),
                                                        ldtJoin,
                                                        member);
                        }
                    else if (!store.isOpen())
                        {
                        sGUID = store.getId();
                        }

                    if (sGUID != null)
                        {
                        store = fBackupStore
                                ? service.getPersistenceControl().openBackupStore(sGUID, storeFrom)
                                : service.getPersistenceControl().openActiveStore(sGUID, storeFrom);

                        // seal immediately if not opened during partition ownership change
                        if (fSeal)
                            {
                            CachePersistenceHelper.seal(store, service, /*oToken*/ null);
                            }

                        if (fBackupStore)
                            {
                            setPersistentBackupStore(store);
                            }
                        else
                            {
                            setPersistentStore(store);
                            }
                        }
                    }
                }

            return store;
            }

        /**
         * Ensure that a persistent directory is created for the partition associated with this control.
         * This method is called on the service thread only.
         */
        public com.oracle.coherence.persistence.PersistentStore ensurePersistentStore()
            {
            return ensurePersistentStore(null);
            }
        
        /**
         * Ensure that a persistent directory is created for the partition associated with this control.
         * This method is called on the service thread only.
         */
        public com.oracle.coherence.persistence.PersistentStore ensurePersistentStore(com.oracle.coherence.persistence.PersistentStore storeFrom)
            {
            return ensurePersistentStore(storeFrom, /*fEventsStore*/ true);
            }
        
        /**
         * Ensure that a persistent directory is created for the partition associated with this control.
         * This method is called on the service thread only.
         */
        public com.oracle.coherence.persistence.PersistentStore ensurePersistentStore(com.oracle.coherence.persistence.PersistentStore storeFrom, boolean fEventsStore)
            {
            return ensurePersistentStore(storeFrom, /*fEventsStore*/ fEventsStore, /*fBackupStore*/ false);
            }
        
        /**
         * Ensure that a persistent directory is created for the partition associated with this control.
         * This method is called on the service thread only.
         */
        public com.oracle.coherence.persistence.PersistentStore ensurePersistentStore(com.oracle.coherence.persistence.PersistentStore storeFrom, boolean fEventsStore, boolean fBackupStore)
            {
            // import com.oracle.coherence.persistence.PersistentStore;
            // import com.tangosol.net.Member;
            // import com.tangosol.persistence.GUIDHelper;
            
            PartitionedService             service         = getService();
            PartitionedService.PersistenceControl ctrlPersistence = service.getPersistenceControl();
            PersistentStore     store           = fBackupStore ? getPersistentBackupStore() : getPersistentStore();
            String              sGUID           = null;
            
            if (store == null || storeFrom != null)
                {
                int     nPartition = getPartitionId();
                Member  member     = service.getThisMember();
                long    ldtJoin    = service.getServiceMemberSet().getServiceJoinTime(member.getId());
            
                // maintain version for backup to match primary owner's
                sGUID = GUIDHelper.generateGUID(nPartition,
                                                service.getOwnershipVersion(nPartition) + (fBackupStore ? 1 : 0),
                                                ldtJoin,
                                                member);
            
                if (!fBackupStore)
                    {
                    store = ctrlPersistence.ensurePersistentStore(sGUID);
                    setPersistentStore(store);
                    }
                else
                    {
                    store = ctrlPersistence.ensureBackupPersistentStore(sGUID);
                    setPersistentBackupStore(store);
                    }
                }
            else
                {
                sGUID = store.getId();
                }
            
            if (fEventsStore && (getPersistentEventsStore() == null || storeFrom != null))
                {
                setPersistentEventsStore(ctrlPersistence.openEventsStore(
                        sGUID,
                        storeFrom == null ? null : storeFrom.getId()));
                }
            
            return store;
            }
        
        /**
         * Obtain a non-exclusive read-lock on the partition, waiting no more
        * than the specified time.
        * 
        * @param cWait  the maximum amount of time to wait for the read-lock,
        * or -1 for indefinite
        * 
        * @return true iff the read-lock was obtained
         */
        public boolean enter(long cWait)
            {
            // import com.oracle.coherence.common.base.MutableLong;
            
            ThreadLocal tlo       = getTLOEnterCounter();
            MutableLong mlCounter = (MutableLong) tlo.get();
            
            if (mlCounter.get() > 0 || getGate().enter(cWait))
                {
                mlCounter.incrementAndGet();
                return true;
                }
            
            return false;
            }
        
        /**
         * Release a read-lock on the partition.
         */
        public void exit()
            {
            // import com.oracle.coherence.common.base.MutableLong;
            
            ThreadLocal tlo       = getTLOEnterCounter();
            MutableLong mlCounter = (MutableLong) tlo.get();
            
            if (mlCounter.decrementAndGet() == 0)
                {
                getGate().exit();
                }
            }
        
        /**
         * This method to called to indicate completion of a pending backup
        * message. Updates pending backup messages count for the partition.
        * 
        * @param lVersion the partition version
         */
        public void finishBackup(long lVersion)
            {
            // import com.oracle.coherence.common.base.Continuation;
            // import java.util.Iterator;
            // import java.util.List;
            
            if (lVersion > getVersionBackup())
                {
                setVersionBackup(lVersion);
                }
            
            if (getBackupPolls().decrementAndGet() == 0 && isLocked())
                {
                // if this is the last outstanding backup request poll and the
                // partition is locked, check for deferred actions
                synchronized (this)
                    {
                    List listActions = getBackupsCompletedActions();
                    if (listActions != null)
                        {
                        setBackupsCompletedActions(null);
            
                        for (Iterator iter = listActions.iterator(); iter.hasNext(); )
                            {
                            Continuation cont = (Continuation) iter.next();
                            cont.proceed(null);
                            }
                        }
                    }
                }
            }
        
        /**
         * This method to called to indicate completion of a pending persistence
        * task. Updates pending persistence task count for the partition.
        * 
        * @param lVersion the partition version
         */
        public void finishPersist()
            {
            // import java.util.concurrent.atomic.AtomicInteger;
            
            AtomicInteger atomicTasks = getPersistenceTasks();
            int           cTask       = atomicTasks.decrementAndGet();
            
            if (cTask == 0)
                {
                synchronized (atomicTasks)
                    {
                    atomicTasks.notifyAll();
                    }
                }
            }
        
        /**
         * Check to see if there are any deferred backup requests that can be
        * flushed now.
         */
        public void flushDeferredBackups()
            {
            // import com.tangosol.net.Guardian$GuardContext as com.tangosol.net.Guardian.GuardContext;
            // import Component.Net.Message;
            // import java.util.List;
            
            Message msgExpected = getDeferredBackup();
            
            if (msgExpected != null)
                {
                setDeferredBackup(null);
                msgExpected.onReceived();
                }
            else
                {
                List listDeferred = getDeferredBackups();
            
                if (!listDeferred.isEmpty())
                    {
                    Message msgDeferred = (Message) listDeferred.remove(0);
                    
                    if (msgDeferred != null)
                        {
                        // Note: onReceived() will recurse back with the next deferred backup message
                        msgDeferred.onReceived();
                        }
            
                    com.tangosol.net.Guardian.GuardContext ctx = getContext();
                    if (ctx != null)
                        {
                        // this partition control was guarded to ensure the (now received) missing
                        // version was not lost (see #checkDeferredBackups).
                        if (listDeferred.isEmpty())
                            {
                            // unguard the partition control now that all holes are filled
                            ctx.release();
                            }
                        else
                            {
                            // made some progress on flushing the deferred backups
                            ctx.heartbeat();
                            }
                        }
                    }
                }
            }
        
        // Accessor for the property "BackupPolls"
        /**
         * Getter for property BackupPolls.<p>
        * Count of pending backup request msgs for the partition.
         */
        public java.util.concurrent.atomic.AtomicInteger getBackupPolls()
            {
            return __m_BackupPolls;
            }
        
        // Accessor for the property "BackupsCompletedActions"
        /**
         * Getter for property BackupsCompletedActions.<p>
        * List of continuations to complete when all outstanding backup polls
        * have completed.  Used only while the partition is locked.
         */
        public java.util.List getBackupsCompletedActions()
            {
            return __m_BackupsCompletedActions;
            }
        
        // From interface: com.tangosol.net.Guardable
        // Accessor for the property "Context"
        /**
         * Getter for property Context.<p>
        * The PartitionControl's GuardContext or null if it is not currently
        * guarded.
        * 
        * This is used by the service thread only.
         */
        public com.tangosol.net.Guardian.GuardContext getContext()
            {
            return __m_Context;
            }
        
        // Accessor for the property "DeferredBackup"
        /**
         * Getter for property DeferredBackup.<p>
        * The deferred backup of ExpectedVersion for this partition. This node
        * must be the primary owner previously; and is in the process of
        * transferring the partition out; and it is assigned as backup owner.
        * The message will be processed right before the partition is unlocked.
        * 
        * see #onTransferRequestCompleted.
         */
        public com.tangosol.coherence.component.net.Message getDeferredBackup()
            {
            return __m_DeferredBackup;
            }
        
        // Accessor for the property "DeferredBackups"
        /**
         * Getter for property DeferredBackups.<p>
        * The list of deferred backups messages for this partition that remain
        * to be processed.  The elements of the list are indexed in the order
        * of the corresponding partition version, starting with the first
        * "skipped" version.  More formally, the element at index k holds the
        * BackupRequest representing the partition version of (ExpectedVersion
        * + k + 1) where (ExpectedVersion=VersionCounter + 1) until we have
        * received the backup for ExpectedVersion.
        * 
        * Used by the backup partition owner only.
         */
        public java.util.List getDeferredBackups()
            {
            return __m_DeferredBackups;
            }
        
        // Accessor for the property "EventStartTime"
        /**
         * Getter for property EventStartTime.<p>
        * Event start time, to keep track of partition unavailability times.
        * Only set when a partition is locked.
         */
        public long getEventStartTime()
            {
            return __m_EventStartTime;
            }
        
        // Accessor for the property "Gate"
        /**
         * Getter for property Gate.<p>
        * ThreadGate that controls access to the partition contents.
        * 
        * Held in _Feed for storage optimization.
         */
        public com.tangosol.util.Gate getGate()
            {
            // import com.tangosol.util.Gate;
            
            return (Gate) get_Feed();
            }
        
        // Accessor for the property "LockAttempt"
        /**
         * Getter for property LockAttempt.<p>
        * A counter on the number of attempts to lock the partition.
         */
        public int getLockAttempt()
            {
            return __m_LockAttempt;
            }
        
        // Accessor for the property "LockId"
        /**
         * Getter for property LockId.<p>
        * An Id that identify a lock action;  a combination of lock type and
        * member id.
         */
        public int getLockId()
            {
            return __m_LockId;
            }
        
        /**
         * Return the type of the exclusive lock currently held on this
        * partition (one of the LOCK_* constants), or LOCK_NONE if no lock is
        * held.
         */
        public int getLockType()
            {
            return ((getPartitionState() & STATE_MASK_LOCK) >> STATE_SHIFT_LOCK) & ~LOCK_PENDING;
            }
        
        /**
         * Readable name as string for partition events based on lock type or
        * type.
         */
        public static String getPartitionEventDescription(int nLockType)
            {
            switch(nLockType)
                {
                case LOCK_BACKUP_XFER_OUT:
                    return "BACKUP_TRANSFER_OUT";
                case LOCK_PRIMARY_XFER_IN:
                    return "PRIMARY_TRANSFER_IN";
                case LOCK_PRIMARY_XFER_OUT:
                    return "PRIMARY_TRANSFER_OUT";
                case LOCK_PERSISTENCE:
                    return "PERSISTENCE";
                case PARTITION_EVENT_ASSIGNED:
                    return "ASSIGN";
                case PARTITION_EVENT_INDEX_BUILD:
                    return "INDEX_BUILD";
                case PARTITION_EVENT_RESTORE:
                    return "RESTORE";
                default:
                    return null;
                }
            }
        
        // Accessor for the property "PartitionId"
        /**
         * Getter for property PartitionId.<p>
        * The partition id.
         */
        public int getPartitionId()
            {
            return __m_PartitionId;
            }
        
        // Accessor for the property "PartitionState"
        /**
         * Getter for property PartitionState.<p>
        * General-purpose bit-vector used to describe the state of the
        * associated partition.  Currently this is used for tracking the
        * partition-lock type as well as the transfer state.
        * 
        * The bits are reserved as follows:
        * 
        * 1-3: Used to describe the lock type (LOCK_*)
        * 4    : Lock is pending (LOCK_PENDING)
        * 5-6: Transfer status (XFER_*)
        * 7    : Partition is pinned (transfer prevented)
        * 
        * @volatile
         */
        public int getPartitionState()
            {
            return __m_PartitionState;
            }
        
        // Accessor for the property "PendingBackups"
        /**
         * Getter for property PendingBackups.<p>
        * A LongArray keyed by cache id of map entries that have been modified
        * and need to be backed up.
         */
        public com.tangosol.util.LongArray getPendingBackups()
            {
            return __m_PendingBackups;
            }
        
        // Accessor for the property "PendingBackupTotalSize"
        /**
         * Getter for property PendingBackupTotalSize.<p>
         */
        public java.util.Map getPendingBackupTotalSize()
            {
            return __m_PendingBackupTotalSize;
            }
        
        // Accessor for the property "PersistenceTasks"
        /**
         * Getter for property PersistenceTasks.<p>
        * Count of pending persistence tasks for the partition.
         */
        public java.util.concurrent.atomic.AtomicInteger getPersistenceTasks()
            {
            return __m_PersistenceTasks;
            }
        
        // Accessor for the property "PersistentBackupExtents"
        /**
         * Getter for property PersistentBackupExtents.<p>
        * A 'list' of backup persistent extents (cache ids) that have been
        * registered with this member, either directly via storage creation or
        * transitively by partition transfer, but have not been ensured with
        * this PartitionControl's PersistentBackupStore.
         */
        public com.tangosol.net.internal.CopyOnWriteLongList getPersistentBackupExtents()
            {
            return __m_PersistentBackupExtents;
            }
        
        // Accessor for the property "PersistentBackupStore"
        /**
         * Getter for property PersistentBackupStore.<p>
        * The backup persistent store associated with this partition.
         */
        public com.oracle.coherence.persistence.PersistentStore getPersistentBackupStore()
            {
            return __m_PersistentBackupStore;
            }
        
        // Accessor for the property "PersistentEventsStore"
        /**
         * Getter for property PersistentEventsStore.<p>
        * The persistent store associated with this partition.
         */
        public com.oracle.coherence.persistence.PersistentStore getPersistentEventsStore()
            {
            return __m_PersistentEventsStore;
            }
        
        // Accessor for the property "PersistentExtents"
        /**
         * Getter for property PersistentExtents.<p>
        * A 'list' of persistent extents (cache ids) that have been registered
        * with this member, either directly via storage creation or
        * transitively by partition transfer, but have not been ensured with
        * this PartitionControl's PersistentStore.
         */
        public com.tangosol.net.internal.CopyOnWriteLongList getPersistentExtents()
            {
            return __m_PersistentExtents;
            }
        
        // Accessor for the property "PersistentStore"
        /**
         * Getter for property PersistentStore.<p>
        * The persistent store associated with this partition.
        * 
        * @volatile
         */
        public com.oracle.coherence.persistence.PersistentStore getPersistentStore()
            {
            return __m_PersistentStore;
            }
        
        // Accessor for the property "Service"
        /**
         * Getter for property Service.<p>
         */
        public PartitionedService getService()
            {
            return (PartitionedService) get_Module();
            }
        
        // Accessor for the property "Statistics"
        /**
         * Getter for property Statistics.<p>
        * The statistics for this partition.
         */
        public com.tangosol.net.partition.PartitionStatistics getStatistics()
            {
            return __m_Statistics;
            }
        
        // Accessor for the property "TLOEnterCounter"
        /**
         * Getter for property TLOEnterCounter.<p>
        * A thread local to track the number of times this thread has 'enter'd
        * this partition.
         */
        public ThreadLocal getTLOEnterCounter()
            {
            return __m_TLOEnterCounter;
            }
        
        /**
         * Return the transfer state of this partition (one of the XFER_*
        * constants)
         */
        public int getTransferState()
            {
            return (getPartitionState() & STATE_MASK_XFER) >> STATE_SHIFT_XFER;
            }
        
        // Accessor for the property "UnlockActions"
        /**
         * Returns UnlockActions queue that is lazily created in addUnlockAction.
         */
        public java.util.Queue getUnlockActions()
            {
            // import java.util.Queue as java.util.Queue;
            
            return (java.util.Queue) get_Sink();
            }
        
        // Accessor for the property "VersionBackup"
        /**
         * Getter for property VersionBackup.<p>
        * The latest partition version known to have been "committed" by the
        * backups.
        * 
        * @since 12.1.3
         */
        public long getVersionBackup()
            {
            return __m_VersionBackup;
            }
        
        // Accessor for the property "VersionCounter"
        /**
         * Getter for property VersionCounter.<p>
        * The partition version represents a transactional change unit.
        * 
        * This is used for backup-message ordering of changes, and does not
        * necessarily reflect changes of ownership information.
        * 
        * @since 12.1.2
         */
        public java.util.concurrent.atomic.AtomicLong getVersionCounter()
            {
            return __m_VersionCounter;
            }
        
        // Accessor for the property "VersionIncrementer"
        /**
         * Getter for property VersionIncrementer.<p>
        * The supplier that increments and returns the partition version.
         */
        public java.util.function.LongSupplier getVersionIncrementer()
            {
            return __m_VersionIncrementer;
            }
        
        /**
         * Return true if there are pending changes to backup.
         */
        public boolean hasScheduledBackups()
            {
            // import com.tangosol.util.LongArray;
            
            LongArray laPending = getPendingBackups();
            
            return laPending != null && !laPending.isEmpty();
            }
        
        /**
         * Updates pending backup messages count for the partition.
        * 
        * @return true iff the backup message should be sent synchronously.
         */
        public boolean initiateBackup()
            {
            // Even if async is allowed, go sync if the partition has too many pending backup messages
            
            PartitionedService service = (PartitionedService) get_Module();
            
            // see finishBackup()
            return getBackupPolls().incrementAndGet() >= PartitionedService.MAX_PENDING_BACKUP_POLL ||
                  !service.isAsyncBackup();
            }
        
        /**
         * Updates pending persistence task count for the partition.
        * 
        * @return true iff the persistence task should be sent synchronously
         */
        public boolean initiatePersist()
            {
            // Even if async is allowed, go sync if the partition has too many pending persistence tasks
            
            PartitionedService             service        = (PartitionedService) get_Module();
            PartitionedService.PersistenceControl ctlPersistence = service.getPersistenceControl();
            
            return getPersistenceTasks().incrementAndGet() >= PartitionedService.MAX_PENDING_BACKUP_POLL ||
                  !ctlPersistence.isAsync();
            }
        
        // Accessor for the property "Locked"
        /**
         * Getter for property Locked.<p>
        * Is this partition currently locked?
         */
        public boolean isLocked()
            {
            int nState = (getPartitionState() & STATE_MASK_LOCK) >> STATE_SHIFT_LOCK;
            
            return nState != LOCK_NONE && (nState & LOCK_PENDING) == 0;
            }
        
        // Accessor for the property "Recovered"
        /**
         * Getter for property Recovered.<p>
        * Flag used to indicate whether a partition has been recovered from the
        * PersistentStore. This flag must be used in combination with LockType
        * == LOCK_PERSISTENCE. @see #isRecovering method.
         */
        public boolean isRecovered()
            {
            return __m_Recovered;
            }
        
        // Accessor for the property "Recovering"
        /**
         * Getter for property Recovering.<p>
        * True if the partition is in the process of being recovered from the
        * associated PersistenceStore.
         */
        public boolean isRecovering()
            {
            return (getLockType() & PartitionedService.PartitionControl.LOCK_PERSISTENCE) != 0 && !isRecovered();
            }
        
        // Accessor for the property "TransferDisallowed"
        /**
         * Getter for property TransferDisallowed.<p>
        * True iff the transfer is not allowed for this partition due to a
        * ongoing transfers or version synchronization protocol.
         */
        public boolean isTransferDisallowed()
            {
            return (getPartitionState() & (STATE_MASK_PIN | STATE_MASK_SYNC)) != 0;
            }
        
        /**
         * Return true if the primary partition is being transferred out.
         */
        public boolean isTransferringOut()
            {
            return isLocked() && getLockType() == LOCK_PRIMARY_XFER_OUT;
            }
        
        /**
         * Obtain an exclusive lock of the specified type on the partition,
        * waiting no more than the specified time.
        * 
        * @param cWait           the maximum amount of time to wait for the
        * lock, or -1 for indefinite
        * @param nLockType  the lock type (one of the LOCK_* constants)
        * 
        * @return true iff the lock was obtained
         */
        public boolean lock(long cWait, int nLockType)
            {
            boolean fLocked        = false;
            long    ldtStart       = Base.getSafeTimeMillis();
            long    cWaitRemaining = cWait;
            
            // COH-25840 - both lock and unlock synchronize on this while
            // lock may hold the gate closed, leading to potential deadlocks
            // ensure that lock yields the intrinsic lock
            while (!(lockInternal(Math.min(100L,
                                      cWait == -1 ? Long.MAX_VALUE : cWaitRemaining),
                                  nLockType)))
                {
                if (cWait >= 0L)
                    {
                    cWaitRemaining -= Base.getSafeTimeMillis() - ldtStart;
                    if (cWaitRemaining <= 0)
                        {
                        return false;
                        }
                    }
                // yield so this thread doesn't hog the lock
                Base.sleep(1L);
                }
            
            return true;
            }
        
        /**
         * Obtain an exclusive lock of the specified type on the partition,
        * waiting no more than the specified time.
        * 
        * @param cWait           the maximum amount of time to wait for the
        * lock, or -1 for indefinite
        * @param nLockType  the lock type (one of the LOCK_* constants)
        * 
        * @return true iff the lock was obtained
         */
        protected synchronized boolean lockInternal(long cWait, int nLockType)
            {
            // import com.tangosol.util.Gate;
            
            Gate gate = getGate();
            if (gate.isEnteredByCurrentThread() ||
                gate.isClosedByCurrentThread() && nLockType != getLockType())
                {
                // there are two cases where we prevent locking:
                //   1. service thread has entered the partition; this mechanism is used
                //      to prevent trasfer - see onTransferRequest/transferBackup
                //   2. service thread has locked the partition for another purpose; this
                //      is commonly due to concurrent transfer and persistence snapshot
                return false;
                }
            else
                {
                int     nLockTypeOld = getLockType();
                boolean fLocked      = false;
            
                // set the lock-type before we call close (and bar entry to the gate)
                setLockType(nLockType | LOCK_PENDING);
            
                try
                    {
                    fLocked = getGate().close(cWait);
                    }
                finally
                    {
                    // remove the pending bit, and set the lock type to either the
                    // requested lock, or the previous value
                    setLockType(fLocked ? nLockType : nLockTypeOld);
                    }
            
                // keep track of time for logging partition unavailability events
                if (fLocked)
                    {
                    beginEvent();
                    }
            
                return fLocked;
                }
            }
        
        /**
         * Obtain an exclusive lock of the specified type on the partition, 
        * waiting no more than the calculated time.
        * 
        * @param cWait           the maximum amount of time to wait for the
        * lock
        * @param nLockType  the lock type (one of the LOCK_* constants)
        * 
        * @return true iff the lock was obtained
         */
        public boolean lockWithAdaptiveTime(long cWait, int nLockType, int nMemberId)
            {
            // import com.tangosol.net.GuardSupport;
            
            PartitionedService service = getService();
            
            int nLockIdCur = getLockId();
            int nLockId    = nMemberId << 16 | nLockType;
            int cAttempt   = nLockIdCur == nLockId ? getLockAttempt() : 0;
            
            long cWaitAdapt = cWait > 0 && cAttempt > 0
                    ? Math.max((long) (service.getMaxContendMillis() *
                        Math.min(Math.log((float) getLockAttempt()) / Math.log((float) service.getMaxLockAttempt()), 1.0f)), cWait)
                    : cWait;
            
            boolean fHeartbeat = cWaitAdapt > 500l && cWaitAdapt > GuardSupport.getThreadContext().getSoftTimeoutMillis() >> 2;
            
            if (fHeartbeat)
                {
                service.heartbeat(cWaitAdapt << 1);
                }
            
            boolean fLock = lock(cWaitAdapt, nLockType);
            
            if (fHeartbeat)
                {
                // reset the guardian timeout to the default
                service.heartbeat();
                }
            
            if (service.isAdaptivePartitionLock() && !fLock && cWait > 0)
                {
                cAttempt = nLockIdCur == nLockId
                        ? getLockAttempt() + 1  // increment lock attempt for repeated distribution
                        : 1;                    // reset lock attemp due to new distribution
            
                setLockAttempt(cAttempt);
                setLockId(nLockId);
                }
            
            return fLock;
            }
        
        /**
         * Mark version sync bit for this partition state.
        * 
        * This method is only called on the service thread.
         */
        protected void markVersionInSync()
            {
            setPartitionState(getPartitionState() | (1 << STATE_SHIFT_SYNC));
            }
        
        // Declared at the super level
        /**
         * The "component has been initialized" method-notification called out
        * of setConstructed() for the topmost component and that in turn
        * notifies all the children.
        * 
        * This notification gets called before the control returns back to this
        * component instantiator (using <code>new Component.X()</code> or
        * <code>_newInstance(sName)</code>) and on the same thread. In
        * addition, visual components have a "posted" notification
        * <code>onInitUI</code> that is called after (or at the same time as)
        * the control returns back to the instantiator and possibly on a
        * different thread.
         */
        public void onInit()
            {
            // import com.tangosol.internal.util.AtomicsHelper;
            // import com.tangosol.util.ThreadGateLite;
            // import java.util.concurrent.atomic.AtomicInteger;
            // import java.util.concurrent.atomic.AtomicLong;
            
            set_Feed(new ThreadGateLite()); // Gate
            setBackupPolls(new AtomicInteger());
            setPersistenceTasks(new AtomicInteger());
            AtomicLong counterVersion = new AtomicLong();
            
            setVersionCounter(counterVersion);
            setVersionIncrementer(AtomicsHelper.newIncrementor(counterVersion));
            }
        
        /**
         * All deferred actions for this partition have been processed
         */
        public void onProcessedActions()
            {
            }
        
        /**
         * Prepare (register or ensure) the provided persistent extent with this
        * PartitionControl.
        * 
        * In the case of registeration the first mutating operation (or adding
        * of a key listener) on an extent will ensure the persistent extent on
        * the associated PersistentStore (see ensurePersistentExtent).
        * 
        * @param lExtentId   the extent to register
        * @param laCaches  the caches (id -> name) to store in the
        * PersistentStore
         */
        public void preparePersistentExtent(long lExtentId, com.tangosol.util.LongArray laCaches, boolean fBackup)
            {
            }
        
        /**
         * Prepare (register or ensure) all known storage cache ids (extents)
        * with this PartitionControl.
        * 
        * In the case of registeration the first mutating operation (or adding
        * of a key listener) on an extent will ensure the persistent extent on
        * the associated PersistentStore (see ensurePersistentExtent).
         */
        public void preparePersistentExtents()
            {
            }
        
        /**
         * Prepare (register or ensure) all known storage cache ids (extents)
        * with this PartitionControl.
        * 
        * In the case of registeration the first mutating operation (or adding
        * of a key listener) on an extent will ensure the persistent extent on
        * the associated PersistentStore (see ensurePersistentExtent).
         */
        public void preparePersistentExtents(com.tangosol.util.LongArray laExtentsExclude)
            {
            }
        
        /**
         * Prevent (primary and/or backup) transfers for this partition.
        * 
        * This method is only called on the service thread.
         */
        public void preventTransfer()
            {
            // import com.tangosol.util.Gate;
            
            Gate gate = getGate();
            if (!gate.isEnteredByCurrentThread())
                {
                setPartitionState(getPartitionState() | (1 << STATE_SHIFT_PIN));
                gate.enter(0L);
                }
            }
        
        // From interface: com.tangosol.net.Guardable
        public void recover()
            {
            // import com.tangosol.net.Guardian$GuardContext as com.tangosol.net.Guardian.GuardContext;
            
            // Note: we are running on the recovery thread, so it is possible that
            //       the context was concurrently heartbeated or released.
            //       Read the expected (missing) version before checking the guard
            //       state to guard against a race with the service thread.
            long         lVersionMissing = getVersionCounter().get() + 1;
            com.tangosol.net.Guardian.GuardContext ctx             = getContext();
            if (ctx != null && ctx.getState() != com.tangosol.net.Guardian.GuardContext.STATE_HEALTHY)
                {
                PartitionedService service = getService();
            
                // the partition has been "stuck" waiting for a backup update version
                // for a long time; before giving up and dropping the backup ownership,
                // "ping" the primary owner to ensure that it is still alive and that
                // the missing updates are not just delayed on the wire.
            
                PartitionedService.PartitionControl.GuardContinuation continuation = (PartitionedService.PartitionControl.GuardContinuation) _newChild("GuardContinuation");
                continuation.setMissingVersion(lVersionMissing);
            
                service.sendPingRequest(service.getPrimaryOwner(getPartitionId()), continuation);
            
                // there is the possibility that before the ping completes, that the
                // "missing" version will arrive; the continuation proceed logic will
                // check for this, but in the meantime, heartbeat the context while the
                // ping is outstanding to keep the partition guarded
                ctx.heartbeat();
                }
            }
        
        /**
         * Reset LockAttempt and LockId.
         */
        public void reset()
            {
            setLockAttempt(0);
            setLockId(0);
            }
        
        // Accessor for the property "BackupPolls"
        /**
         * Setter for property BackupPolls.<p>
        * Count of pending backup request msgs for the partition.
         */
        protected void setBackupPolls(java.util.concurrent.atomic.AtomicInteger integerPolls)
            {
            __m_BackupPolls = integerPolls;
            }
        
        // Accessor for the property "BackupsCompletedActions"
        /**
         * Setter for property BackupsCompletedActions.<p>
        * List of continuations to complete when all outstanding backup polls
        * have completed.  Used only while the partition is locked.
         */
        public void setBackupsCompletedActions(java.util.List listActions)
            {
            __m_BackupsCompletedActions = listActions;
            }
        
        // From interface: com.tangosol.net.Guardable
        // Accessor for the property "Context"
        /**
         * Setter for property Context.<p>
        * The PartitionControl's GuardContext or null if it is not currently
        * guarded.
        * 
        * This is used by the service thread only.
         */
        public void setContext(com.tangosol.net.Guardian.GuardContext ctx)
            {
            __m_Context = ctx;
            }
        
        // Accessor for the property "DeferredBackup"
        /**
         * Setter for property DeferredBackup.<p>
        * The deferred backup of ExpectedVersion for this partition. This node
        * must be the primary owner previously; and is in the process of
        * transferring the partition out; and it is assigned as backup owner.
        * The message will be processed right before the partition is unlocked.
        * 
        * see #onTransferRequestCompleted.
         */
        public void setDeferredBackup(com.tangosol.coherence.component.net.Message msgBackup)
            {
            __m_DeferredBackup = msgBackup;
            }
        
        // Accessor for the property "DeferredBackups"
        /**
         * Setter for property DeferredBackups.<p>
        * The list of deferred backups messages for this partition that remain
        * to be processed.  The elements of the list are indexed in the order
        * of the corresponding partition version, starting with the first
        * "skipped" version.  More formally, the element at index k holds the
        * BackupRequest representing the partition version of (ExpectedVersion
        * + k + 1) where (ExpectedVersion=VersionCounter + 1) until we have
        * received the backup for ExpectedVersion.
        * 
        * Used by the backup partition owner only.
         */
        protected void setDeferredBackups(java.util.List listBackups)
            {
            __m_DeferredBackups = listBackups;
            }
        
        // Accessor for the property "EventStartTime"
        /**
         * Setter for property EventStartTime.<p>
        * Event start time, to keep track of partition unavailability times.
        * Only set when a partition is locked.
         */
        public void setEventStartTime(long ldtTime)
            {
            __m_EventStartTime = ldtTime;
            }
        
        // Accessor for the property "LockAttempt"
        /**
         * Setter for property LockAttempt.<p>
        * A counter on the number of attempts to lock the partition.
         */
        public void setLockAttempt(int nAttempt)
            {
            __m_LockAttempt = nAttempt;
            }
        
        // Accessor for the property "LockId"
        /**
         * Setter for property LockId.<p>
        * An Id that identify a lock action;  a combination of lock type and
        * member id.
         */
        public void setLockId(int nId)
            {
            __m_LockId = nId;
            }
        
        /**
         * Set the type of the exclusive lock currently held on this partition
        * (one of the LOCK_* constants).
        * 
        * This method must be called while holding synchronization on the
        * PartitionControl on the service thread.
         */
        protected void setLockType(int nLockType)
            {
            setPartitionState((getPartitionState() & ~STATE_MASK_LOCK) |
                              (nLockType << STATE_SHIFT_LOCK));
            }
        
        // Accessor for the property "PartitionId"
        /**
         * Setter for property PartitionId.<p>
        * The partition id.
         */
        public void setPartitionId(int nId)
            {
            __m_PartitionId = nId;
            }
        
        // Accessor for the property "PartitionState"
        /**
         * Setter for property PartitionState.<p>
        * General-purpose bit-vector used to describe the state of the
        * associated partition.  Currently this is used for tracking the
        * partition-lock type as well as the transfer state.
        * 
        * The bits are reserved as follows:
        * 
        * 1-3: Used to describe the lock type (LOCK_*)
        * 4    : Lock is pending (LOCK_PENDING)
        * 5-6: Transfer status (XFER_*)
        * 7    : Partition is pinned (transfer prevented)
        * 
        * @volatile
         */
        protected void setPartitionState(int nLockType)
            {
            __m_PartitionState = nLockType;
            }
        
        // Accessor for the property "PendingBackups"
        /**
         * Setter for property PendingBackups.<p>
        * A LongArray keyed by cache id of map entries that have been modified
        * and need to be backed up.
         */
        public synchronized void setPendingBackups(com.tangosol.util.LongArray arrayBackups)
            {
            __m_PendingBackups = arrayBackups;
            }
        
        // Accessor for the property "PendingBackupTotalSize"
        /**
         * Setter for property PendingBackupTotalSize.<p>
         */
        public void setPendingBackupTotalSize(java.util.Map mapSize)
            {
            __m_PendingBackupTotalSize = mapSize;
            }
        
        // Accessor for the property "PersistenceTasks"
        /**
         * Setter for property PersistenceTasks.<p>
        * Count of pending persistence tasks for the partition.
         */
        protected void setPersistenceTasks(java.util.concurrent.atomic.AtomicInteger integerTasks)
            {
            __m_PersistenceTasks = integerTasks;
            }
        
        // Accessor for the property "PersistentBackupExtents"
        /**
         * Setter for property PersistentBackupExtents.<p>
        * A 'list' of backup persistent extents (cache ids) that have been
        * registered with this member, either directly via storage creation or
        * transitively by partition transfer, but have not been ensured with
        * this PartitionControl's PersistentBackupStore.
         */
        public void setPersistentBackupExtents(com.tangosol.net.internal.CopyOnWriteLongList listExtents)
            {
            __m_PersistentBackupExtents = listExtents;
            }
        
        // Accessor for the property "PersistentBackupStore"
        /**
         * Setter for property PersistentBackupStore.<p>
        * The backup persistent store associated with this partition.
         */
        protected void setPersistentBackupStore(com.oracle.coherence.persistence.PersistentStore store)
            {
            __m_PersistentBackupStore = store;
            }
        
        // Accessor for the property "PersistentEventsStore"
        /**
         * Setter for property PersistentEventsStore.<p>
        * The persistent store associated with this partition.
         */
        protected void setPersistentEventsStore(com.oracle.coherence.persistence.PersistentStore store)
            {
            __m_PersistentEventsStore = store;
            }
        
        // Accessor for the property "PersistentExtents"
        /**
         * Setter for property PersistentExtents.<p>
        * A 'list' of persistent extents (cache ids) that have been registered
        * with this member, either directly via storage creation or
        * transitively by partition transfer, but have not been ensured with
        * this PartitionControl's PersistentStore.
         */
        public void setPersistentExtents(com.tangosol.net.internal.CopyOnWriteLongList listExtents)
            {
            __m_PersistentExtents = listExtents;
            }
        
        // Accessor for the property "PersistentStore"
        /**
         * Setter for property PersistentStore.<p>
        * The persistent store associated with this partition.
        * 
        * @volatile
         */
        protected void setPersistentStore(com.oracle.coherence.persistence.PersistentStore store)
            {
            __m_PersistentStore = store;
            }
        
        // Accessor for the property "Recovered"
        /**
         * Setter for property Recovered.<p>
        * Flag used to indicate whether a partition has been recovered from the
        * PersistentStore. This flag must be used in combination with LockType
        * == LOCK_PERSISTENCE. @see #isRecovering method.
         */
        public void setRecovered(boolean fRecovered)
            {
            __m_Recovered = fRecovered;
            }
        
        // Accessor for the property "Statistics"
        /**
         * Setter for property Statistics.<p>
        * The statistics for this partition.
         */
        public void setStatistics(com.tangosol.net.partition.PartitionStatistics statistics)
            {
            __m_Statistics = statistics;
            }
        
        // Accessor for the property "TLOEnterCounter"
        /**
         * Setter for property TLOEnterCounter.<p>
        * A thread local to track the number of times this thread has 'enter'd
        * this partition.
         */
        public void setTLOEnterCounter(ThreadLocal localCount)
            {
            __m_TLOEnterCounter = localCount;
            }
        
        /**
         * Set the transfer state of this partition (one of the XFER_*
        * constants).
        * 
        * This method is only called on the service thread.
         */
        public synchronized void setTransferState(int nState)
            {
            setPartitionState((getPartitionState() & ~STATE_MASK_XFER) |
                              (nState << STATE_SHIFT_XFER));
            }
        
        // Accessor for the property "VersionBackup"
        /**
         * Setter for property VersionBackup.<p>
        * The latest partition version known to have been "committed" by the
        * backups.
        * 
        * @since 12.1.3
         */
        public void setVersionBackup(long lVersion)
            {
            __m_VersionBackup = lVersion;
            }
        
        // Accessor for the property "VersionCounter"
        /**
         * Setter for property VersionCounter.<p>
        * The partition version represents a transactional change unit.
        * 
        * This is used for backup-message ordering of changes, and does not
        * necessarily reflect changes of ownership information.
        * 
        * @since 12.1.2
         */
        protected void setVersionCounter(java.util.concurrent.atomic.AtomicLong atomic)
            {
            __m_VersionCounter = atomic;
            }
        
        // Accessor for the property "VersionIncrementer"
        /**
         * Setter for property VersionIncrementer.<p>
        * The supplier that increments and returns the partition version.
         */
        protected void setVersionIncrementer(java.util.function.LongSupplier atomic)
            {
            __m_VersionIncrementer = atomic;
            }
        
        // From interface: com.tangosol.net.Guardable
        public void terminate()
            {
            }
        
        // Declared at the super level
        public String toString()
            {
            // version description
            long lVersion = getVersionCounter().get();
            
            // lock type description
            int    nLockType = getLockType();
            String sLockType = "";
            switch (nLockType)
                {
                case LOCK_BACKUP_XFER_OUT:
                    sLockType = "[Backup Transfer Snapshot]";
                    break;
            
                case LOCK_NONE:
                    sLockType = "NONE";
                    break;
            
                case LOCK_PERSISTENCE:
                    sLockType = "[Persistence Operation]";
                    break;
            
                case LOCK_PRIMARY_XFER_IN:
                    sLockType = "[Incoming Partition Transfer]";
                    break;
            
                case LOCK_PRIMARY_XFER_OUT:
                    sLockType = "[Outgoing Partition Transfer]";
                    break;
            
                default:
                    sLockType = "[unknown]";
                    break;
                }
            
            // transfer state description
            int    nXferState = getTransferState();
            String sXferState = "";
            switch (nXferState)
                {
                case XFER_NONE:
                    sXferState = "NONE";
                    break;
            
                case XFER_STARTED:
                    sXferState = "[Transfer Started]";
                    break;
            
                case XFER_SENT:
                    sXferState = "[Transfer Sent]";
                    break;
            
                default:
                    sXferState = "[unknown]";
                    break;
                }
            
            // transfer prevention description
            String sXferPrevented = isTransferDisallowed() ? ", TransferDisallowed" : "";
            
            return "PartitionControl{Partition=" + getPartitionId() + ", Version=" + lVersion + ", Lock=" + sLockType + ", TransferState=" + sXferState
                 + sXferPrevented + "}";
            }
        
        /**
         * Truncate the provided extent if it has been ensured.
        * 
        * @param lExtentId  the extent to ensure
         */
        public void truncatePersistentExtent(long lExtentId)
            {
            }
        
        /**
         * Release an exclusive lock on the partition.
         */
        public void unlock()
            {
            unlock(/*fRollback*/ false);
            }
        
        /**
         * Release an exclusive lock on the partition.
         */
        public void unlock(boolean fRollBack)
            {
            // import com.oracle.coherence.common.base.Continuation;
            // import com.tangosol.util.Base;
            // import java.util.Queue as java.util.Queue;
            
            // Note: We iterate the actions and run them without holding
            //       synchronization on the PartitionControl (though the
            //       gate is still closed) to avoid deadlock.
            java.util.Queue   queueActions = getUnlockActions(); // dirty read
            boolean fActioned    = false;
            while (true)
                {
                // Run any unlock actions that may have been registered
                Continuation cont = null;
                while (queueActions != null && (cont = (Continuation) queueActions.poll()) != null)
                    {
                    try
                        {
                        cont.proceed(null);
                        fActioned = true;
                        }
                    catch (Throwable t)
                        {
                        // catch and log any exceptions here; we have to open the
                        // gate no matter what
                        _trace("Caught " + t + " while running deferred event:\n"
                             + Base.getStackTrace(t), 1);
                        }
                    }
            
                synchronized (this)
                    {
                    if (queueActions == null)
                        {
                        queueActions = getUnlockActions();
                        }
            
                    if (queueActions == null || queueActions.isEmpty())
                        {
                        // log partition events causing unavailability
                        int nLockType = getService().isRestoreInProgress() ? PARTITION_EVENT_RESTORE : getLockType();
            
                        endEvent(getPartitionId(), nLockType, fRollBack);
            
                        if (fActioned)
                            {
                            fActioned &= enter(0L);
                            }
            
                        setLockType(LOCK_NONE);
                        getGate().open();
            
                        break;
                        }
                    }
                }
            
            if (fActioned)
                {
                onProcessedActions();
                exit();
                }
            
            return;
            }
        
        /**
         * Unmark version sync bit for this partition state.
        * 
        * This method is only called on the service thread.
         */
        public void unmarkVersionInSync()
            {
            setPartitionState(getPartitionState() & ~STATE_MASK_SYNC);
            }
        
        /**
         * There are two ways the partition storage statistics are calculated.
        * If the backing map is a PartitionAwareBackingMap and also
        * a ConfigurableCacheMap with BinaryCalculator, then the storage size
        * is retrieved directly using getUnits. Otherwise,  the statistics are
        * updated as changes occur - see
        * PartitionedCache$Storage#onBackingMapEvent().
         */
        public com.tangosol.net.partition.PartitionStatistics updateDirectStorageSize()
            {
            return null;
            }
        
        /**
         * Change the persistent store version.
         */
        public void updatePersistentStoreVersion()
            {
            // import com.oracle.coherence.persistence.PersistentStore as com.oracle.coherence.persistence.PersistentStore;
            // import com.tangosol.persistence.CachePersistenceHelper as com.tangosol.persistence.CachePersistenceHelper;
            
            com.oracle.coherence.persistence.PersistentStore store = getPersistentStore();
            if (store != null)
                {
                PartitionedService service  = getService();
                String  sStoreId = store.getId();

                PersistentStore storeNew = store.isOpen()
                                           ? ensureOpenPersistentStore(store, false)
                                           : ensurePersistentStore(store);

                service.saveQuorum(-1, storeNew);
            
                // seal the events store first
                com.oracle.coherence.persistence.PersistentStore storeEvents = getPersistentEventsStore();
                if (storeEvents != null)
                    {
                    com.tangosol.persistence.CachePersistenceHelper.seal(storeEvents, service, /*oToken*/ null);
                    }
            
                com.tangosol.persistence.CachePersistenceHelper.seal(storeNew, service, /*oToken*/ null);
            
                service.getPersistenceManager().delete(sStoreId, false);
                }
            }

        // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService$PartitionControl$GuardContinuation
        
        /**
         * Continuation implementation used by the PartitionControl guard
         * implementation to ensure that "lost" backup version updates do not
         * result in a logical partition "deadlock".
         * 
         * See $PartitionControl#checkDeferredBackups, $PartitionControl#recover
         */
        @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
        public static class GuardContinuation
                extends    com.tangosol.coherence.Component
                implements com.oracle.coherence.common.base.Continuation
            {
            // ---- Fields declarations ----
            
            /**
             * Property MissingVersion
             *
             * The version number that is missing.
             */
            private long __m_MissingVersion;
            
            // Default constructor
            public GuardContinuation()
                {
                this(null, null, true);
                }
            
            // Initializing constructor
            public GuardContinuation(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                {
                super(sName, compParent, false);
                
                if (fInit)
                    {
                    __init();
                    }
                }
            
            // Main initializer
            public void __init()
                {
                // private initialization
                __initPrivate();
                
                
                // signal the end of the initialization
                set_Constructed(true);
                }
            
            // Private initializer
            protected void __initPrivate()
                {
                
                super.__initPrivate();
                }
            
            //++ getter for static property _Instance
            /**
             * Getter for property _Instance.<p>
            * Auto generated
             */
            public static com.tangosol.coherence.Component get_Instance()
                {
                return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.PartitionControl.GuardContinuation();
                }
            
            //++ getter for static property _CLASS
            /**
             * Getter for property _CLASS.<p>
            * Property with auto-generated accessor that returns the Class
            * object for a given component.
             */
            public static Class get_CLASS()
                {
                Class clz;
                try
                    {
                    clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/PartitionedService$PartitionControl$GuardContinuation".replace('/', '.'));
                    }
                catch (ClassNotFoundException e)
                    {
                    throw new NoClassDefFoundError(e.getMessage());
                    }
                return clz;
                }
            
            //++ getter for autogen property _Module
            /**
             * This is an auto-generated method that returns the global [design
            * time] parent component.
            * 
            * Note: the class generator will ignore any custom implementation
            * for this behavior.
             */
            private com.tangosol.coherence.Component get_Module()
                {
                return this.get_Parent().get_Parent();
                }
            
            // Accessor for the property "MissingVersion"
            /**
             * Getter for property MissingVersion.<p>
            * The version number that is missing.
             */
            public long getMissingVersion()
                {
                return __m_MissingVersion;
                }
            
            // Accessor for the property "PartitionControl"
            /**
             * Getter for property PartitionControl.<p>
            * The partition control.
             */
            public PartitionedService.PartitionControl getPartitionControl()
                {
                return (PartitionedService.PartitionControl) get_Parent();
                }
            
            // Accessor for the property "Service"
            /**
             * Getter for property Service.<p>
            * The partitioned service.
             */
            public PartitionedService getService()
                {
                return (PartitionedService) get_Module();
                }
            
            // From interface: com.oracle.coherence.common.base.Continuation
            public void proceed(Object FResponded)
                {
                // import Component.Net.Message.RequestMessage.ChainedRequest.BackupRequest;
                // import com.tangosol.net.Guardian$GuardContext as com.tangosol.net.Guardian.GuardContext;
                // import java.util.Iterator;
                
                PartitionedService.PartitionControl ctrlPartition = getPartitionControl();
                boolean           fResponded    = ((Boolean) FResponded).booleanValue();
                
                if (fResponded)
                    {
                    // the primary responded to our ping so we know it's alive;
                    // double-check that we have not made any progress on closing the
                    // gaps (a ping response would flush any late msgs on the wire)
                
                    long lVersionLast    = ctrlPartition.getVersionCounter().get();
                    long lVersionMissing = getMissingVersion();
                    if (lVersionLast < lVersionMissing)
                        {
                        // the missing version has not arrived and we know the primary
                        // is still alive; proceed with dropping the backup
                
                        int     nPartition = ctrlPartition.getPartitionId();
                        PartitionedService service    = getService();
                
                        _trace("The update for version " + lVersionMissing + " of partition " + nPartition
                             + " has been delayed for over " + (service.getDeferredBackupTimeoutMillis() / 1000)
                             + " seconds; discarding the backup ownership.", 2);
                
                        // drop the partition backup and inform the primary
                        service.discardBackupOwnership(nPartition);
                
                        // unblock any clients that are waiting on this partition
                        for (Iterator iter = ctrlPartition.getDeferredBackups().iterator(); iter.hasNext(); )
                            {
                            // msgBackup will be null at each missing version "hole"
                            BackupRequest msgBackup = (BackupRequest) iter.next();
                            if (msgBackup != null)
                                {
                                // fwd or reply to the backup msg to allow the primary proceed
                                msgBackup.forwardOrReply(msgBackup);
                                }
                
                            iter.remove();
                            }
                        }
                    }
                else
                    {
                    // the primary was dead, so nothing to do; the ownership/restore
                    // protocol will ensure that versions re-sync
                    com.tangosol.net.Guardian.GuardContext ctx = ctrlPartition.getContext();
                    if (ctx != null)
                        {
                        ctx.release();
                        }
                    }
                }
            
            // Accessor for the property "MissingVersion"
            /**
             * Setter for property MissingVersion.<p>
            * The version number that is missing.
             */
            public void setMissingVersion(long lVersion)
                {
                __m_MissingVersion = lVersion;
                }
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService$PartitionFilter
    
    /**
     * A Filter that evaluates Binary keys or Entry<Binary, ?> to test whether
     * they belong to the specified partition set.
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class PartitionFilter
            extends    com.tangosol.coherence.component.Util
            implements com.tangosol.util.Filter
        {
        // ---- Fields declarations ----
        
        /**
         * Property PartitionSet
         *
         * The set of partitions to test each key/entry against.
         */
        private com.tangosol.net.partition.PartitionSet __m_PartitionSet;
        
        // Default constructor
        public PartitionFilter()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public PartitionFilter(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.PartitionFilter();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/PartitionedService$PartitionFilter".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        public void addPartition(int iPartition)
            {
            }
        
        // From interface: com.tangosol.util.Filter
        public boolean evaluate(Object oTest)
            {
            // import com.tangosol.io.ReadBuffer;
            // import com.tangosol.util.Binary;
            // import java.util.Map$Entry as java.util.Map.Entry;
            
            Binary binKey = null;
            if (oTest instanceof ReadBuffer)
                {
                binKey = ((ReadBuffer) oTest).toBinary();
                }
            else if (oTest instanceof java.util.Map.Entry)
                {
                binKey = (Binary) ((java.util.Map.Entry) oTest).getKey();
                }
            else
                {
                return false;
                }
            
            return getPartitionSet().contains(((PartitionedService) get_Module()).getKeyPartition(binKey));
            }
        
        // Accessor for the property "PartitionSet"
        /**
         * Getter for property PartitionSet.<p>
        * The set of partitions to test each key/entry against.
         */
        public com.tangosol.net.partition.PartitionSet getPartitionSet()
            {
            return __m_PartitionSet;
            }
        
        // Accessor for the property "PartitionSet"
        /**
         * Setter for property PartitionSet.<p>
        * The set of partitions to test each key/entry against.
         */
        public void setPartitionSet(com.tangosol.net.partition.PartitionSet setPartition)
            {
            __m_PartitionSet = setPartition;
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService$PartitionRecoverCleanup
    
    /**
     * Sent to a storage member to request it to remove any old partitions from
     * persistent storage.
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class PartitionRecoverCleanup
            extends    com.tangosol.coherence.component.net.Message
            implements Runnable
        {
        // ---- Fields declarations ----
        
        /**
         * Property Partitions
         *
         * The set of partitions that should be scanned for old versions.
         */
        private com.tangosol.net.partition.PartitionSet __m_Partitions;
        
        /**
         * Property Primary
         *
         */
        private boolean __m_Primary;
        
        // Default constructor
        public PartitionRecoverCleanup()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public PartitionRecoverCleanup(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                setMessageType(45);
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.PartitionRecoverCleanup();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/PartitionedService$PartitionRecoverCleanup".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        // Accessor for the property "Partitions"
        /**
         * Getter for property Partitions.<p>
        * The set of partitions that should be scanned for old versions.
         */
        public com.tangosol.net.partition.PartitionSet getPartitions()
            {
            return __m_Partitions;
            }
        
        // Accessor for the property "Primary"
        /**
         * Getter for property Primary.<p>
         */
        public boolean isPrimary()
            {
            return __m_Primary;
            }
        
        // Declared at the super level
        /**
         * This is the event that is executed when a Message is received.
        * <p>
        * It is the main processing event of the Message called by the
        * <code>Service.onMessage()</code> event. With regards to the use of
        * Message components within clustered Services, Services are designed
        * by dragging Message components into them as static children. These
        * Messages are the components that a Service can send to other running
        * instances of the same Service within a cluster. When the onReceived
        * event is invoked by a Service, it means that the Message has been
        * received; the code in the onReceived event is therefore the Message
        * specific logic for processing a received Message. For example, when
        * onReceived is invoked on a Message named FindData, the onReceived
        * event should do the work to "find the data", because it is being
        * invoked by the Service that received the "find the data" Message.
         */
        public void onReceived()
            {
            super.onReceived();
            
            getService().getDaemonPool().add(this);
            }
        
        // Declared at the super level
        public void read(com.tangosol.io.ReadBuffer.BufferInput input)
                throws java.io.IOException
            {
            // import com.tangosol.net.partition.PartitionSet;
            
            super.read(input);
            
            PartitionSet parts = new PartitionSet();
            parts.readExternal(input);
            setPartitions(parts);
            
            if (getService().isVersionCompatible(getFromMember(), 22, 6, 10))
                {
                setPrimary(input.readBoolean());
                }
            }
        
        // From interface: java.lang.Runnable
        public void run()
            {
            ((PartitionedService) getService()).onPartitionRecoverCleanup(this);
            }
        
        // Accessor for the property "Partitions"
        /**
         * Setter for property Partitions.<p>
        * The set of partitions that should be scanned for old versions.
         */
        public void setPartitions(com.tangosol.net.partition.PartitionSet parts)
            {
            __m_Partitions = parts;
            }
        
        // Accessor for the property "Primary"
        /**
         * Setter for property Primary.<p>
         */
        public void setPrimary(boolean fPrimary)
            {
            __m_Primary = fPrimary;
            }
        
        // Declared at the super level
        public void write(com.tangosol.io.WriteBuffer.BufferOutput output)
                throws java.io.IOException
            {
            super.write(output);
            
            getPartitions().writeExternal(output);

            output.writeBoolean(isPrimary());
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService$PartitionRecoverRequest
    
    /**
     * Sent to a member to request it to recover a partition from persistent
     * storage.
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class PartitionRecoverRequest
            extends    com.tangosol.coherence.component.net.message.RequestMessage
        {
        // ---- Fields declarations ----
        
        /**
         * Property EventsPartsFailed
         *
         * Transient (shared) set of partitions that were successfully
         * recovered.
         */
        private com.tangosol.net.partition.PartitionSet __m_EventsPartsFailed;
        
        /**
         * Property GUIDs
         *
         * The list of GUIDs to recover from persistent storage.
         */
        private String[] __m_GUIDs;

        /**
         * Property InvalidPersistentIds
         *
         * A list of invalid persistentIds to be deleted.
         */
        private String[] __m_InvalidPersistentIds;

        /**
         * Property MapAssigned
         *
         * A Map<Integer, Ownership>containing ownerhip updates for assigned
         * partitions that need to be published.
         */
        private transient java.util.Map __m_MapAssigned;
        
        /**
         * Property PartsAssign
         *
         * Set of partitions that are to be assigned.
         */
        private com.tangosol.net.partition.PartitionSet __m_PartsAssign;
        
        /**
         * Property PartsAssigned
         *
         * Set of partitions that are assigned.
         */
        private transient com.tangosol.net.partition.PartitionSet __m_PartsAssigned;
        
        /**
         * Property PartsLost
         *
         * Set of partitions that are lost.
         */
        private transient com.tangosol.net.partition.PartitionSet __m_PartsLost;
        
        /**
         * Property PartsRecover
         *
         * Transient set of partitions that are to be recovered.
         */
        private com.tangosol.net.partition.PartitionSet __m_PartsRecover;
        
        /**
         * Property PartsRecovered
         *
         * Transient (shared) set of partitions that were successfully
         * recovered.
         */
        private com.tangosol.net.partition.PartitionSet __m_PartsRecovered;
        
        /**
         * Property RecoverJobs
         *
         * Count of partition recover jobs.
         */
        private java.util.concurrent.atomic.AtomicInteger __m_RecoverJobs;
        
        /**
         * Property SnapshotToRecover
         *
         * The name of the persistent snapshot to recover, or null to recover
         * from the active persistence manager.
         */
        private String __m_SnapshotToRecover;
        private static com.tangosol.util.ListMap __mapChildren;
        
        // Static initializer
        static
            {
            __initStatic();
            }
        
        // Default static initializer
        private static void __initStatic()
            {
            // register child classes
            __mapChildren = new com.tangosol.util.ListMap();
            __mapChildren.put("Poll", PartitionedService.PartitionRecoverRequest.Poll.get_CLASS());
            __mapChildren.put("RecoverJob", PartitionedService.PartitionRecoverRequest.RecoverJob.get_CLASS());
            }
        
        // Default constructor
        public PartitionRecoverRequest()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public PartitionRecoverRequest(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                setMessageType(43);
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // containment initialization: children
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.PartitionRecoverRequest();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/PartitionedService$PartitionRecoverRequest".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        //++ getter for autogen property _ChildClasses
        /**
         * This is an auto-generated method that returns the map of design time
        * [static] children.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        protected java.util.Map get_ChildClasses()
            {
            return __mapChildren;
            }
        
        // Accessor for the property "EventsPartsFailed"
        /**
         * Getter for property EventsPartsFailed.<p>
        * Transient (shared) set of partitions that were successfully recovered.
         */
        public com.tangosol.net.partition.PartitionSet getEventsPartsFailed()
            {
            return __m_EventsPartsFailed;
            }
        
        // Accessor for the property "GUIDs"
        /**
         * Getter for property GUIDs.<p>
        * The list of GUIDs to recover from persistent storage.
         */
        public String[] getGUIDs()
            {
            return __m_GUIDs;
            }

        /**
         * Getter for property InvalidPersistentIds
         * A list of invalid persistentIds to be deleted.
         */
        public String[] getInvalidPersistentIds()
            {
            return __m_InvalidPersistentIds;
            }

        // Accessor for the property "MapAssigned"
        /**
         * Getter for property MapAssigned.<p>
        * A Map<Integer, Ownership>containing ownerhip updates for assigned
        * partitions that need to be published.
         */
        public java.util.Map getMapAssigned()
            {
            return __m_MapAssigned;
            }
        
        // Accessor for the property "PartsAssign"
        /**
         * Getter for property PartsAssign.<p>
        * Set of partitions that are to be assigned.
         */
        public com.tangosol.net.partition.PartitionSet getPartsAssign()
            {
            return __m_PartsAssign;
            }
        
        // Accessor for the property "PartsAssigned"
        /**
         * Getter for property PartsAssigned.<p>
        * Set of partitions that are assigned.
         */
        public com.tangosol.net.partition.PartitionSet getPartsAssigned()
            {
            return __m_PartsAssigned;
            }
        
        // Accessor for the property "PartsLost"
        /**
         * Getter for property PartsLost.<p>
        * Set of partitions that are lost.
         */
        public com.tangosol.net.partition.PartitionSet getPartsLost()
            {
            return __m_PartsLost;
            }
        
        // Accessor for the property "PartsRecover"
        /**
         * Getter for property PartsRecover.<p>
        * Transient set of partitions that are to be recovered.
         */
        public com.tangosol.net.partition.PartitionSet getPartsRecover()
            {
            return __m_PartsRecover;
            }
        
        // Accessor for the property "PartsRecovered"
        /**
         * Getter for property PartsRecovered.<p>
        * Transient (shared) set of partitions that were successfully recovered.
         */
        public com.tangosol.net.partition.PartitionSet getPartsRecovered()
            {
            return __m_PartsRecovered;
            }
        
        // Accessor for the property "PersistenceManager"
        /**
         * Getter for property PersistenceManager.<p>
         */
        public com.oracle.coherence.persistence.PersistenceManager getPersistenceManager()
            {
            String               sSnapshot       = getSnapshotToRecover();
            PartitionedService.PersistenceControl  ctrlPersistence = ((PartitionedService) getService()).getPersistenceControl();
            
            return sSnapshot == null
                    ? ctrlPersistence.getActiveManager()
                    : ctrlPersistence.openSnapshot(sSnapshot);
            }
        
        // Accessor for the property "RecoverJobs"
        /**
         * Getter for property RecoverJobs.<p>
        * Count of partition recover jobs.
         */
        public java.util.concurrent.atomic.AtomicInteger getRecoverJobs()
            {
            return __m_RecoverJobs;
            }
        
        // Accessor for the property "SnapshotToRecover"
        /**
         * Getter for property SnapshotToRecover.<p>
        * The name of the persistent snapshot to recover, or null to recover
        * from the active persistence manager.
         */
        public String getSnapshotToRecover()
            {
            return __m_SnapshotToRecover;
            }
        
        // Declared at the super level
        protected com.tangosol.coherence.component.net.Poll instantiatePoll()
            {
            // import Component.Net.Poll as com.tangosol.coherence.component.net.Poll;
            
            return (com.tangosol.coherence.component.net.Poll) _newChild("Poll");
            }
        
        // Declared at the super level
        /**
         * This is the event that is executed when a Message is received.
        * <p>
        * It is the main processing event of the Message called by the
        * <code>Service.onMessage()</code> event. With regards to the use of
        * Message components within clustered Services, Services are designed
        * by dragging Message components into them as static children. These
        * Messages are the components that a Service can send to other running
        * instances of the same Service within a cluster. When the onReceived
        * event is invoked by a Service, it means that the Message has been
        * received; the code in the onReceived event is therefore the Message
        * specific logic for processing a received Message. For example, when
        * onReceived is invoked on a Message named FindData, the onReceived
        * event should do the work to "find the data", because it is being
        * invoked by the Service that received the "find the data" Message.
         */
        public void onReceived()
            {
            scheduleRecoveryJobs();
            }
        
        // Declared at the super level
        public void read(com.tangosol.io.ReadBuffer.BufferInput input)
                throws java.io.IOException
            {
            // import com.tangosol.net.partition.PartitionSet;
            
            int      cGUID  = input.readInt();
            String[] asGUID = new String[cGUID];
            
            for (int i = 0; i < cGUID; i++)
                {
                asGUID[i] = input.readUTF();
                }
            
            setGUIDs(asGUID);
            
            PartitionSet partsAssign = new PartitionSet();
            partsAssign.readExternal(input);
            setPartsAssign(partsAssign);
            
            if (input.readBoolean())  // snapshot
                {
                setSnapshotToRecover(input.readUTF());
                }

            if (getService().isVersionCompatible(OwnershipResponse::isLazyOpenCompatible))
                {
                int cSize = input.readInt();
                String[] asGUIDToClean = new String[cSize];
                for (int i = 0; i < cSize; i++)
                    {
                    asGUIDToClean[i] = input.readUTF();
                    }
                setInvalidPersistentIds(asGUIDToClean);
                }
            }
        
        /**
         * Split this task ($PartitionRecoverRequest) into batch jobs and
        * schedule them with the daemon pool. Called on the service thread only.
         */
        public void scheduleRecoveryJobs()
            {
            // import Component.Util.DaemonPool as com.tangosol.coherence.component.util.DaemonPool;
            // import com.oracle.coherence.common.internal.Platform;
            // import com.oracle.coherence.persistence.PersistenceManager;
            // import com.tangosol.coherence.config.Config;
            // import com.tangosol.net.internal.PartitionRecoverInfo;
            // import com.tangosol.persistence.GUIDHelper;
            // import com.tangosol.util.LongArray;
            // import com.tangosol.util.SparseArray;
            // import java.util.ArrayList;
            // import java.util.Collections;
            // import java.util.concurrent.atomic.AtomicInteger;
            // import java.util.Iterator;
            // import java.util.Map;

            PartitionedService   service = (PartitionedService) getService();
            String[]  asGUIDs = getGUIDs();
            int       cGUIDs  = asGUIDs.length;                                    
            int       cFair   = Config.getInteger("coherence.distributed.persistence.recover.threads",
                                       Platform.getPlatform().getFairShareProcessors() + 2).intValue();
            int       cBatch  = cGUIDs / cFair + 1;
            LongArray laJob   = new SparseArray();
            
            // lock & (locally) own all partitions that will be recovered or assigned
            Map mapUpdate = service.lockForRecovery(this);
            
            PartitionRecoverInfo info = new PartitionRecoverInfo(
                    this,
                    mapUpdate,
                    new ArrayList(),
                    getPersistenceManager(),
                    service.instantiatePartitionSet(false),
                    service.instantiatePartitionSet(false),
                    service.instantiatePartitionSet(false));
            
            for (int i = 0; i < cGUIDs; i++)
                {
                String      sGUID      = asGUIDs[i];
                int         nPartition = GUIDHelper.getPartition(sGUID);
                if (mapUpdate.containsKey(nPartition))
                    {
                    int nBatch = i / cBatch;
                    PartitionedService.PartitionRecoverRequest.RecoverJob job = (PartitionedService.PartitionRecoverRequest.RecoverJob) laJob.get(nBatch);
                    if (job == null)
                        {
                        job = new PartitionedService.PartitionRecoverRequest.RecoverJob();
                        job.setListGUID(new ArrayList());
                        job.setService(service);
                        job.setRecoverInfo(info);
                        laJob.set(nBatch, job);
                        }
                    job.getListGUID().add(sGUID);
                    }
                }
            
            if (laJob.isEmpty())
                {
                // minimally add a job to perform the assignments on a worker thread
                PartitionedService.PartitionRecoverRequest.RecoverJob job = new PartitionedService.PartitionRecoverRequest.RecoverJob();
                job.setListGUID(Collections.emptyList());
                job.setService(service);
                job.setRecoverInfo(info);
                laJob.set(0, job);
                }
            
            setRecoverJobs(new AtomicInteger(laJob.getSize()));
            
            com.tangosol.coherence.component.util.DaemonPool pool = service.getDaemonPool(); 
            for (Iterator iter = laJob.iterator(); iter.hasNext();)
                {
                PartitionedService.PartitionRecoverRequest.RecoverJob job = (PartitionedService.PartitionRecoverRequest.RecoverJob) iter.next();
                pool.add(job);
                }
            }
        
        // Accessor for the property "EventsPartsFailed"
        /**
         * Setter for property EventsPartsFailed.<p>
        * Transient (shared) set of partitions that were successfully recovered.
         */
        public void setEventsPartsFailed(com.tangosol.net.partition.PartitionSet setRecovered)
            {
            __m_EventsPartsFailed = setRecovered;
            }
        
        // Accessor for the property "GUIDs"
        /**
         * Setter for property GUIDs.<p>
        * The list of GUIDs to recover from persistent storage.
         */
        public void setGUIDs(String[] asGUID)
            {
            __m_GUIDs = asGUID;
            }

        /**
         * Setter for property InvalidPersistentIds
         * A list of invalid persistentIds to be deleted.
         */
        public void setInvalidPersistentIds(String[] asGUIDs)
            {
            __m_InvalidPersistentIds = asGUIDs;
            }

        // Accessor for the property "MapAssigned"
        /**
         * Setter for property MapAssigned.<p>
        * A Map<Integer, Ownership>containing ownerhip updates for assigned
        * partitions that need to be published.
         */
        public void setMapAssigned(java.util.Map mapAssigned)
            {
            __m_MapAssigned = mapAssigned;
            }
        
        // Accessor for the property "PartsAssign"
        /**
         * Setter for property PartsAssign.<p>
        * Set of partitions that are to be assigned.
         */
        public void setPartsAssign(com.tangosol.net.partition.PartitionSet setRecovered)
            {
            __m_PartsAssign = setRecovered;
            }
        
        // Accessor for the property "PartsAssigned"
        /**
         * Setter for property PartsAssigned.<p>
        * Set of partitions that are assigned.
         */
        public void setPartsAssigned(com.tangosol.net.partition.PartitionSet setAssigned)
            {
            __m_PartsAssigned = setAssigned;
            }
        
        // Accessor for the property "PartsLost"
        /**
         * Setter for property PartsLost.<p>
        * Set of partitions that are lost.
         */
        public void setPartsLost(com.tangosol.net.partition.PartitionSet setAssigned)
            {
            __m_PartsLost = setAssigned;
            }
        
        // Accessor for the property "PartsRecover"
        /**
         * Setter for property PartsRecover.<p>
        * Transient set of partitions that are to be recovered.
         */
        public void setPartsRecover(com.tangosol.net.partition.PartitionSet setRecovered)
            {
            __m_PartsRecover = setRecovered;
            }
        
        // Accessor for the property "PartsRecovered"
        /**
         * Setter for property PartsRecovered.<p>
        * Transient (shared) set of partitions that were successfully recovered.
         */
        public void setPartsRecovered(com.tangosol.net.partition.PartitionSet setRecovered)
            {
            __m_PartsRecovered = setRecovered;
            }
        
        // Accessor for the property "RecoverJobs"
        /**
         * Setter for property RecoverJobs.<p>
        * Count of partition recover jobs.
         */
        public void setRecoverJobs(java.util.concurrent.atomic.AtomicInteger atomicJobs)
            {
            __m_RecoverJobs = atomicJobs;
            }
        
        // Accessor for the property "SnapshotToRecover"
        /**
         * Setter for property SnapshotToRecover.<p>
        * The name of the persistent snapshot to recover, or null to recover
        * from the active persistence manager.
         */
        public void setSnapshotToRecover(String sSnapshot)
            {
            __m_SnapshotToRecover = sSnapshot;
            }
        
        // Declared at the super level
        public void write(com.tangosol.io.WriteBuffer.BufferOutput output)
                throws java.io.IOException
            {
            String[] asGUID = getGUIDs();
            int      cGUID  = asGUID.length;
            
            output.writeInt(cGUID);
            for (int i = 0; i < cGUID; i++)
                {
                output.writeUTF(asGUID[i]);
                }
            
            getPartsAssign().writeExternal(output);
            
            String sSnapshot = getSnapshotToRecover();
            if (sSnapshot == null)
                {
                output.writeBoolean(false);
                }
            else
                {
                output.writeBoolean(true);
                output.writeUTF(sSnapshot);
                }

            if (getService().isVersionCompatible(OwnershipResponse::isLazyOpenCompatible))
                {
                String[] asInvalidGUIDs = getInvalidPersistentIds();
                int cSize = asInvalidGUIDs == null ? 0 : asInvalidGUIDs.length;

                output.writeInt(cSize);
                for (int i = 0; i < cSize; i++)
                    {
                    output.writeUTF(asInvalidGUIDs[i]);
                    }
                }
            }

        // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService$PartitionRecoverRequest$Poll
        
        /**
         * The Poll contains information regarding a request sent to one or
         * more Cluster Members that require responses. A Service may poll
         * other Members that are running the same Service, and the Poll is
         * used to wait for and assemble the responses from each of those
         * Members. A client thread may also use the Poll to block on a
         * response or set of responses, thus waiting for the completion of the
         * Poll. In its simplest form, which is a Poll that is sent to one
         * Member of the Cluster, the Poll actually represents the
         * request/response model.
         */
        @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
        public static class Poll
                extends    com.tangosol.coherence.component.net.Poll
            {
            // ---- Fields declarations ----
            
            // Default constructor
            public Poll()
                {
                this(null, null, true);
                }
            
            // Initializing constructor
            public Poll(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                {
                super(sName, compParent, false);
                
                if (fInit)
                    {
                    __init();
                    }
                }
            
            // Main initializer
            public void __init()
                {
                // private initialization
                __initPrivate();
                
                
                // signal the end of the initialization
                set_Constructed(true);
                }
            
            // Private initializer
            protected void __initPrivate()
                {
                
                super.__initPrivate();
                }
            
            //++ getter for static property _Instance
            /**
             * Getter for property _Instance.<p>
            * Auto generated
             */
            public static com.tangosol.coherence.Component get_Instance()
                {
                return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.PartitionRecoverRequest.Poll();
                }
            
            //++ getter for static property _CLASS
            /**
             * Getter for property _CLASS.<p>
            * Property with auto-generated accessor that returns the Class
            * object for a given component.
             */
            public static Class get_CLASS()
                {
                Class clz;
                try
                    {
                    clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/PartitionedService$PartitionRecoverRequest$Poll".replace('/', '.'));
                    }
                catch (ClassNotFoundException e)
                    {
                    throw new NoClassDefFoundError(e.getMessage());
                    }
                return clz;
                }
            
            //++ getter for autogen property _Module
            /**
             * This is an auto-generated method that returns the global [design
            * time] parent component.
            * 
            * Note: the class generator will ignore any custom implementation
            * for this behavior.
             */
            private com.tangosol.coherence.Component get_Module()
                {
                return this.get_Parent().get_Parent();
                }
            
            // Declared at the super level
            /**
             * This is the event that is executed when all the Members that were
            * polled have responded or have left the Service.
             */
            protected void onCompletion()
                {
                PartitionedService service = (PartitionedService) get_Module();
                
                if (service.getPersistenceControl().getActiveRecoveryRequests().decrementAndGet() == 0)
                    {
                    // schedule a distribution now that all recover requests are completed.
                    //
                    // The ownership for partitions that were successfully recovered will be
                    // known at this point, so remaining orphans are partitions which failed
                    // during recovery; the next checkDistribution() will restart the
                    // recovery/assignment process.
                    if (!service.isSuspended())
                        {
                        service.getDistributionStrategy().scheduleImmediate();
                        }
                
                    service.setOwnershipInProgress(0);
                
                    PartitionedService.PartitionRecoverRequest msgRequest = (PartitionedService.PartitionRecoverRequest) get_Parent();
                
                    String sSnapshot = msgRequest.getSnapshotToRecover();
                    if (sSnapshot != null || service.isActivePersistence())
                        {
                        if (sSnapshot == null)
                            {
                            // automatic recovery from "active" persistence;
                            // send a message to all storage members requesting them to delete old
                            // versions of persisted partitions
                            PartitionedService.PartitionRecoverCleanup msg = (PartitionedService.PartitionRecoverCleanup)
                                    service.instantiateMessage("PartitionRecoverCleanup");
                            msg.setPartitions(msgRequest.getPartsRecovered());
                            msg.setToMemberSet(service.getOwnershipMemberSet());
                
                            service.post(msg);
                            }
                
                        // signal the persistence controller that recovery has completed
                        service.getPersistenceControl().getSnapshotController()
                                .onRecoveryCompleted(sSnapshot, service.collectOrphanPartitions(), msgRequest.getEventsPartsFailed());
                        }
                    }
                
                super.onCompletion();
                }
            
            // Declared at the super level
            /**
             * This event occurs for each response Message from each polled
            * Member.
             */
            public void onResponse(com.tangosol.coherence.component.net.Message msg)
                {
                // import com.tangosol.net.partition.PartitionSet;
                
                PartitionedService.Response                msgResponse = (PartitionedService.Response) msg;
                PartitionedService.PartitionRecoverRequest msgRequest  = (PartitionedService.PartitionRecoverRequest) get_Parent();
                
                // Note: a single PartitionSet is updated without concurrency concerns
                //       as the response is always processed on the service thread
                // _assert(Thread.currentThread() == get_Module().getThread());
                
                PartitionSet partsRecovered    = null;
                PartitionSet partsFailedEvents = null;
                Object       oResponseValue    = msgResponse.getValue();
                
                // Checking if response value is an array is workaround for
                // bug 33740616 isVersionCompatible incorrectly returns false
                // when member has concurrently left cluster
                if (getService().isVersionCompatible(msgResponse.getFromMember(), 21, 6, 0) ||
                    oResponseValue.getClass().isArray())
                    {
                    Object[] aoResult = (Object[]) oResponseValue;
                
                    partsRecovered    = (PartitionSet) aoResult[0];
                    partsFailedEvents = (PartitionSet) aoResult[1];
                    }
                else
                    {
                    partsRecovered = (PartitionSet) oResponseValue;
                    }
                
                msgRequest.getPartsRecovered().add(partsRecovered);
                
                if (partsFailedEvents != null)
                    {
                    msgRequest.getEventsPartsFailed().add(partsFailedEvents);
                    }
                
                super.onResponse(msg);
                }
            }

        // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService$PartitionRecoverRequest$RecoverJob
        
        /**
         * RecoverJob performs partition recovery for a sub set of partitions
         * based on the associated PartitionRecoverRequest to facilitate
         * parallel recovery.
         */
        @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
        public static class RecoverJob
                extends    com.tangosol.coherence.component.Util
                implements com.tangosol.net.PriorityTask,
                           Runnable
            {
            // ---- Fields declarations ----
            
            /**
             * Property ListGUID
             *
             * A list of GUIDs to be recovered for the RecoverJob.
             */
            private java.util.List __m_ListGUID;
            
            /**
             * Property RecoverInfo
             *
             * The PartitionRecoverInfo for the PartitionRecoverRequest.
             */
            private com.tangosol.net.internal.PartitionRecoverInfo __m_RecoverInfo;
            
            /**
             * Property Service
             *
             */
            private com.tangosol.coherence.component.util.daemon.queueProcessor.service.Grid __m_Service;
            
            // Default constructor
            public RecoverJob()
                {
                this(null, null, true);
                }
            
            // Initializing constructor
            public RecoverJob(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                {
                super(sName, compParent, false);
                
                if (fInit)
                    {
                    __init();
                    }
                }
            
            // Main initializer
            public void __init()
                {
                // private initialization
                __initPrivate();
                
                
                // signal the end of the initialization
                set_Constructed(true);
                }
            
            // Private initializer
            protected void __initPrivate()
                {
                
                super.__initPrivate();
                }
            
            //++ getter for static property _Instance
            /**
             * Getter for property _Instance.<p>
            * Auto generated
             */
            public static com.tangosol.coherence.Component get_Instance()
                {
                return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.PartitionRecoverRequest.RecoverJob();
                }
            
            //++ getter for static property _CLASS
            /**
             * Getter for property _CLASS.<p>
            * Property with auto-generated accessor that returns the Class
            * object for a given component.
             */
            public static Class get_CLASS()
                {
                Class clz;
                try
                    {
                    clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/PartitionedService$PartitionRecoverRequest$RecoverJob".replace('/', '.'));
                    }
                catch (ClassNotFoundException e)
                    {
                    throw new NoClassDefFoundError(e.getMessage());
                    }
                return clz;
                }
            
            //++ getter for autogen property _Module
            /**
             * This is an auto-generated method that returns the global [design
            * time] parent component.
            * 
            * Note: the class generator will ignore any custom implementation
            * for this behavior.
             */
            private com.tangosol.coherence.Component get_Module()
                {
                return this.get_Parent().get_Parent();
                }
            
            // From interface: com.tangosol.net.PriorityTask
            public long getExecutionTimeoutMillis()
                {
                return 0L;
                }
            
            // Accessor for the property "ListGUID"
            /**
             * Getter for property ListGUID.<p>
            * A list of GUIDs to be recovered for the RecoverJob.
             */
            public java.util.List getListGUID()
                {
                return __m_ListGUID;
                }
            
            // Accessor for the property "RecoverInfo"
            /**
             * Getter for property RecoverInfo.<p>
            * The PartitionRecoverInfo for the PartitionRecoverRequest.
             */
            public com.tangosol.net.internal.PartitionRecoverInfo getRecoverInfo()
                {
                return __m_RecoverInfo;
                }
            
            // From interface: com.tangosol.net.PriorityTask
            public long getRequestTimeoutMillis()
                {
                return 0L;
                }
            
            // From interface: com.tangosol.net.PriorityTask
            public int getSchedulingPriority()
                {
                // import com.tangosol.net.PriorityTask;
                
                return PriorityTask.SCHEDULE_IMMEDIATE;
                }
            
            // Accessor for the property "Service"
            /**
             * Getter for property Service.<p>
             */
            public com.tangosol.coherence.component.util.daemon.queueProcessor.service.Grid getService()
                {
                return __m_Service;
                }
            
            // From interface: java.lang.Runnable
            public void run()
                {
                PartitionedService service = (PartitionedService) getService();
                
                // mark this thread as recovery thread; see #PC.onBackingMapEvent
                service.setRecoveryThread(true);
                try
                    {
                    ((PartitionedService) getService()).onPartitionRecoverJob(this);
                    }
                finally
                    {
                    service.setRecoveryThread(false);
                    }
                }
            
            // From interface: com.tangosol.net.PriorityTask
            public void runCanceled(boolean Param_1)
                {
                }
            
            // Accessor for the property "ListGUID"
            /**
             * Setter for property ListGUID.<p>
            * A list of GUIDs to be recovered for the RecoverJob.
             */
            public void setListGUID(java.util.List listD)
                {
                __m_ListGUID = listD;
                }
            
            // Accessor for the property "RecoverInfo"
            /**
             * Setter for property RecoverInfo.<p>
            * The PartitionRecoverInfo for the PartitionRecoverRequest.
             */
            public void setRecoverInfo(com.tangosol.net.internal.PartitionRecoverInfo infoRecover)
                {
                __m_RecoverInfo = infoRecover;
                }
            
            // Accessor for the property "Service"
            /**
             * Setter for property Service.<p>
             */
            public void setService(com.tangosol.coherence.component.util.daemon.queueProcessor.service.Grid gridService)
                {
                __m_Service = gridService;
                }
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService$PartitionStatsUpdate
    
    /**
     * The Message contains all of the information necessary to describe a
     * message to send or to describe a received message.
     * <p>
     * With regards to the use of Message components within clustered Services,
     * Services are designed by dragging Message components into them as static
     * children. These Messages are the components that a Service can send to
     * other running instances of the same Service within a cluster. To send a
     * Message, a Service calls <code>instantiateMessage(String
     * sMsgName)</code> with the name of the child, then configures the Message
     * object and calls Service.send passing the Message. An incoming Message
     * is created by the Message Receiver by calling the
     * <code>Service.instantiateMessage(int nMsgType)</code> and the
     * configuring the Message using the Received data. The Message is then
     * queued in the Service's Queue. When the Service thread gets the Message
     * out of the Queue, it invokes onMessage passing the Message, and the
     * default implementation for onMessage in turn calls
     * <code>onReceived()</code> on the Message object.
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class PartitionStatsUpdate
            extends    com.tangosol.coherence.component.net.Message
        {
        // ---- Fields declarations ----
        
        /**
         * Property StatsList
         *
         * Array of the partition statistics, indexed by partition-id.
         */
        private java.util.List __m_StatsList;
        
        // Default constructor
        public PartitionStatsUpdate()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public PartitionStatsUpdate(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                setMessageType(50);
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.PartitionStatsUpdate();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/PartitionedService$PartitionStatsUpdate".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        // Accessor for the property "StatsList"
        /**
         * Getter for property StatsList.<p>
        * Array of the partition statistics, indexed by partition-id.
         */
        public java.util.List getStatsList()
            {
            return __m_StatsList;
            }
        
        // Declared at the super level
        /**
         * This is the event that is executed when a Message is received.
        * <p>
        * It is the main processing event of the Message called by the
        * <code>Service.onMessage()</code> event. With regards to the use of
        * Message components within clustered Services, Services are designed
        * by dragging Message components into them as static children. These
        * Messages are the components that a Service can send to other running
        * instances of the same Service within a cluster. When the onReceived
        * event is invoked by a Service, it means that the Message has been
        * received; the code in the onReceived event is therefore the Message
        * specific logic for processing a received Message. For example, when
        * onReceived is invoked on a Message named FindData, the onReceived
        * event should do the work to "find the data", because it is being
        * invoked by the Service that received the "find the data" Message.
         */
        public void onReceived()
            {
            super.onReceived();
            
            PartitionedService service = (PartitionedService) get_Module();
            service.getDistributionStrategy().onPartitionStatsUpdate(this);
            }
        
        // Declared at the super level
        public void read(com.tangosol.io.ReadBuffer.BufferInput input)
                throws java.io.IOException
            {
            // import com.tangosol.util.ExternalizableHelper as com.tangosol.util.ExternalizableHelper;
            // import java.util.ArrayList;
            // import java.util.List;
            
            super.read(input);
            
            int cParts = com.tangosol.util.ExternalizableHelper.readInt(input);
            
            List listStats = new ArrayList(cParts);
            for (int i = 0; i < cParts; i++)
                {
                listStats.add(com.tangosol.util.ExternalizableHelper.readObject(input));
                }
            
            setStatsList(listStats);
            }
        
        // Accessor for the property "StatsList"
        /**
         * Setter for property StatsList.<p>
        * Array of the partition statistics, indexed by partition-id.
         */
        public void setStatsList(java.util.List listStats)
            {
            __m_StatsList = listStats;
            }
        
        // Declared at the super level
        public void write(com.tangosol.io.WriteBuffer.BufferOutput output)
                throws java.io.IOException
            {
            // import com.tangosol.util.ExternalizableHelper as com.tangosol.util.ExternalizableHelper;
            // import java.util.Iterator;
            // import java.util.List;
            
            super.write(output);
            
            List listStats = getStatsList();
            
            com.tangosol.util.ExternalizableHelper.writeInt(output, listStats.size());
            for (Iterator iter = listStats.iterator(); iter.hasNext(); )
                {
                com.tangosol.util.ExternalizableHelper.writeObject(output, iter.next());
                }
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService$PartitionSwapRequest
    
    /**
     * PartitionSwapRequest is sent by the primary partition owner to backup
     * owners to swap storage indices.  While this message is logically
     * directed at 2 members (the members that will be "swapping" backup
     * ownership), it will be delivered and chained through each of the
     * preceding backup owners.
     * 
     * For example, suppose a partition ownership: (M1,M2,M3,M4)
     * 
     * If the primary owner M1 wishes to swap the backup ownership for M3,M4
     * making the desired ownership (M1,M2,M4,M3), it will send a
     * PartitionSwapRequest to the MemberList: [M2,M4,M3].
     * 
     * The PartitionSwapRequest may only be used to swap "adjacent" backup
     * owners.  (i.e. in the prior example of (M1,M2,M3,M4), swap of M3 and M4
     * is allowed, swap of M2 and M3 is allowed, but a direct swap of M2 and M4
     * is disallowed and must be accomplished by a composite of 2 swap
     * operations).
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class PartitionSwapRequest
            extends    com.tangosol.coherence.component.net.message.requestMessage.ChainedRequest
        {
        // ---- Fields declarations ----
        
        /**
         * Property Owners
         *
         * The partition ownership.
         */
        private com.tangosol.net.partition.VersionedOwnership __m_Owners;
        
        /**
         * Property Partition
         *
         * The partition-id to swap.
         */
        private int __m_Partition;
        
        /**
         * Property PromoteIndex
         *
         * The backup storage index to promote to.
         * 
         * Note: since the PartitionSwapRequest is only allowed to swap
         * adjacent indices, the "demote" index is trivially derived
         */
        private int __m_PromoteIndex;
        private static com.tangosol.util.ListMap __mapChildren;
        
        // Static initializer
        static
            {
            __initStatic();
            }
        
        // Default static initializer
        private static void __initStatic()
            {
            // register child classes
            __mapChildren = new com.tangosol.util.ListMap();
            __mapChildren.put("Poll", PartitionedService.PartitionSwapRequest.Poll.get_CLASS());
            }
        
        // Default constructor
        public PartitionSwapRequest()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public PartitionSwapRequest(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                setMessageType(39);
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // containment initialization: children
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.PartitionSwapRequest();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/PartitionedService$PartitionSwapRequest".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        //++ getter for autogen property _ChildClasses
        /**
         * This is an auto-generated method that returns the map of design time
        * [static] children.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        protected java.util.Map get_ChildClasses()
            {
            return __mapChildren;
            }
        
        // Declared at the super level
        /**
         * Instantiate a copy of this message. This is quite different from the
        * standard "clone" since only the "transmittable" portion of the
        * message (and none of the internal) state should be cloned.
         */
        public com.tangosol.coherence.component.net.Message cloneMessage()
            {
            PartitionedService.PartitionSwapRequest msg = (PartitionedService.PartitionSwapRequest) super.cloneMessage();
            
            msg.setOwners      (getOwners());
            msg.setPartition   (getPartition());
            msg.setPromoteIndex(getPromoteIndex());
            
            return msg;
            }
        
        // Accessor for the property "Owners"
        /**
         * Getter for property Owners.<p>
        * The partition ownership.
         */
        public com.tangosol.net.partition.VersionedOwnership getOwners()
            {
            return __m_Owners;
            }
        
        // Accessor for the property "Partition"
        /**
         * Getter for property Partition.<p>
        * The partition-id to swap.
         */
        public int getPartition()
            {
            return __m_Partition;
            }
        
        // Accessor for the property "PromoteIndex"
        /**
         * Getter for property PromoteIndex.<p>
        * The backup storage index to promote to.
        * 
        * Note: since the PartitionSwapRequest is only allowed to swap adjacent
        * indices, the "demote" index is trivially derived
         */
        public int getPromoteIndex()
            {
            return __m_PromoteIndex;
            }
        
        // Declared at the super level
        /**
         * This is the event that is executed when a Message is received.
        * <p>
        * It is the main processing event of the Message called by the
        * <code>Service.onMessage()</code> event. With regards to the use of
        * Message components within clustered Services, Services are designed
        * by dragging Message components into them as static children. These
        * Messages are the components that a Service can send to other running
        * instances of the same Service within a cluster. When the onReceived
        * event is invoked by a Service, it means that the Message has been
        * received; the code in the onReceived event is therefore the Message
        * specific logic for processing a received Message. For example, when
        * onReceived is invoked on a Message named FindData, the onReceived
        * event should do the work to "find the data", because it is being
        * invoked by the Service that received the "find the data" Message.
         */
        public void onReceived()
            {
            super.onReceived();  // forward the request
            
            ((PartitionedService) get_Module()).onPartitionSwapRequest(this);
            }
        
        // Declared at the super level
        /**
         * This method is called on the originating member of the request when
        * the request has been fully delivered.
         */
        public void onRequestCompleted()
            {
            // import com.tangosol.net.partition.VersionedOwnership;
            
            PartitionedService            service    = (PartitionedService) getService();
            int                iPartition = getPartition();
            int                iStoreLow  = getPromoteIndex();
            int                iStoreHigh = iStoreLow + 1;
            int[]              aiOwner    = service.getPartitionAssignments()[iPartition];
            VersionedOwnership owners     = new VersionedOwnership(service.getPartitionConfig(iPartition));
            
            // publish the "local" assignments, as it is possible that one (or both)
            // of the members involved in the swap have died in the interim
            owners.setOwner(iStoreLow,  aiOwner[iStoreLow]);
            owners.setOwner(iStoreHigh, aiOwner[iStoreHigh]);
            
            service.putPartitionConfig(iPartition, owners);
            
            // re-enable the partition for transfer
            service.getPartitionControl(iPartition).enableTransfer();
            }
        
        // Declared at the super level
        public void read(com.tangosol.io.ReadBuffer.BufferInput input)
                throws java.io.IOException
            {
            // import com.tangosol.net.partition.VersionedOwnership;
            
            super.read(input);
            
            setPartition   (input.readInt());
            setPromoteIndex(input.readInt());
            
            VersionedOwnership owners = new VersionedOwnership();
            owners.readExternal(input);
            setOwners(owners);
            }
        
        // Accessor for the property "Owners"
        /**
         * Setter for property Owners.<p>
        * The partition ownership.
         */
        public void setOwners(com.tangosol.net.partition.VersionedOwnership ownershipOwners)
            {
            __m_Owners = ownershipOwners;
            }
        
        // Accessor for the property "Partition"
        /**
         * Setter for property Partition.<p>
        * The partition-id to swap.
         */
        public void setPartition(int nPartition)
            {
            __m_Partition = nPartition;
            }
        
        // Accessor for the property "PromoteIndex"
        /**
         * Setter for property PromoteIndex.<p>
        * The backup storage index to promote to.
        * 
        * Note: since the PartitionSwapRequest is only allowed to swap adjacent
        * indices, the "demote" index is trivially derived
         */
        public void setPromoteIndex(int nIndex)
            {
            __m_PromoteIndex = nIndex;
            }
        
        // Declared at the super level
        public void write(com.tangosol.io.WriteBuffer.BufferOutput output)
                throws java.io.IOException
            {
            super.write(output);
            
            output.writeInt(getPartition());
            output.writeInt(getPromoteIndex());
            getOwners().writeExternal(output);
            }

        // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService$PartitionSwapRequest$Poll
        
        /**
         * The Poll contains information regarding a request sent to one or
         * more Cluster Members that require responses. A Service may poll
         * other Members that are running the same Service, and the Poll is
         * used to wait for and assemble the responses from each of those
         * Members. A client thread may also use the Poll to block on a
         * response or set of responses, thus waiting for the completion of the
         * Poll. In its simplest form, which is a Poll that is sent to one
         * Member of the Cluster, the Poll actually represents the
         * request/response model.
         */
        @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
        public static class Poll
                extends    com.tangosol.coherence.component.net.message.requestMessage.ChainedRequest.Poll
            {
            // ---- Fields declarations ----
            
            // Default constructor
            public Poll()
                {
                this(null, null, true);
                }
            
            // Initializing constructor
            public Poll(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                {
                super(sName, compParent, false);
                
                if (fInit)
                    {
                    __init();
                    }
                }
            
            // Main initializer
            public void __init()
                {
                // private initialization
                __initPrivate();
                
                
                // signal the end of the initialization
                set_Constructed(true);
                }
            
            // Private initializer
            protected void __initPrivate()
                {
                
                super.__initPrivate();
                }
            
            // Getter for virtual constant Preprocessable
            public boolean isPreprocessable()
                {
                return false;
                }
            
            //++ getter for static property _Instance
            /**
             * Getter for property _Instance.<p>
            * Auto generated
             */
            public static com.tangosol.coherence.Component get_Instance()
                {
                return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.PartitionSwapRequest.Poll();
                }
            
            //++ getter for static property _CLASS
            /**
             * Getter for property _CLASS.<p>
            * Property with auto-generated accessor that returns the Class
            * object for a given component.
             */
            public static Class get_CLASS()
                {
                Class clz;
                try
                    {
                    clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/PartitionedService$PartitionSwapRequest$Poll".replace('/', '.'));
                    }
                catch (ClassNotFoundException e)
                    {
                    throw new NoClassDefFoundError(e.getMessage());
                    }
                return clz;
                }
            
            //++ getter for autogen property _Module
            /**
             * This is an auto-generated method that returns the global [design
            * time] parent component.
            * 
            * Note: the class generator will ignore any custom implementation
            * for this behavior.
             */
            private com.tangosol.coherence.Component get_Module()
                {
                return this.get_Parent().get_Parent();
                }
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService$PartitionVersionSyncRequest
    
    /**
     * A PartitionVersionSyncRequest is sent from the primary partition owner
     * to all of its backups in order to synchronize the current partition
     * version.
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class PartitionVersionSyncRequest
            extends    com.tangosol.coherence.component.net.message.requestMessage.ChainedRequest
        {
        // ---- Fields declarations ----
        
        /**
         * Property Partition
         *
         * The partition to synchronize the version of.
         */
        private int __m_Partition;
        
        /**
         * Property PartitionVersion
         *
         * The current partition version.
         */
        private long __m_PartitionVersion;
        private static com.tangosol.util.ListMap __mapChildren;
        
        // Static initializer
        static
            {
            __initStatic();
            }
        
        // Default static initializer
        private static void __initStatic()
            {
            // register child classes
            __mapChildren = new com.tangosol.util.ListMap();
            __mapChildren.put("Poll", PartitionedService.PartitionVersionSyncRequest.Poll.get_CLASS());
            }
        
        // Default constructor
        public PartitionVersionSyncRequest()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public PartitionVersionSyncRequest(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                setMessageType(41);
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // containment initialization: children
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.PartitionVersionSyncRequest();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/PartitionedService$PartitionVersionSyncRequest".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        //++ getter for autogen property _ChildClasses
        /**
         * This is an auto-generated method that returns the map of design time
        * [static] children.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        protected java.util.Map get_ChildClasses()
            {
            return __mapChildren;
            }
        
        // Declared at the super level
        /**
         * Instantiate a copy of this message. This is quite different from the
        * standard "clone" since only the "transmittable" portion of the
        * message (and none of the internal) state should be cloned.
         */
        public com.tangosol.coherence.component.net.Message cloneMessage()
            {
            PartitionedService.PartitionVersionSyncRequest msg = (PartitionedService.PartitionVersionSyncRequest) super.cloneMessage();
            
            msg.setPartition       (getPartition());
            msg.setPartitionVersion(getPartitionVersion());
            
            return msg;
            }
        
        // Accessor for the property "Partition"
        /**
         * Getter for property Partition.<p>
        * The partition to synchronize the version of.
         */
        public int getPartition()
            {
            return __m_Partition;
            }
        
        // Accessor for the property "PartitionVersion"
        /**
         * Getter for property PartitionVersion.<p>
        * The current partition version.
         */
        public long getPartitionVersion()
            {
            return __m_PartitionVersion;
            }
        
        // Declared at the super level
        /**
         * This is the event that is executed when a Message is received.
        * <p>
        * It is the main processing event of the Message called by the
        * <code>Service.onMessage()</code> event. With regards to the use of
        * Message components within clustered Services, Services are designed
        * by dragging Message components into them as static children. These
        * Messages are the components that a Service can send to other running
        * instances of the same Service within a cluster. When the onReceived
        * event is invoked by a Service, it means that the Message has been
        * received; the code in the onReceived event is therefore the Message
        * specific logic for processing a received Message. For example, when
        * onReceived is invoked on a Message named FindData, the onReceived
        * event should do the work to "find the data", because it is being
        * invoked by the Service that received the "find the data" Message.
         */
        public void onReceived()
            {
            // import java.util.concurrent.atomic.AtomicLong;
            
            super.onReceived();
            
            int               nPartition = getPartition();
            PartitionedService           service    = (PartitionedService) getService();
            PartitionedService.PartitionControl ctrlPart   = service.getPartitionControl(nPartition);
            if (ctrlPart != null)
                {
                // Note: it is possible we have just transferred the primary ownership
                //       and have been assigned to become a new backup.  Due to the
                //       message delivery mechanism (direct PartitionedService.TransferResponse), it is
                //       possible that this sync msg arrives before we learn we are a
                //       backup. (see COH-8382, COH-10474)
            
                AtomicLong atomicVersion = ctrlPart.getVersionCounter();
                long       lVersionCur   = atomicVersion.get();
                long       lVersionNew   = getPartitionVersion();
            
                if (lVersionNew == lVersionCur)
                    {
                    // we already had the sync'd version
                    }
                else
                    {
                    if (lVersionNew == lVersionCur + 1)
                        {
                        // common case; this happens whe the version-sync request is being
                        // issued as a result of primary transfer, restore or recovery
                        }
                    else if (lVersionNew > lVersionCur)
                        {
                        // should not happen, but not a problem yet (see below)
                        _trace("Synchronizing the version counter for partition " + nPartition
                             + " forward to version " + lVersionNew + " from " + lVersionCur, 3);
                        }
                    else // lVersionNew < lVersionCur
                        {
                        // we have already seen future partition version, or we missed an old one;
                        // this should not happen; log a not-so-scary-sounding message
                        _trace("Reverting the backup version for partition " + nPartition
                             + " from version " + lVersionCur + " to version " + lVersionNew, 2);
                        return;
                        }
            
                    atomicVersion.set(lVersionNew);
                    }
            
                ctrlPart.flushDeferredBackups();
                }
            else
                {
                // we received a version-sync request for a partition that we are not the backup
                // owner for; this should not happen
                _trace("Ignoring PartitionVersionSyncRequest for un-owned partition " + nPartition
                     + " originating from member " + getOriginatingMemberId(), 2);
                }
            }
        
        // Declared at the super level
        /**
         * This method is called on the originating member of the request when
        * the request has been fully delivered.
         */
        public void onRequestCompleted()
            {
            ((PartitionedService) getService()).getPartitionControl(getPartition()).unmarkVersionInSync();
            }
        
        // Declared at the super level
        public void read(com.tangosol.io.ReadBuffer.BufferInput input)
                throws java.io.IOException
            {
            super.read(input);
            
            setPartition       (input.readInt());
            setPartitionVersion(input.readLong());
            }
        
        // Accessor for the property "Partition"
        /**
         * Setter for property Partition.<p>
        * The partition to synchronize the version of.
         */
        public void setPartition(int sProperty)
            {
            __m_Partition = sProperty;
            }
        
        // Accessor for the property "PartitionVersion"
        /**
         * Setter for property PartitionVersion.<p>
        * The current partition version.
         */
        public void setPartitionVersion(long lVersion)
            {
            __m_PartitionVersion = lVersion;
            }
        
        // Declared at the super level
        public void write(com.tangosol.io.WriteBuffer.BufferOutput output)
                throws java.io.IOException
            {
            super.write(output);
            
            output.writeInt (getPartition());
            output.writeLong(getPartitionVersion());
            }

        // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService$PartitionVersionSyncRequest$Poll
        
        /**
         * The Poll contains information regarding a request sent to one or
         * more Cluster Members that require responses. A Service may poll
         * other Members that are running the same Service, and the Poll is
         * used to wait for and assemble the responses from each of those
         * Members. A client thread may also use the Poll to block on a
         * response or set of responses, thus waiting for the completion of the
         * Poll. In its simplest form, which is a Poll that is sent to one
         * Member of the Cluster, the Poll actually represents the
         * request/response model.
         */
        @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
        public static class Poll
                extends    com.tangosol.coherence.component.net.message.requestMessage.ChainedRequest.Poll
            {
            // ---- Fields declarations ----
            
            // Default constructor
            public Poll()
                {
                this(null, null, true);
                }
            
            // Initializing constructor
            public Poll(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                {
                super(sName, compParent, false);
                
                if (fInit)
                    {
                    __init();
                    }
                }
            
            // Main initializer
            public void __init()
                {
                // private initialization
                __initPrivate();
                
                
                // signal the end of the initialization
                set_Constructed(true);
                }
            
            // Private initializer
            protected void __initPrivate()
                {
                
                super.__initPrivate();
                }
            
            // Getter for virtual constant Preprocessable
            public boolean isPreprocessable()
                {
                return false;
                }
            
            //++ getter for static property _Instance
            /**
             * Getter for property _Instance.<p>
            * Auto generated
             */
            public static com.tangosol.coherence.Component get_Instance()
                {
                return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.PartitionVersionSyncRequest.Poll();
                }
            
            //++ getter for static property _CLASS
            /**
             * Getter for property _CLASS.<p>
            * Property with auto-generated accessor that returns the Class
            * object for a given component.
             */
            public static Class get_CLASS()
                {
                Class clz;
                try
                    {
                    clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/PartitionedService$PartitionVersionSyncRequest$Poll".replace('/', '.'));
                    }
                catch (ClassNotFoundException e)
                    {
                    throw new NoClassDefFoundError(e.getMessage());
                    }
                return clz;
                }
            
            //++ getter for autogen property _Module
            /**
             * This is an auto-generated method that returns the global [design
            * time] parent component.
            * 
            * Note: the class generator will ignore any custom implementation
            * for this behavior.
             */
            private com.tangosol.coherence.Component get_Module()
                {
                return this.get_Parent().get_Parent();
                }
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService$PersistenceControl
    
    /**
     * The PersistenceControl manages the persistence-related state and
     * functionality.
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class PersistenceControl
            extends    com.tangosol.coherence.Component
        {
        // ---- Fields declarations ----
        
        /**
         * Property ActiveFailureHandler
         *
         * The Exception continuation for handling critical failures of the
         * active persistence.
         */
        private com.oracle.coherence.common.base.Continuation __m_ActiveFailureHandler;
        
        /**
         * Property ActiveFailureMode
         *
         * The failure mode (one of the PersistenceDependencies.FAILURE_*
         * constants) determining how failures of the active persistence
         * operations should be handled.
         */
        private int __m_ActiveFailureMode;
        
        /**
         * Property ActiveManager
         *
         * The active PersistenceManager, or null if the service is not
         * configured for active persistence.
         */
        private com.oracle.coherence.persistence.PersistenceManager __m_ActiveManager;
        
        /**
         * Property ActiveRecoveryRequests
         *
         * A counter for the number of PartitionRecoverRequests that have been
         * sent. 
         */
        private transient java.util.concurrent.atomic.AtomicInteger __m_ActiveRecoveryRequests;
        
        /**
         * Property Async
         *
         * Specifies whether persistence should be written async.
         */
        private boolean __m_Async;
        
        /**
         * Property BackupManager
         *
         * The backup PersistenceManager, or null if the service is not
         * configured for active persistence.
         */
        private com.oracle.coherence.persistence.PersistenceManager __m_BackupManager;
        
        /**
         * Property Disabled
         *
         * True iff the active persistence has been configured but is disabled
         * due to a persistence failure.
         * 
         * @volatile
         */
        private volatile boolean __m_Disabled;
        
        /**
         * Property EventsManager
         *
         * The active PersistenceManager, or null if the service is not
         * configured for active persistence.
         */
        private com.oracle.coherence.persistence.PersistenceManager __m_EventsManager;
        
        /**
         * Property ForceRecovery
         *
         * Indicates thet the active persistence recovery should be forced
         * despite the quorum's decision.
         */
        private boolean __m_ForceRecovery;
        
        /**
         * Property PartitionVersionExclusionList
         *
         * Contains partition versions that failed to be recovered.
         */
        private com.tangosol.net.internal.PartitionVersionExclusionList __m_PartitionVersionExclusionList;
        
        /**
         * Property PersistenceEnvironment
         *
         * The PersistenceEnvironment.
         */
        private com.oracle.coherence.persistence.PersistenceEnvironment __m_PersistenceEnvironment;
        
        /**
         * Property QuorumRaw
         *
         * The "last well known" quorum as it was last written to the "META"
         * extent by the global partition owner.
         * 
         * @volatile
         */
        private volatile com.tangosol.util.Binary __m_QuorumRaw;
        
        /**
         * Property ResumeOnFailover
         *
         * Flag that indicates whether this service should be automatically
         * resumed upon failover.
         */
        private boolean __m_ResumeOnFailover;
        
        /**
         * Property SnapshotArchiver
         *
         * The SnapshotArchiver to be used to archive snapshots
         */
        private com.tangosol.persistence.SnapshotArchiver __m_SnapshotArchiver;
        
        /**
         * Property SnapshotController
         *
         * The SnapshotController, if it exists.
         * 
         * Only used on the ownership senior.
         */
        private PartitionedService.PersistenceControl.SnapshotController __m_SnapshotController;
        
        /**
         * Property StatsLatencyCount
         *
         * The Count of persistence operations for this service.
         */
        private long __m_StatsLatencyCount;
        
        /**
         * Property StatsLatencyMax
         *
         * The Max persistence latency in millis for this service.
         */
        private long __m_StatsLatencyMax;
        
        /**
         * Property StatsLatencyTotal
         *
         * The Total persistence latency in millis for this service.
         */
        private long __m_StatsLatencyTotal;
        private static com.tangosol.util.ListMap __mapChildren;
        
        // Static initializer
        static
            {
            __initStatic();
            }
        
        // Default static initializer
        private static void __initStatic()
            {
            // register child classes
            __mapChildren = new com.tangosol.util.ListMap();
            __mapChildren.put("SnapshotBuilder", PartitionedService.PersistenceControl.SnapshotBuilder.get_CLASS());
            __mapChildren.put("SnapshotController", PartitionedService.PersistenceControl.SnapshotController.get_CLASS());
            }
        
        // Default constructor
        public PersistenceControl()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public PersistenceControl(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                setActiveRecoveryRequests(new java.util.concurrent.atomic.AtomicInteger());
                setPartitionVersionExclusionList(new com.tangosol.net.internal.PartitionVersionExclusionList());
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // containment initialization: children
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.PersistenceControl();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/PartitionedService$PersistenceControl".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        //++ getter for autogen property _ChildClasses
        /**
         * This is an auto-generated method that returns the map of design time
        * [static] children.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        protected java.util.Map get_ChildClasses()
            {
            return __mapChildren;
            }
        
        public void add(Object o)
            {
            }
        
        /**
         * Archive a persistent snapshot according to the specified
        * SnapshotArchiveRequest.
        * This method is called on the service thread only.
        * 
        * @param msgRequest    the SnapshotRequest
        * @param fArchive           if true this is an archive operation
        * otherwise retrieve
         */
        public void archiveOperation(PartitionedService.SnapshotArchiveRequest msgRequest, boolean fArchive)
            {
            // import Component.Net.Member;
            // import com.oracle.coherence.persistence.PersistenceException;
            // import com.tangosol.persistence.SnapshotArchiver;
            // import com.tangosol.persistence.Snapshot;
            // import java.util.Arrays;
            // import java.util.LinkedList;
            // import java.util.List;
            // import java.util.Map;
            
            String sDesc = fArchive ? "archive" : "retrieve";
            PartitionedService   service     = (PartitionedService) get_Module();
            PartitionedService.Response msgResponse = (PartitionedService.Response) service.instantiateMessage("Response");
            msgResponse.respondTo(msgRequest);
            msgResponse.setResult(PartitionedService.Response.RESULT_SUCCESS);
            
            if (!isValid())
                {
                _trace("Service is not configured for persistence", 2);
                msgResponse.setResult(PartitionedService.Response.RESULT_FAILURE);
                service.send(msgResponse);
                return;
                }
            
            String sSnapshot = msgRequest.getSnapshotName();
            Map    mapStores = msgRequest.getStores();
            
            // retrieve the stores that this member should archive or retrieve
            Object[] aoStores = (Object[]) mapStores.get(Integer.valueOf(service.getThisMember().getId()));
            if (aoStores == null || aoStores.length == 0)
                {
                throw new IllegalArgumentException("Did not receive any stores to archive"); 
                }
            
            // convert to String[] as POF will widen to Object[]
            String[] asStores = new String[aoStores.length];
            for (int i = 0; i < aoStores.length ; i++)
                {
                asStores[i] = aoStores[i].toString();
                }
            
            _trace("Received request to " + sDesc + " " + asStores.length + " stores for snapshot \"" + sSnapshot + "\"" ,3);
            
            try
                {
                SnapshotArchiver archiver = getSnapshotArchiver();
                if (archiver == null)
                    {
                    throw new IllegalStateException("No archiver is defined for this service");
                    }
            
                Snapshot snapshot = new Snapshot(sSnapshot, asStores);
            
                if (fArchive)
                    {
                    archiver.archive(snapshot, getPersistenceEnvironment());
                    }
                else
                    {
                    archiver.retrieve(snapshot, getPersistenceEnvironment());
                    }
                }
            catch (Exception e)
                {
                _trace("Failed to " + sDesc + " persistent snapshot: " + getStackTrace(e), 2);
                msgResponse.setResult(PartitionedService.Response.RESULT_FAILURE);
                }
            
            service.send(msgResponse);
            }
        
        /**
         * Create a persistent snapshot according to the specified
        * SnapshotRequest.
        * This method is called on the service thread only.
        * 
        * @param msgRequest    the SnapshotRequest
         */
        public void createSnapshot(PartitionedService.SnapshotRequest msgRequest)
            {
            // import com.oracle.coherence.persistence.PersistenceException;
            // import com.oracle.coherence.persistence.PersistenceManager;
            // import com.tangosol.net.partition.PartitionSet;
            
            PartitionedService   service     = (PartitionedService) get_Module();
            PartitionedService.Response msgResponse = (PartitionedService.Response) service.instantiateMessage("Response");
            
            msgResponse.respondTo(msgRequest);
            msgResponse.setResult(PartitionedService.Response.RESULT_SUCCESS);
            
            if (!isValid())
                {
                _trace("Service is not configured for persistent snapshot creation.", 2);
                msgResponse.setResult(PartitionedService.Response.RESULT_FAILURE);
                service.send(msgResponse);
                return;
                }
            
            PartitionSet parts     = service.collectOwnedPartitions(true);
            PartitionSet partsMask = msgRequest.getRequestMask();
            if (partsMask != null)
                {
                parts.retain(partsMask);
                }
            
            if (parts.isEmpty())
                {
                // nothing to recover; reply immediately
                service.send(msgResponse);
                return;
                }
            
            String             sSnapshot   = msgRequest.getSnapshotName();
            PersistenceManager mgrSnapshot;
            try
                {
                mgrSnapshot = getPersistenceEnvironment().createSnapshot(sSnapshot);
                }
            catch (PersistenceException e)
                {
                _trace("Failed to create persistent snapshot: " + getStackTrace(e), 2);
            
                msgResponse.setResult(PartitionedService.Response.RESULT_FAILURE);
                service.send(msgResponse);
                return;
                }
            
            _trace("Creating snapshot \"" + sSnapshot + "\" of partitions " + parts + " using " + mgrSnapshot, 3);
            
            // the response will be posted when the builder completes;
            // see PartitionedService.PersistenceControl.SnapshotBuilder.onCompletion
            PartitionedService.PersistenceControl.SnapshotBuilder builder = (PartitionedService.PersistenceControl.SnapshotBuilder) _newChild("SnapshotBuilder");
            builder.setManager(mgrSnapshot);
            builder.setResponse(msgResponse);
            builder.setPartitions(parts);
            
            builder.build(/*iPart*/ 0);
            }

        /**
         * Open and return a PersistentStore with the specified GUID name from the active persistence manager.
         * The returned store is "failure-safe' and any persistence failure (synchronous or asynchronous)
         * will be handled by the active failure handler.
         *
         * This method is called on the service thread only.
         */
        public PersistentStore ensurePersistentStore(String sGUID)
            {
            try
                {
                // create an unopened persistence store
                return new SafePersistenceWrappers.SafePersistentStore(getActiveManager().createStore(sGUID), getActiveFailureHandler());
                }
            catch (PersistenceException e)
                {
                onActivePersistenceFailure(e);
                }

            return NullImplementation.getPersistentStore();
            }


        /**
         * Open and return a PersistentStore with the specified GUID name from the backup persistence manager.
         * The returned store is "failure-safe' and any persistence failure (synchronous or asynchronous)
         * will be handled by the active failure handler.
         *
         * This method is called on the service thread only.
         */
        public PersistentStore ensureBackupPersistentStore(String sGUID)
            {
            try
                {
                // create an unopened persistence store
                return new SafePersistenceWrappers.SafePersistentStore(getBackupManager().createStore(sGUID), getActiveFailureHandler());
                }
            catch (PersistenceException e)
                {
                onActivePersistenceFailure(e);
                }

            return NullImplementation.getPersistentStore();
            }

        // Accessor for the property "ActiveFailureHandler"
        /**
         * Getter for property ActiveFailureHandler.<p>
        * The Exception continuation for handling critical failures of the
        * active persistence.
         */
        public com.oracle.coherence.common.base.Continuation getActiveFailureHandler()
            {
            return __m_ActiveFailureHandler;
            }
        
        // Accessor for the property "ActiveFailureMode"
        /**
         * Getter for property ActiveFailureMode.<p>
        * The failure mode (one of the PersistenceDependencies.FAILURE_*
        * constants) determining how failures of the active persistence
        * operations should be handled.
         */
        public int getActiveFailureMode()
            {
            return __m_ActiveFailureMode;
            }
        
        // Accessor for the property "ActiveManager"
        /**
         * Getter for property ActiveManager.<p>
        * The active PersistenceManager, or null if the service is not
        * configured for active persistence.
         */
        public com.oracle.coherence.persistence.PersistenceManager getActiveManager()
            {
            return __m_ActiveManager;
            }
        
        // Accessor for the property "ActiveRecoveryRequests"
        /**
         * Getter for property ActiveRecoveryRequests.<p>
        * A counter for the number of PartitionRecoverRequests that have been
        * sent. 
         */
        public java.util.concurrent.atomic.AtomicInteger getActiveRecoveryRequests()
            {
            return __m_ActiveRecoveryRequests;
            }
        
        // Accessor for the property "BackupManager"
        /**
         * Getter for property BackupManager.<p>
        * The backup PersistenceManager, or null if the service is not
        * configured for active persistence.
         */
        public com.oracle.coherence.persistence.PersistenceManager getBackupManager()
            {
            return __m_BackupManager;
            }
        
        // Accessor for the property "EventsManager"
        /**
         * Getter for property EventsManager.<p>
        * The active PersistenceManager, or null if the service is not
        * configured for active persistence.
         */
        public com.oracle.coherence.persistence.PersistenceManager getEventsManager()
            {
            return __m_EventsManager;
            }
        
        // Accessor for the property "MBeanName"
        /**
         * Return the name of the SnapshotManagerMBean.
         */
        public String getMBeanName()
            {
            return null;
            }
        
        // Accessor for the property "PartitionVersionExclusionList"
        /**
         * Getter for property PartitionVersionExclusionList.<p>
        * Contains partition versions that failed to be recovered.
         */
        protected com.tangosol.net.internal.PartitionVersionExclusionList getPartitionVersionExclusionList()
            {
            return __m_PartitionVersionExclusionList;
            }
        
        // Accessor for the property "PersistenceEnvironment"
        /**
         * Getter for property PersistenceEnvironment.<p>
        * The PersistenceEnvironment.
         */
        public com.oracle.coherence.persistence.PersistenceEnvironment getPersistenceEnvironment()
            {
            return __m_PersistenceEnvironment;
            }
        
        // Accessor for the property "QuorumRaw"
        /**
         * Getter for property QuorumRaw.<p>
        * The "last well known" quorum as it was last written to the "META"
        * extent by the global partition owner.
        * 
        * @volatile
         */
        public com.tangosol.util.Binary getQuorumRaw()
            {
            return __m_QuorumRaw;
            }
        
        // Accessor for the property "SnapshotArchiver"
        /**
         * Getter for property SnapshotArchiver.<p>
        * The SnapshotArchiver to be used to archive snapshots
         */
        public com.tangosol.persistence.SnapshotArchiver getSnapshotArchiver()
            {
            return __m_SnapshotArchiver;
            }
        
        // Accessor for the property "SnapshotController"
        /**
         * Getter for property SnapshotController.<p>
        * The SnapshotController, if it exists.
        * 
        * Only used on the ownership senior.
         */
        public PartitionedService.PersistenceControl.SnapshotController getSnapshotController()
            {
            return __m_SnapshotController;
            }
        
        // Accessor for the property "StatsLatencyCount"
        /**
         * Getter for property StatsLatencyCount.<p>
        * The Count of persistence operations for this service.
         */
        public long getStatsLatencyCount()
            {
            return __m_StatsLatencyCount;
            }
        
        // Accessor for the property "StatsLatencyMax"
        /**
         * Getter for property StatsLatencyMax.<p>
        * The Max persistence latency in millis for this service.
         */
        public long getStatsLatencyMax()
            {
            return __m_StatsLatencyMax;
            }
        
        // Accessor for the property "StatsLatencyTotal"
        /**
         * Getter for property StatsLatencyTotal.<p>
        * The Total persistence latency in millis for this service.
         */
        public long getStatsLatencyTotal()
            {
            return __m_StatsLatencyTotal;
            }
        
        /**
         * Return true if the GUID is permitted for recovery.
         */
        public boolean isAllowed(String sGUID)
            {
            // import com.tangosol.persistence.GUIDHelper;
            
            return getPartitionVersionExclusionList().isAllowed(
                GUIDHelper.getPartition(sGUID), (int) GUIDHelper.getVersion(sGUID));
            }
        
        // Accessor for the property "Async"
        /**
         * Getter for property Async.<p>
        * Specifies whether persistence should be written async.
         */
        public boolean isAsync()
            {
            return __m_Async;
            }
        
        // Accessor for the property "Disabled"
        /**
         * Getter for property Disabled.<p>
        * True iff the active persistence has been configured but is disabled
        * due to a persistence failure.
        * 
        * @volatile
         */
        public boolean isDisabled()
            {
            return __m_Disabled;
            }
        
        // Accessor for the property "ForceRecovery"
        /**
         * Getter for property ForceRecovery.<p>
        * Indicates thet the active persistence recovery should be forced
        * despite the quorum's decision.
         */
        public boolean isForceRecovery()
            {
            return __m_ForceRecovery;
            }
        
        // Accessor for the property "PersistEvents"
        /**
         * Getter for property PersistEvents.<p>
         */
        public boolean isPersistEvents()
            {
            return getEventsManager() != null;
            }
        
        // Accessor for the property "ResumeOnFailover"
        /**
         * Getter for property ResumeOnFailover.<p>
        * Flag that indicates whether this service should be automatically
        * resumed upon failover.
         */
        public boolean isResumeOnFailover()
            {
            return __m_ResumeOnFailover;
            }
        
        // Accessor for the property "Valid"
        /**
         * Getter for property Valid.<p>
        * Property is true if this PersistenceControl has been configured and
        * is usable.
         */
        public boolean isValid()
            {
            return getPersistenceEnvironment() != null;
            }
        
        /**
         * Called to handle a failure of the active persistence.
        * This method could be called on any thread.
        * 
        * @param e  the PersistenceException
         */
        public void onActivePersistenceFailure(com.oracle.coherence.persistence.PersistenceException e)
            {
            // import com.oracle.coherence.persistence.PersistentStore;
            // import com.tangosol.internal.net.service.grid.PersistenceDependencies;
            // import com.tangosol.net.partition.PartitionSet;
            // import com.tangosol.persistence.GUIDHelper;
            // import com.tangosol.util.NullImplementation;
            
            if (!isDisabled())
                {
                PartitionedService           service    = (PartitionedService) get_Module();
                PersistentStore   store      = e.getPersistentStore();
                int               nPartition = GUIDHelper.getPartition(store.getId());
                PartitionedService.PartitionControl ctrl       = service.getPartitionControl(nPartition);
                int               nLockState = ctrl.getLockType();
            
                if (ctrl.isLocked() && nLockState == PartitionedService.PartitionControl.LOCK_PERSISTENCE)
                    {
                    throw e;
                    }
            
                switch (getActiveFailureMode())
                    {
                    case PersistenceDependencies.FAILURE_STOP_SERVICE:
                        _trace("Stopping service due to an unexpected persistence exception: " + getStackTrace(e), 1);
            
                        service.stop();
                        break;
            
                    case PersistenceDependencies.FAILURE_STOP_PERSISTENCE:
                        _trace("Disabling active persistence due to an unexpected persistence exception: " + getStackTrace(e), 1);
            
                        // swap out the active manager and all opened active stores
                        setActiveManager(NullImplementation.getPersistenceManager());
            
                        PartitionSet parts = service.collectOwnedPartitions(true);
                        for (int iPart = parts.next(0); iPart >= 0; iPart = parts.next(iPart + 1))
                            {
                            service.getPartitionControl(iPart).disablePersistentStore();
                            }
                        break;
                    }
            
                setDisabled(true);
                }
            }
        
        // Declared at the super level
        /**
         * The "component has been initialized" method-notification called out
        * of setConstructed() for the topmost component and that in turn
        * notifies all the children.
        * 
        * This notification gets called before the control returns back to this
        * component instantiator (using <code>new Component.X()</code> or
        * <code>_newInstance(sName)</code>) and on the same thread. In
        * addition, visual components have a "posted" notification
        * <code>onInitUI</code> that is called after (or at the same time as)
        * the control returns back to the instantiator and possibly on a
        * different thread.
         */
        public void onInit()
            {
            // import com.oracle.coherence.common.base.Continuation;
            
            PartitionedService        service    = (PartitionedService) get_Module();
            PartitionedService.Continuations contHelper = service.getContinuations();
             
            setActiveFailureHandler(contHelper.instantiatePersistenceErrorHandler(
                                    contHelper.instantiateActivePersistenceError()));
            }
        
        /**
         * Called when this service is being resumed.
         */
        public void onMembershipChanged(int nMemberEvent)
            {
            PartitionedService.PersistenceControl.SnapshotController ctrlSnapshot = getSnapshotController();
            if (ctrlSnapshot != null)
                {
                ctrlSnapshot.setSnapshotNames(null);
                }
            }
        
        /**
         * Called when this service assumes the ownership seniority.
         */
        public void onOwnershipSeniority()
            {
            if (isValid())
                {
                setSnapshotController((PartitionedService.PersistenceControl.SnapshotController) _newChild("SnapshotController"));
                }
            }
        
        /**
         * Called when the provided partition has been owned.
         */
        public synchronized void onPrimaryOwnershipChanged(int iPartition)
            {
            getPartitionVersionExclusionList().reset(iPartition);
            }
        
        /**
         * Called when this service is being resumed.
         */
        public void onServiceResume()
            {
            setResumeOnFailover(false);
            }
        
        /**
         * Called when this service is being suspended.
         */
        public void onServiceSuspend(boolean fAutoResume)
            {
            if (fAutoResume)
                {
                setResumeOnFailover(true);
                }
            }
        
        /**
         * Called when this service is being resumed.
         */
        public synchronized void onTransientException(String sGUID)
            {
            // import com.tangosol.persistence.GUIDHelper;
            
            getPartitionVersionExclusionList().exclude(
                GUIDHelper.getPartition(sGUID), (int) GUIDHelper.getVersion(sGUID));
            }
        
        /**
         * Return an active PersistenceManager iff configured.
         */
        public com.oracle.coherence.persistence.PersistenceManager openActiveManager()
            {
            // import com.oracle.coherence.persistence.PersistenceEnvironment;
            // import com.oracle.coherence.persistence.PersistenceManager;
            
            PersistenceEnvironment env       = getPersistenceEnvironment();
            PersistenceManager     mgrActive = getActiveManager();
            
            if (env != null && mgrActive == null)
                {
                setActiveManager(mgrActive = env.openActive());
                setEventsManager(env.openEvents());
                setBackupManager(env.openBackup());
                }
            return mgrActive;
            }

        /**
         * Open and return a PersistentStore with the specified GUID name from
        * the active persistence manager.  The returned store is "failure-safe'
        * and any persistence failure (synchronous or asynchronous) will be
        * handled by the active failure handler.
        * 
        * This method is called on the service thread only.
         */
        public com.oracle.coherence.persistence.PersistentStore openActiveStore(String sGUID, com.oracle.coherence.persistence.PersistentStore storeFrom)
            {
            // import com.oracle.coherence.persistence.PersistenceException;
            // import com.tangosol.persistence.SafePersistenceWrappers$SafePersistentStore as com.tangosol.persistence.SafePersistenceWrappers.SafePersistentStore;
            // import com.tangosol.util.NullImplementation;
            
            try
                {
                // the active failure handler will ensure it is executed on the
                // service thread only
            
                // Note: below is a double-wrap of the PersistentStore which assumes all other
                //       layers have failure continuations that throw back to the outer most
                //       layer allowing it to process the exception on the service thread
            
                return new com.tangosol.persistence.SafePersistenceWrappers.SafePersistentStore(getActiveManager().open(sGUID, storeFrom),
                        getActiveFailureHandler());
                }
            catch (PersistenceException e)
                {
                onActivePersistenceFailure(e);
                }
            
            return NullImplementation.getPersistentStore();
            }
        
        /**
         * Open and return a PersistentStore with the specified GUID name from
        * the active persistence manager.  The returned store is "failure-safe'
        * and any persistence failure (synchronous or asynchronous) will be
        * handled by the active failure handler.
        * 
        * This method is called on the service thread only.
         */
        public com.oracle.coherence.persistence.PersistentStore openBackupStore(String sGUID, com.oracle.coherence.persistence.PersistentStore storeFrom)
            {
            // import com.oracle.coherence.persistence.PersistenceException;
            // import com.tangosol.persistence.SafePersistenceWrappers$SafePersistentStore as com.tangosol.persistence.SafePersistenceWrappers.SafePersistentStore;
            // import com.tangosol.util.NullImplementation;
            
            try
                {
                // the active failure handler will ensure it is executed on the
                // service thread only
            
                // Note: below is a double-wrap of the PersistentStore which assumes all other
                //       layers have failure continuations that throw back to the outer most
                //       layer allowing it to process the exception on the service thread
            
                return new com.tangosol.persistence.SafePersistenceWrappers.SafePersistentStore(getBackupManager().open(sGUID, storeFrom),
                        getActiveFailureHandler());
                }
            catch (PersistenceException e)
                {
                if (e.getPersistentStore() != null)
                    {
                    onActivePersistenceFailure(e);
                    }

                // don't fail, partition could have moved out
                }
            
            return NullImplementation.getPersistentStore();
            }
        
        /**
         * Open and return a PersistentStore with the specified GUID name from
        * the active persistence manager.  The returned store is "failure-safe'
        * and any persistence failure (synchronous or asynchronous) will be
        * handled by the active failure handler.
        * 
        * This method is called on the service thread only.
         */
        public com.oracle.coherence.persistence.PersistentStore openEventsStore(String sGUID, String sGUIDFrom)
            {
            // import com.oracle.coherence.persistence.PersistenceException;
            // import com.oracle.coherence.persistence.PersistenceManager;
            // import com.oracle.coherence.persistence.PersistentStore;
            // import com.tangosol.persistence.SafePersistenceWrappers$SafePersistentStore as com.tangosol.persistence.SafePersistenceWrappers.SafePersistentStore;
            // import com.tangosol.util.NullImplementation;
            
            if (isPersistEvents())
                {
                try
                    {
                    // the active failure handler will ensure it is executed on the
                    // service thread only
            
                    // Note: below is a double-wrap of the PersistentStore which assumes all other
                    //       layers have failure continuations that throw back to the outer most
                    //       layer allowing it to process the exception on the service thread
            
            
                    PersistenceManager mgrEvents = getEventsManager();
                    PersistentStore    storeFrom = null;
            
                    if (sGUIDFrom != null)
                        {
                        // _assert(isRecovering())
            
                        if (!mgrEvents.contains(sGUIDFrom))
                            {
                            return null;
                            }
            
                        storeFrom = openStoreForRead(mgrEvents, sGUIDFrom, /*fOpen*/ false);
                        }
            
                    return new com.tangosol.persistence.SafePersistenceWrappers.SafePersistentStore(getEventsManager().open(sGUID, storeFrom),
                            getActiveFailureHandler());
                    }
                catch (PersistenceException e)
                    {
                    // don't fail / re-throw
                    //onActivePersistenceFailure(e);
                    }
                }
            
            return null;
            }
        
        public com.oracle.coherence.persistence.PersistenceManager openSnapshot(String sSnapshot)
            {
            // import com.oracle.coherence.persistence.PersistenceException;
            // import com.oracle.coherence.persistence.PersistenceManager;
            
            PersistenceManager mgr = null;
            try
                {
                mgr = getPersistenceEnvironment().openSnapshot(sSnapshot);
                }
            catch (PersistenceException e)
                {
                _trace("Failed to recover from snapshot \"" + sSnapshot + "\": " + getStackTrace(e), 2);
                }
            
            return mgr;
            }

        /**
         * Open a persistent store for reading. An empty directory indicates that
         * no resources have been allocated yet, in which case an "unopened"
         * store is returned.
         * An unopened store corresponds to an empty partition.
         *
         * @param mgr    the persistence manager to use to open the store
         * @param sGUID  the store GUID
         *
         * @return the opened store
         */
        public com.oracle.coherence.persistence.PersistentStore openStoreForRead(com.oracle.coherence.persistence.PersistenceManager mgr, String sGUID)
            {
            // import com.oracle.coherence.persistence.ConcurrentAccessException;
            // import com.oracle.coherence.persistence.FatalAccessException;
            // import com.oracle.coherence.persistence.PersistentStore;
            // import com.tangosol.persistence.CachePersistenceHelper as com.tangosol.persistence.CachePersistenceHelper;

            // _assert(isRecovering());

            PartitionedService service = (PartitionedService) get_Module();

            if (mgr.isEmpty(sGUID))
                {
                return mgr.createStore(sGUID);
                }

            for (int cRetry = 0; true; cRetry++)
                {
                try
                    {
                    PersistentStore store = mgr.open(sGUID, /*storeFrom*/ null);

                    com.tangosol.persistence.CachePersistenceHelper.validate(store, service);

                    return store;
                    }
                catch (ConcurrentAccessException e)
                    {
                    if (cRetry > 100)
                        {
                        throw new FatalAccessException(e);
                        }
                    service.sleep(10L);
                    }
                }
            }


        /**
         * Open a persistent store for reading.
         *
         * @param mgr    the persistence manager to use to open the store
         * @param sGUID  the store GUID
         * @param fOpen  whether the store is to be actually opened or just
         *               created (e.g.: for snapshot processing)
         *
         * @return the opened store
         */
        public com.oracle.coherence.persistence.PersistentStore openStoreForRead(com.oracle.coherence.persistence.PersistenceManager mgr, String sGUID, boolean fOpen)
            {
            // import com.oracle.coherence.persistence.ConcurrentAccessException;
            // import com.oracle.coherence.persistence.FatalAccessException;
            // import com.oracle.coherence.persistence.PersistentStore;
            // import com.tangosol.persistence.CachePersistenceHelper as com.tangosol.persistence.CachePersistenceHelper;
            
            // _assert(isRecovering());
            
            PartitionedService service = (PartitionedService) get_Module();
            
            if (fOpen)
                {
                for (int cRetry = 0; true; cRetry++)
                    {
                    try
                        {
                        PersistentStore store = mgr.open(sGUID, /*storeFrom*/ null);
            
                        com.tangosol.persistence.CachePersistenceHelper.validate(store, service);
            
                        return store;
                        }
                    catch (ConcurrentAccessException e)
                        {
                        if (cRetry > 100) 
                            {
                            throw new FatalAccessException(e);
                            }
                        service.sleep(10L);
                        }
                    }
                }
            
            return mgr.createStore(sGUID);
            }
        
        /**
         * Record the latency statistics for persistence operations.  This may
        * be called from many threads and as it is a stat and approximate, we
        * don't care too much if we lose a few stats due to concurrency.
         */
        public void recordLatencyStats(long cMillis)
            {
            // Record the latency statistics for persistence operations.  This may be called
            // from many threads and as it is a stat and approximate, we don't care too much
            // if we lose a few stats due to concurrency
            
            // We also call this method with a latency of 0 when there is no latency, to ensure
            // that the count is updated
            
            setStatsLatencyTotal(getStatsLatencyTotal() + cMillis);
            setStatsLatencyCount(getStatsLatencyCount() + 1);
            
            // update the max latency if required
            if (cMillis > getStatsLatencyMax())
                {
                setStatsLatencyMax(cMillis);
                }
            }
        
        /**
         * Release all resources associated with this PersistenceControl.
         */
        public void release()
            {
            // import com.oracle.coherence.persistence.PersistenceManager;
            // import com.tangosol.net.management.Registry;
            
            PartitionedService.PersistenceControl.SnapshotController ctrlSnapshot = getSnapshotController();
            if (ctrlSnapshot != null)
                {
                ctrlSnapshot.release();
            
                setSnapshotController(null);
                }
            
            // release the active manager, if necessary
            PersistenceManager mgr = getActiveManager();
            if (mgr != null)
                {
                mgr.release();
                }
            }
        
        /**
         * Remove a persistent snapshot according to the specified
        * SnapshotRequest.
        * 
        * @param msgRequest    the SnapshotRequest
         */
        public void removeSnapshot(PartitionedService.SnapshotRequest msgRequest)
            {
            // import com.oracle.coherence.persistence.PersistenceException;
            
            PartitionedService   service     = (PartitionedService) get_Module();
            PartitionedService.Response msgResponse = (PartitionedService.Response) service.instantiateMessage("Response");
            
            msgResponse.respondTo(msgRequest);
            msgResponse.setResult(PartitionedService.Response.RESULT_SUCCESS);
            
            if (!isValid())
                {
                _trace("Service is not configured for persistent snapshot removal.", 2);
                msgResponse.setResult(PartitionedService.Response.RESULT_FAILURE);
                service.send(msgResponse);
                return;
                }
            
            String sSnapshot = msgRequest.getSnapshotName();
            try
                {
                if (!getPersistenceEnvironment().removeSnapshot(sSnapshot))
                    {
                    // ignore the snapshot not being removed as its likley the first
                    // member on the same machine that executes this will remove the
                    // directories first. A warning message is logged in
                    // AbstractPersistenceEnvironment.removeSnapshotInternal and other
                    // members will silently succeed.
                    // Any "real" persistence related exception will be raised
                    // as a PersistenceException and caught below.
                    }
                }
            catch (PersistenceException e)
                {
                _trace("Failed to remove persistent snapshot \"" + sSnapshot + "\" : " +
                       getStackTrace(e), 2);
                msgResponse.setResult(PartitionedService.Response.RESULT_FAILURE);
                }
            
            service.send(msgResponse);
            }
        
        /**
         * Reset any persistence related stats.
         */
        public void resetStats()
            {
            setStatsLatencyMax(0L);
            setStatsLatencyCount(0L);
            setStatsLatencyTotal(0L);
            }
        
        /**
         * Retrieve a persistent snapshot according to the specified
        * SnapshotArchiveRequest.
        * This method is called on the service thread only.
        * 
        * @param msgRequest    the SnapshotRequest
         */
        public void retrieveSnapshot(PartitionedService.SnapshotArchiveRequest msgRequest)
            {
            }
        
        // Accessor for the property "ActiveFailureHandler"
        /**
         * Setter for property ActiveFailureHandler.<p>
        * The Exception continuation for handling critical failures of the
        * active persistence.
         */
        protected void setActiveFailureHandler(com.oracle.coherence.common.base.Continuation cont)
            {
            __m_ActiveFailureHandler = cont;
            }
        
        // Accessor for the property "ActiveFailureMode"
        /**
         * Setter for property ActiveFailureMode.<p>
        * The failure mode (one of the PersistenceDependencies.FAILURE_*
        * constants) determining how failures of the active persistence
        * operations should be handled.
         */
        public void setActiveFailureMode(int nMode)
            {
            __m_ActiveFailureMode = nMode;
            }
        
        // Accessor for the property "ActiveManager"
        /**
         * Setter for property ActiveManager.<p>
        * The active PersistenceManager, or null if the service is not
        * configured for active persistence.
         */
        protected void setActiveManager(com.oracle.coherence.persistence.PersistenceManager mgr)
            {
            __m_ActiveManager = mgr;
            }
        
        // Accessor for the property "ActiveRecoveryRequests"
        /**
         * Setter for property ActiveRecoveryRequests.<p>
        * A counter for the number of PartitionRecoverRequests that have been
        * sent. 
         */
        protected void setActiveRecoveryRequests(java.util.concurrent.atomic.AtomicInteger atomicRecoverRequests)
            {
            __m_ActiveRecoveryRequests = atomicRecoverRequests;
            }
        
        // Accessor for the property "Async"
        /**
         * Setter for property Async.<p>
        * Specifies whether persistence should be written async.
         */
        public void setAsync(boolean fAsync)
            {
            __m_Async = fAsync;
            }
        
        // Accessor for the property "BackupManager"
        /**
         * Setter for property BackupManager.<p>
        * The backup PersistenceManager, or null if the service is not
        * configured for active persistence.
         */
        public void setBackupManager(com.oracle.coherence.persistence.PersistenceManager managerBackup)
            {
            __m_BackupManager = managerBackup;
            }
        
        // Accessor for the property "Disabled"
        /**
         * Setter for property Disabled.<p>
        * True iff the active persistence has been configured but is disabled
        * due to a persistence failure.
        * 
        * @volatile
         */
        protected void setDisabled(boolean fDisabled)
            {
            __m_Disabled = fDisabled;
            }
        
        // Accessor for the property "EventsManager"
        /**
         * Setter for property EventsManager.<p>
        * The active PersistenceManager, or null if the service is not
        * configured for active persistence.
         */
        protected void setEventsManager(com.oracle.coherence.persistence.PersistenceManager mgr)
            {
            __m_EventsManager = mgr;
            }
        
        // Accessor for the property "ForceRecovery"
        /**
         * Setter for property ForceRecovery.<p>
        * Indicates thet the active persistence recovery should be forced
        * despite the quorum's decision.
         */
        public void setForceRecovery(boolean fRecovery)
            {
            __m_ForceRecovery = fRecovery;
            }
        
        // Accessor for the property "PartitionVersionExclusionList"
        /**
         * Setter for property PartitionVersionExclusionList.<p>
        * Contains partition versions that failed to be recovered.
         */
        protected void setPartitionVersionExclusionList(com.tangosol.net.internal.PartitionVersionExclusionList storage)
            {
            __m_PartitionVersionExclusionList = storage;
            }
        
        // Accessor for the property "PersistenceEnvironment"
        /**
         * Setter for property PersistenceEnvironment.<p>
        * The PersistenceEnvironment.
         */
        public void setPersistenceEnvironment(com.oracle.coherence.persistence.PersistenceEnvironment env)
            {
            _assert(getPersistenceEnvironment() == null, "Environment is not resettable");
            
            __m_PersistenceEnvironment = (env);
            }
        
        // Accessor for the property "QuorumRaw"
        /**
         * Setter for property QuorumRaw.<p>
        * The "last well known" quorum as it was last written to the "META"
        * extent by the global partition owner.
        * 
        * @volatile
         */
        public void setQuorumRaw(com.tangosol.util.Binary binRaw)
            {
            __m_QuorumRaw = binRaw;
            }
        
        // Accessor for the property "ResumeOnFailover"
        /**
         * Setter for property ResumeOnFailover.<p>
        * Flag that indicates whether this service should be automatically
        * resumed upon failover.
         */
        protected void setResumeOnFailover(boolean fFailover)
            {
            __m_ResumeOnFailover = fFailover;
            }
        
        // Accessor for the property "SnapshotArchiver"
        /**
         * Setter for property SnapshotArchiver.<p>
        * The SnapshotArchiver to be used to archive snapshots
         */
        public void setSnapshotArchiver(com.tangosol.persistence.SnapshotArchiver archiverSnapshot)
            {
            __m_SnapshotArchiver = archiverSnapshot;
            }
        
        // Accessor for the property "SnapshotController"
        /**
         * Setter for property SnapshotController.<p>
        * The SnapshotController, if it exists.
        * 
        * Only used on the ownership senior.
         */
        protected void setSnapshotController(PartitionedService.PersistenceControl.SnapshotController controller)
            {
            __m_SnapshotController = controller;
            }
        
        // Accessor for the property "StatsLatencyCount"
        /**
         * Setter for property StatsLatencyCount.<p>
        * The Count of persistence operations for this service.
         */
        protected void setStatsLatencyCount(long cStats)
            {
            __m_StatsLatencyCount = cStats;
            }
        
        // Accessor for the property "StatsLatencyMax"
        /**
         * Setter for property StatsLatencyMax.<p>
        * The Max persistence latency in millis for this service.
         */
        protected void setStatsLatencyMax(long cMillisMax)
            {
            __m_StatsLatencyMax = cMillisMax;
            }
        
        // Accessor for the property "StatsLatencyTotal"
        /**
         * Setter for property StatsLatencyTotal.<p>
        * The Total persistence latency in millis for this service.
         */
        protected void setStatsLatencyTotal(long cMillisTotal)
            {
            __m_StatsLatencyTotal = cMillisTotal;
            }

        // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService$PersistenceControl$SnapshotBuilder
        
        /**
         * SnapshotBuilder encapsulates the state associated with a request to
         * build a persistent snapshot (which may be carried out
         * asynchronously).
         */
        @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
        public static class SnapshotBuilder
                extends    com.tangosol.coherence.Component
                implements com.oracle.coherence.common.base.Continuation,
                           com.tangosol.net.PriorityTask,
                           Runnable
            {
            // ---- Fields declarations ----
            
            /**
             * Property Manager
             *
             * The PersistenceManager to use for creating snapshots.
             */
            private com.oracle.coherence.persistence.PersistenceManager __m_Manager;
            
            /**
             * Property Partition
             *
             * The partition to be processed (snapshot) be the dedicated
             * snapshot thread. Two special values for this property exist; -1
             * can be inferred as uninitialized and MIN_VALUE suggests
             * snapshotting is complete.
             */
            private int __m_Partition;
            
            /**
             * Property PartitionLocked
             *
             * True iff the current partition was locked prior to
             * asynchronously copying the persistent store.
             * 
             * Note: this transient property is both written and read from the
             * service thread only. 
             */
            private boolean __m_PartitionLocked;
            
            /**
             * Property Partitions
             *
             * A PartitionSet of all partitions that should be snapshot.
             * 
             * Note: this PartitionSet is only modified upon completion of the
             * SnapshotBuilder; see onSnapshotCompleted.
             */
            private com.tangosol.net.partition.PartitionSet __m_Partitions;
            
            /**
             * Property RejectedPartitions
             *
             * A set of partitions that failed.
             * 
             * @volatile
             */
            private volatile com.tangosol.net.partition.PartitionSet __m_RejectedPartitions;
            
            /**
             * Property Response
             *
             * The response to the SnapshotRequest associated with this
             * SnapshotBuilder.
             */
            private PartitionedService.Response __m_Response;
            
            // Default constructor
            public SnapshotBuilder()
                {
                this(null, null, true);
                }
            
            // Initializing constructor
            public SnapshotBuilder(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                {
                super(sName, compParent, false);
                
                if (fInit)
                    {
                    __init();
                    }
                }
            
            // Main initializer
            public void __init()
                {
                // private initialization
                __initPrivate();
                
                // state initialization: public and protected properties
                try
                    {
                    setPartition(-1);
                    }
                catch (java.lang.Exception e)
                    {
                    // re-throw as a runtime exception
                    throw new com.tangosol.util.WrapperException(e);
                    }
                
                // signal the end of the initialization
                set_Constructed(true);
                }
            
            // Private initializer
            protected void __initPrivate()
                {
                
                super.__initPrivate();
                }
            
            //++ getter for static property _Instance
            /**
             * Getter for property _Instance.<p>
            * Auto generated
             */
            public static com.tangosol.coherence.Component get_Instance()
                {
                return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.PersistenceControl.SnapshotBuilder();
                }
            
            //++ getter for static property _CLASS
            /**
             * Getter for property _CLASS.<p>
            * Property with auto-generated accessor that returns the Class
            * object for a given component.
             */
            public static Class get_CLASS()
                {
                Class clz;
                try
                    {
                    clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/PartitionedService$PersistenceControl$SnapshotBuilder".replace('/', '.'));
                    }
                catch (ClassNotFoundException e)
                    {
                    throw new NoClassDefFoundError(e.getMessage());
                    }
                return clz;
                }
            
            //++ getter for autogen property _Module
            /**
             * This is an auto-generated method that returns the global [design
            * time] parent component.
            * 
            * Note: the class generator will ignore any custom implementation
            * for this behavior.
             */
            private com.tangosol.coherence.Component get_Module()
                {
                return this.get_Parent().get_Parent();
                }
            
            /**
             * Proceed with building the snapshot of the next partition.
            * 
            * Note: the next partition to snapshot is passed on the stack and
            * accepted as an argument to this method. the next partition is
            * incremented during #proceed
            * 
            * This method is called on the service thread only.
             */
            public void build(int iPart)
                {
                PartitionedService   service    = getService();
                boolean   fSuspended = service.isSuspendedFully();
                boolean   fLocked    = false;
                
                // acquire a lock for the next partition
                while ((iPart = getPartitions().next(iPart)) >= 0)
                    {
                    if (fSuspended || (fLocked = lock(iPart)))
                        {
                        break;
                        }
                    if (!fSuspended) // process failure to lock
                        {
                        onPartitionFailed(iPart, null);
                        }
                    iPart++;
                    }
                
                if (iPart == -1) // completed all partitions
                    {
                    // Note: this will notify the worker thread to exit
                    setPartition(Integer.MIN_VALUE);
                
                    onSnapshotCompleted();
                    return;
                    }
                
                _assert(fSuspended || fLocked);
                
                // recall whether the partition was locked; see proceed()
                setPartitionLocked(fLocked);
                
                boolean fStart = getPartition() == -1;
                
                setPartition(iPart);
                
                if (fStart)
                    {
                    service.getDaemonPool().add(this);
                    }
                }
            
            /**
             * Return a GUID for the provided partition.
             */
            protected String buildGUID(int iPart)
                {
                // import Component.Net.Member;
                // import com.tangosol.persistence.GUIDHelper;
                
                PartitionedService service    = getService();
                Member  memberThis = service.getThisMember();
                
                return GUIDHelper.generateGUID(iPart,
                         service.getOwnershipVersion(iPart),
                         service.getServiceMemberSet().getServiceJoinTime(memberThis.getId()),
                         memberThis);
                }
            
            // From interface: com.tangosol.net.PriorityTask
            public long getExecutionTimeoutMillis()
                {
                return 0L;
                }
            
            // Accessor for the property "Manager"
            /**
             * Getter for property Manager.<p>
            * The PersistenceManager to use for creating snapshots.
             */
            public com.oracle.coherence.persistence.PersistenceManager getManager()
                {
                return __m_Manager;
                }
            
            // Accessor for the property "Partition"
            /**
             * Getter for property Partition.<p>
            * The partition to be processed (snapshot) be the dedicated
            * snapshot thread. Two special values for this property exist; -1
            * can be inferred as uninitialized and MIN_VALUE suggests
            * snapshotting is complete.
             */
            public int getPartition()
                {
                return __m_Partition;
                }
            
            // Accessor for the property "Partitions"
            /**
             * Getter for property Partitions.<p>
            * A PartitionSet of all partitions that should be snapshot.
            * 
            * Note: this PartitionSet is only modified upon completion of the
            * SnapshotBuilder; see onSnapshotCompleted.
             */
            public com.tangosol.net.partition.PartitionSet getPartitions()
                {
                return __m_Partitions;
                }
            
            // Accessor for the property "RejectedPartitions"
            /**
             * Getter for property RejectedPartitions.<p>
            * A set of partitions that failed.
            * 
            * @volatile
             */
            public com.tangosol.net.partition.PartitionSet getRejectedPartitions()
                {
                return __m_RejectedPartitions;
                }
            
            // From interface: com.tangosol.net.PriorityTask
            public long getRequestTimeoutMillis()
                {
                return 0L;
                }
            
            // Accessor for the property "Response"
            /**
             * Getter for property Response.<p>
            * The response to the SnapshotRequest associated with this
            * SnapshotBuilder.
             */
            public PartitionedService.Response getResponse()
                {
                return __m_Response;
                }
            
            // From interface: com.tangosol.net.PriorityTask
            public int getSchedulingPriority()
                {
                // import com.tangosol.net.PriorityTask;
                
                return PriorityTask.SCHEDULE_IMMEDIATE;
                }
            
            // Accessor for the property "Service"
            /**
             * Getter for property Service.<p>
             */
            protected PartitionedService getService()
                {
                return (PartitionedService) get_Module();
                }
            
            // Accessor for the property "PartitionLocked"
            /**
             * Getter for property PartitionLocked.<p>
            * True iff the current partition was locked prior to asynchronously
            * copying the persistent store.
            * 
            * Note: this transient property is both written and read from the
            * service thread only. 
             */
            protected boolean isPartitionLocked()
                {
                return __m_PartitionLocked;
                }
            
            /**
             * Attempt to lock the provided partition.
             */
            protected boolean lock(int iPart)
                {
                // import com.oracle.coherence.common.base.Blocking;
                // import java.util.concurrent.atomic.AtomicInteger;
                
                PartitionedService           service  = getService();
                PartitionedService.PartitionControl ctrlPart = service.getPartitionControl(iPart);
                long              cMillis  = service.getDistributionContendMillis();
                boolean           fLocked  = ctrlPart != null && // a once owned partition may no longer be owned
                                             ctrlPart.lock(cMillis, PartitionedService.PartitionControl.LOCK_PERSISTENCE);
                
                AtomicInteger atomicTasks = ctrlPart.getPersistenceTasks();
                if (fLocked && atomicTasks.get() > 0)
                    {
                    try
                        {
                        synchronized (atomicTasks)
                            {
                            Blocking.wait(atomicTasks, cMillis);
                            }
                        }
                    catch (InterruptedException e)
                        {
                        }
                
                    if (atomicTasks.get() > 0)
                        {
                        ctrlPart.unlock();
                        fLocked = false;
                        }
                    }
                
                return fLocked;
                }
            
            /**
             * Called when creating a snapshot of the given partition failed.
             */
            public void onPartitionFailed(int iPart, Throwable tFailure)
                {
                // import com.tangosol.net.partition.PartitionSet;
                // import com.tangosol.util.Base;
                
                PartitionedService.Response    msgResponse   = getResponse();
                PartitionSet partsRejected = (PartitionSet) getRejectedPartitions();
                
                if (partsRejected == null)
                    {
                    msgResponse.setResult(PartitionedService.Response.RESULT_FAILURE);
                    partsRejected = getService().instantiatePartitionSet(/*fFill*/ false);
                    }
                
                String sMsg = "Failed to create snapshot of partition";
                if (iPart != -1)
                    {
                    partsRejected.add(iPart);
                    sMsg += " " + iPart;
                
                    // force a volatile write as the PartitionSet is modified on
                    // worker threads and read on the service thread
                    setRejectedPartitions(partsRejected);
                    }
                // else - should not be possible
                
                if (tFailure == null)
                    {
                    _trace(sMsg + " due to a failure to lock", 6);
                    }
                else
                    {
                    _trace(sMsg + " due to: " + tFailure + '\n' + Base.getStackTrace(tFailure), 2);
                    }
                }
            
            /**
             * Called when creating a snapshot of the given partitions failed.
             */
            protected void onPartitionsFailed(com.tangosol.net.partition.PartitionSet partsFailed, Throwable tFailure)
                {
                // import com.tangosol.net.partition.PartitionSet;
                // import com.tangosol.util.Base;
                
                if (partsFailed.isEmpty())
                    {
                    return;
                    }
                
                PartitionedService.Response    msgResponse   = getResponse();
                PartitionSet partsRejected = (PartitionSet) getRejectedPartitions();
                
                if (partsRejected == null)
                    {
                    msgResponse.setResult(PartitionedService.Response.RESULT_FAILURE);
                    partsRejected = getService().instantiatePartitionSet(/*fFill*/ false);
                    }
                
                partsRejected.add(partsFailed);
                
                String sMsg = "Failed to create snapshot of partitions " + partsFailed +
                    " due to: " + tFailure + '\n' + Base.getStackTrace(tFailure);
                
                // force a volatile write as the PartitionSet is modified on
                // worker threads and read on the service thread
                setRejectedPartitions(partsRejected);
                
                _trace(sMsg, 2);
                }
            
            /**
             * Called when the snapshots of the requested partitions have
            * completed.
             */
            protected void onSnapshotCompleted()
                {
                // import com.tangosol.net.partition.PartitionSet;
                
                PartitionedService.Response    msgResponse    = getResponse();
                PartitionSet partsCompleted = getPartitions();
                PartitionSet partsRejected  = getRejectedPartitions();
                
                if (partsRejected != null)
                    {
                    partsCompleted.remove(partsRejected);
                    }
                
                msgResponse.setValue(partsCompleted);
                
                getManager().release();
                
                getService().send(msgResponse);
                }
            
            // From interface: com.oracle.coherence.common.base.Continuation
            /**
             * This method is called on the service thread only.
             */
            public void proceed(Object o)
                {
                // import com.tangosol.net.partition.PartitionSet;
                
                Throwable t     = null;
                int       iPart;
                
                if (o instanceof Integer)
                    {
                    iPart = ((Integer) o).intValue();
                    }
                else // o instanceof Throwable
                    {
                    t     = (Throwable) o;
                    iPart = getPartition();
                    }
                
                if (isPartitionLocked()) // see build
                    {
                    getService().getPartitionControl(iPart).unlock();
                    }
                
                if (t == null)
                    {
                    // increment the next partition to snapshot
                    build(iPart + 1);
                    }
                else
                    {
                    PartitionSet parts       = getPartitions();
                    PartitionSet partsFailed = getService().instantiatePartitionSet(/*fFill*/ false);
                    for (; iPart >= 0; iPart = parts.next(iPart + 1))
                        {
                        partsFailed.add(iPart);
                        }
                
                    onPartitionsFailed(partsFailed, t);
                    }
                }
            
            /**
             * Remove the caches that are not intented to be snapshotted from
            * the copied store.
             */
            public void removeTransientCaches(com.oracle.coherence.persistence.PersistentStore store)
                {
                }
            
            // From interface: java.lang.Runnable
            public void run()
                {
                // import com.oracle.coherence.common.base.Blocking;
                
                int iPartPrev = -1;
                int iPart;
                
                while (true)
                    {
                    synchronized (this)
                        {
                        while ((iPart = getPartition()) < 0 || iPartPrev == iPart)
                            {
                            if (iPart == Integer.MIN_VALUE)
                                {
                                return;
                                }
                            try
                                {
                                Blocking.wait(this, 1000L);
                                }
                            catch (InterruptedException e)
                                {
                                // leave the thread as uninterrupted informing the service
                                // thread of the failure
                                getService().getContinuations().thenOnServiceThread(this).proceed(e);
                                }
                            }
                        }
                
                    // snapshot the partition
                    snapshotStore(iPart);
                    iPartPrev = iPart;
                    }
                }
            
            // From interface: com.tangosol.net.PriorityTask
            public void runCanceled(boolean fAbandoned)
                {
                }
            
            // Accessor for the property "Manager"
            /**
             * Setter for property Manager.<p>
            * The PersistenceManager to use for creating snapshots.
             */
            public void setManager(com.oracle.coherence.persistence.PersistenceManager manager)
                {
                if (getManager() != null)
                    {
                    throw new IllegalStateException("The PersistenceManager cannot be reset.");
                    }
                
                __m_Manager = (manager);
                }
            
            // Accessor for the property "Partition"
            /**
             * Setter for property Partition.<p>
            * The partition to be processed (snapshot) be the dedicated
            * snapshot thread. Two special values for this property exist; -1
            * can be inferred as uninitialized and MIN_VALUE suggests
            * snapshotting is complete.
             */
            public synchronized void setPartition(int nPartition)
                {
                __m_Partition = (nPartition);
                
                notify();
                }
            
            // Accessor for the property "PartitionLocked"
            /**
             * Setter for property PartitionLocked.<p>
            * True iff the current partition was locked prior to asynchronously
            * copying the persistent store.
            * 
            * Note: this transient property is both written and read from the
            * service thread only. 
             */
            protected void setPartitionLocked(boolean fLocked)
                {
                __m_PartitionLocked = fLocked;
                }
            
            // Accessor for the property "Partitions"
            /**
             * Setter for property Partitions.<p>
            * A PartitionSet of all partitions that should be snapshot.
            * 
            * Note: this PartitionSet is only modified upon completion of the
            * SnapshotBuilder; see onSnapshotCompleted.
             */
            public void setPartitions(com.tangosol.net.partition.PartitionSet setPartitions)
                {
                __m_Partitions = setPartitions;
                }
            
            // Accessor for the property "RejectedPartitions"
            /**
             * Setter for property RejectedPartitions.<p>
            * A set of partitions that failed.
            * 
            * @volatile
             */
            public void setRejectedPartitions(com.tangosol.net.partition.PartitionSet setPartitions)
                {
                __m_RejectedPartitions = setPartitions;
                }
            
            // Accessor for the property "Response"
            /**
             * Setter for property Response.<p>
            * The response to the SnapshotRequest associated with this
            * SnapshotBuilder.
             */
            public void setResponse(PartitionedService.Response response)
                {
                __m_Response = response;
                }
            
            /**
             * Perform the snapshotting of the given partition synchronously on
            * the calling thread.
            * 
            * Control is returned after notifying the service thread of the
            * completion (successful or not) of snapshotting the provided
            * partition.
             */
            protected void snapshotStore(int iPart)
                {
                // import com.oracle.coherence.persistence.PersistenceManager;
                // import com.oracle.coherence.persistence.PersistentStore;
                // import com.tangosol.net.GuardSupport;
                
                PersistenceManager  mgrActive   = ((PartitionedService.PersistenceControl) get_Parent()).getActiveManager();
                PersistenceManager  mgrSnapshot = getManager();
                PersistentStore     store       = null;
                
                Object    oToken   = null;
                PartitionedService   service  = getService();
                Throwable eFailure = null;
                String    sGUID    = null;
                try
                    {
                    GuardSupport.heartbeat();
                
                    if (mgrActive == null)
                        {
                        // we are not actively persisting; generate a complete snapshot by iterating
                        // the $Storage contents and persisting asynchronously (as it could 
                        // take quite awhile and require quite a bit of memory).
                
                        sGUID  = buildGUID(iPart);
                        if (service.hasPersistentData(iPart))
                            {
                            store  = mgrSnapshot.open(sGUID, /*storeFrom*/ null);
                            oToken = store.begin();

                            service.snapshotPartition(iPart, store, oToken);

                            store.commit(oToken);
                            }
                        else
                            {
                            mgrSnapshot.createStore(sGUID);
                            }
                        }
                    else
                        {
                        PersistentStore storeFrom = service.getPartitionControl(iPart).getPersistentStore();
                
                        store = mgrSnapshot.open(sGUID = storeFrom.getId(), storeFrom);
                
                        removeTransientCaches(store);
                        }
                
                    _trace("Created snapshot of partition " + iPart, 3);
                    }
                catch (Throwable t)
                    {
                    eFailure = t;
                    if (store != null)
                        {
                        store.abort(oToken);
                        }
                    onPartitionFailed(iPart, t);
                    }
                finally
                    {
                    // free up resources associated to the PersistentStore
                    if (store != null)
                        {
                        mgrSnapshot.close(sGUID);
                        }
                
                    // continue the snapshot process with the next GUID on the service thread (see #proceed)
                    getService().getContinuations().thenOnServiceThread(this).proceed(Integer.valueOf(iPart));
                    }
                }
            }

        // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService$PersistenceControl$SnapshotController
        
        /**
         * The SnapshotController provides the control of all snapshot-related
         * functionality for the service.  The SnapshotController is only used
         * by the ownership-senior member and serves as the point of
         * coordination for snapshot creation, recovery and archival
         * operations.  The SnapshotController can transition between the
         * following states:
         * 
         * from STATE_IDLE:
         *     to STATE_SNAPSHOT_BUILDING
         *           - when the createSnapshot operation is issued
         *              and while the subsequent $SnapshotRequests
         *              are outstanding
         *     to STATE_RECOVER_ABANDONING
         *           - when the recoverSnapshot operation is issued
         *              and partitions have to be "abandoned"
         *              (intentionally orphaned) by their current
         *              owners prior to recovery.  This state is
         *              maintained until the completion of all
         *              outstanding $PartitionAbandonRequests have
         *              completed
         *     to STATE_RECOVER_RECOVERING
         *           - when the recoverSnapshot operation is issued
         *              and all partitions are already orphaned.  This
         *              state is maintained until the completion of the
         *              ownership protocol
         *     to STATE_SNAPSHOT_REMOVING
         *           - when the removeSnapshot operation is issued
         *              and while the subsequent $SnapshotRequests
         *              are outstanding
         *     to STATE_SNAPSHOT_ARCHIVING
         *           - when the archiveSnapshot operation is issued
         *              and while the subsequent
         *              $SnapshotArchiveRequests are outstanding
         *     to STATE_SNAPSHOT_RETRIEVING
         *           - when the retrieveSnapshot operation is issued
         *              and while the subsequent
         *              $SnapshotArchiveRequests are outstanding
         *     to STATE_ACTIVE_RECOVERY
         *           - when active recovery (after service/ cluster
         *              restart) is in progress
         * 
         * from STATE_SNAPSHOT_BUILDING:
         *     to STATE_IDLE:
         *           - when all outstanding $SnapshotRequests have
         *              completed
         * 
         * from STATE_SNAPSHOT_ARCHIVING:
         *     to STATE_IDLE:
         *          - when all outstanding
         *             $SnapshotArchiveRequests with Archive = true
         *             have been completed
         * 
         * from STATE_SNAPSHOT_RETRIEVING:
         *     to STATE_IDLE:
         *          - when all outstanding
         *             $SnapshotArchiveRequests with Archive = false
         *             have been completed
         * 
         * from STATE_SNAPSHOT_REMOVING
         *     to STATE_IDLE
         *           - when all outstanding remove $SnapshotRequests 
         *              have completed
         * 
         * from STATE_RECOVER_ABANDONING:
         *     to STATE_RECOVER_RECOVERING
         *           - when all $PartitionAbandonRequests have
         *              completed and the recovery has commenced.
         *              This state is maintained until the completion of
         *              the ownership protocol
         * 
         * from STATE_RECOVER_RECOVERING:
         *     to STATE_IDLE
         *           - when the ownership protocol has completed
         * 
         * from  to STATE_ACTIVE_RECOVERY
         *     to STATE_IDLE
         *           - when active recovery is complete
         */
        @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
        public static class SnapshotController
                extends    com.tangosol.coherence.Component
                implements com.tangosol.persistence.PersistenceManagerMBean
            {
            // ---- Fields declarations ----
            
            /**
             * Property ResumeOnCompletion
             *
             * Indicates if the service should be resumed on completion of the
             * snapshot operation. This will be set to true if the service was
             * automatically suspended prior to the operation.
             */
            private boolean __m_ResumeOnCompletion;
            
            /**
             * Property SNAPSHOT_NAMES_EXPIRE
             *
             * The number of millis after the completion of a
             * SnapshotListRequest to retain the cache of SnapshotNames.
             */
            public static final int SNAPSHOT_NAMES_EXPIRE = 5000;
            
            /**
             * Property SnapshotName
             *
             * The name of the snapshot whose creation, recovery or archival is
             * in-progress.
             */
            private String __m_SnapshotName;
            
            /**
             * Property SnapshotNames
             *
             * A cache of snapshot names held for at most SNAPSHOT_NAMES_EXPIRE
             * millis after a SnapshotListRequest.
             */
            private String[] __m_SnapshotNames;
            
            /**
             * Property SnapshotNamesExpire
             *
             * An absolute time when SnapshotNames should no longer be used.
             * 
             * @volatile
             */
            private volatile long __m_SnapshotNamesExpire;
            
            /**
             * Property State
             *
             * The current state of the SnapshotController.  The controller can
             * only perform one logical management operation at a time.
             * 
             * @volatile
             */
            private volatile int __m_State;
            
            /**
             * Property STATE_ACTIVE_RECOVERY
             *
             * State of the controller when the service is in active recovery.
             */
            public static final int STATE_ACTIVE_RECOVERY = 6;
            
            /**
             * Property STATE_IDLE
             *
             * State representing an idle controller (no pending operation).
             */
            public static final int STATE_IDLE = 0;
            
            /**
             * Property STATE_RECOVER_RECOVERING
             *
             * State of the controller when the recovery protocol
             * ($OwnershipRequest) is outstanding.
             */
            public static final int STATE_RECOVER_RECOVERING = 2;
            
            /**
             * Property STATE_SNAPSHOT_ARCHIVING
             *
             * State of the controller when a remove snapshot operation is
             * outstanding ($SnapshotRequest poll is open).
             */
            public static final int STATE_SNAPSHOT_ARCHIVING = 4;
            
            /**
             * Property STATE_SNAPSHOT_BUILDING
             *
             * State of the controller when a create snapshot operation is
             * outstanding ($SnapshotRequest poll is open).
             */
            public static final int STATE_SNAPSHOT_BUILDING = 1;
            
            /**
             * Property STATE_SNAPSHOT_REMOVING
             *
             * State of the controller when a remove snapshot operation is
             * outstanding ($SnapshotRequest poll is open).
             */
            public static final int STATE_SNAPSHOT_REMOVING = 3;
            
            /**
             * Property STATE_SNAPSHOT_RETRIEVING
             *
             * State of the controller when a remove snapshot operation is
             * outstanding ($SnapshotRequest poll is open).
             */
            public static final int STATE_SNAPSHOT_RETRIEVING = 5;
            
            // Default constructor
            public SnapshotController()
                {
                this(null, null, true);
                }
            
            // Initializing constructor
            public SnapshotController(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                {
                super(sName, compParent, false);
                
                if (fInit)
                    {
                    __init();
                    }
                }
            
            // Main initializer
            public void __init()
                {
                // private initialization
                __initPrivate();
                
                
                // signal the end of the initialization
                set_Constructed(true);
                }
            
            // Private initializer
            protected void __initPrivate()
                {
                
                super.__initPrivate();
                }
            
            //++ getter for static property _Instance
            /**
             * Getter for property _Instance.<p>
            * Auto generated
             */
            public static com.tangosol.coherence.Component get_Instance()
                {
                return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.PersistenceControl.SnapshotController();
                }
            
            //++ getter for static property _CLASS
            /**
             * Getter for property _CLASS.<p>
            * Property with auto-generated accessor that returns the Class
            * object for a given component.
             */
            public static Class get_CLASS()
                {
                Class clz;
                try
                    {
                    clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/PartitionedService$PersistenceControl$SnapshotController".replace('/', '.'));
                    }
                catch (ClassNotFoundException e)
                    {
                    throw new NoClassDefFoundError(e.getMessage());
                    }
                return clz;
                }
            
            //++ getter for autogen property _Module
            /**
             * This is an auto-generated method that returns the global [design
            * time] parent component.
            * 
            * Note: the class generator will ignore any custom implementation
            * for this behavior.
             */
            private com.tangosol.coherence.Component get_Module()
                {
                return this.get_Parent().get_Parent();
                }
            
            /**
             * Adds a JMX notification which indicates that a particular
            * persistence related event has occured.
            * 
            * @param sNotificationType  the type of notification to add. See
            * PersistenceManagerMBean.CREATE_* and RECOVER_* statics
            * @param sMessage                the message to add to the
            * notification
            * @param sUserData               any specific user data that
            * provides more information about the message
             */
            protected void addNotification(String sNotificationType, String sMessage, String sUserData)
                {
                // import com.tangosol.net.management.Registry;
                
                Registry registry = getService().getCluster().getManagement();
                if (registry != null)
                    {
                    getService().dispatchNotification(registry.ensureGlobalName(getMBeanName()),
                        sNotificationType, sMessage, sUserData);
                    }
                }
            
            // From interface: com.tangosol.persistence.PersistenceManagerMBean
            /**
             * Initiates a request to all storage-enabled members instructing
            * them
            * to archive a snapshot with the given name.
            * 
            * @param sSnapshot    the name of the snapshot to be archived
             */
            public synchronized void archiveSnapshot(String sSnapshot)
                {
                // import java.util.Iterator;
                // import java.util.Map;
                // import com.tangosol.net.Member;
                // import com.tangosol.net.management.MBeanHelper;
                // import com.tangosol.persistence.GUIDHelper;
                // import com.tangosol.persistence.PersistenceManagerMBean;
                // import Component.Net.MemberSet;
                // import Component.Net.MemberSet.ActualMemberSet;
                
                MBeanHelper.checkReadOnly("archiveSnapshot");
                
                ensureArchiveReady();
                
                // validate the snapshot we are archiving
                if (!hasSnapshot(sSnapshot))
                    {
                    throw new IllegalArgumentException("A snapshot named \"" + sSnapshot + "\" does not exist");
                    }
                
                if(hasArchivedSnapshot(sSnapshot))
                    {
                    throw new IllegalArgumentException("The archived snapshot \"" + sSnapshot + "\" already exists");
                    }
                
                // get the list of stores that each member sees
                Map     mapStores = getSnapshotStores(sSnapshot);
                PartitionedService service   = getService(); 
                
                // allocate the stores evenly across all members; Map<Integer, PersistentStoreInfo[]>
                mapStores = GUIDHelper.assignStores(GUIDHelper.getMapGuids(mapStores), service.getPartitionCount());
                
                // update the attributes
                setSnapshotName(sSnapshot);
                
                // build a set of members that are aware of the snapshot rather than sending to
                // all memebrs by default. this will cater for the case when a new machine has
                // been added and it's members do not yet have any local snapshot parts - COH-13264
                
                MemberSet setMembers = new ActualMemberSet();
                for (Iterator iter = service.getOwnershipMemberSet().iterator(); iter.hasNext() ;)
                    {
                    Member   member   = (Member) iter.next();
                    Object[] aoStores = (Object[]) mapStores.get(Integer.valueOf(member.getId()));
                    
                    // only add to the member set if the member responded that it
                    // could see at least one store from the snapshot
                    if (aoStores != null && aoStores.length > 0)
                        {
                        setMembers.add(member);
                        }
                    }
                
                // send a request for each storage member who is aware of the snapshot
                // with the stores Map to archive
                PartitionedService.SnapshotArchiveRequest msgArchiveRequest = (PartitionedService.SnapshotArchiveRequest)
                    service.instantiateMessage("SnapshotArchiveRequest");
                
                msgArchiveRequest.setSnapshotName(sSnapshot);
                msgArchiveRequest.setToMemberSet(setMembers);
                msgArchiveRequest.setArchive(true);
                msgArchiveRequest.setStores(mapStores);
                service.send(msgArchiveRequest);   
                
                setState(STATE_SNAPSHOT_ARCHIVING);
                
                // generate notification
                addNotification(PersistenceManagerMBean.ARCHIVE_SNAPSHOT_BEGIN, getOperationStatus(), "");
                }
            
            /**
             * If ResumeOnCompletion is true then resume the service as it was
            * previously
            * automatically suspended.
             */
            protected void checkResume()
                {
                // import com.tangosol.persistence.CachePersistenceHelper as com.tangosol.persistence.CachePersistenceHelper;
                
                // if the service was previously suspened then resume the service
                if (isResumeOnCompletion())
                    {
                    PartitionedService service      = getService();
                    String  sServiceName = service.getServiceName();
                
                    _trace("Automatically resuming service " + sServiceName, 3);
                
                    com.tangosol.persistence.CachePersistenceHelper.resumeService(service.getCluster(), sServiceName);
                
                    setResumeOnCompletion(false);
                    }
                }
            
            /**
             * Combine any members that that left during the poll with the set
            * of members that failed
            * during the snapshot operation. setMembersLeft is never null and
            * setMembersFailed 
            * can be null if no members failed.
            * 
            * Note: The passed in setMemberFailed could be modified by this
            * method.
             */
            public com.tangosol.coherence.component.net.MemberSet combineMembersLeft(com.tangosol.coherence.component.net.MemberSet setMembersFailed, com.tangosol.coherence.component.net.MemberSet setMembersLeft)
                {
                if (setMembersFailed == null)
                    {
                    return setMembersLeft;
                    }
                
                // some failures and some members left, so combine them
                if (!setMembersLeft.isEmpty())
                    {
                    setMembersFailed.addAll(setMembersLeft);
                    }
                
                // default is that some members failed and none left
                return setMembersFailed;
                }
            
            // From interface: com.tangosol.persistence.PersistenceManagerMBean
            /**
             * Initiates a request to all storage-enabled members instructing
            * them
            * to create a snapshot with the given name for all the currently
            * owned
            * partitions.
            * 
            * @param sSnapshot    the name of the snapshot to be created
             */
            public synchronized void createSnapshot(String sSnapshot)
                {
                // import Component.Net.MemberSet;
                // import com.tangosol.persistence.PersistenceManagerMBean;
                // import com.tangosol.net.management.MBeanHelper;
                
                MBeanHelper.checkReadOnly("createSnapshot");
                
                ensureReady(false);
                
                if (hasSnapshot(sSnapshot))
                    {
                    throw new IllegalArgumentException("A snapshot named \"" + sSnapshot + "\" already exists");
                    }
                
                PartitionedService   service      = getService();
                MemberSet setOwners    = service.getOwnershipMemberSet();
                boolean   fPartitioned = service.isVersionCompatible(setOwners, 12, 2, 1, 2, 0) &&
                                         !service.isSuspendedFully();
                
                if (!fPartitioned)
                    {
                    // ensure the service is suspended
                    ensureSuspended();
                    }
                
                // transition and hold snapshot state
                setSnapshotName(sSnapshot);
                setState(STATE_SNAPSHOT_BUILDING);
                
                // send the snapshot request
                PartitionedService.SnapshotRequest msgRequest = (PartitionedService.SnapshotRequest) 
                    service.instantiateMessage("SnapshotRequest");
                
                msgRequest.setSnapshotName(sSnapshot);
                msgRequest.setToMemberSet(setOwners);
                msgRequest.setCreate(true);
                
                if (fPartitioned)
                    {
                    msgRequest.setCompleted(service.instantiatePartitionSet(/*fFill*/ false));
                    msgRequest.setRequestMask(service.instantiatePartitionSet(/*fFill*/ true));
                    }
                
                service.send(msgRequest);
                
                // generate a notification
                addNotification(PersistenceManagerMBean.CREATE_SNAPSHOT_BEGIN, getOperationStatus(), "");
                }
            
            /**
             * Ensure that the service is ready to perform an archive-related
            * operation.  This generally requires that:
            * 1) a Snapshot archiver exists for this service
            * 2) no other snapshot-related operation is outstanding
             */
            protected void ensureArchiveReady()
                {
                ensureReady(/*fSuspend*/ false);
                
                if (getPersistenceControl().getSnapshotArchiver() == null)
                    {
                    throw new IllegalArgumentException("No archiver is defined for this service");
                    }
                }
            
            /**
             * Ensure that the service is ready to perform a snapshot-related
            * operation.  This generally requires that:
            * 1) service is quiesced
            * 2) no other snapshot-related operation is outstanding
            * 
            * @param fSuspend  if true, the service should already be suspended
             */
            protected void ensureReady(boolean fSuspend)
                {
                PartitionedService service = getService();
                
                if (service == null || !service.isRunning())
                    {
                    // there is a small possibility of a race condition on the re-registration of the
                    // responsibility MBean on the responsibility transfer (e.g. this service stopping),
                    // this MBean is not usable unless the service is queisced and there is no notion of
                    // graceul departure in a quiesced service.
                    throw new IllegalStateException("There are no remaining storage-enabled members of the service");
                    }
                
                // snapshot operations must only be coordinated by the ownership senior
                _assert(service.getOwnershipSenior() == service.getThisMember());
                
                if (!getPersistenceControl().isValid())
                    {
                    throw new IllegalStateException("Persistence has not been configured on the ownership senior");
                    }
                
                if (fSuspend)
                    {
                    if (!service.isSuspended())
                        {
                        throw new IllegalStateException("The service must be suspended; " +
                            "see the \"suspendService\" operation on the ClusterMBean");
                        }
                    }
                
                if (!isIdle())
                    {
                    // a request is already pending
                    throw new IllegalStateException("Request is pending: " + getOperationStatus());
                    }
                }
            
            /**
             * If service is not suspended then suspend and set
            * ResumeOnCompletion to be true.
            * If the service is suspended then just set ResumeOnCompletion to
            * false and continue as
            * the suspend service was called prior to this operation.
             */
            protected void ensureSuspended()
                {
                // import Component.Net.Cluster;
                
                PartitionedService service = getService();
                
                if (service.isSuspended())
                    {
                    // already suspended so ensure we do not try to resume when completed
                    setResumeOnCompletion(false);
                    }
                else
                    {
                    // suspend the service and hold state allowing checkResume()
                    // to resume an implicitly suspended service
                    String sServiceName = service.getServiceName();
                
                    _trace("Automatically suspending service " + sServiceName, 3);
                
                    ((Cluster) service.getCluster()).suspendService(sServiceName, /*fResumeOnFailover*/ true);
                
                    setResumeOnCompletion(true);
                    }
                }
            
            // From interface: com.tangosol.persistence.PersistenceManagerMBean
            public void forceRecovery()
                {
                // import com.tangosol.net.management.MBeanHelper;
                
                MBeanHelper.checkReadOnly("forceRecovery");
                
                getPersistenceControl().setForceRecovery(true);
                }
            
            // From interface: com.tangosol.persistence.PersistenceManagerMBean
            /**
             * Return the member id of the service node that is the persistence
            * coordinator.
             */
            public int getCoordinatorId()
                {
                PartitionedService service = getService();
                
                return service == null || !service.isRunning() ? -1 : service.getThisMember().getId();
                }
            
            /**
             * Get the GUID from the list of stores that matches the given
            * partition.
            * 
            * @param nPartition  the partition to look for
            * @param asStores    the list of stores to look in 
             */
            public String getGUIDFromPartition(int nPartition, String[] asStores)
                {
                // import com.tangosol.persistence.GUIDHelper;
                
                for (int i = 0; i < asStores.length ; i++)
                    {
                    if (GUIDHelper.getPartition(asStores[i]) == nPartition)
                        {
                        return asStores[i];
                        }
                    }
                
                return null;
                }
            
            // Accessor for the property "MBeanName"
            /**
             * Getter for property MBeanName.<p>
            * The MBean name of the PersistenceSnapshot bean.
             */
            public String getMBeanName()
                {
                // import com.tangosol.persistence.CachePersistenceHelper;
                
                return CachePersistenceHelper.getMBeanName(getService().getServiceName());
                }
            
            // From interface: com.tangosol.persistence.PersistenceManagerMBean
            // Accessor for the property "OperationStatus"
            /**
             * Returns the  status of the current operation issued by the
            * snapshot manager.
             */
            public String getOperationStatus()
                {
                PartitionedService service = getService();
                
                if (service == null || !service.isRunning())
                    {
                    return "n/a";
                    }
                
                switch (getState())
                    {
                    case STATE_IDLE:
                        return "Idle";
                
                    case STATE_SNAPSHOT_BUILDING:
                        return "Building snapshot \"" + getSnapshotName() + '"';
                
                    case STATE_RECOVER_RECOVERING:
                        return "Recovering snapshot \"" + getSnapshotName() + '"';
                
                    case STATE_SNAPSHOT_REMOVING:
                        return "Removing snapshot \"" + getSnapshotName() + '"';
                
                    case STATE_SNAPSHOT_ARCHIVING:
                        return "Archiving snapshot \"" + getSnapshotName() + '"';
                
                    case STATE_SNAPSHOT_RETRIEVING:
                        return "Retrieving archived snapshot \"" + getSnapshotName() + '"';
                
                    case STATE_ACTIVE_RECOVERY:
                        return "Active recovery in progress";
                        
                    default:
                        throw new IllegalStateException("Invalid state: " + getState());
                    }
                }
            
            // Accessor for the property "PersistenceControl"
            /**
             * Getter for property PersistenceControl.<p>
             */
            protected PartitionedService.PersistenceControl getPersistenceControl()
                {
                return (PartitionedService.PersistenceControl) get_Parent();
                }
            
            // Accessor for the property "Service"
            /**
             * Getter for property Service.<p>
             */
            protected PartitionedService getService()
                {
                return (PartitionedService) get_Module();
                }
            
            // Accessor for the property "SnapshotName"
            /**
             * Getter for property SnapshotName.<p>
            * The name of the snapshot whose creation, recovery or archival is
            * in-progress.
             */
            public String getSnapshotName()
                {
                return __m_SnapshotName;
                }
            
            // Accessor for the property "SnapshotNames"
            /**
             * Getter for property SnapshotNames.<p>
            * A cache of snapshot names held for at most SNAPSHOT_NAMES_EXPIRE
            * millis after a SnapshotListRequest.
             */
            protected String[] getSnapshotNames()
                {
                return __m_SnapshotNames;
                }
            
            // Accessor for the property "SnapshotNamesExpire"
            /**
             * Getter for property SnapshotNamesExpire.<p>
            * An absolute time when SnapshotNames should no longer be used.
            * 
            * @volatile
             */
            protected long getSnapshotNamesExpire()
                {
                return __m_SnapshotNamesExpire;
                }
            
            // From interface: com.tangosol.persistence.PersistenceManagerMBean
            /**
             * Return a list of snapshots that are available for recovery.
             */
            public String[] getSnapshots()
                {
                // import com.tangosol.util.Base;
                
                PartitionedService service = getService();
                
                if (service == null || !service.isRunning())
                    {
                    return null;
                    }
                
                if (Base.getSafeTimeMillis() < getSnapshotNamesExpire() ||
                    Thread.currentThread() == service.getThread())
                    {
                    // use the cached value if within the allowed staleness or if being asked
                    // on the service thread, as it requires a poll to all storage-enabled members.
                    // This question could only be asked meaningfully on the Management thread
                    // but could be called during serialization of the model for initial
                    // registration - see Registry.registerLocalModel()
                    return getSnapshotNames();
                    }
                // else
                
                PartitionedService.SnapshotListRequest msgRequest = (PartitionedService.SnapshotListRequest)
                        service.instantiateMessage("SnapshotListRequest");
                
                    msgRequest.setToMemberSet(service.getOwnershipMemberSet());
                    msgRequest.setSnapshotName(null);    // this ensures we get list of snapshots
                
                String[] asNames = (String[]) service.poll(msgRequest);
                setSnapshotNames(asNames);
                
                return asNames;
                }
            
            /**
             * Return a Map<Integer, String[]> where the key is the member id
            * and the value is the list of stores that are known by all members
            * 
            * for a given snapshot.
            * 
            * Note: This method should only be used on client threads as it
            * issues poll().
             */
            private java.util.Map getSnapshotStores(String sSnapshot)
                {
                // import java.util.Map;
                
                // get the list of stores that each member sees by issuing a
                // SnapshotListRequest poll with the SnapshotName set
                
                PartitionedService service = getService(); 
                PartitionedService.SnapshotListRequest msgRequest = (PartitionedService.SnapshotListRequest)
                    service.instantiateMessage("SnapshotListRequest");
                
                msgRequest.setToMemberSet(service.getOwnershipMemberSet());
                msgRequest.setSnapshotName(sSnapshot);    // this ensures we get list of stores
                
                // the result is a Map<Integer, String[]> where the key is the member id
                // and the value is the list of stores that are known
                Map mapStores = (Map) service.poll(msgRequest);
                
                if (mapStores == null || mapStores.size() == 0)
                    {
                    throw new IllegalArgumentException("No members returned snapshot store details");
                    }
                
                return mapStores;
                }
            
            // Accessor for the property "State"
            /**
             * Getter for property State.<p>
            * The current state of the SnapshotController.  The controller can
            * only perform one logical management operation at a time.
            * 
            * @volatile
             */
            public int getState()
                {
                return __m_State;
                }
            
            /**
             * Return true if the specified archived snapshot exists.
            * 
            * @param sSnapshot the snapshot to check for 
            * 
            * @return true if the snapshot exists, otherwise false
             */
            protected boolean hasArchivedSnapshot(String sSnapshot)
                {
                String[] asSnapshots = listArchivedSnapshots();
                
                for (int i = 0, c = asSnapshots.length; i < c; i++)
                    {
                    if (sSnapshot.equals(asSnapshots[i]))
                        {
                        return true;
                        }
                    }
                
                return false;
                }
            
            /**
             * Return true if the specified snapshot exists.
            * 
            * @param sSnapshot the snapshot to check for 
            * 
            * @return true if the snapshot exists, otherwise false
             */
            protected boolean hasSnapshot(String sSnapshot)
                {
                String[] asSnapshots = getSnapshots();  // Note: this is a poll()
                for (int i = 0, c = asSnapshots.length; i < c; i++)
                    {
                    if (sSnapshot.equals(asSnapshots[i]))
                        {
                        return true;
                        }
                    }
                
                return false;
                }
            
            // From interface: com.tangosol.persistence.PersistenceManagerMBean
            /**
             * Returns true if the snapshot manager is idle.
             */
            public boolean isIdle()
                {
                return getState() == STATE_IDLE;
                }
            
            // Accessor for the property "ResumeOnCompletion"
            /**
             * Getter for property ResumeOnCompletion.<p>
            * Indicates if the service should be resumed on completion of the
            * snapshot operation. This will be set to true if the service was
            * automatically suspended prior to the operation.
             */
            public boolean isResumeOnCompletion()
                {
                return __m_ResumeOnCompletion;
                }
            
            // From interface: com.tangosol.persistence.PersistenceManagerMBean
            /**
             * Return a list of archived snapshots that the configured archiver
            * knows about.
            * If none exist, an empty String[] will be returned.
             */
            public String[] listArchivedSnapshots()
                {
                // import com.tangosol.persistence.SnapshotArchiver;
                
                SnapshotArchiver archiver = getPersistenceControl().getSnapshotArchiver();
                if (archiver == null)
                    {
                    throw new IllegalArgumentException("No archiver is defined for this service");
                    }
                
                return archiver.list();
                }
            
            // From interface: com.tangosol.persistence.PersistenceManagerMBean
            /**
             * Return a list of stores for a given archived snapshot.
            * 
            * @param sSnapshot  the snapshot name to list stores for
             */
            public String[] listArchivedSnapshotStores(String sSnapshot)
                {
                // import com.tangosol.persistence.SnapshotArchiver;
                
                if (!hasArchivedSnapshot(sSnapshot))
                    {
                    throw new IllegalArgumentException("A snapshot named \"" + sSnapshot + "\" does not exist");
                    }
                
                SnapshotArchiver archiver = getPersistenceControl().getSnapshotArchiver();
                return archiver.get(sSnapshot).listStores();
                }
            
            /**
             * Called when the archive operation has completed.
            * Called on the service thread only.
            * 
            * @param setMembersFailed    the set of members that could not
            * archive the snapshot
             */
            public void onArchiveCompleted(com.tangosol.coherence.component.net.MemberSet setMembersFailed)
                {
                // import com.tangosol.persistence.PersistenceManagerMBean;
                
                int nState = getState();
                _assert(nState == STATE_SNAPSHOT_ARCHIVING || nState == STATE_SNAPSHOT_RETRIEVING);
                
                String  sSnapshot    = getSnapshotName();
                String  sUserData    = "";
                boolean fArchive     = nState == STATE_SNAPSHOT_ARCHIVING;
                String  sDesc        = fArchive ? "archive" : "retrieve";
                String  sArchived    = fArchive ? "" : " archived ";
                String  sServiceName = getService().getServiceName();
                String  sMessage;
                
                if (setMembersFailed == null || setMembersFailed.isEmpty())
                    {
                    sMessage = "Successfully " + sDesc + "d " + sArchived + "snapshot \"" + sSnapshot + '"';
                    _trace(sMessage, 3);
                    }
                else
                    {
                    sMessage  = "Failed to " + sDesc + " " + sArchived + "snapshot \"" + sSnapshot + '"';
                    sUserData = "failed members " + setMembersFailed;
                    _trace(sMessage + " because of " + sUserData, 2);
                    }
                
                String sNotificationType;
                if (fArchive)
                    {
                    sNotificationType = PersistenceManagerMBean.ARCHIVE_SNAPSHOT_END;
                    }
                else
                    {
                    sNotificationType = PersistenceManagerMBean.RETRIEVE_ARCHIVED_SNAPSHOT_END;
                
                    // reset the cache of snapshot names
                    setSnapshotNames(null);
                    }
                
                // generate a notification
                addNotification(sNotificationType, sMessage, sUserData);
                
                reset();
                }
            
            // Declared at the super level
            /**
             * The "component has been initialized" method-notification called
            * out of setConstructed() for the topmost component and that in
            * turn notifies all the children.
            * 
            * This notification gets called before the control returns back to
            * this component instantiator (using <code>new Component.X()</code>
            * or <code>_newInstance(sName)</code>) and on the same thread. In
            * addition, visual components have a "posted" notification
            * <code>onInitUI</code> that is called after (or at the same time
            * as) the control returns back to the instantiator and possibly on
            * a different thread.
             */
            public void onInit()
                {
                // import com.tangosol.net.management.AnnotatedStandardEmitterMBean;
                // import com.tangosol.net.management.Registry;
                // import com.tangosol.persistence.PersistenceManagerMBean;
                // import com.tangosol.util.Base;
                
                super.onInit();
                
                // register the MBean
                Registry registry = getService().getCluster().getManagement();
                if (registry != null)
                    {
                    try
                        {
                        registry.register(registry.ensureGlobalName(getMBeanName()),
                            new AnnotatedStandardEmitterMBean(this, PersistenceManagerMBean.class));
                        }
                    catch (Exception e)
                        {
                        throw Base.ensureRuntimeException(e);
                        }
                    }
                
                // auto-resume the service if necessary
                setResumeOnCompletion(getPersistenceControl().isResumeOnFailover());
                checkResume();
                }
            
            /**
             * Called when recovery has completed either as a part of active
            * persistence or snapshot recovery.
            * Called on the service thread only.
            * 
            * @param sSnapshot    the name of the snapshot recovered
            * @param partsFailed  the set of partitions which could not be
            * recovered
             */
            public void onRecoveryCompleted(String sSnapshot, com.tangosol.net.partition.PartitionSet partsFailed, com.tangosol.net.partition.PartitionSet partsFailedEvents)
                {
                // import com.tangosol.persistence.PersistenceManagerMBean;
                
                // TODO: add support for active persistence completion (dispatch notification)
                //       followed by RECOVER_SNAPSHOT_END notification such that a subscriber
                //       would see: [SNAPSHOT_START, RECOVER_START, RECOVER_END, SNAPSHOT_END]
                    
                if (sSnapshot == null)
                    {
                    // a null snapshot means we have completed active recovery
                    addNotification(PersistenceManagerMBean.RECOVER_END, "Recovery Completed", "");
                
                    // TODO: hraja - implement retry
                    if (!partsFailedEvents.isEmpty())
                        {
                        _trace("Event stores for the following partitions failed to recover: " + partsFailedEvents, 2);
                        }
                    
                    reset();
                    return;
                    }
                
                _assert(getState() == STATE_RECOVER_RECOVERING);
                
                String sMessage, sUserData;
                
                if (partsFailed == null || partsFailed.isEmpty())
                    {
                    sMessage = "Successfully recovered snapshot \"" + sSnapshot + '"';
                    sUserData = "";
                    _trace(sMessage, 3);
                    }
                else
                    {
                    sMessage  = "Failed to recover snapshot \"" + sSnapshot + '"';
                    sUserData = "failed partitions " + partsFailed;
                    _trace(sMessage + " because of " + sUserData, 2);
                    }
                
                // resume the service if it was previously suspended
                checkResume();
                
                // generate a notification for the end of recover (as part of manual recovery)
                addNotification(PersistenceManagerMBean.RECOVER_END, "Recovery Completed", "");
                
                // generate a notification
                addNotification(PersistenceManagerMBean.RECOVER_SNAPSHOT_END, sMessage, sUserData);
                
                reset();
                sendMemberRecovered();
                }
            
            /**
             * Called when recovery has started either as a part of active
            * persistence or snapshot recovery.
            * Called on the service thread only.
            * 
            * @param sSnapshot     the name of the snapshot to recover
            * @param partsRecover  the set of partitions to recover
             */
            public void onRecoveryStarted(String sSnapshot, com.tangosol.net.partition.PartitionSet partsRecover)
                {
                // import com.tangosol.persistence.PersistenceManagerMBean;
                
                if (sSnapshot == null)
                    {
                    // only set the state if snapshot is null; if it's not null
                    // then the state will already be another value (e.g. STATE_RECOVER_RECOVERING)
                    setState(STATE_ACTIVE_RECOVERY);
                    }
                
                addNotification(PersistenceManagerMBean.RECOVER_BEGIN, getOperationStatus(),
                                        partsRecover.cardinality() + " partitions to recover");
                }
            
            /**
             * Called when the snapshot creation operation has completed.
            * Called on the service thread only.
            * 
            * @param setMembersFailed    the set of members that could not
            * create the snapshot
             */
            public void onSnapshotCompleted(com.tangosol.coherence.component.net.MemberSet setMembersFailed, com.tangosol.net.partition.PartitionSet partsFailed)
                {
                // import com.tangosol.persistence.PersistenceManagerMBean;
                
                int nState       = getState();
                _assert(nState == STATE_SNAPSHOT_BUILDING || nState == STATE_SNAPSHOT_REMOVING);
                
                String  sSnapshot       = getSnapshotName();
                String  sUserData       = "";
                boolean fCreate         = nState == STATE_SNAPSHOT_BUILDING;
                String  sDesc           = fCreate ? "create" : "remove";
                boolean fPartsSuccess   = partsFailed == null || partsFailed.isEmpty();
                boolean fMembersSuccess = setMembersFailed == null || setMembersFailed.isEmpty();
                String  sMessage;
                
                if (fMembersSuccess && fPartsSuccess)
                    {
                    sMessage  = "Successfully " + sDesc + "d snapshot \"" + sSnapshot + '"';
                    _trace(sMessage, 3);
                    }
                else
                    {
                    sMessage  =  "Failed to " + sDesc + " snapshot \"" + sSnapshot + '"';
                    sUserData += fPartsSuccess ? "" : "failed " + partsFailed;
                    sUserData += fMembersSuccess ? ""
                                    : (fPartsSuccess ? "failed " : " on ") + setMembersFailed;
                    _trace(sMessage + " because of " + sUserData, 2);
                    }
                
                // resume the service if it was previously suspended.
                // Note: remove snapshot does not require a suspended service.
                if (fCreate)
                    {
                    checkResume();
                    }
                
                // reset the cache of snapshot names
                setSnapshotNames(null);
                
                // generate a notification
                addNotification(fCreate
                        ? PersistenceManagerMBean.CREATE_SNAPSHOT_END
                        : PersistenceManagerMBean.REMOVE_SNAPSHOT_END,
                    sMessage, sUserData);
                
                reset();
                }
            
            // From interface: com.tangosol.persistence.PersistenceManagerMBean
            /**
             * Initiates a request to all storage-enabled members instructing
            * them
            * to recover a snapshot with the given name for all the currently 
            * owned partitions.
            * 
            * @param sSnapshot    the name of the snapshot to be recovered
             */
            public synchronized void recoverSnapshot(String sSnapshot)
                {
                // import Component.Net.MemberSet;
                // import com.tangosol.net.partition.PartitionSet;
                // import com.tangosol.persistence.GUIDHelper;
                // import com.tangosol.persistence.PersistenceManagerMBean;
                // import com.tangosol.net.management.MBeanHelper;
                
                MBeanHelper.checkReadOnly("recoverSnapshot");
                
                ensureReady(false);
                
                // make sure we are not recovering a snapshot that doesn't exist
                if (!hasSnapshot(sSnapshot))
                    {
                    throw new IllegalArgumentException("A snapshot named \"" + sSnapshot + "\" does not exist");
                    }
                
                // validate that the number of stores in the snapshot is the same as the service
                // count. This could indicate that not all machines are present - COH-13270
                
                // poll to ownership memberset to ensure all partitions are accessible
                PartitionedService      service = getService();
                int          cParts  = service.getPartitionCount();
                PartitionSet parts   = GUIDHelper.getPartitions(getSnapshotStores(sSnapshot), cParts);
                if (parts.cardinality() != cParts)
                    {
                    throw new IllegalStateException("Missing the following partitions to recover snapsot '" +
                        sSnapshot + "': " + parts.invert());
                    }
                
                // if the service is not already suspended then do so
                ensureSuspended();
                
                // update the attributes
                setSnapshotName(sSnapshot);
                
                // generate a notification
                addNotification(PersistenceManagerMBean.RECOVER_SNAPSHOT_BEGIN,
                          "Recovering Snapshot \"" + sSnapshot + '"', "");
                
                // ownership protocol will abandon partitions in addition to performing recovery
                setState(STATE_RECOVER_RECOVERING);
                
                PartitionedService.NotifySnapshotRecoverRequest msg = (PartitionedService.NotifySnapshotRecoverRequest)
                        service.instantiateMessage("NotifySnapshotRecoverRequest");
                msg.setSnapshotName(sSnapshot);
                msg.addToMember(service.getThisMember());
                
                service.post(msg);
                }
            
            public void release()
                {
                // import com.tangosol.net.management.Registry;
                
                // unregister the MBean
                Registry registry = getService().getCluster().getManagement();
                if (registry != null)
                    {
                    registry.unregister(registry.ensureGlobalName(getMBeanName()));
                    }
                }
            
            // From interface: com.tangosol.persistence.PersistenceManagerMBean
            /**
             * Remove the archived snapshot from the central archive location.
            * 
            * @param sSnapshot  the snapshot name to remove
             */
            public void removeArchivedSnapshot(String sSnapshot)
                {
                // import com.tangosol.persistence.PersistenceManagerMBean;
                // import com.tangosol.persistence.SnapshotArchiver;
                
                ensureArchiveReady();
                
                if (!hasArchivedSnapshot(sSnapshot))
                    {
                    throw new IllegalArgumentException("The archived snapshot \"" + sSnapshot + "\" does not exist");
                    }
                
                SnapshotArchiver archiver     = getPersistenceControl().getSnapshotArchiver();
                String           sServiceName = getService().getServiceName();
                
                _trace("Removing archived snapshot \"" + sSnapshot + "\" for service " + sServiceName, 3);
                try
                    {
                    addNotification(PersistenceManagerMBean.REMOVE_ARCHIVED_SNAPSHOT_BEGIN,
                        "Removing archived snapshot \"" + sSnapshot + "\"" , "");
                
                    archiver.remove(sSnapshot);
                
                    _trace("Archived snapshot \"" + sSnapshot + "\" removed for service " + sServiceName, 3);
                    addNotification(PersistenceManagerMBean.REMOVE_ARCHIVED_SNAPSHOT_END,
                        "Sucessfully removed archived snapshot \"" + sSnapshot + "\"", "");
                    }
                catch (Exception e)
                    {
                    String sStack = getStackTrace(e);
                
                    _trace("Unable to remove archived snapshot \"" + sSnapshot + "\"\n" + sStack, 2);
                    addNotification(PersistenceManagerMBean.REMOVE_ARCHIVED_SNAPSHOT_END,
                        "Failed to remove archived snapshot \"" + sSnapshot + "\"", sStack);
                    }
                }
            
            // From interface: com.tangosol.persistence.PersistenceManagerMBean
            /**
             * Initiates a request to all storage-enabled members instructing
            * them
            * to remove a snapshot with the given name.
            * 
            * @param sSnapshot    the name of the snapshot to be removed
             */
            public void removeSnapshot(String sSnapshot)
                {
                // import com.tangosol.persistence.PersistenceManagerMBean;
                // import com.tangosol.net.management.MBeanHelper;
                
                MBeanHelper.checkReadOnly("removeSnapshot");
                
                ensureReady(false);
                
                // make sure we are not removing a snapshot that doesn't exist
                if (!hasSnapshot(sSnapshot))
                    {
                    throw new IllegalArgumentException(
                        "A snapshot named \"" + sSnapshot + "\" does not exist");
                    }
                
                // update the attributes
                setSnapshotName(sSnapshot);
                setState(STATE_SNAPSHOT_REMOVING);
                
                // send the request
                PartitionedService          service    = getService();
                PartitionedService.SnapshotRequest msgRequest = (PartitionedService.SnapshotRequest)
                    service.instantiateMessage("SnapshotRequest");
                
                msgRequest.setSnapshotName(sSnapshot);
                msgRequest.setCreate(false);
                msgRequest.setToMemberSet(service.getOwnershipMemberSet());
                
                service.send(msgRequest);
                
                // generate a notification
                addNotification(PersistenceManagerMBean.REMOVE_SNAPSHOT_BEGIN, getOperationStatus(), "");
                }
            
            /**
             * Reset the state of the SnapshotController after an operation has
            * completed.
             */
            protected synchronized void reset()
                {
                setSnapshotName(null);
                setState(STATE_IDLE);
                }
            
            // From interface: com.tangosol.persistence.PersistenceManagerMBean
            /**
             * Initiates a request to all storage-enabled members instructing
            * them
            * to retrieve a snapshot with the given name from the central
            * archive
            * location.
            * 
            * @param sSnapshot    the name of the snapshot to be retrieved
             */
            public void retrieveArchivedSnapshot(String sSnapshot)
                {
                // import Component.Net.MemberSet.ActualMemberSet;
                // import com.tangosol.net.management.MBeanHelper;
                // import com.tangosol.net.partition.Ownership;
                // import com.tangosol.persistence.PersistenceManagerMBean;
                // import com.tangosol.persistence.Snapshot;
                // import com.tangosol.persistence.SnapshotArchiver;
                // import java.util.HashMap;
                // import java.util.HashSet;
                // import java.util.Iterator;
                // import java.util.Map;
                // import java.util.Map$Entry as java.util.Map.Entry;
                // import java.util.Set;
                
                MBeanHelper.checkReadOnly("retrieveArchivedSnapshot");
                
                ensureArchiveReady();
                
                // make sure we are not retrieving a snapshot that exists already
                if (hasSnapshot(sSnapshot))
                    {
                    throw new IllegalArgumentException(
                        "A local snapshot named \"" + sSnapshot + "\" already exists and " +
                        "must be removed prior to being retrieved");
                    }
                
                if (!hasArchivedSnapshot(sSnapshot))
                    {
                    throw new IllegalArgumentException("The archived snapshot \"" +
                        sSnapshot + "\" does not exist");
                    }
                
                SnapshotArchiver archiver = getPersistenceControl().getSnapshotArchiver();
                PartitionedService          service  = getService();
                int              cParts   = service.getPartitionCount();
                
                // Get the snapshot details which will give us the entire list of stores
                Snapshot snapshot = archiver.get(sSnapshot);
                String[] asStores = snapshot.listStores();
                
                if (cParts != asStores.length)
                    {
                    throw new IllegalStateException("The number of archived stores for snapshot " +
                        sSnapshot + " is " + asStores.length + " which does not " +
                        "match the current service partition count of " + cParts);
                    }
                
                // build a Map<Integer, Set<String>> (which will be converted to a Map<Integer, String[]>)
                // that has the current partition assignment and ask each member to retrieve their owned
                // partitions from the archive location.
                
                ActualMemberSet setMembers = service.getServiceMemberSet();
                ActualMemberSet setTo      = new ActualMemberSet();
                Map             mapStores  = new HashMap();
                
                for (int iPart = 0; iPart < cParts; iPart++)
                    {
                    // retrieve the owner of the primary partition
                    int     nMember   = service.getPartitionConfig(iPart).getPrimaryOwner();
                    Integer NMember   = Integer.valueOf(nMember);
                    Set     setStores = (Set) mapStores.get(NMember);
                    if (setStores == null)
                        {
                        mapStores.put(NMember, setStores = new HashSet());
                        setTo.add(setMembers.getMember(nMember));
                        }
                
                    // retrieve the GUID for the current partition
                    String sGUID = getGUIDFromPartition(iPart, asStores);
                    if (sGUID == null)
                        {
                        // if we can't find a matching GUID then this means the partition
                        // count must be different so raise an error
                        throw new IllegalStateException("Unable to find a GUID for partition " +
                            iPart + " in the list of stores for snapshot " + sSnapshot + ". Unable to retrieve");
                        }
                
                    setStores.add(sGUID);
                    }
                
                // convert Map<Integer, Set<String>> to Map<Integer, String[]>
                Map mapConvertedStores = new HashMap();
                
                for (Iterator iter = mapStores.entrySet().iterator(); iter.hasNext();)
                    {
                    java.util.Map.Entry entry     = (java.util.Map.Entry) iter.next();
                    Set   setStores = (Set) entry.getValue();
                
                    mapConvertedStores.put(entry.getKey(),
                                           setStores.toArray(new String[setStores.size()]));
                    }
                
                // update the attributes
                setSnapshotName(sSnapshot);
                
                // send a request for each storage member with the stores Map to archive
                PartitionedService.SnapshotArchiveRequest msgArchiveRequest =
                             (PartitionedService.SnapshotArchiveRequest) service.instantiateMessage("SnapshotArchiveRequest");
                
                msgArchiveRequest.setSnapshotName(sSnapshot);
                msgArchiveRequest.setToMemberSet(setTo);
                msgArchiveRequest.setArchive(false);
                msgArchiveRequest.setStores(mapConvertedStores);
                service.send(msgArchiveRequest);   
                
                setState(STATE_SNAPSHOT_RETRIEVING);
                
                // generate a notification
                addNotification(PersistenceManagerMBean.RETRIEVE_ARCHIVED_SNAPSHOT_BEGIN, getOperationStatus(), "");
                }
            
            /**
             * Send a Member RECOVERED message to signal that this member's recovery has completed.
             */
            public void sendMemberRecovered()
                {
                PartitionedService   service = (PartitionedService) get_Module();
                Grid.MemberRecovered msg     = (MemberRecovered) service.instantiateMessage("MemberRecovered");
                Member               member  = service.getThisMember();
                msg.setMemberId(member.getId());
                msg.setToMemberSet(service.getServiceMemberSet());
                service.post(msg);
                }

            // Accessor for the property "ResumeOnCompletion"
            /**
             * Setter for property ResumeOnCompletion.<p>
            * Indicates if the service should be resumed on completion of the
            * snapshot operation. This will be set to true if the service was
            * automatically suspended prior to the operation.
             */
            protected void setResumeOnCompletion(boolean fResume)
                {
                __m_ResumeOnCompletion = fResume;
                }
            
            // Accessor for the property "SnapshotName"
            /**
             * Setter for property SnapshotName.<p>
            * The name of the snapshot whose creation, recovery or archival is
            * in-progress.
             */
            protected void setSnapshotName(String sSnapshot)
                {
                __m_SnapshotName = sSnapshot;
                }
            
            // Accessor for the property "SnapshotNames"
            /**
             * Setter for property SnapshotNames.<p>
            * A cache of snapshot names held for at most SNAPSHOT_NAMES_EXPIRE
            * millis after a SnapshotListRequest.
             */
            public void setSnapshotNames(String[] asNames)
                {
                // import com.tangosol.util.Base;
                
                __m_SnapshotNames = (asNames);
                
                setSnapshotNamesExpire(asNames == null
                    ? 0L : Base.getSafeTimeMillis() + SNAPSHOT_NAMES_EXPIRE);
                }
            
            // Accessor for the property "SnapshotNamesExpire"
            /**
             * Setter for property SnapshotNamesExpire.<p>
            * An absolute time when SnapshotNames should no longer be used.
            * 
            * @volatile
             */
            protected void setSnapshotNamesExpire(long ldtExpire)
                {
                __m_SnapshotNamesExpire = ldtExpire;
                }
            
            // Accessor for the property "State"
            /**
             * Setter for property State.<p>
            * The current state of the SnapshotController.  The controller can
            * only perform one logical management operation at a time.
            * 
            * @volatile
             */
            protected void setState(int nState)
                {
                __m_State = nState;
                }
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService$PinningIterator
    
    /**
     * A specialized iterator that iterates through the underlying Set of
     * Binary keys or Entries and read-locks (pins) all necessary partitions.
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class PinningIterator
            extends    com.tangosol.coherence.component.Util
            implements java.util.Iterator
        {
        // ---- Fields declarations ----
        
        /**
         * Property Concurrent
         *
         * Specifies wheter or not the processing is hapenning on daemon
         * threads.
         */
        private boolean __m_Concurrent;
        
        /**
         * Property DeferredPartitions
         *
         * Partitions that are currently pending for deferred index update. 
         * Keys that belong to any of the pending partitions will be rejected.
         */
        private com.tangosol.net.partition.PartitionSet __m_DeferredPartitions;
        
        /**
         * Property FullIterator
         *
         * The iterator of the full set.
         */
        private java.util.Iterator __m_FullIterator;
        
        /**
         * Property FullSet
         *
         * Original set of keys or entries.
         */
        private java.util.Set __m_FullSet;
        
        /**
         * Property InitialRun
         *
         * True if the iterator is used the very first time; false otherwise.
         */
        private boolean __m_InitialRun;
        
        /**
         * Property Next
         *
         * Is there a next item which passed the test?
         */
        private boolean __m_Next;
        
        /**
         * Property NextItem
         *
         * The next item which passed the test.
         */
        private Object __m_NextItem;
        
        /**
         * Property PartitionVersions
         *
         * The ownership versions to ensure of the partitions being pinned. 
         * Entries of partitions whose ownership version differs will be
         * excluded from the iterator.
         * 
         * May be null.
         */
        private com.tangosol.net.internal.PartitionVersions __m_PartitionVersions;
        
        /**
         * Property PinnedPartitions
         *
         * Partitions that were successfully locked; never null.
         */
        private com.tangosol.net.partition.PartitionSet __m_PinnedPartitions;
        
        /**
         * Property RejectedKeys
         *
         * Set of keys or entries that could not be locked; could be null.
         */
        private java.util.Set __m_RejectedKeys;
        
        /**
         * Property RejectedPartitions
         *
         * Partitions that could not be locked; could be null.
         */
        private com.tangosol.net.partition.PartitionSet __m_RejectedPartitions;
        
        /**
         * Property Removable
         *
         * Is there a previous item which passed the test and can be removed?
         */
        private boolean __m_Removable;
        
        // Default constructor
        public PinningIterator()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public PinningIterator(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.PinningIterator();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/PartitionedService$PinningIterator".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        protected java.util.Set ensureRejectedKeys()
            {
            // import java.util.HashSet;
            // import java.util.Set;
            
            Set setReject = getRejectedKeys();
            if (setReject == null)
                {
                setRejectedKeys(setReject = new HashSet());
                }
            return setReject;
            }
        
        /**
         * Enter the partition.
        * 
        * This method is overridden by the PartitionCache to ensure that the
        * index can be used for that partition.
        * 
        * @return true iff the partition is successfully entered
         */
        protected boolean enterPartition(int nPartition)
            {
            return ((PartitionedService) get_Module()).enterPartition(nPartition);
            }
        
        private boolean evaluate(Object o)
            {
            // import com.tangosol.net.partition.PartitionSet;
            // import com.tangosol.util.Binary;
            // import java.util.Set;
            // import java.util.Map$Entry as java.util.Map.Entry;
            
            Binary binKey;
            if (o instanceof Binary)
                {
                binKey = (Binary) o;
                }
            else
                {
                binKey = (Binary) ((java.util.Map.Entry) o).getKey();
                }
            
            if (isInitialRun())
                {
                PartitionedService      service    = (PartitionedService) get_Module();
                PartitionSet partAccept = getPinnedPartitions();
                PartitionSet partReject = getRejectedPartitions();
                PartitionSet partDefer  = getDeferredPartitions();
            
                int iPartition = service.getKeyPartition(binKey);
                if (partAccept.contains(iPartition))
                    {
                    return true;
                    }
                if (partReject != null && partReject.contains(iPartition))
                    {
                    ensureRejectedKeys().add(binKey);
                    return false;
                    }
                if (partDefer != null && partDefer.contains(iPartition))
                    {
                    if (partReject == null)
                        {
                        setRejectedPartitions(
                            partReject = new PartitionSet(service.getPartitionCount()));
                        }
                    partReject.add(iPartition);
                    ensureRejectedKeys().add(binKey);
                    return false;
                    }
            
                boolean fEntered = false;
                int     nVersion = getVersion(iPartition);
                if ((!isConcurrent() || (fEntered = enterPartition(iPartition))) &&
                    service.isPrimaryOwner(iPartition) &&
                    (nVersion == -1 || nVersion == service.getOwnershipVersion(iPartition)))
                    {
                    partAccept.add(iPartition);
                    // leave the gate entered
                    return true;
                    }
            
                if (partReject == null)
                    {
                    setRejectedPartitions(
                        partReject = new PartitionSet(service.getPartitionCount()));
                    }
                partReject.add(iPartition);
                ensureRejectedKeys().add(binKey);
            
                if (fEntered)
                    {
                    service.exitPartition(iPartition);
                    }
                return false;
                }
            else
                {
                Set setRejected = getRejectedKeys();
                return setRejected == null || !setRejected.contains(binKey);
                }
            }
        
        // Accessor for the property "DeferredPartitions"
        /**
         * Getter for property DeferredPartitions.<p>
        * Partitions that are currently pending for deferred index update. 
        * Keys that belong to any of the pending partitions will be rejected.
         */
        public com.tangosol.net.partition.PartitionSet getDeferredPartitions()
            {
            return __m_DeferredPartitions;
            }
        
        // Accessor for the property "FullIterator"
        /**
         * Getter for property FullIterator.<p>
        * The iterator of the full set.
         */
        private java.util.Iterator getFullIterator()
            {
            return __m_FullIterator;
            }
        
        // Accessor for the property "FullSet"
        /**
         * Getter for property FullSet.<p>
        * Original set of keys or entries.
         */
        public java.util.Set getFullSet()
            {
            return __m_FullSet;
            }
        
        // Accessor for the property "NextItem"
        /**
         * Getter for property NextItem.<p>
        * The next item which passed the test.
         */
        private Object getNextItem()
            {
            return __m_NextItem;
            }
        
        // Accessor for the property "PartitionVersions"
        /**
         * Getter for property PartitionVersions.<p>
        * The ownership versions to ensure of the partitions being pinned. 
        * Entries of partitions whose ownership version differs will be
        * excluded from the iterator.
        * 
        * May be null.
         */
        public com.tangosol.net.internal.PartitionVersions getPartitionVersions()
            {
            return __m_PartitionVersions;
            }
        
        // Accessor for the property "PinnedPartitions"
        /**
         * Getter for property PinnedPartitions.<p>
        * Partitions that were successfully locked; never null.
         */
        public com.tangosol.net.partition.PartitionSet getPinnedPartitions()
            {
            return __m_PinnedPartitions;
            }
        
        // Accessor for the property "RejectedKeys"
        /**
         * Getter for property RejectedKeys.<p>
        * Set of keys or entries that could not be locked; could be null.
         */
        public java.util.Set getRejectedKeys()
            {
            return __m_RejectedKeys;
            }
        
        // Accessor for the property "RejectedPartitions"
        /**
         * Getter for property RejectedPartitions.<p>
        * Partitions that could not be locked; could be null.
         */
        public com.tangosol.net.partition.PartitionSet getRejectedPartitions()
            {
            return __m_RejectedPartitions;
            }
        
        /**
         * Return the ownership version expected of the specified partition, or
        * -1 if the version is not enforced.
         */
        protected int getVersion(int nPartition)
            {
            // import com.tangosol.net.internal.PartitionVersions;
            
            PartitionVersions versions = getPartitionVersions();
            return versions == null ? -1 : versions.getVersion(nPartition);
            }
        
        // From interface: java.util.Iterator
        public boolean hasNext()
            {
            // import java.util.Iterator;
            
            // check if we've already check for the "next one"
            boolean fNext = isNext();
            if (fNext)
                {
                return true;
                }
            
            // find if there is a "next one"
            Iterator iter = getFullIterator();
            while (iter.hasNext())
                {
                Object oNext = iter.next();
                if (evaluate(oNext))
                    {
                    setNextItem(oNext);
                    setNext(fNext = true);
                    break;
                    }
                else
                    {
                    // remove the element from the FullSet if it is not pinned.
                    
                    // Note: this must be the initial run, as a previous evaluation
                    //       failure would result in removal from the FullSet
                    _assert(isInitialRun());
                    iter.remove();
                    }
                }
            
            // can't call remove now (because we'd end up potentially
            // removing the wrong one
            setRemovable(false);
            return fNext;
            }
        
        // Accessor for the property "Concurrent"
        /**
         * Getter for property Concurrent.<p>
        * Specifies wheter or not the processing is hapenning on daemon threads.
         */
        public boolean isConcurrent()
            {
            return __m_Concurrent;
            }
        
        /**
         * Checks whether or not the PinningIterator will produce any entries
        * AFTER it is reset.
         */
        public boolean isEmpty()
            {
            return size() == 0;
            }
        
        // Accessor for the property "InitialRun"
        /**
         * Getter for property InitialRun.<p>
        * True if the iterator is used the very first time; false otherwise.
         */
        private boolean isInitialRun()
            {
            return __m_InitialRun;
            }
        
        // Accessor for the property "Next"
        /**
         * Getter for property Next.<p>
        * Is there a next item which passed the test?
         */
        private boolean isNext()
            {
            return __m_Next;
            }
        
        // Accessor for the property "Removable"
        /**
         * Getter for property Removable.<p>
        * Is there a previous item which passed the test and can be removed?
         */
        private boolean isRemovable()
            {
            return __m_Removable;
            }
        
        // From interface: java.util.Iterator
        public Object next()
            {
            // import java.util.NoSuchElementException;
            
            if (isNext())
                {
                setNext(false);
                setRemovable(true);
                return getNextItem();
                }
            else
                {
                throw new NoSuchElementException();
                }
            }
        
        // From interface: java.util.Iterator
        public void remove()
            {
            // import java.util.Map$Entry as java.util.Map.Entry;
            
            if (isRemovable())
                {
                setRemovable(false);
            
                Object oNext = getNextItem();
                ensureRejectedKeys().add(
                    oNext instanceof java.util.Map.Entry ? ((java.util.Map.Entry) oNext).getKey() : oNext);
            
                getFullIterator().remove();
                }
            else
                {
                throw new IllegalStateException();
                }
            }
        
        /**
         * Reset the PinningIterator, so it could be re-iterated
         */
        public void reset()
            {
            setNext(false);
            setRemovable(false);
            setInitialRun(false);
            setFullIterator(getFullSet().iterator());
            }
        
        // Accessor for the property "Concurrent"
        /**
         * Setter for property Concurrent.<p>
        * Specifies wheter or not the processing is hapenning on daemon threads.
         */
        protected void setConcurrent(boolean fConcurrent)
            {
            __m_Concurrent = fConcurrent;
            }
        
        // Accessor for the property "DeferredPartitions"
        /**
         * Setter for property DeferredPartitions.<p>
        * Partitions that are currently pending for deferred index update. 
        * Keys that belong to any of the pending partitions will be rejected.
         */
        public void setDeferredPartitions(com.tangosol.net.partition.PartitionSet setPartitions)
            {
            __m_DeferredPartitions = setPartitions;
            }
        
        // Accessor for the property "FullIterator"
        /**
         * Setter for property FullIterator.<p>
        * The iterator of the full set.
         */
        private void setFullIterator(java.util.Iterator iter)
            {
            __m_FullIterator = iter;
            }
        
        // Accessor for the property "FullSet"
        /**
         * Setter for property FullSet.<p>
        * Original set of keys or entries.
         */
        public void setFullSet(java.util.Set set)
            {
            // import com.tangosol.net.partition.PartitionSet;
            
            _assert(getFullSet() == null, "Not resettable");
            
            PartitionedService service = (PartitionedService) get_Module();
            
            setPinnedPartitions(
                new PartitionSet(service.getPartitionCount()));
            setConcurrent(service.isConcurrent());
            setFullIterator(set.iterator());
            setInitialRun(true);
            
            __m_FullSet = (set);
            }
        
        // Accessor for the property "InitialRun"
        /**
         * Setter for property InitialRun.<p>
        * True if the iterator is used the very first time; false otherwise.
         */
        private void setInitialRun(boolean f)
            {
            __m_InitialRun = f;
            }
        
        // Accessor for the property "Next"
        /**
         * Setter for property Next.<p>
        * Is there a next item which passed the test?
         */
        private void setNext(boolean f)
            {
            __m_Next = f;
            }
        
        // Accessor for the property "NextItem"
        /**
         * Setter for property NextItem.<p>
        * The next item which passed the test.
         */
        private void setNextItem(Object oNext)
            {
            __m_NextItem = oNext;
            }
        
        // Accessor for the property "PartitionVersions"
        /**
         * Setter for property PartitionVersions.<p>
        * The ownership versions to ensure of the partitions being pinned. 
        * Entries of partitions whose ownership version differs will be
        * excluded from the iterator.
        * 
        * May be null.
         */
        public void setPartitionVersions(com.tangosol.net.internal.PartitionVersions versions)
            {
            __m_PartitionVersions = versions;
            }
        
        // Accessor for the property "PinnedPartitions"
        /**
         * Setter for property PinnedPartitions.<p>
        * Partitions that were successfully locked; never null.
         */
        protected void setPinnedPartitions(com.tangosol.net.partition.PartitionSet partitions)
            {
            __m_PinnedPartitions = partitions;
            }
        
        // Accessor for the property "RejectedKeys"
        /**
         * Setter for property RejectedKeys.<p>
        * Set of keys or entries that could not be locked; could be null.
         */
        protected void setRejectedKeys(java.util.Set set)
            {
            __m_RejectedKeys = set;
            }
        
        // Accessor for the property "RejectedPartitions"
        /**
         * Setter for property RejectedPartitions.<p>
        * Partitions that could not be locked; could be null.
         */
        protected void setRejectedPartitions(com.tangosol.net.partition.PartitionSet partitions)
            {
            __m_RejectedPartitions = partitions;
            }
        
        // Accessor for the property "Removable"
        /**
         * Setter for property Removable.<p>
        * Is there a previous item which passed the test and can be removed?
         */
        private void setRemovable(boolean f)
            {
            __m_Removable = f;
            }
        
        /**
         * Calculate a number of entries the PinningIterator will produce AFTER
        * it is reset.
         */
        public int size()
            {
            // import java.util.Set;
            
            Set setReject = getRejectedKeys();
            int cReject   = setReject == null ? 0 : setReject.size();
            
            return getFullSet().size() - cReject;
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService$SnapshotArchiveRequest
    
    /**
     * SnapshotArchiveRequest is sent to all ownership-enabled service members
     * to archive or retrieve an archived snapshot.
     * 
     * The attribute 'Archive' indicates if this is an archive or retrieve
     * snapshot request.
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class SnapshotArchiveRequest
            extends    com.tangosol.coherence.component.net.message.RequestMessage
            implements Runnable
        {
        // ---- Fields declarations ----
        
        /**
         * Property Archive
         *
         * If true, archive a snapshot; otherwise retrieve it.
         */
        private boolean __m_Archive;
        
        /**
         * Property SnapshotName
         *
         * The name of the snapshot to create.
         */
        private String __m_SnapshotName;
        
        /**
         * Property Stores
         *
         * A Map<Integer, String[]> containing the members and the stores to
         * archive.
         */
        private java.util.Map __m_Stores;
        private static com.tangosol.util.ListMap __mapChildren;
        
        // Static initializer
        static
            {
            __initStatic();
            }
        
        // Default static initializer
        private static void __initStatic()
            {
            // register child classes
            __mapChildren = new com.tangosol.util.ListMap();
            __mapChildren.put("Poll", PartitionedService.SnapshotArchiveRequest.Poll.get_CLASS());
            }
        
        // Default constructor
        public SnapshotArchiveRequest()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public SnapshotArchiveRequest(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                setMessageType(49);
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // containment initialization: children
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.SnapshotArchiveRequest();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/PartitionedService$SnapshotArchiveRequest".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        //++ getter for autogen property _ChildClasses
        /**
         * This is an auto-generated method that returns the map of design time
        * [static] children.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        protected java.util.Map get_ChildClasses()
            {
            return __mapChildren;
            }
        
        // Accessor for the property "SnapshotName"
        /**
         * Getter for property SnapshotName.<p>
        * The name of the snapshot to create.
         */
        public String getSnapshotName()
            {
            return __m_SnapshotName;
            }
        
        // Accessor for the property "Stores"
        /**
         * Getter for property Stores.<p>
        * A Map<Integer, String[]> containing the members and the stores to
        * archive.
         */
        public java.util.Map getStores()
            {
            return __m_Stores;
            }
        
        // Declared at the super level
        protected com.tangosol.coherence.component.net.Poll instantiatePoll()
            {
            // import Component.Net.Poll as com.tangosol.coherence.component.net.Poll;
            
            return (com.tangosol.coherence.component.net.Poll) _newChild("Poll");
            }
        
        // Accessor for the property "Archive"
        /**
         * Getter for property Archive.<p>
        * If true, archive a snapshot; otherwise retrieve it.
         */
        public boolean isArchive()
            {
            return __m_Archive;
            }
        
        // Declared at the super level
        /**
         * This is the event that is executed when a Message is received.
        * <p>
        * It is the main processing event of the Message called by the
        * <code>Service.onMessage()</code> event. With regards to the use of
        * Message components within clustered Services, Services are designed
        * by dragging Message components into them as static children. These
        * Messages are the components that a Service can send to other running
        * instances of the same Service within a cluster. When the onReceived
        * event is invoked by a Service, it means that the Message has been
        * received; the code in the onReceived event is therefore the Message
        * specific logic for processing a received Message. For example, when
        * onReceived is invoked on a Message named FindData, the onReceived
        * event should do the work to "find the data", because it is being
        * invoked by the Service that received the "find the data" Message.
         */
        public void onReceived()
            {
            PartitionedService             service         = (PartitionedService) getService();
            PartitionedService.PersistenceControl ctrlPersistence = service.getPersistenceControl();
            if (ctrlPersistence.isValid())
                {
                // run this on a worker thread as this operation may take a while
                // and we don't want to block the service thread
                service.getDaemonPool().add(this);
                }
            else
                {
                // we are not configured for persistence; shouldn't be possible
                PartitionedService.Response msgResponse = (PartitionedService.Response) service.instantiateMessage("Response");
                msgResponse.respondTo(this);
                msgResponse.setResult(PartitionedService.Response.RESULT_FAILURE);
            
                service.send(msgResponse);
                }
            }
        
        // Declared at the super level
        public void read(com.tangosol.io.ReadBuffer.BufferInput input)
                throws java.io.IOException
            {
            // import com.tangosol.util.ExternalizableHelper as com.tangosol.util.ExternalizableHelper;
            // import java.util.HashMap;
            // import java.util.Map;
            
            Map mapStores = new HashMap();
            
            super.read(input);
            
            setSnapshotName(input.readUTF());
            setArchive(input.readBoolean());
            com.tangosol.util.ExternalizableHelper.readMap(input, mapStores, null);
            setStores(mapStores);
            }
        
        // From interface: java.lang.Runnable
        public void run()
            {
            PartitionedService             service         = (PartitionedService) getService();
            PartitionedService.PersistenceControl ctrlPersistence = service.getPersistenceControl();
            
            // no checking for null for ctrlPersistence as this has already been done
            // to get to this point
            ctrlPersistence.archiveOperation(this, isArchive());
            }
        
        // Accessor for the property "Archive"
        /**
         * Setter for property Archive.<p>
        * If true, archive a snapshot; otherwise retrieve it.
         */
        public void setArchive(boolean fArchive)
            {
            __m_Archive = fArchive;
            }
        
        // Accessor for the property "SnapshotName"
        /**
         * Setter for property SnapshotName.<p>
        * The name of the snapshot to create.
         */
        public void setSnapshotName(String sName)
            {
            __m_SnapshotName = sName;
            }
        
        // Accessor for the property "Stores"
        /**
         * Setter for property Stores.<p>
        * A Map<Integer, String[]> containing the members and the stores to
        * archive.
         */
        public void setStores(java.util.Map sName)
            {
            __m_Stores = sName;
            }
        
        // Declared at the super level
        public void write(com.tangosol.io.WriteBuffer.BufferOutput output)
                throws java.io.IOException
            {
            // import com.tangosol.util.ExternalizableHelper as com.tangosol.util.ExternalizableHelper;
            
            super.write(output);
            
            output.writeUTF(getSnapshotName());
            output.writeBoolean(isArchive());
            com.tangosol.util.ExternalizableHelper.writeMap(output, getStores());
            }

        // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService$SnapshotArchiveRequest$Poll
        
        /**
         * The Poll contains information regarding a request sent to one or
         * more Cluster Members that require responses. A Service may poll
         * other Members that are running the same Service, and the Poll is
         * used to wait for and assemble the responses from each of those
         * Members. A client thread may also use the Poll to block on a
         * response or set of responses, thus waiting for the completion of the
         * Poll. In its simplest form, which is a Poll that is sent to one
         * Member of the Cluster, the Poll actually represents the
         * request/response model.
         */
        @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
        public static class Poll
                extends    com.tangosol.coherence.component.net.Poll
            {
            // ---- Fields declarations ----
            
            /**
             * Property Failures
             *
             */
            private com.tangosol.coherence.component.net.MemberSet __m_Failures;
            
            // Default constructor
            public Poll()
                {
                this(null, null, true);
                }
            
            // Initializing constructor
            public Poll(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                {
                super(sName, compParent, false);
                
                if (fInit)
                    {
                    __init();
                    }
                }
            
            // Main initializer
            public void __init()
                {
                // private initialization
                __initPrivate();
                
                
                // signal the end of the initialization
                set_Constructed(true);
                }
            
            // Private initializer
            protected void __initPrivate()
                {
                
                super.__initPrivate();
                }
            
            //++ getter for static property _Instance
            /**
             * Getter for property _Instance.<p>
            * Auto generated
             */
            public static com.tangosol.coherence.Component get_Instance()
                {
                return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.SnapshotArchiveRequest.Poll();
                }
            
            //++ getter for static property _CLASS
            /**
             * Getter for property _CLASS.<p>
            * Property with auto-generated accessor that returns the Class
            * object for a given component.
             */
            public static Class get_CLASS()
                {
                Class clz;
                try
                    {
                    clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/PartitionedService$SnapshotArchiveRequest$Poll".replace('/', '.'));
                    }
                catch (ClassNotFoundException e)
                    {
                    throw new NoClassDefFoundError(e.getMessage());
                    }
                return clz;
                }
            
            //++ getter for autogen property _Module
            /**
             * This is an auto-generated method that returns the global [design
            * time] parent component.
            * 
            * Note: the class generator will ignore any custom implementation
            * for this behavior.
             */
            private com.tangosol.coherence.Component get_Module()
                {
                return this.get_Parent().get_Parent();
                }
            
            // Accessor for the property "Failures"
            /**
             * Getter for property Failures.<p>
             */
            public com.tangosol.coherence.component.net.MemberSet getFailures()
                {
                return __m_Failures;
                }
            
            // Declared at the super level
            /**
             * This is the event that is executed when all the Members that were
            * polled have responded or have left the Service.
             */
            protected void onCompletion()
                {
                // import Component.Net.MemberSet;
                
                PartitionedService.PersistenceControl.SnapshotController ctrlSnapshot = ((PartitionedService) get_Module()).getPersistenceControl().getSnapshotController();
                
                // ensure we take into account members that left during the poll      
                MemberSet setFailures = ctrlSnapshot.combineMembersLeft(getFailures(), getLeftMemberSet());
                
                ctrlSnapshot.onArchiveCompleted(setFailures);
                
                super.onCompletion();
                }
            
            // Declared at the super level
            /**
             * This event occurs for each response Message from each polled
            * Member.
             */
            public void onResponse(com.tangosol.coherence.component.net.Message msg)
                {
                // import Component.Net.MemberSet;
                
                PartitionedService.Response msgResponse = (PartitionedService.Response) msg;
                if (msgResponse.getResult() == PartitionedService.Response.RESULT_FAILURE)
                    {
                    MemberSet setFailed = getFailures();
                    if (setFailed == null)
                        {
                        setFailed = new MemberSet();
                        setFailures(setFailed);
                        }
                
                    setFailed.add(msg.getFromMember());
                    }
                
                super.onResponse(msg);
                }
            
            // Accessor for the property "Failures"
            /**
             * Setter for property Failures.<p>
             */
            public void setFailures(com.tangosol.coherence.component.net.MemberSet setFailures)
                {
                __m_Failures = setFailures;
                }
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService$SnapshotListRequest
    
    /**
     * SnapshotListRequest is sent to all storage-enabled members of a
     * persistence-enabled service in order to retrieve either:
     * 1) a list of the available snapshots if SnapshotName is
     * null or
     * 2) a list of the available archived snapshot stores if
     * SnapshotName is not null.
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class SnapshotListRequest
            extends    com.tangosol.coherence.component.net.message.RequestMessage
        {
        // ---- Fields declarations ----
        
        /**
         * Property RESPONSE_SNAPSHOTS
         *
         * This value indicates the response was for a list of snapshots.
         */
        public static final String RESPONSE_SNAPSHOTS = "1";
        
        /**
         * Property RESPONSE_STORES
         *
         * This value indicates the response was for a list of stores for a
         * snapshot.
         */
        public static final String RESPONSE_STORES = "2";
        
        /**
         * Property SnapshotName
         *
         * If Snapshot is null this means that SnapshotListRequest should
         * retrieve the snapshots for the service otherwise the stores for the
         * snapshot specified by SnapshotName should be returned.
         */
        private String __m_SnapshotName;
        private static com.tangosol.util.ListMap __mapChildren;
        
        // Static initializer
        static
            {
            __initStatic();
            }
        
        // Default static initializer
        private static void __initStatic()
            {
            // register child classes
            __mapChildren = new com.tangosol.util.ListMap();
            __mapChildren.put("Poll", PartitionedService.SnapshotListRequest.Poll.get_CLASS());
            }
        
        // Default constructor
        public SnapshotListRequest()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public SnapshotListRequest(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                setMessageType(48);
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // containment initialization: children
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.SnapshotListRequest();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/PartitionedService$SnapshotListRequest".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        //++ getter for autogen property _ChildClasses
        /**
         * This is an auto-generated method that returns the map of design time
        * [static] children.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        protected java.util.Map get_ChildClasses()
            {
            return __mapChildren;
            }
        
        // Accessor for the property "SnapshotName"
        /**
         * Getter for property SnapshotName.<p>
        * If Snapshot is null this means that SnapshotListRequest should
        * retrieve the snapshots for the service otherwise the stores for the
        * snapshot specified by SnapshotName should be returned.
         */
        public String getSnapshotName()
            {
            return __m_SnapshotName;
            }
        
        // Declared at the super level
        protected com.tangosol.coherence.component.net.Poll instantiatePoll()
            {
            // import Component.Net.Poll as com.tangosol.coherence.component.net.Poll;
            
            return (com.tangosol.coherence.component.net.Poll) _newChild("Poll");
            }
        
        // Declared at the super level
        /**
         * This is the event that is executed when a Message is received.
        * <p>
        * It is the main processing event of the Message called by the
        * <code>Service.onMessage()</code> event. With regards to the use of
        * Message components within clustered Services, Services are designed
        * by dragging Message components into them as static children. These
        * Messages are the components that a Service can send to other running
        * instances of the same Service within a cluster. When the onReceived
        * event is invoked by a Service, it means that the Message has been
        * received; the code in the onReceived event is therefore the Message
        * specific logic for processing a received Message. For example, when
        * onReceived is invoked on a Message named FindData, the onReceived
        * event should do the work to "find the data", because it is being
        * invoked by the Service that received the "find the data" Message.
         */
        public void onReceived()
            {
            // import com.oracle.coherence.persistence.PersistenceEnvironment;
            // import com.oracle.coherence.persistence.PersistenceManager;
            // import com.tangosol.io.ReadBuffer;
            
            PartitionedService service = (PartitionedService) get_Module();
            
            PartitionedService.Response msgResponse = (PartitionedService.Response) service.instantiateMessage("Response");
            msgResponse.respondTo(this);
            
            // the result will be an object array with the first element being
            // either RESPONSE_SNAPSHOTS or RESPONSE_STORES and the second
            // element being the array of snapshots or stores
            
            PartitionedService.PersistenceControl ctrlPersistence = service.getPersistenceControl();
            if (ctrlPersistence.isValid())
                {
                String sSnapshotName           = getSnapshotName();
                PersistenceEnvironment env     = ctrlPersistence.getPersistenceEnvironment();
                PersistenceManager mgrSnapshot = null;
                
                msgResponse.setResult(PartitionedService.Response.RESULT_SUCCESS);
                
                if (sSnapshotName == null)
                    {
                    // respond with list of snapshots
                    msgResponse.setValue (new Object[] {RESPONSE_SNAPSHOTS, env.listSnapshots()});
                    }
                else
                    {
                    try {
                        // respond with list of the stores for the named snapshot
                        // return an empty String[] if the snapshot is not known to this member
                        mgrSnapshot = ctrlPersistence.openSnapshot(sSnapshotName);
            
                        msgResponse.setValue(new Object[]
                            {
                            RESPONSE_STORES,
                            mgrSnapshot == null ? new PersistentStoreInfo[0] : mgrSnapshot.listStoreInfo()
                            });
                        }
                    finally
                        {
                        if (mgrSnapshot != null)
                            {
                            mgrSnapshot.release();
                            }
                        }
                    }
                }
            else
                {
                // shouldn't be possible; see #validateServiceConfig
                msgResponse.setResult(PartitionedService.Response.RESULT_FAILURE);
                }
            
            service.post(msgResponse);
            }
        
        // Declared at the super level
        public void read(com.tangosol.io.ReadBuffer.BufferInput input)
                throws java.io.IOException
            {
            super.read(input);
            
            boolean fNull = input.readBoolean();
            setSnapshotName(fNull ? null : input.readUTF());
            }
        
        // Accessor for the property "SnapshotName"
        /**
         * Setter for property SnapshotName.<p>
        * If Snapshot is null this means that SnapshotListRequest should
        * retrieve the snapshots for the service otherwise the stores for the
        * snapshot specified by SnapshotName should be returned.
         */
        public void setSnapshotName(String sSnapshotName)
            {
            __m_SnapshotName = sSnapshotName;
            }
        
        // Declared at the super level
        public void write(com.tangosol.io.WriteBuffer.BufferOutput output)
                throws java.io.IOException
            {
            super.write(output);
            
            boolean fNull = getSnapshotName() == null;
            output.writeBoolean(fNull);
            if (!fNull)
                {
                output.writeUTF(getSnapshotName());
                }
            }

        // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService$SnapshotListRequest$Poll
        
        /**
         * The Poll contains information regarding a request sent to one or
         * more Cluster Members that require responses. A Service may poll
         * other Members that are running the same Service, and the Poll is
         * used to wait for and assemble the responses from each of those
         * Members. A client thread may also use the Poll to block on a
         * response or set of responses, thus waiting for the completion of the
         * Poll. In its simplest form, which is a Poll that is sent to one
         * Member of the Cluster, the Poll actually represents the
         * request/response model.
         */
        @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
        public static class Poll
                extends    com.tangosol.coherence.component.net.Poll
            {
            // ---- Fields declarations ----
            
            /**
             * Property Snapshots
             *
             * The set of snapshot names returned by the SnapshotListRequests.
             */
            private transient java.util.Set __m_Snapshots;
            
            /**
             * Property Stores
             *
             * If this oroginal SnapshotListRequest specified a snapshot, then
             * this is a Map<Integer, String[]> representing the MemberId and
             * the snapshot stores that are visible to the member. This
             * information is used to allocate each of the sotrage-enabled
             * memebers a fair share of stores to archive.
             */
            private java.util.Map __m_Stores;
            
            // Default constructor
            public Poll()
                {
                this(null, null, true);
                }
            
            // Initializing constructor
            public Poll(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                {
                super(sName, compParent, false);
                
                if (fInit)
                    {
                    __init();
                    }
                }
            
            // Main initializer
            public void __init()
                {
                // private initialization
                __initPrivate();
                
                
                // signal the end of the initialization
                set_Constructed(true);
                }
            
            // Private initializer
            protected void __initPrivate()
                {
                
                super.__initPrivate();
                }
            
            //++ getter for static property _Instance
            /**
             * Getter for property _Instance.<p>
            * Auto generated
             */
            public static com.tangosol.coherence.Component get_Instance()
                {
                return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.SnapshotListRequest.Poll();
                }
            
            //++ getter for static property _CLASS
            /**
             * Getter for property _CLASS.<p>
            * Property with auto-generated accessor that returns the Class
            * object for a given component.
             */
            public static Class get_CLASS()
                {
                Class clz;
                try
                    {
                    clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/PartitionedService$SnapshotListRequest$Poll".replace('/', '.'));
                    }
                catch (ClassNotFoundException e)
                    {
                    throw new NoClassDefFoundError(e.getMessage());
                    }
                return clz;
                }
            
            //++ getter for autogen property _Module
            /**
             * This is an auto-generated method that returns the global [design
            * time] parent component.
            * 
            * Note: the class generator will ignore any custom implementation
            * for this behavior.
             */
            private com.tangosol.coherence.Component get_Module()
                {
                return this.get_Parent().get_Parent();
                }
            
            // Accessor for the property "Snapshots"
            /**
             * Getter for property Snapshots.<p>
            * The set of snapshot names returned by the SnapshotListRequests.
             */
            public java.util.Set getSnapshots()
                {
                return __m_Snapshots;
                }
            
            // Accessor for the property "Stores"
            /**
             * Getter for property Stores.<p>
            * If this oroginal SnapshotListRequest specified a snapshot, then
            * this is a Map<Integer, String[]> representing the MemberId and
            * the snapshot stores that are visible to the member. This
            * information is used to allocate each of the sotrage-enabled
            * memebers a fair share of stores to archive.
             */
            public java.util.Map getStores()
                {
                return __m_Stores;
                }
            
            // Declared at the super level
            /**
             * This is the event that is executed when all the Members that were
            * polled have responded or have left the Service.
             */
            protected void onCompletion()
                {
                // import java.util.Map;
                // import java.util.Set;
                
                Set setSnapshots = getSnapshots();
                Map mapStores    = getStores();
                
                if (setSnapshots != null)
                    {
                    setResult(setSnapshots.toArray(new String[setSnapshots.size()]));
                    }
                else
                    {
                    setResult(mapStores);
                    }
                
                super.onCompletion();
                }
            
            // Declared at the super level
            /**
             * This event occurs for each response Message from each polled
            * Member.
             */
            public void onResponse(com.tangosol.coherence.component.net.Message msg)
                {
                // import java.util.HashMap;
                // import java.util.Map;
                // import java.util.Set;
                // import java.util.TreeSet;
                
                PartitionedService.Response msgResponse = (PartitionedService.Response) msg;
                Object[] oResult      = null;
                
                if (msgResponse.getResult() == PartitionedService.Response.RESULT_SUCCESS)
                    {
                    oResult = (Object[]) msgResponse.getValue();
                    if (oResult != null)
                        {
                        if (PartitionedService.SnapshotListRequest.RESPONSE_SNAPSHOTS.equals(oResult[0])) 
                            {
                            // list of snapshots was asked for
                            Set setSnapshots = getSnapshots();
                            if (setSnapshots == null)
                                {
                                setSnapshots = new TreeSet();
                                setSnapshots(setSnapshots);
                                }
                            
                            Object[] asSnapshots  = (Object[]) oResult[1];  // logically String[] but POF widens it
                            for (int i = 0, c = asSnapshots.length; i < c; i++)
                                {
                                setSnapshots.add(asSnapshots[i]);
                                }
                            }
                        else
                            {
                            // list of stores per snapshot was asked for from each member.
                            // in this case the mapStores is the result and contains a key of
                            // member id and value of String[] of stores for the member
                            Map mapStores = getStores();
                            if (mapStores == null)
                                {
                                setStores(mapStores = new HashMap());
                                }
                            
                            Object[] aoStores = (Object[]) oResult[1];  // logically String[] but POF widens it
                
                            if (aoStores.length > 0)
                                {
                                mapStores.put(Integer.valueOf(msg.getFromMember().getId()), aoStores);
                                }
                            }
                        }
                    }
                else
                    {
                    // shouldn't happen...
                    }
                
                super.onResponse(msg);
                }
            
            // Accessor for the property "Snapshots"
            /**
             * Setter for property Snapshots.<p>
            * The set of snapshot names returned by the SnapshotListRequests.
             */
            public void setSnapshots(java.util.Set setSnapshots)
                {
                __m_Snapshots = setSnapshots;
                }
            
            // Accessor for the property "Stores"
            /**
             * Setter for property Stores.<p>
            * If this oroginal SnapshotListRequest specified a snapshot, then
            * this is a Map<Integer, String[]> representing the MemberId and
            * the snapshot stores that are visible to the member. This
            * information is used to allocate each of the sotrage-enabled
            * memebers a fair share of stores to archive.
             */
            public void setStores(java.util.Map mapStores)
                {
                __m_Stores = mapStores;
                }
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService$SnapshotRequest
    
    /**
     * SnapshotRequest is sent to all ownership-enabled service members to
     * create or remove a persistent snapshot.
     * 
     * The attribute 'Create' indicates if this is a create or remove snapshot
     * request.
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class SnapshotRequest
            extends    com.tangosol.coherence.component.net.message.RequestMessage
        {
        // ---- Fields declarations ----
        
        /**
         * Property Attempt
         *
         * The number of attempts to retry snapshot creation.
         * 
         * Note: this property is decremented at runtime for each failure.
         */
        private int __m_Attempt;
        
        /**
         * Property Completed
         *
         * A set of partitions that have successfully completed.
         */
        private com.tangosol.net.partition.PartitionSet __m_Completed;
        
        /**
         * Property Create
         *
         * If true, create a snapshot; otherwise remove it.
         */
        private boolean __m_Create;
        
        /**
         * Property RequestMask
         *
         * A set of partitions that should be snapshot.
         */
        private com.tangosol.net.partition.PartitionSet __m_RequestMask;
        
        /**
         * Property SnapshotName
         *
         * The name of the snapshot to create.
         */
        private String __m_SnapshotName;
        private static com.tangosol.util.ListMap __mapChildren;
        
        // Static initializer
        static
            {
            __initStatic();
            }
        
        // Default static initializer
        private static void __initStatic()
            {
            // register child classes
            __mapChildren = new com.tangosol.util.ListMap();
            __mapChildren.put("Poll", PartitionedService.SnapshotRequest.Poll.get_CLASS());
            }
        
        // Default constructor
        public SnapshotRequest()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public SnapshotRequest(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                setAttempt(10);
                setMessageType(47);
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // containment initialization: children
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.SnapshotRequest();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/PartitionedService$SnapshotRequest".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        //++ getter for autogen property _ChildClasses
        /**
         * This is an auto-generated method that returns the map of design time
        * [static] children.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        protected java.util.Map get_ChildClasses()
            {
            return __mapChildren;
            }
        
        // Declared at the super level
        /**
         * Instantiate a copy of this message. This is quite different from the
        * standard "clone" since only the "transmittable" portion of the
        * message (and none of the internal) state should be cloned.
         */
        public com.tangosol.coherence.component.net.Message cloneMessage()
            {
            PartitionedService.SnapshotRequest msgClone = (PartitionedService.SnapshotRequest) super.cloneMessage();
            
            msgClone.setAttempt(getAttempt() - 1);
            msgClone.setCompleted(getCompleted());
            msgClone.setCreate(isCreate());
            msgClone.setRequestMask(getRequestMask());
            msgClone.setSnapshotName(getSnapshotName());
            
            return msgClone;
            }
        
        // Accessor for the property "Attempt"
        /**
         * Getter for property Attempt.<p>
        * The number of attempts to retry snapshot creation.
        * 
        * Note: this property is decremented at runtime for each failure.
         */
        public int getAttempt()
            {
            return __m_Attempt;
            }
        
        // Accessor for the property "Completed"
        /**
         * Getter for property Completed.<p>
        * A set of partitions that have successfully completed.
         */
        public com.tangosol.net.partition.PartitionSet getCompleted()
            {
            return __m_Completed;
            }
        
        // Accessor for the property "RequestMask"
        /**
         * Getter for property RequestMask.<p>
        * A set of partitions that should be snapshot.
         */
        public com.tangosol.net.partition.PartitionSet getRequestMask()
            {
            return __m_RequestMask;
            }
        
        // Accessor for the property "SnapshotName"
        /**
         * Getter for property SnapshotName.<p>
        * The name of the snapshot to create.
         */
        public String getSnapshotName()
            {
            return __m_SnapshotName;
            }
        
        // Declared at the super level
        protected com.tangosol.coherence.component.net.Poll instantiatePoll()
            {
            // import Component.Net.Poll as com.tangosol.coherence.component.net.Poll;
            
            return (com.tangosol.coherence.component.net.Poll) _newChild("Poll");
            }
        
        // Accessor for the property "Create"
        /**
         * Getter for property Create.<p>
        * If true, create a snapshot; otherwise remove it.
         */
        public boolean isCreate()
            {
            return __m_Create;
            }
        
        // Declared at the super level
        /**
         * This is the event that is executed when a Message is received.
        * <p>
        * It is the main processing event of the Message called by the
        * <code>Service.onMessage()</code> event. With regards to the use of
        * Message components within clustered Services, Services are designed
        * by dragging Message components into them as static children. These
        * Messages are the components that a Service can send to other running
        * instances of the same Service within a cluster. When the onReceived
        * event is invoked by a Service, it means that the Message has been
        * received; the code in the onReceived event is therefore the Message
        * specific logic for processing a received Message. For example, when
        * onReceived is invoked on a Message named FindData, the onReceived
        * event should do the work to "find the data", because it is being
        * invoked by the Service that received the "find the data" Message.
         */
        public void onReceived()
            {
            PartitionedService             service         = (PartitionedService) getService();
            PartitionedService.PersistenceControl ctrlPersistence = service.getPersistenceControl();
            if (ctrlPersistence.isValid())
                {
                if (isCreate())
                    {
                    ctrlPersistence.createSnapshot(this);
                    }
                else
                    {
                    ctrlPersistence.removeSnapshot(this);
                    }
                }
            else
                {
                // we are not configured for persistence; shouldn't be possible
                PartitionedService.Response msgResponse = (PartitionedService.Response) service.instantiateMessage("Response");
                msgResponse.respondTo(this);
                msgResponse.setResult(PartitionedService.Response.RESULT_FAILURE);
            
                service.send(msgResponse);
                }
            }
        
        // Declared at the super level
        public void read(com.tangosol.io.ReadBuffer.BufferInput input)
                throws java.io.IOException
            {
            // import com.tangosol.net.partition.PartitionSet;
            
            super.read(input);
            
            PartitionedService service = (PartitionedService) getService();
            
            setSnapshotName(input.readUTF());
            setCreate(input.readBoolean());
            
            if (isCreate() && service.isVersionCompatible(getFromMember(), 12, 2, 1, 2, 0))
                {
                PartitionSet partsMask = service.instantiatePartitionSet(/*fFill*/ false);
                partsMask.readExternal(input);
            
                if (!partsMask.isEmpty())
                    {
                    setRequestMask(partsMask);
                    }
                }
            }
        
        // Accessor for the property "Attempt"
        /**
         * Setter for property Attempt.<p>
        * The number of attempts to retry snapshot creation.
        * 
        * Note: this property is decremented at runtime for each failure.
         */
        public void setAttempt(int nAttempt)
            {
            __m_Attempt = nAttempt;
            }
        
        // Accessor for the property "Completed"
        /**
         * Setter for property Completed.<p>
        * A set of partitions that have successfully completed.
         */
        public void setCompleted(com.tangosol.net.partition.PartitionSet fCreate)
            {
            __m_Completed = fCreate;
            }
        
        // Accessor for the property "Create"
        /**
         * Setter for property Create.<p>
        * If true, create a snapshot; otherwise remove it.
         */
        public void setCreate(boolean fCreate)
            {
            __m_Create = fCreate;
            }
        
        // Accessor for the property "RequestMask"
        /**
         * Setter for property RequestMask.<p>
        * A set of partitions that should be snapshot.
         */
        public void setRequestMask(com.tangosol.net.partition.PartitionSet fCreate)
            {
            __m_RequestMask = fCreate;
            }
        
        // Accessor for the property "SnapshotName"
        /**
         * Setter for property SnapshotName.<p>
        * The name of the snapshot to create.
         */
        public void setSnapshotName(String sName)
            {
            __m_SnapshotName = sName;
            }
        
        // Declared at the super level
        public void write(com.tangosol.io.WriteBuffer.BufferOutput output)
                throws java.io.IOException
            {
            // import com.tangosol.net.partition.PartitionSet;
            
            super.write(output);
            
            boolean fCreate = isCreate();
            
            output.writeUTF(getSnapshotName());
            output.writeBoolean(fCreate);
            
            if (fCreate)
                {
                // Note:
                //   i ) RequestMask is only sent for snapshot creation requests
                //   ii) a RequestMask is *always* sent regardless of the version of the
                //       recepient as older versions will simply not read the RequestMask
            
                PartitionSet partsMask = getRequestMask();
                if (partsMask == null)
                    {
                    partsMask = ((PartitionedService) get_Module()).instantiatePartitionSet(/*fFill*/ false);
                    }
                partsMask.writeExternal(output);
                }
            }

        // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService$SnapshotRequest$Poll
        
        /**
         * The Poll contains information regarding a request sent to one or
         * more Cluster Members that require responses. A Service may poll
         * other Members that are running the same Service, and the Poll is
         * used to wait for and assemble the responses from each of those
         * Members. A client thread may also use the Poll to block on a
         * response or set of responses, thus waiting for the completion of the
         * Poll. In its simplest form, which is a Poll that is sent to one
         * Member of the Cluster, the Poll actually represents the
         * request/response model.
         */
        @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
        public static class Poll
                extends    com.tangosol.coherence.component.net.Poll
            {
            // ---- Fields declarations ----
            
            /**
             * Property Failures
             *
             */
            private com.tangosol.coherence.component.net.MemberSet __m_Failures;
            
            // Default constructor
            public Poll()
                {
                this(null, null, true);
                }
            
            // Initializing constructor
            public Poll(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                {
                super(sName, compParent, false);
                
                if (fInit)
                    {
                    __init();
                    }
                }
            
            // Main initializer
            public void __init()
                {
                // private initialization
                __initPrivate();
                
                
                // signal the end of the initialization
                set_Constructed(true);
                }
            
            // Private initializer
            protected void __initPrivate()
                {
                
                super.__initPrivate();
                }
            
            //++ getter for static property _Instance
            /**
             * Getter for property _Instance.<p>
            * Auto generated
             */
            public static com.tangosol.coherence.Component get_Instance()
                {
                return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.SnapshotRequest.Poll();
                }
            
            //++ getter for static property _CLASS
            /**
             * Getter for property _CLASS.<p>
            * Property with auto-generated accessor that returns the Class
            * object for a given component.
             */
            public static Class get_CLASS()
                {
                Class clz;
                try
                    {
                    clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/PartitionedService$SnapshotRequest$Poll".replace('/', '.'));
                    }
                catch (ClassNotFoundException e)
                    {
                    throw new NoClassDefFoundError(e.getMessage());
                    }
                return clz;
                }
            
            //++ getter for autogen property _Module
            /**
             * This is an auto-generated method that returns the global [design
            * time] parent component.
            * 
            * Note: the class generator will ignore any custom implementation
            * for this behavior.
             */
            private com.tangosol.coherence.Component get_Module()
                {
                return this.get_Parent().get_Parent();
                }
            
            // Accessor for the property "Failures"
            /**
             * Getter for property Failures.<p>
             */
            public com.tangosol.coherence.component.net.MemberSet getFailures()
                {
                return __m_Failures;
                }
            
            // Declared at the super level
            /**
             * This is the event that is executed when all the Members that were
            * polled have responded or have left the Service.
             */
            protected void onCompletion()
                {
                // import Component.Net.MemberSet;
                // import com.tangosol.net.partition.PartitionSet;
                
                PartitionedService             service        = (PartitionedService) getService();
                PartitionedService.PersistenceControl.SnapshotController ctrlSnapshot   = service.getPersistenceControl().getSnapshotController();
                PartitionedService.SnapshotRequest    msgRequest     = (PartitionedService.SnapshotRequest) get_Parent();
                PartitionSet        partsCompleted = msgRequest.getCompleted();
                PartitionSet        partsMask      = msgRequest.getRequestMask();
                
                if (partsCompleted != null)
                    {
                    partsMask.remove(partsCompleted);
                    }
                
                if (partsMask == null || partsMask.isEmpty() ||
                    msgRequest.getAttempt() <= 0)
                    {
                    // ensure we take into account members that left during the poll
                    MemberSet setFailures = ctrlSnapshot.combineMembersLeft(getFailures(), getLeftMemberSet());
                
                    ctrlSnapshot.onSnapshotCompleted(setFailures, partsMask);
                    }
                else // repeat the SnapshotRequest
                    {
                    PartitionedService.SnapshotRequest msgRepeat = (PartitionedService.SnapshotRequest) msgRequest.cloneMessage();
                
                    msgRepeat.setToMemberSet(service.getOwnershipMemberSet());
                
                    service.send(msgRepeat);
                    }
                
                super.onCompletion();
                }
            
            // Declared at the super level
            /**
             * This event occurs for each response Message from each polled
            * Member.
             */
            public void onResponse(com.tangosol.coherence.component.net.Message msg)
                {
                // import Component.Net.MemberSet;
                // import com.tangosol.net.partition.PartitionSet;
                
                PartitionedService.Response msgResponse = (PartitionedService.Response) msg;
                if (msgResponse.getResult() == PartitionedService.Response.RESULT_FAILURE)
                    {
                    MemberSet setFailed = getFailures();
                    if (setFailed == null)
                        {
                        setFailures(setFailed = new MemberSet());
                        }
                    setFailed.add(msg.getFromMember());
                    }
                
                PartitionedService.SnapshotRequest msgRequest  = (PartitionedService.SnapshotRequest) get_Parent();
                PartitionSet     partsAll    = msgRequest.getCompleted();
                PartitionSet     partsMember = partsAll == null
                        ? null : (PartitionSet) msgResponse.getValue();
                        
                // partsMember can be null in the following scenarios:
                //   1. at leaset one of the ownership members is on a version < 12.2.1.2
                //   2. the responder does not own any of the requested partitions
                //   3. persistence is mis-configured on the responder
                if (partsMember != null)
                    {
                    partsAll.add(partsMember);
                    }
                
                super.onResponse(msg);
                }
            
            // Accessor for the property "Failures"
            /**
             * Setter for property Failures.<p>
             */
            public void setFailures(com.tangosol.coherence.component.net.MemberSet setFailures)
                {
                __m_Failures = setFailures;
                }
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService$TransferControl
    
    /**
     * TransferControl manages state associated with incoming and outgoing
     * transfers to/from this service.
     * 
     * For example, TransferControl manages:
     * * size-limits for batched outgoing transfer
     * * incoming TransferRequests waiting to be processed
     * * partitions that have been transferred but are awaiting ownership
     * publication
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class TransferControl
            extends    com.tangosol.coherence.Component
        {
        // ---- Fields declarations ----
        
        /**
         * Property DistributionRequest
         *
         * The request for distribution that this TransferControl is responding
         * to (if doing primary distribution), or null otherwise.
         */
        private com.tangosol.coherence.component.net.message.RequestMessage __m_DistributionRequest;
        
        /**
         * Property IncomingTransfers
         *
         * The map of queues (keyed by the sending member) holding partial
         * transfer messages that carry data that belongs to the current
         * (incoming) transfer.
         */
        private java.util.Map __m_IncomingTransfers;
        
        /**
         * Property PartitionsOut
         *
         * A PrimitiveSparseArray that describes the (outgoing) partition
         * transfers that are in-progress.  The array is indexed by partition
         * and the elements are the backup index (e.g. 0 for primary, or backup
         * index otherwise). 
         * 
         * A transfer in-progress refers to either a primary partition owned by
         * this member that is being transferred out, or a backup for a
         * partition that is owned by this member that is being transferred
         * elsewhere.
         */
        private com.tangosol.util.PrimitiveSparseArray __m_PartitionsOut;
        
        /**
         * Property ToMember
         *
         * The member that this TransferControl is transferring to.
         */
        private com.tangosol.coherence.component.net.Member __m_ToMember;
        
        /**
         * Property TransferCountLimit
         *
         * The number of partitions that a logical distribution is limited to.
         */
        private int __m_TransferCountLimit;
        
        /**
         * Property TransferredBytes
         *
         * The number of bytes transferred for this logical distribution.
         */
        private long __m_TransferredBytes;
        
        /**
         * Property TransferSizeLimit
         *
         * The number of bytes that the size of logical distribution is limited
         * to.
         */
        private long __m_TransferSizeLimit;
        private static com.tangosol.util.ListMap __mapChildren;
        
        // Static initializer
        static
            {
            __initStatic();
            }
        
        // Default static initializer
        private static void __initStatic()
            {
            // register child classes
            __mapChildren = new com.tangosol.util.ListMap();
            __mapChildren.put("TransferIterator", PartitionedService.TransferControl.TransferIterator.get_CLASS());
            }
        
        // Default constructor
        public TransferControl()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public TransferControl(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                setIncomingTransfers(new java.util.HashMap());
                setPartitionsOut(new com.tangosol.util.PrimitiveSparseArray());
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // containment initialization: children
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.TransferControl();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/PartitionedService$TransferControl".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        //++ getter for autogen property _ChildClasses
        /**
         * This is an auto-generated method that returns the map of design time
        * [static] children.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        protected java.util.Map get_ChildClasses()
            {
            return __mapChildren;
            }
        
        /**
         * Called when the transfer for the specified partition has commenced
        * (the partition was locked), but later has been cancelled. This method
        * is called prior to the partition being unlocked.
         */
        public void cancelTransmit(int iPartition)
            {
            }
        
        /**
         * Perform any final actions once the last transfer message in the
        * distribution has been received.
        * Note: this method is called on the receiver upon transfer success, or
        * on the sender upon transfer failure.
        * 
        * @param msgTransferLast   the last transfer message in the
        * distribution, or null
         */
        public void finalizeReceive(PartitionedService.TransferRequest msgTransferLast)
            {
            }
        
        public void finalizeReceivePartition(int iPartition, java.util.List listXferRequests)
            {
            // import java.util.Iterator;
            
            for (Iterator iter = listXferRequests.iterator(); iter.hasNext(); )
                {
                PartitionedService.TransferRequest msgTransfer = (PartitionedService.TransferRequest) iter.next();
            
                if (msgTransfer.isLastInPartition())
                    {
                    finalizeReceive(msgTransfer);
                    }
                }
            }
        
        /**
         * Perform any final actions once the last transfer message in the
        * distribution has been posted.
        * 
        * @param msgTransferLast   the last transfer message in the distribution
         */
        protected void finalizeTransmit(PartitionedService.TransferRequest msgTransferLast)
            {
            setTransferState(msgTransferLast.getPartition(), PartitionedService.PartitionControl.XFER_SENT);
            }
        
        // Accessor for the property "DistributionRequest"
        /**
         * Getter for property DistributionRequest.<p>
        * The request for distribution that this TransferControl is responding
        * to (if doing primary distribution), or null otherwise.
         */
        public com.tangosol.coherence.component.net.message.RequestMessage getDistributionRequest()
            {
            return __m_DistributionRequest;
            }
        
        // Accessor for the property "IncomingTransfers"
        /**
         * Getter for property IncomingTransfers.<p>
        * The map of queues (keyed by the sending member) holding partial
        * transfer messages that carry data that belongs to the current
        * (incoming) transfer.
         */
        public java.util.Map getIncomingTransfers()
            {
            return __m_IncomingTransfers;
            }
        
        // Accessor for the property "PartitionControl"
        /**
         * Getter for property PartitionControl.<p>
         */
        public PartitionedService.PartitionControl getPartitionControl(int idx)
            {
            return ((PartitionedService) get_Module()).getPartitionControl(idx);
            }
        
        // Accessor for the property "PartitionsOut"
        /**
         * Getter for property PartitionsOut.<p>
        * A PrimitiveSparseArray that describes the (outgoing) partition
        * transfers that are in-progress.  The array is indexed by partition
        * and the elements are the backup index (e.g. 0 for primary, or backup
        * index otherwise). 
        * 
        * A transfer in-progress refers to either a primary partition owned by
        * this member that is being transferred out, or a backup for a
        * partition that is owned by this member that is being transferred
        * elsewhere.
         */
        public com.tangosol.util.PrimitiveSparseArray getPartitionsOut()
            {
            return __m_PartitionsOut;
            }
        
        /**
         * Return the queue used to hold incoming transfer requests from the
        * specified member, if it exists.
        * Called on the service thread.
        * 
        * @param member    the sending member to retrieve the incoming transfer
        * queue for
         */
        public java.util.List getQueuedTransfers(com.tangosol.coherence.component.net.Member member)
            {
            // import java.util.List;
            
            return (List) getIncomingTransfers().get(member);
            }
        
        // Accessor for the property "ToMember"
        /**
         * Getter for property ToMember.<p>
        * The member that this TransferControl is transferring to.
         */
        public com.tangosol.coherence.component.net.Member getToMember()
            {
            return __m_ToMember;
            }
        
        // Accessor for the property "TransferCount"
        /**
         * Getter for property TransferCount.<p>
        * The number of outgoing partition transfers that are currently in
        * progress.
         */
        public int getTransferCount()
            {
            return getPartitionsOut().getSize();
            }
        
        // Accessor for the property "TransferCountLimit"
        /**
         * Getter for property TransferCountLimit.<p>
        * The number of partitions that a logical distribution is limited to.
         */
        public int getTransferCountLimit()
            {
            return __m_TransferCountLimit;
            }
        
        // Accessor for the property "TransferredBytes"
        /**
         * Getter for property TransferredBytes.<p>
        * The number of bytes transferred for this logical distribution.
         */
        public long getTransferredBytes()
            {
            return __m_TransferredBytes;
            }
        
        // Accessor for the property "TransferSizeLimit"
        /**
         * Getter for property TransferSizeLimit.<p>
        * The number of bytes that the size of logical distribution is limited
        * to.
         */
        public long getTransferSizeLimit()
            {
            return __m_TransferSizeLimit;
            }
        
        /**
         * Return true iff there is a pending incoming transfer from the
        * specified member.
        * 
        * @param member    the transfer sender
         */
        public boolean isIncomingTransfer(com.tangosol.coherence.component.net.Member member)
            {
            return getIncomingTransfers().containsKey(member);
            }
        
        /**
         * Return true iff there is a pending (incomplete) incoming transfer
        * from the specified member.
        * 
        * @param member    the transfer sender
         */
        public boolean isIncompleteTransfer(com.tangosol.coherence.component.net.Member member)
            {
            // import java.util.List;
            
            List listXfers = (List) getIncomingTransfers().get(member);
            if (listXfers == null || listXfers.isEmpty())
                {
                return false;
                }
            
            PartitionedService.TransferRequest msgXferLast = (PartitionedService.TransferRequest) listXfers.get(listXfers.size() - 1);
            return !msgXferLast.isLastInTransfer();
            }
        
        // Accessor for the property "InProgress"
        /**
         * Getter for property InProgress.<p>
        * Is an outgoing partition transfer in-progress?  A transfer is
        * considered "in-progress" if a transfer snapshot has been taken, and a
        * transfer confirmation or rejection has not yet been received.
         */
        public boolean isInProgress()
            {
            // if there is a pending (primary) DistributionRequest, consider
            // the distribution to be "in-progress" even if we have not yet
            // put any transfers on the wire; we may have locked the partitions
            // to prepare for transfer, pending completion of outstanding backup
            // requests (COH-7312).  See #onFinalizeSendPrimary.
            return getDistributionRequest() != null || getTransferCount() > 0;
            }
        
        // Accessor for the property "TransferFull"
        /**
         * Getter for property TransferFull.<p>
        * Has the size of the current transfer reached the allowed transfer
        * size threshold or partition limit?
         */
        public boolean isTransferFull()
            {
            return getTransferredBytes() >= getTransferSizeLimit() ||
                 getTransferCount() >= getTransferCountLimit();
            }
        
        /**
         * Return true iff the (outgoing) transfer of the specified partition is
        * currently in-progress.
         */
        public boolean isTransferInProgress(int iPartition)
            {
            return getPartitionsOut().exists(iPartition);
            }
        
        /**
         * Return an iteration of the partition transfers that are currently
        * in-progress.  
        * 
        * The partitions are iterated by a PrimitiveSparseArray$Iterator where
        * nextPrimitive() returns 
        * the backup-index, and getIndex() returns the partition number being
        * transferred.  For example,
        * an iteration over the in-progress transfers might look like:
        * 
        * for (PrimitiveSparseArray$Iterator iter =
        * iterateTransfersInProgress(); iter.hasNext(); )
        *     {
        *     int iStore     = (int) iter.nextPrimitive();
        *     int iPartition = (int) iter.getIndex();
        * 
        *     // transfer of iPartition to the backup-index given by iStore
        *     }
         */
        public PartitionedService.TransferControl.TransferIterator iterateTransfersInProgress()
            {
            return (PartitionedService.TransferControl.TransferIterator) _newChild("TransferIterator");
            }
        
        /**
         * Called on the service thread when the specified member has left the
        * service.
        * 
        * @param member    the (departed) member
         */
        public void onMemberLeft(com.tangosol.coherence.component.net.Member member)
            {
            if (isIncompleteTransfer(member))
                {
                // rollback the receipt of the incoming transfer
                //
                // Note: as of Coherence 3.7.1, there could be a pending transfer
                //       that is "complete" or "fully received", that is waiting on
                //       event interceptor dispatch.  Since we have received all of
                //       the transfer messages from the sender and will delay both
                //       taking ownership of the incoming partitions and starting the
                //       ownership protocol until the distribution is complete, we
                //       must not "roll-back" these transfers.
                //       See #onFinalizeReceiveTransfer
                onReceiveRollback(member);
                }
            }
        
        /**
         * The transfer messages received for the current distribution have been
        * committed.
        * 
        * @param msgLastTransfer  the last transfer message in the distribution
         */
        public void onReceiveCommitted(PartitionedService.TransferRequest msgLastTransfer)
            {
            _assert(msgLastTransfer.isLastInTransfer());
            
            getIncomingTransfers().remove(msgLastTransfer.getFromMember());
            }
        
        /**
         * The transfer being received has been rolled back/aborted.
        * 
        * @param memberSender    the sender of the transfer that is being
        * rolled back
         */
        public void onReceiveRollback(com.tangosol.coherence.component.net.Member memberSender)
            {
            // the transfers being received have been aborted;
            // clear the transfer message queue and finalize the receive
            getIncomingTransfers().remove(memberSender);
            finalizeReceive(null);
            }
        
        /**
         * The specified TransferRequest was received. 
        * 
        * See PartitionedService#onTransferRequest for details.
         */
        public void onReceiveStarted(PartitionedService.TransferRequest msgRequest, com.oracle.coherence.common.base.Continuation continuation)
            {
            // import Component.Net.Member;
            // import java.util.ArrayList;
            // import java.util.List;
            // import java.util.Map;
            
            // Queue the transfer messages until all messages have been received
            // and process them all at once.
            
            Member memberFrom = msgRequest.getFromMember();
            Map    mapQueues  = getIncomingTransfers();
            List   listXfers  = (List) mapQueues.get(memberFrom);
            if (listXfers == null)
                {
                listXfers = new ArrayList();
                mapQueues.put(memberFrom, listXfers);
                }
            
            listXfers.add(msgRequest);
            
            if (continuation != null)
                {
                continuation.proceed(null);
                }
            }
        
        /**
         * The transfer messages for the current distribution have been sent.
        * 
        * @param msgLastTransfer  the last transfer message in the distribution
         */
        public void onTransmitCommitted(PartitionedService.TransferRequest msgLastTransfer)
            {
            finalizeTransmit(msgLastTransfer);
            }
        
        /**
         * The specified outgoing transfer has been received.  This indicates
        * that the recipient of the transfer received all transfer messages and
        * has sent acknowledgment to the sender, though the ownership change
        * may not have been published to the service senior yet.
        * 
        * Called on the service thread only.
         */
        public void onTransmitCompleted(int iPartition, int iStore)
            {
            // import com.tangosol.util.PrimitiveSparseArray;
            
            PrimitiveSparseArray saInProgress = getPartitionsOut();
            
            setTransferState(iPartition, PartitionedService.PartitionControl.XFER_NONE);
            
            int iStoreXfer = (int) saInProgress.removePrimitive(iPartition);
            _assert(iStoreXfer == iStore);
            
            if (saInProgress.isEmpty())
                {
                // all outgoing transfers are finished
                reset();
                }
            }
        
        /**
         * The specified outgoing transfer has been rejected by the recipient.
        * 
        * Called on the service thread only.
         */
        public void onTransmitRejected(int iPartition, int iStore)
            {
            // import com.tangosol.util.PrimitiveSparseArray;
            
            setTransferState(iPartition, PartitionedService.PartitionControl.XFER_NONE);
            
            PrimitiveSparseArray saInProgress = getPartitionsOut();
            int                  iStoreXfer   = (int) saInProgress.removePrimitive(iPartition);
            _assert(iStoreXfer == iStore);
            
            if (iStore == 0)
                {
                cancelTransmit(iPartition);
                }
            
            if (saInProgress.isEmpty())
                {
                // all outgoing transfers are finished
                reset();
                }
            }
        
        /**
         * Prepare to transfer partitions subject to the specified limit.
        * 
        * @param member the member to transfer to
        * @param cbLimit  the size threshold to limit the transfer to
        * @param cPartitionLimit  the number of partitions to limit the
        * transfer to
         */
        public void prepareBackupTransfer(com.tangosol.coherence.component.net.Member member, long cbLimit, int cPartitionLimit)
            {
            _assert(!isInProgress());
            setDistributionRequest(null);
            setToMember(member);
            setTransferSizeLimit(cbLimit);
            setTransferCountLimit(cPartitionLimit);
            }
        
        /**
         * Prepare to transfer partitions in response to the specified
        * distribution request, subject to the specified limit.
        * 
        * @param msgRequest  the distribution request
        * @param cbLimit  the size threshold to limit the transfer to
         */
        public void preparePrimaryTransfer(com.tangosol.coherence.component.net.message.RequestMessage msgRequest, long cbLimit)
            {
            _assert(!isInProgress());
            setDistributionRequest(msgRequest);
            setToMember(msgRequest.getFromMember());
            setTransferSizeLimit(cbLimit);
            setTransferCountLimit(Integer.MAX_VALUE);
            }
        
        /**
         * Record the specified outgoing transfer.
        * 
        * @param msgTransfer  the transfer request
        * @param cbTransfer     the transfer size
        * 
        * @return true iff the transfer limit size has been exceeded
         */
        public boolean recordTransfer(PartitionedService.TransferRequest msgTransfer, long cbTransfer)
            {
            // import Component.Net.Member;
            // import Component.Net.Message.RequestMessage;
            
            RequestMessage msgRequest = getDistributionRequest();
            Member         member     = getToMember();
            
            // address the TransferRequest message accordingly
            msgTransfer.setRecipient(member);
            if (msgRequest == null)
                {
                msgTransfer.addToMember(member);
                }
            else
                {
                msgTransfer.respondTo(msgRequest);
                }
            
            int iPartition = msgTransfer.getPartition();
            int iStore     = msgTransfer.getStore();
            
            setTransferredBytes(getTransferredBytes() + cbTransfer);
            getPartitionsOut().setPrimitive(iPartition, iStore);
            
            setTransferState(iPartition, PartitionedService.PartitionControl.XFER_STARTED);
            
            return isTransferFull();
            }
        
        /**
         * Send a backup CONFIRM request for the specified partition backup
        * index to the specified member.
        * 
        * @param iPartition                    the partition
        * @param iStore                          the backup storage index
        * @param nMemberDeparted   the member whose departure initiated this
        * confirmation request
        * @param memberTo                 the member to send the release
        * message to
         */
        public void requestBackupConfirmation(int iPartition, int iStore, int nMemberDeparted, com.tangosol.coherence.component.net.Member memberTo)
            {
            _assert(iStore > 0);
            
            _trace("Sending backup[" + iStore + "] confirmation to member "
                  + memberTo.getId() + " for partition " + iPartition, 3);
            
            PartitionedService               service = (PartitionedService) get_Module();
            PartitionedService.BackupConfirmRequest msg     = (PartitionedService.BackupConfirmRequest) service.instantiateMessage("BackupConfirmRequest");
            
            // prevent any partition transfer until we get a RELEASE or ANNOUNCE;
            // transfer is reenabled on poll completion
            getPartitionControl(iPartition).preventTransfer();
            
            msg.setPartition(iPartition);
            msg.setStore(iStore);
            msg.setDepartedMemberId(nMemberDeparted);
            msg.addToMember(memberTo);
            
            service.post(msg);
            }
        
        /**
         * Reset the state of TransferControl
         */
        protected void reset()
            {
            setDistributionRequest(null);
            getPartitionsOut().clear();
            setToMember(null);
            setTransferCountLimit(0);
            setTransferredBytes(0L);
            
            // shouldn't be necessary, but...
            PartitionedService.PartitionControl[] aCtrlPartition = ((PartitionedService) get_Module()).getPartitionControl();
            int                 cPartitions    = aCtrlPartition.length;
            for (int i = 0; i < cPartitions; i++)
                {
                PartitionedService.PartitionControl ctrlPartition = aCtrlPartition[i];
                if (ctrlPartition != null &&
                    ctrlPartition.getTransferState() != PartitionedService.PartitionControl.XFER_NONE)
                    {
                    _trace("Partition " + i + " is in an unexpected transfer state; recovering.", 3);
                    ctrlPartition.setTransferState(PartitionedService.PartitionControl.XFER_NONE);
                    }
                }
            }
        
        /**
         * Send a backup ANNOUNCE for the specified partition backup index to
        * the specified member.
        * 
        * @param iPartition        the partition
        * @param iStore              the backup storage index
        * @param memberTo     the member to send the release message to
        * @param msgRequest  the CONFIRM request being responded to, or null
         */
        public void sendBackupAnnounce(int iPartition, int iStore, com.tangosol.coherence.component.net.Member memberTo, PartitionedService.BackupConfirmRequest msgRequest)
            {
            _assert(iStore != 0); // -1 means announce all backups
            
            PartitionedService           service = (PartitionedService) get_Module();
            PartitionedService.BackupAssignment msg     = (PartitionedService.BackupAssignment) service.instantiateMessage("BackupAssignment");
            
            msg.setPartition(iPartition);
            msg.setStore(iStore);
            msg.setRelease(false);
            
            if (msgRequest == null)
                {
                // completing the backup-transfer "triangle"
                msg.addToMember(memberTo);
                }
            else
                {
                // answering a CONFIRM request
                msg.respondTo(msgRequest);
                }
            
            service.post(msg);
            }
        
        /**
         * Send a backup RELEASE for the specified partition backup index to the
        * specified member.
        * 
        * @param iPartition              the partition
        * @param iStore                    the backup storage index
        * @param nOwnerPrimary   the member-id of the primary owner
        * @param nOwnerNew         the member-id of the new backup owner
        * @param memberTo           the member to send the release message to
        * @param msgRequest        the CONFIRM request being responded to, or
        * null
         */
        public void sendBackupRelease(int iPartition, int iStore, int nOwnerPrimary, int nOwnerNew, com.tangosol.coherence.component.net.Member memberTo, PartitionedService.BackupConfirmRequest msgRequest)
            {
            _assert(iStore > 0);
            
            PartitionedService           service = (PartitionedService) get_Module();
            PartitionedService.BackupAssignment msg     = (PartitionedService.BackupAssignment) service.instantiateMessage("BackupAssignment");
            
            msg.setPartition(iPartition);
            msg.setStore(iStore);
            msg.setRelease(true);
            msg.setNewBackupOwner(nOwnerNew);
            msg.setPrimaryOwner(nOwnerPrimary);
            
            if (msgRequest == null)
                {
                // part of the backup-transfer "triangle", a command from the primary to
                // drop the backup ownership, or an "unsolicited" notification to the
                // primary that this member is not an owner.
                msg.addToMember(memberTo);
                }
            else
                {
                // answering a CONFIRM request
                msg.respondTo(msgRequest);
                }
            
            service.post(msg);
            }
        
        // Accessor for the property "DistributionRequest"
        /**
         * Setter for property DistributionRequest.<p>
        * The request for distribution that this TransferControl is responding
        * to (if doing primary distribution), or null otherwise.
         */
        protected void setDistributionRequest(com.tangosol.coherence.component.net.message.RequestMessage msgRequest)
            {
            __m_DistributionRequest = msgRequest;
            }
        
        // Accessor for the property "IncomingTransfers"
        /**
         * Setter for property IncomingTransfers.<p>
        * The map of queues (keyed by the sending member) holding partial
        * transfer messages that carry data that belongs to the current
        * (incoming) transfer.
         */
        protected void setIncomingTransfers(java.util.Map laQueues)
            {
            __m_IncomingTransfers = laQueues;
            }
        
        // Accessor for the property "PartitionsOut"
        /**
         * Setter for property PartitionsOut.<p>
        * A PrimitiveSparseArray that describes the (outgoing) partition
        * transfers that are in-progress.  The array is indexed by partition
        * and the elements are the backup index (e.g. 0 for primary, or backup
        * index otherwise). 
        * 
        * A transfer in-progress refers to either a primary partition owned by
        * this member that is being transferred out, or a backup for a
        * partition that is owned by this member that is being transferred
        * elsewhere.
         */
        protected void setPartitionsOut(com.tangosol.util.PrimitiveSparseArray saInProgress)
            {
            __m_PartitionsOut = saInProgress;
            }
        
        // Accessor for the property "ToMember"
        /**
         * Setter for property ToMember.<p>
        * The member that this TransferControl is transferring to.
         */
        protected void setToMember(com.tangosol.coherence.component.net.Member member)
            {
            __m_ToMember = member;
            }
        
        // Accessor for the property "TransferCountLimit"
        /**
         * Setter for property TransferCountLimit.<p>
        * The number of partitions that a logical distribution is limited to.
         */
        protected void setTransferCountLimit(int cTransfer)
            {
            __m_TransferCountLimit = cTransfer;
            }
        
        // Accessor for the property "TransferredBytes"
        /**
         * Setter for property TransferredBytes.<p>
        * The number of bytes transferred for this logical distribution.
         */
        protected void setTransferredBytes(long cbTransfer)
            {
            __m_TransferredBytes = cbTransfer;
            }
        
        // Accessor for the property "TransferSizeLimit"
        /**
         * Setter for property TransferSizeLimit.<p>
        * The number of bytes that the size of logical distribution is limited
        * to.
         */
        protected void setTransferSizeLimit(long cbLimit)
            {
            __m_TransferSizeLimit = cbLimit;
            }
        
        /**
         * Set the transfer state of the specified partition.
         */
        protected void setTransferState(int nPartition, int nState)
            {
            // Note: transfer state is held by the PartitionedService.PartitionControl for
            //       storage optimization.  See PartitionedService.PartitionControl.PartitionState
            getPartitionControl(nPartition).setTransferState(nState);
            }

        // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService$TransferControl$TransferIterator
        
        /**
         * TransferIterator is used to iterate the list of pending outgoing
         * transfers in a TransferControl.
         */
        @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
        public static class TransferIterator
                extends    com.tangosol.coherence.Component
            {
            // ---- Fields declarations ----
            
            /**
             * Property Backup
             *
             * The backup index of the current transfer in the iteration.
             */
            private int __m_Backup;
            
            /**
             * Property Iterator
             *
             * The PrimitiveSparseArray$Iterator on the underlying list of
             * outgoing transfers
             */
            private com.tangosol.util.PrimitiveSparseArray.Iterator __m_Iterator;
            
            /**
             * Property NextBackup
             *
             * The backup index of the next transfer in the iteration.
             */
            private int __m_NextBackup;
            
            /**
             * Property NextPartition
             *
             * The partition number of the next transfer in the iteration.
             */
            private int __m_NextPartition;
            
            /**
             * Property Partition
             *
             * The partition number of the current transfer in the iteration.
             */
            private int __m_Partition;
            
            // Default constructor
            public TransferIterator()
                {
                this(null, null, true);
                }
            
            // Initializing constructor
            public TransferIterator(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                {
                super(sName, compParent, false);
                
                if (fInit)
                    {
                    __init();
                    }
                }
            
            // Main initializer
            public void __init()
                {
                // private initialization
                __initPrivate();
                
                // state initialization: public and protected properties
                try
                    {
                    setBackup(-1);
                    setNextBackup(-1);
                    setNextPartition(-1);
                    setPartition(-1);
                    }
                catch (java.lang.Exception e)
                    {
                    // re-throw as a runtime exception
                    throw new com.tangosol.util.WrapperException(e);
                    }
                
                // signal the end of the initialization
                set_Constructed(true);
                }
            
            // Private initializer
            protected void __initPrivate()
                {
                
                super.__initPrivate();
                }
            
            //++ getter for static property _Instance
            /**
             * Getter for property _Instance.<p>
            * Auto generated
             */
            public static com.tangosol.coherence.Component get_Instance()
                {
                return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.TransferControl.TransferIterator();
                }
            
            //++ getter for static property _CLASS
            /**
             * Getter for property _CLASS.<p>
            * Property with auto-generated accessor that returns the Class
            * object for a given component.
             */
            public static Class get_CLASS()
                {
                Class clz;
                try
                    {
                    clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/PartitionedService$TransferControl$TransferIterator".replace('/', '.'));
                    }
                catch (ClassNotFoundException e)
                    {
                    throw new NoClassDefFoundError(e.getMessage());
                    }
                return clz;
                }
            
            //++ getter for autogen property _Module
            /**
             * This is an auto-generated method that returns the global [design
            * time] parent component.
            * 
            * Note: the class generator will ignore any custom implementation
            * for this behavior.
             */
            private com.tangosol.coherence.Component get_Module()
                {
                return this.get_Parent().get_Parent();
                }
            
            /**
             * Advance the internal state of the iterator to the next transfer.
             */
            protected void advance()
                {
                // import com.tangosol.util.PrimitiveSparseArray$Iterator as com.tangosol.util.PrimitiveSparseArray.Iterator;
                // import java.util.NoSuchElementException;
                
                com.tangosol.util.PrimitiveSparseArray.Iterator iter = getIterator();
                
                if (iter == null)
                    {
                    throw new NoSuchElementException();
                    }
                else if (iter.hasNext())
                    {
                    setNextBackup   ((int) iter.nextPrimitive());
                    setNextPartition((int) iter.getIndex());
                    }
                else
                    {
                    setIterator(null);
                    }
                }
            
            // Accessor for the property "Backup"
            /**
             * Getter for property Backup.<p>
            * The backup index of the current transfer in the iteration.
             */
            public int getBackup()
                {
                return __m_Backup;
                }
            
            // Accessor for the property "Iterator"
            /**
             * Getter for property Iterator.<p>
            * The PrimitiveSparseArray$Iterator on the underlying list of
            * outgoing transfers
             */
            public com.tangosol.util.PrimitiveSparseArray.Iterator getIterator()
                {
                return __m_Iterator;
                }
            
            // Accessor for the property "NextBackup"
            /**
             * Getter for property NextBackup.<p>
            * The backup index of the next transfer in the iteration.
             */
            public int getNextBackup()
                {
                return __m_NextBackup;
                }
            
            // Accessor for the property "NextPartition"
            /**
             * Getter for property NextPartition.<p>
            * The partition number of the next transfer in the iteration.
             */
            public int getNextPartition()
                {
                return __m_NextPartition;
                }
            
            // Accessor for the property "Partition"
            /**
             * Getter for property Partition.<p>
            * The partition number of the current transfer in the iteration.
             */
            public int getPartition()
                {
                return __m_Partition;
                }
            
            /**
             * @return true iff there are more transfers in the iteration
             */
            public boolean hasNext()
                {
                return getIterator() != null;
                }
            
            /**
             * Advance the iterator to the next transfer in the iteration.
             */
            public void next()
                {
                setPartition(getNextPartition());
                setBackup(getNextBackup());
                advance();
                }
            
            // Declared at the super level
            /**
             * The "component has been initialized" method-notification called
            * out of setConstructed() for the topmost component and that in
            * turn notifies all the children.
            * 
            * This notification gets called before the control returns back to
            * this component instantiator (using <code>new Component.X()</code>
            * or <code>_newInstance(sName)</code>) and on the same thread. In
            * addition, visual components have a "posted" notification
            * <code>onInitUI</code> that is called after (or at the same time
            * as) the control returns back to the instantiator and possibly on
            * a different thread.
             */
            public void onInit()
                {
                // import com.tangosol.util.PrimitiveSparseArray$Iterator as com.tangosol.util.PrimitiveSparseArray.Iterator;
                
                PartitionedService.TransferControl control = (PartitionedService.TransferControl) get_Parent();
                
                setIterator((com.tangosol.util.PrimitiveSparseArray.Iterator) control.getPartitionsOut().iterator());
                advance();
                }
            
            // Accessor for the property "Backup"
            /**
             * Setter for property Backup.<p>
            * The backup index of the current transfer in the iteration.
             */
            protected void setBackup(int nBackup)
                {
                __m_Backup = nBackup;
                }
            
            // Accessor for the property "Iterator"
            /**
             * Setter for property Iterator.<p>
            * The PrimitiveSparseArray$Iterator on the underlying list of
            * outgoing transfers
             */
            protected void setIterator(com.tangosol.util.PrimitiveSparseArray.Iterator iter)
                {
                __m_Iterator = iter;
                }
            
            // Accessor for the property "NextBackup"
            /**
             * Setter for property NextBackup.<p>
            * The backup index of the next transfer in the iteration.
             */
            protected void setNextBackup(int nBackup)
                {
                __m_NextBackup = nBackup;
                }
            
            // Accessor for the property "NextPartition"
            /**
             * Setter for property NextPartition.<p>
            * The partition number of the next transfer in the iteration.
             */
            protected void setNextPartition(int iPartition)
                {
                __m_NextPartition = iPartition;
                }
            
            // Accessor for the property "Partition"
            /**
             * Setter for property Partition.<p>
            * The partition number of the current transfer in the iteration.
             */
            protected void setPartition(int nPartition)
                {
                __m_Partition = nPartition;
                }
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService$TransferRequest
    
    /**
     * TransferRequest is a poll (by data owner) that transfers partition data.
     *  
     * 
     * Note: Multiple TransferRequests may be sent for a given partition
     * transfer (e.g. PartitionedCache may send a TransferRequest message per
     * cache).
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class TransferRequest
            extends    com.tangosol.coherence.component.net.message.RequestMessage
        {
        // ---- Fields declarations ----
        
        /**
         * Property LastInPartition
         *
         * Set to true if this is the last TransferRequest message in a the
         * distribution for a particular partition.
         */
        private boolean __m_LastInPartition;
        
        /**
         * Property LastInTransfer
         *
         * Set to true if this is the last TransferRequest message in a logical
         * distribution.
         */
        private boolean __m_LastInTransfer;
        
        /**
         * Property Owners
         *
         * The Ownership (according to the transfer sender) for the specified
         * partition.
         */
        private com.tangosol.net.partition.VersionedOwnership __m_Owners;
        
        /**
         * Property Partition
         *
         * The partition number of this transfer.
         */
        private int __m_Partition;
        
        /**
         * Property PartitionVersion
         *
         * The partition version.
         */
        private long __m_PartitionVersion;
        
        /**
         * Property PendingEvents
         *
         * PendingEvents associated with currently transferred partition. It
         * could be a single MapEvent or a List of MapEvents.  It is only used
         * by PartitionedCache but is  declared here to avoid casting the
         * msgRequest in PartitionedCache.onTransferRequest.
         */
        private Object __m_PendingEvents;
        
        /**
         * Property PendingResults
         *
         * A LongArray containing invocation results associated with currently
         * pending responses for the transferred partition. The LongArray is
         * keyed by the SUID for the request and value is a Map(LongArray<SUID,
         * Map<binKey, binResult>>.
         */
        private com.tangosol.util.LongArray __m_PendingResults;
        
        /**
         * Property Recipient
         *
         * The transfer recipient.
         */
        private transient com.tangosol.coherence.component.net.Member __m_Recipient;
        
        /**
         * Property Response
         *
         * A transient property populated upon close of TransferRequest$Poll.
         */
        private Object __m_Response;
        
        /**
         * Property RESPONSE_BACKUP
         *
         * Response to the TransferRequest indicating that the [primary
         * partition] transfer has been accepted by the recepient and the
         * sender is advised to backup the partition content. (Actually any
         * positive number indicates the assigned backup index)
         */
        public static final int RESPONSE_BACKUP = 1;
        
        /**
         * Property RESPONSE_INCOMPLETE
         *
         * Response to the TransferRequest indicating that the transfer has
         * been accepted by the recepient but more data are expected.
         */
        public static final int RESPONSE_INCOMPLETE = 0;
        
        /**
         * Property RESPONSE_REJECT
         *
         * Response to the TransferRequest indicating that the transfer has
         * been rejected by the recepient or that the recepient has left the
         * cluster.
         */
        public static final int RESPONSE_REJECT = -1;
        
        /**
         * Property RESPONSE_RELEASE
         *
         * Response to the TransferRequest indicating that the [primary
         * partition] transfer has been accepted by the recepient and the
         * sender is advised to release the partition content.
         */
        public static final int RESPONSE_RELEASE = -2;
        
        /**
         * Property Store
         *
         * Store index. It is zero for the primary ownership; otherwise the
         * backup index.
         */
        private int __m_Store;
        private static com.tangosol.util.ListMap __mapChildren;
        
        // Static initializer
        static
            {
            __initStatic();
            }
        
        // Default static initializer
        private static void __initStatic()
            {
            // register child classes
            __mapChildren = new com.tangosol.util.ListMap();
            __mapChildren.put("Poll", PartitionedService.TransferRequest.Poll.get_CLASS());
            }
        
        // Default constructor
        public TransferRequest()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public TransferRequest(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                setMessageType(34);
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // containment initialization: children
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.TransferRequest();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/PartitionedService$TransferRequest".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        //++ getter for autogen property _ChildClasses
        /**
         * This is an auto-generated method that returns the map of design time
        * [static] children.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        protected java.util.Map get_ChildClasses()
            {
            return __mapChildren;
            }
        
        // Declared at the super level
        /**
         * Getter for property Description.<p>
        * Used for debugging purposes (from toString). Create a human-readable
        * description of the specific Message data.
         */
        public String getDescription()
            {
            return "Partition=" + getPartition() + ", Store=" + getStore()
                 + ", Version=" + getPartitionVersion() + ", Owners=" + getOwners()
                 + ", LastInTransfer=" + isLastInTransfer();
            }
        
        // Accessor for the property "Owners"
        /**
         * Getter for property Owners.<p>
        * The Ownership (according to the transfer sender) for the specified
        * partition.
         */
        public com.tangosol.net.partition.VersionedOwnership getOwners()
            {
            return __m_Owners;
            }
        
        // Accessor for the property "Partition"
        /**
         * Getter for property Partition.<p>
        * The partition number of this transfer.
         */
        public int getPartition()
            {
            return __m_Partition;
            }
        
        // Accessor for the property "PartitionVersion"
        /**
         * Getter for property PartitionVersion.<p>
        * The partition version.
         */
        public long getPartitionVersion()
            {
            return __m_PartitionVersion;
            }
        
        // Accessor for the property "PendingEvents"
        /**
         * Getter for property PendingEvents.<p>
        * PendingEvents associated with currently transferred partition. It
        * could be a single MapEvent or a List of MapEvents.  It is only used
        * by PartitionedCache but is  declared here to avoid casting the
        * msgRequest in PartitionedCache.onTransferRequest.
         */
        public Object getPendingEvents()
            {
            return __m_PendingEvents;
            }
        
        // Accessor for the property "PendingResults"
        /**
         * Getter for property PendingResults.<p>
        * A LongArray containing invocation results associated with currently
        * pending responses for the transferred partition. The LongArray is
        * keyed by the SUID for the request and value is a Map(LongArray<SUID,
        * Map<binKey, binResult>>.
         */
        public com.tangosol.util.LongArray getPendingResults()
            {
            return __m_PendingResults;
            }
        
        // Accessor for the property "Recipient"
        /**
         * Getter for property Recipient.<p>
        * The transfer recipient.
         */
        public com.tangosol.coherence.component.net.Member getRecipient()
            {
            return __m_Recipient;
            }
        
        // Accessor for the property "Response"
        /**
         * Getter for property Response.<p>
        * A transient property populated upon close of TransferRequest$Poll.
         */
        public Object getResponse()
            {
            return __m_Response;
            }
        
        // Accessor for the property "Store"
        /**
         * Getter for property Store.<p>
        * Store index. It is zero for the primary ownership; otherwise the
        * backup index.
         */
        public int getStore()
            {
            return __m_Store;
            }
        
        // Declared at the super level
        protected com.tangosol.coherence.component.net.Poll instantiatePoll()
            {
            // import Component.Net.Poll as com.tangosol.coherence.component.net.Poll;
            
            return (com.tangosol.coherence.component.net.Poll) _newChild("Poll");
            }
        
        // Accessor for the property "LastInPartition"
        /**
         * Getter for property LastInPartition.<p>
        * Set to true if this is the last TransferRequest message in a the
        * distribution for a particular partition.
         */
        public boolean isLastInPartition()
            {
            return __m_LastInPartition;
            }
        
        // Accessor for the property "LastInTransfer"
        /**
         * Getter for property LastInTransfer.<p>
        * Set to true if this is the last TransferRequest message in a logical
        * distribution.
         */
        public boolean isLastInTransfer()
            {
            return __m_LastInTransfer;
            }
        
        // Declared at the super level
        /**
         * This is the event that is executed when a Message is received.
        * <p>
        * It is the main processing event of the Message called by the
        * <code>Service.onMessage()</code> event. With regards to the use of
        * Message components within clustered Services, Services are designed
        * by dragging Message components into them as static children. These
        * Messages are the components that a Service can send to other running
        * instances of the same Service within a cluster. When the onReceived
        * event is invoked by a Service, it means that the Message has been
        * received; the code in the onReceived event is therefore the Message
        * specific logic for processing a received Message. For example, when
        * onReceived is invoked on a Message named FindData, the onReceived
        * event should do the work to "find the data", because it is being
        * invoked by the Service that received the "find the data" Message.
         */
        public void onReceived()
            {
            ((PartitionedService) getService()).onTransferRequest(this);
            }
        
        // Declared at the super level
        public void read(com.tangosol.io.ReadBuffer.BufferInput input)
                throws java.io.IOException
            {
            // import com.tangosol.net.partition.VersionedOwnership;
            // import com.tangosol.util.ExternalizableHelper as com.tangosol.util.ExternalizableHelper;
            
            super.read(input);
            
            setPartition       (com.tangosol.util.ExternalizableHelper.readInt(input));
            setPartitionVersion(com.tangosol.util.ExternalizableHelper.readLong(input));
            setStore           (input.readUnsignedByte());
            setLastInPartition (input.readBoolean());
            setLastInTransfer  (input.readBoolean());
            
            VersionedOwnership owners = new VersionedOwnership();
            owners.readExternal(input);
            setOwners(owners);
            }
        
        // Accessor for the property "LastInPartition"
        /**
         * Setter for property LastInPartition.<p>
        * Set to true if this is the last TransferRequest message in a the
        * distribution for a particular partition.
         */
        public void setLastInPartition(boolean fLast)
            {
            __m_LastInPartition = fLast;
            }
        
        // Accessor for the property "LastInTransfer"
        /**
         * Setter for property LastInTransfer.<p>
        * Set to true if this is the last TransferRequest message in a logical
        * distribution.
         */
        public void setLastInTransfer(boolean fLast)
            {
            __m_LastInTransfer = fLast;
            }
        
        // Accessor for the property "Owners"
        /**
         * Setter for property Owners.<p>
        * The Ownership (according to the transfer sender) for the specified
        * partition.
         */
        public void setOwners(com.tangosol.net.partition.VersionedOwnership owners)
            {
            __m_Owners = owners;
            }
        
        // Accessor for the property "Partition"
        /**
         * Setter for property Partition.<p>
        * The partition number of this transfer.
         */
        public void setPartition(int iPartition)
            {
            __m_Partition = iPartition;
            }
        
        // Accessor for the property "PartitionVersion"
        /**
         * Setter for property PartitionVersion.<p>
        * The partition version.
         */
        public void setPartitionVersion(long lVersion)
            {
            __m_PartitionVersion = lVersion;
            }
        
        // Accessor for the property "PendingEvents"
        /**
         * Setter for property PendingEvents.<p>
        * PendingEvents associated with currently transferred partition. It
        * could be a single MapEvent or a List of MapEvents.  It is only used
        * by PartitionedCache but is  declared here to avoid casting the
        * msgRequest in PartitionedCache.onTransferRequest.
         */
        public void setPendingEvents(Object oEvents)
            {
            __m_PendingEvents = oEvents;
            }
        
        // Accessor for the property "PendingResults"
        /**
         * Setter for property PendingResults.<p>
        * A LongArray containing invocation results associated with currently
        * pending responses for the transferred partition. The LongArray is
        * keyed by the SUID for the request and value is a Map(LongArray<SUID,
        * Map<binKey, binResult>>.
         */
        public void setPendingResults(com.tangosol.util.LongArray arrayResults)
            {
            __m_PendingResults = arrayResults;
            }
        
        // Accessor for the property "Recipient"
        /**
         * Setter for property Recipient.<p>
        * The transfer recipient.
         */
        public void setRecipient(com.tangosol.coherence.component.net.Member member)
            {
            __m_Recipient = member;
            }
        
        // Accessor for the property "Response"
        /**
         * Setter for property Response.<p>
        * A transient property populated upon close of TransferRequest$Poll.
         */
        public void setResponse(Object oResponse)
            {
            __m_Response = oResponse;
            }
        
        // Accessor for the property "Store"
        /**
         * Setter for property Store.<p>
        * Store index. It is zero for the primary ownership; otherwise the
        * backup index.
         */
        public void setStore(int nStore)
            {
            __m_Store = nStore;
            }
        
        // Declared at the super level
        public void write(com.tangosol.io.WriteBuffer.BufferOutput output)
                throws java.io.IOException
            {
            // import com.tangosol.util.ExternalizableHelper as com.tangosol.util.ExternalizableHelper;
            
            super.write(output);
            
            com.tangosol.util.ExternalizableHelper.writeInt(output, getPartition());
            com.tangosol.util.ExternalizableHelper.writeLong(output, getPartitionVersion());
            output.writeByte(getStore());
            output.writeBoolean(isLastInPartition());
            output.writeBoolean(isLastInTransfer());
            
            getOwners().writeExternal(output);
            }

        // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService$TransferRequest$Poll
        
        /**
         * The Poll contains information regarding a request sent to one or
         * more Cluster Members that require responses. A Service may poll
         * other Members that are running the same Service, and the Poll is
         * used to wait for and assemble the responses from each of those
         * Members. A client thread may also use the Poll to block on a
         * response or set of responses, thus waiting for the completion of the
         * Poll. In its simplest form, which is a Poll that is sent to one
         * Member of the Cluster, the Poll actually represents the
         * request/response model.
         */
        @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
        public static class Poll
                extends    com.tangosol.coherence.component.net.Poll
            {
            // ---- Fields declarations ----
            
            // Default constructor
            public Poll()
                {
                this(null, null, true);
                }
            
            // Initializing constructor
            public Poll(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                {
                super(sName, compParent, false);
                
                if (fInit)
                    {
                    __init();
                    }
                }
            
            // Main initializer
            public void __init()
                {
                // private initialization
                __initPrivate();
                
                
                // signal the end of the initialization
                set_Constructed(true);
                }
            
            // Private initializer
            protected void __initPrivate()
                {
                
                super.__initPrivate();
                }
            
            //++ getter for static property _Instance
            /**
             * Getter for property _Instance.<p>
            * Auto generated
             */
            public static com.tangosol.coherence.Component get_Instance()
                {
                return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.TransferRequest.Poll();
                }
            
            //++ getter for static property _CLASS
            /**
             * Getter for property _CLASS.<p>
            * Property with auto-generated accessor that returns the Class
            * object for a given component.
             */
            public static Class get_CLASS()
                {
                Class clz;
                try
                    {
                    clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/PartitionedService$TransferRequest$Poll".replace('/', '.'));
                    }
                catch (ClassNotFoundException e)
                    {
                    throw new NoClassDefFoundError(e.getMessage());
                    }
                return clz;
                }
            
            //++ getter for autogen property _Module
            /**
             * This is an auto-generated method that returns the global [design
            * time] parent component.
            * 
            * Note: the class generator will ignore any custom implementation
            * for this behavior.
             */
            private com.tangosol.coherence.Component get_Module()
                {
                return this.get_Parent().get_Parent();
                }
            
            // Declared at the super level
            /**
             * Getter for property Description.<p>
            * Used for debugging purposes (from toString). Create a
            * human-readable description of the specific Message data.
             */
            public String getDescription()
                {
                return ", Result=" + getResult() +
                       ", Partition=" + ((PartitionedService.TransferRequest) get_Parent()).getPartition();
                }
            
            // Declared at the super level
            /**
             * This is the event that is executed when all the Members that were
            * polled have responded or have left the Service.
             */
            protected void onCompletion()
                {
                PartitionedService service = (PartitionedService) getService();
                Object  oResult = getResult();
                        oResult = oResult == null 
                                     ? Integer.valueOf(PartitionedService.TransferRequest.RESPONSE_REJECT) : oResult;
                Integer NResult = oResult instanceof Integer ? (Integer) oResult : null;
                
                PartitionedService.TransferRequest msg = (PartitionedService.TransferRequest) get_Parent();
                msg.setResponse(oResult);
                
                if (msg.getStore() == 0 && msg.isLastInTransfer())
                    {
                    boolean fSuccess = NResult == null; // must be a map of partitioned responses
                    service.onTransferCompleted(fSuccess, oResult, msg);
                    }
                else
                    {
                    // backups and incomplete transfers can be completed immediately
                    service.onTransferRequestCompleted(msg);
                    }
                
                super.onCompletion();
                }
            
            // Declared at the super level
            /**
             * This event occurs for each response Message from each polled
            * Member.
             */
            public void onResponse(com.tangosol.coherence.component.net.Message msg)
                {
                setResult(((PartitionedService.TransferResponse) msg).getValue());
                
                super.onResponse(msg);
                }
            }
        }

    // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService$TransferResponse
    
    /**
     * TransferResponse is the response to a TransferRequest, and informs the
     * sender on the success of the transfer.  For primary partition transfer,
     * the response also instructs the sender (previous owner) to either
     * release or backup the storage.
     * 
     * As of Cohernce 12.1.3, this message is a poll and instead of onSent()
     * notification the poll closure is used to re-enabled the transfer
     * (COH-10946).
     */
    @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
    public static class TransferResponse
            extends    com.tangosol.coherence.component.net.message.RequestMessage
        {
        // ---- Fields declarations ----
        
        /**
         * Property PrimaryPartitions
         *
         * (Transient) The set of primary partitions associated with this
         * transfer response; may be null.
         */
        private transient com.tangosol.net.partition.PartitionSet __m_PrimaryPartitions;
        
        /**
         * Property Value
         *
         * The response value; either a backup index to that the old primary
         * owner should move its storage to, or
         * $TransferRequest.RESPONSE_RELEASE
         */
        private Object __m_Value;
        private static com.tangosol.util.ListMap __mapChildren;
        
        // Static initializer
        static
            {
            __initStatic();
            }
        
        // Default static initializer
        private static void __initStatic()
            {
            // register child classes
            __mapChildren = new com.tangosol.util.ListMap();
            __mapChildren.put("Poll", PartitionedService.TransferResponse.Poll.get_CLASS());
            }
        
        // Default constructor
        public TransferResponse()
            {
            this(null, null, true);
            }
        
        // Initializing constructor
        public TransferResponse(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
            {
            super(sName, compParent, false);
            
            if (fInit)
                {
                __init();
                }
            }
        
        // Main initializer
        public void __init()
            {
            // private initialization
            __initPrivate();
            
            // state initialization: public and protected properties
            try
                {
                setMessageType(38);
                }
            catch (java.lang.Exception e)
                {
                // re-throw as a runtime exception
                throw new com.tangosol.util.WrapperException(e);
                }
            
            // containment initialization: children
            
            // signal the end of the initialization
            set_Constructed(true);
            }
        
        // Private initializer
        protected void __initPrivate()
            {
            
            super.__initPrivate();
            }
        
        //++ getter for static property _Instance
        /**
         * Getter for property _Instance.<p>
        * Auto generated
         */
        public static com.tangosol.coherence.Component get_Instance()
            {
            return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.TransferResponse();
            }
        
        //++ getter for static property _CLASS
        /**
         * Getter for property _CLASS.<p>
        * Property with auto-generated accessor that returns the Class object
        * for a given component.
         */
        public static Class get_CLASS()
            {
            Class clz;
            try
                {
                clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/PartitionedService$TransferResponse".replace('/', '.'));
                }
            catch (ClassNotFoundException e)
                {
                throw new NoClassDefFoundError(e.getMessage());
                }
            return clz;
            }
        
        //++ getter for autogen property _Module
        /**
         * This is an auto-generated method that returns the global [design
        * time] parent component.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        private com.tangosol.coherence.Component get_Module()
            {
            return this.get_Parent();
            }
        
        //++ getter for autogen property _ChildClasses
        /**
         * This is an auto-generated method that returns the map of design time
        * [static] children.
        * 
        * Note: the class generator will ignore any custom implementation for
        * this behavior.
         */
        protected java.util.Map get_ChildClasses()
            {
            return __mapChildren;
            }
        
        // Accessor for the property "PrimaryPartitions"
        /**
         * Getter for property PrimaryPartitions.<p>
        * (Transient) The set of primary partitions associated with this
        * transfer response; may be null.
         */
        public com.tangosol.net.partition.PartitionSet getPrimaryPartitions()
            {
            return __m_PrimaryPartitions;
            }
        
        // Accessor for the property "Value"
        /**
         * Getter for property Value.<p>
        * The response value; either a backup index to that the old primary
        * owner should move its storage to, or $TransferRequest.RESPONSE_RELEASE
         */
        public Object getValue()
            {
            return __m_Value;
            }
        
        // Declared at the super level
        protected com.tangosol.coherence.component.net.Poll instantiatePoll()
            {
            // import Component.Net.Poll as com.tangosol.coherence.component.net.Poll;
            
            return (com.tangosol.coherence.component.net.Poll) _newChild("Poll");
            }
        
        // Declared at the super level
        /**
         * This is the event that is executed when a Message is received.
        * <p>
        * It is the main processing event of the Message called by the
        * <code>Service.onMessage()</code> event. With regards to the use of
        * Message components within clustered Services, Services are designed
        * by dragging Message components into them as static children. These
        * Messages are the components that a Service can send to other running
        * instances of the same Service within a cluster. When the onReceived
        * event is invoked by a Service, it means that the Message has been
        * received; the code in the onReceived event is therefore the Message
        * specific logic for processing a received Message. For example, when
        * onReceived is invoked on a Message named FindData, the onReceived
        * event should do the work to "find the data", because it is being
        * invoked by the Service that received the "find the data" Message.
         */
        public void onReceived()
            {
            // acknowledge the reponse
            PartitionedService   service     = (PartitionedService) getService();
            PartitionedService.Response msgResponse = (PartitionedService.Response) service.instantiateMessage("Response");
            msgResponse.respondTo(this);
            
            service.post(msgResponse);
            }
        
        // Declared at the super level
        public void read(com.tangosol.io.ReadBuffer.BufferInput input)
                throws java.io.IOException
            {
            setValue(readObject(input));
            }
        
        // Accessor for the property "PrimaryPartitions"
        /**
         * Setter for property PrimaryPartitions.<p>
        * (Transient) The set of primary partitions associated with this
        * transfer response; may be null.
         */
        public void setPrimaryPartitions(com.tangosol.net.partition.PartitionSet parts)
            {
            __m_PrimaryPartitions = parts;
            }
        
        // Accessor for the property "Value"
        /**
         * Setter for property Value.<p>
        * The response value; either a backup index to that the old primary
        * owner should move its storage to, or $TransferRequest.RESPONSE_RELEASE
         */
        public void setValue(Object oValue)
            {
            __m_Value = oValue;
            }
        
        // Declared at the super level
        public void write(com.tangosol.io.WriteBuffer.BufferOutput output)
                throws java.io.IOException
            {
            writeObject(output, getValue());
            }

        // ---- class: com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService$TransferResponse$Poll
        
        /**
         * The Poll contains information regarding a request sent to one or
         * more Cluster Members that require responses. A Service may poll
         * other Members that are running the same Service, and the Poll is
         * used to wait for and assemble the responses from each of those
         * Members. A client thread may also use the Poll to block on a
         * response or set of responses, thus waiting for the completion of the
         * Poll. In its simplest form, which is a Poll that is sent to one
         * Member of the Cluster, the Poll actually represents the
         * request/response model.
         */
        @SuppressWarnings({"deprecation", "rawtypes", "unused", "unchecked", "ConstantConditions", "DuplicatedCode", "ForLoopReplaceableByForEach", "IfCanBeSwitch", "RedundantArrayCreation", "RedundantSuppression", "SameParameterValue", "TryFinallyCanBeTryWithResources", "TryWithIdenticalCatches", "UnnecessaryBoxing", "UnnecessaryUnboxing", "UnusedAssignment"})
        public static class Poll
                extends    com.tangosol.coherence.component.net.Poll
            {
            // ---- Fields declarations ----
            
            // Default constructor
            public Poll()
                {
                this(null, null, true);
                }
            
            // Initializing constructor
            public Poll(String sName, com.tangosol.coherence.Component compParent, boolean fInit)
                {
                super(sName, compParent, false);
                
                if (fInit)
                    {
                    __init();
                    }
                }
            
            // Main initializer
            public void __init()
                {
                // private initialization
                __initPrivate();
                
                
                // signal the end of the initialization
                set_Constructed(true);
                }
            
            // Private initializer
            protected void __initPrivate()
                {
                
                super.__initPrivate();
                }
            
            //++ getter for static property _Instance
            /**
             * Getter for property _Instance.<p>
            * Auto generated
             */
            public static com.tangosol.coherence.Component get_Instance()
                {
                return new com.tangosol.coherence.component.util.daemon.queueProcessor.service.grid.PartitionedService.TransferResponse.Poll();
                }
            
            //++ getter for static property _CLASS
            /**
             * Getter for property _CLASS.<p>
            * Property with auto-generated accessor that returns the Class
            * object for a given component.
             */
            public static Class get_CLASS()
                {
                Class clz;
                try
                    {
                    clz = Class.forName("com.tangosol.coherence/component/util/daemon/queueProcessor/service/grid/PartitionedService$TransferResponse$Poll".replace('/', '.'));
                    }
                catch (ClassNotFoundException e)
                    {
                    throw new NoClassDefFoundError(e.getMessage());
                    }
                return clz;
                }
            
            //++ getter for autogen property _Module
            /**
             * This is an auto-generated method that returns the global [design
            * time] parent component.
            * 
            * Note: the class generator will ignore any custom implementation
            * for this behavior.
             */
            private com.tangosol.coherence.Component get_Module()
                {
                return this.get_Parent().get_Parent();
                }
            
            // Declared at the super level
            /**
             * This is the event that is executed when all the Members that were
            * polled have responded or have left the Service.
             */
            protected void onCompletion()
                {
                // import com.tangosol.net.partition.PartitionSet;
                
                PartitionedService.TransferResponse msgResponse = (PartitionedService.TransferResponse) get_Parent();
                PartitionSet      parts       = msgResponse.getPrimaryPartitions();
                if (parts != null)
                    {
                    // if this PartitionedService.TransferResponse is associated with a successful primary
                    // transfer, we must exit the partition control (re-opening for transfer)
                    // for each partition.  See #onTransferRequest
                    PartitionedService             service  = (PartitionedService) getService();
                    PartitionedService.PartitionControl[] aControl = service.getPartitionControl(); 
                    for (int iPart = parts.next(0); iPart >= 0; iPart = parts.next(iPart + 1))
                        {
                        aControl[iPart].enableTransfer();
                        }
                    }
                }
            }
        }

    // ----- inner class: MaintenanceTask -------------------------------

    /**
     * Task used to perform necessary maintenance of the underlying environment.
     */
    public class MaintenanceTask implements Runnable
        {
        // ----- Runnable interface -----------------------------------------

        public void run()
            {
            try
                {
                PersistenceManager manager = getPersistenceManager();
                if (manager != null)
                    {
                    manager.maintainEnvironment();
                    }
                }
            finally
                {
                scheduleEnvironmentMaintenance();
                }
            }
        }
    }
