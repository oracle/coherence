///////////////////////////////////////////////////////////////////////////////
    Copyright (c) 2000, 2022, Oracle and/or its affiliates.

    Licensed under the Universal Permissive License v 1.0 as shown at
    http://oss.oracle.com/licenses/upl.
///////////////////////////////////////////////////////////////////////////////
= Coherence TLS Enhancements
:description: Coherence TLS Enhancements
:keywords: coherence, SSL, TLS, java, documentation

// DO NOT remove this header - it might look like a duplicate of the header above, but
// they both serve a purpose, and the docs will look wrong if it is removed.
== Coherence TLS Enhancements

Coherence has supported using SSL/TLS to secure communication between cluster members and Extend client for a long time.
From Coherence version 22.06, this functionality has been enhanced to allow a more flexible configuration and allow customisation via extensions.

[NOTE]
====
The documentation here only covers the changes made in Coherence 22.06 that apply to
https://docs.oracle.com/en/middleware/standalone/coherence/14.1.1.0/secure/using-ssl-secure-communication.html#GUID-90E20139-3945-4993-9048-7FBC93B243A3[6 Using SSL to Secure Communication] in the commercial documentation on _Securing Oracle Coherence_
====

* The <<passwords,Encrypting SSL Passwords>> section covers a new configuration option to read a password from a file or simple URL.
* The <<keys-and-certs,Using Private Key and Certificate Files>> section describes using private key and certificate files instead of using Java keystores.
* The <<custom-loaders,Custom Keystore, Private Key and Certificate Loaders>> section describes loading keystores, private keys and certificates from custom sources and formats instead of from files.
* The <<refresh,Refreshable KeyStores, Private Keys and Certificates>> section shows how to configure automatic refresh of keystores, private keys and certificates.
* The <<operational,Operational Configuration Element Reference>> section details changes to the
https://docs.oracle.com/en/middleware/standalone/coherence/14.1.1.0/develop-applications/operational-configuration-elements.html#GUID-6FD7679F-C4A3-4B74-8B81-8C5B7929BC18[Operational Configuration Element Reference] documentation based on the SSL configuration changes introduced in Coherence 22.06.


== 6 Using SSL to Secure Communication
Oracle Coherence supports Secure Sockets Layer (SSL) to secure TCMP communication between cluster nodes and to secure the TCP communication between Oracle Coherence*Extend clients and proxies. Oracle Coherence supports the Transport Layer Security (TLS) protocol, which superseded the SSL protocol; however, the term SSL is used in this documentation because it is the more widely recognized term.

[#passwords]
== Encrypting SSL Passwords

Entering passwords in an operational override file as clear text is not recommended beyond simple development and testing scenarios. Exposed passwords are a security risk and can lead to unwanted access to sensitive data. Coherence offers two alternatives to hard coded passwords,

* <<password-url,Read a password from a URL>>
* <<password-provider,Use a custom Password Provider>>


[#password-url]
=== Read Passwords from a URL

To load a password from a URL, such as a file on the file system, the `<password-url>` element can be used instead of the `<password>` element.

<<example-6-6,Example 6-6>> demonstrates an SSL socket provider configuration that reads the keystore and private key passwords from files on the file system.

In the example XML, the identity manager's keystore password is read from the `/coherence/security/server-pass.txt` file.
The private key used by the identity manager is read from the `/coherence/security/key-pass.txt` file.
The keystore password used by the trust manager is read from the `/coherence/security/trust-pass.txt` file.

[#example-6-6]
=== _Example 6-6 Reading a Password From a File in the Configuration for SSL_

[source,xml]
----
<?xml version='1.0'?>
<coherence xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   xmlns="http://xmlns.oracle.com/coherence/coherence-operational-config"
   xsi:schemaLocation="http://xmlns.oracle.com/coherence/coherence-operational-config
   coherence-operational-config.xsd">
   <cluster-config>
      <socket-providers>
         <socket-provider id="mySSLConfig">
            <ssl>
               <protocol>TLS</protocol>
               <identity-manager>
                  <algorithm>SunX509</algorithm>
                  <key-store>
                     <url>file:server.jks</url>
                     <password-url>file:/coherence/security/server-pass.txt</password-url>
                     <type>JKS</type>
                  </key-store>
                  <password-url>file:/coherence/security/key-pass.txt</password-url>
               </identity-manager>
               <trust-manager>
                  <algorithm>SunX509</algorithm>
                  <key-store>
                     <url>file:trust.jks</url>
                     <password-url>file:/coherence/security/trust-pass.txt</password-url>
                     <type>JKS</type>
                  </key-store>
               </trust-manager>
               <socket-provider>tcp</socket-provider>
            </ssl>
         </socket-provider>
      </socket-providers>
   </cluster-config>
</coherence>
----

By default, the `<password-url>` configuration will use all the data returned from the URL as the password.
This behaviour can be changed to only use the first line of data returned as the password by setting the `first-line-only` attribute of the `<password-url>` element to `true`.

For example, if the file `/secret.txt` contained the password followed by additional data on subsequent lines, the `<password-url>` element could be configured as shown below:

[source,xml]
----
<password-url first-line-only="true">file:/secret.txt</password-url>
----


[#password-provider]
=== Custom Password Providers

Password providers allow you to obtain the SSL passwords from any source, including using encryption.

Password providers implement the `com.tangosol.net.PasswordProvider` interface. The class has a get method that returns a password for use in an SSL configuration. You can create your own password provider, or you can use the predefined `com.tangosol.coherence.config.xml.processor.PasswordProviderBuilderProcessor$DefaultPasswordProvider` class. The predefined password provider takes a password of type `string` and returns a password of type `char[]`.

Define password providers in an operational override file by overriding the `<password-providers>` element within the `<cluster-config>` element. The preferred approach is to use the `<password-provider>` element in an SSL configuration to reference a password provider that is defined within a `<password-providers>` node. However, the `<password-provider>` element can also be defined in-line when configuring a password for an SSL socket provider. Both approaches are demonstrated in this section.
See https://docs.oracle.com/pls/topic/lookup?ctx=en/middleware/standalone/coherence/14.1.1.0/secure&id=COHDG-GUID-C4F23EE0-5EBF-49E4-A735-7EF41A53CD9D[password-provider] in _Developing Applications with Oracle Coherence_.

<<example-6-7,Example 6-7>> demonstrates an SSL socket provider configuration that references a password provider that is named `MyPasswordProvider` and is defined within the `<password-providers>` element. The password provider is used to access the identity manager private key and keystore and the trust manager keystore.

[#example-6-7]
=== _Example 6-7 Sample Password Provider Configuration for SSL_

[source,xml]
----
<?xml version='1.0'?>
<coherence xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   xmlns="http://xmlns.oracle.com/coherence/coherence-operational-config"
   xsi:schemaLocation="http://xmlns.oracle.com/coherence/coherence-operational-config
   coherence-operational-config.xsd">
   <cluster-config>
      <socket-providers>
         <socket-provider id="mySSLConfig">
            <ssl>
               <protocol>TLS</protocol>
               <identity-manager>
                  <algorithm>SunX509</algorithm>
                  <key-store>
                     <url>file:server.jks</url>
                     <password-provider>
                        <name>MyPasswordProvider</name>
                        <init-params>
                           <init-param>
                              <param-name>param_1</param-name>
                              <param-value>private</param-value>
                           </init-param>
                        </init-params>
                     </password-provider>
                     <type>JKS</type>
                  </key-store>
                  <password-provider>
                     <name>MyPasswordProvider</name>
                     <init-params>
                        <init-param>
                           <param-name>param_1</param-name>
                           <param-value>private</param-value>
                        </init-param>
                     </init-params>
                  </password-provider>
               </identity-manager>
               <trust-manager>
                  <algorithm>SunX509</algorithm>
                  <key-store>
                     <url>file:trust.jks</url>
                     <password-provider>
                        <name>MyPasswordProvider</name>
                        <init-params>
                           <init-param>
                              <param-name>param_1</param-name>
                              <param-value>private</param-value>
                           </init-param>
                        </init-params>
                     </password-provider>
                     <type>JKS</type>
                  </key-store>
               </trust-manager>
               <socket-provider>tcp</socket-provider>
            </ssl>
         </socket-provider>
      </socket-providers>

      <password-providers>
          <password-provider id="MyPasswordProvider">
              <class-name>package.MyPasswordProvider</class-name>
              <init-params>
                  <init-param>
                      <param-name>param_1</param-name>
                      <param-value>password</param-value>
                  </init-param>
              </init-params>
          </password-provider>
      <password-providers>
   </cluster-config>
</coherence>
----

As an alternative, you can define a password provider in-line within an SSL socket provider configuration as shown
in <<example-6-8,Example 6-8>>:

[#example-6-8]
=== _Example 6-8 Sample In-line Password Provider Configuration for SSL_

[source,xml]
----
<?xml version='1.0'?>
<coherence xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   xmlns="http://xmlns.oracle.com/coherence/coherence-operational-config"
   xsi:schemaLocation="http://xmlns.oracle.com/coherence/coherence-operational-config
   coherence-operational-config.xsd">
   <cluster-config>
      <socket-providers>
         <socket-provider id="mySSLConfig">
            <ssl>
               <protocol>TLS</protocol>
               <identity-manager>
                  <algorithm>SunX509</algorithm>
                  <key-store>
                     <url>file:server.jks</url>
                     <password-provider>
                        <class-name>package.MyPasswordProvider</class-name>
                        <init-params>
                           <init-param>
                              <param-name>param_1</param-name>
                              <param-value>password</param-value>
                           </init-param>
                        </init-params>
                     </password-provider>
                     <type>JKS</type>
                  </key-store>
                  <password-provider>
                     <class-name>package.MyPasswordProvider</class-name>
                     <init-params>
                        <init-param>
                           <param-name>param_1</param-name>
                           <param-value>password</param-value>
                        </init-param>
                     </init-params>
                  </password-provider>
               </identity-manager>
               <trust-manager>
                  <algorithm>SunX509</algorithm>
                  <key-store>
                     <url>file:trust.jks</url>
                     <password-provider>
                        <class-name>package.MyPasswordProvider</class-name>
                        <init-params>
                           <init-param>
                              <param-name>param_1</param-name>
                              <param-value>password</param-value>
                           </init-param>
                        </init-params>
                     </password-provider>
                     <type>JKS</type>
                  </key-store>
               </trust-manager>
               <socket-provider>tcp</socket-provider>
            </ssl>
         </socket-provider>
      </socket-providers>
   </cluster-config>
</coherence>
----


[#keys-and-certs]
== Using Private Key and Certificate Files

The examples in the previous sections used Java keystore files to store the private key and certificates used to establish trust and identity in Coherence SSL. Coherence also supports using private key and certificate files directly, instead of loading them into a keystore.

[NOTE]
====
Out of the box, Coherence only supports file formats supported by the JDK. This is private key files in PEM format (i.e. a file with a header of `-----BEGIN RSA PRIVATE KEY-----` or `-----BEGIN ENCRYPTED PRIVATE KEY-----`) and X509 certificate files (i.e. a file with a header of `-----BEGIN CERTIFICATE-----`). Alternative formats can be read using custom loaders, see <<custom-loaders,Custom Keystore, Private Key and Certificate Loaders>>
====

=== Configuring an Identity Manager

When configuring an `<identity-manager>` element of a socket provider, instead of the `<keystore>` element, the `<key>` and `<cert>` elements can be used to supply the private key a certificate file locations.
The value for both the `<key>` and `<cert>` element is a URL from which to load the key or certificate data.

<<example-6-9,Example 6-9] shows an `<identity-manager>` configuration that uses a private key loaded from the `/coherence/security/client.pem` file and a certificate loaded from the `/coherence/security/client.cert` file.

[#example-6-9]
=== _Example 6-9 Sample Identity Manager using a Private Key and Certificate File_

[source,xml]
----
<socket-provider>
  <ssl>
    <identity-manager>
      <key>file:/coherence/security/client.pem</key>
      <cert>file:/coherence/security/client.cert</cert>
    </identity-manager>
  </ssl>
</socket-provider>
----

When configuring an `<identity-manager>` element, the `<keystore>` element and the `<key>` and `<cert>` elements are mutually exclusive; either configure a keystore, or a key and certificate. The Coherence operational configuration XSD validation will not allow both.

=== Configuring a Trust Manager

When configuring an `<trust-manager>` element of a socket provider, instead of the `<keystore>` element, one or more `<cert>` elements can be used to supply the certificate file locations.
The value for the `<cert>` element is a URL from which to load the certificate data.

<<example-6-9,Example 6-10] shows a `<trust-manager>` configuration that uses a certificate loaded from the `/coherence/security/server-ca.cert` file.

[#example-6-10]
=== _Example 6-10 Sample Trust Manager using a Certificate File_

[source,xml]
----
<socket-provider>
  <ssl>
    <trust-manager>
      <cert>file:/coherence/security/server-ca.cert</cert>
    </trust-manager>
  </ssl>
</socket-provider>
----

When configuring an `<trust-manager>` element, the `<keystore>` element and the `<cert>` elements are mutually exclusive; either configure a keystore, or one or more certificates. The Coherence operational configuration XSD validation will not allow both.

[#custom-loaders]
== Custom Keystore, Private Key and Certificate Loaders

To support loading keystores, private keys and certificates from sources other than simple URLS or files, and to read different data formats, Coherence provides a way to configure custom loaders to read the required data from whatever external source is required. For example in the cloud, keys and certificates can be stored in a secrets service and loaded directly from secrets instead of files.
The https://github.com/oracle/coherence-oci[Coherence OCI] project on GitHub includes custom keystore, key and certificate loaders that can read data from secrets in the Oracle Cloud (OCI) Secrets Service.

=== Custom KeyStore Loader

If using Java Keystores, an instance of a `com.tangosol.net.ssl.KeyStoreLoader` can be implemented in application code and configured in the `<key-store-loader>` element, which is a child of the `<key-store>` element.
This class can load the contents of a Java KeyStore from any desired location.

<<example-6-11,Example 6-11>> Shows a custom implementation of the `KeyStoreLoader` interface.

[#example-6-11]
==== _Example 6-11 A Custom KeyStore Loader Class_

[source,java]
.CustomKeyStoreLoader.java
----
package com.acme.coherence;

import com.tangosol.net.ssl.KeyStoreLoader;
import java.io.IOException;
import java.security.GeneralSecurityException;
import java.security.KeyStore;

public class CustomKeyStoreLoader
        implements KeyStoreLoader
    {
    @Override
    public KeyStore load(String sType, PasswordProvider password)
            throws GeneralSecurityException, IOException
        {
        // return a KeyStore of the required type
        }
    }
----

<<example-6-12,Example 6-12>> shows how the `CustomKeyStoreLoader` class can be used in an `<identity-manager>` configuration.

[#example-6-12]
==== _Example 6-12 Configure an Identity Manager with a Custom KeyStore Loader Class_

[source,xml]
----
<socket-provider>
  <ssl>
    <identity-manager>
      <key-store>
        <key-store-loader>
          <class-name>com.acme.coherence.CustomKeyStoreLoader</class-name>
        </key-store-loader>
      </key-store>
    </identity-manager>
  </ssl>
</socket-provider>
----

<<example-6-13,Example 6-13>> shows how the `CustomKeyStoreLoader` class can be used in an `<trust-manager>` configuration.

[#example-6-13]
==== _Example 6-13 Configure an Identity Manager with a Custom KeyStore Loader Class_

[source,xml]
----
<socket-provider>
  <ssl>
    <trust-manager>
      <key-store>
        <key-store-loader>
          <class-name>com.acme.coherence.CustomKeyStoreLoader</class-name>
        </key-store-loader>
      </key-store>
    </trust-manager>
  </ssl>
</socket-provider>
----

As with other extension points in Coherence, the `<key-store-loader>` is an "instance" configuration that takes a `class-name` or a `class-factory-name` and `method-name` parameter. Optionally the configuration can also use `<init-params>` to pass parameters to the class constructor or factory method.

<<example-6-14,Example 6-14>> shows how the `CustomKeyStoreLoader` can be refactored to add constructor arguments.

[#example-6-14]
==== _Example 6-14 a Custom KeyStore Loader With Parameters_

[source,java]
.CustomKeyStoreLoader.java
----
package com.acme.coherence;

import com.tangosol.net.ssl.KeyStoreLoader;
import java.io.IOException;
import java.security.GeneralSecurityException;
import java.security.KeyStore;

public class CustomKeyStoreLoader
        implements KeyStoreLoader
    {
    private final String param1;

    private final String param2;

    public CustomKeyStoreLoader(String param1, String param2)
        {
        this.param1 = param1;
        this.param2 = param2;
        }

    @Override
    public KeyStore load(String sType, PasswordProvider password)
            throws GeneralSecurityException, IOException
        {
        // return a KeyStore of the required type
        }
    }
----

<<example-6-15,Example 6-14>> shows how the parameterized `CustomKeyStoreLoader` can be configured.
With the example configuration, the `CustomKeyStoreLoader` constructor will be called with the parameters `foo` and `bar`.

[#example-6-15]
==== _Example 6-15 Configure a Custom KeyStore Loader With Parameters_

[source,xml]
----
<socket-provider>
  <ssl>
    <identity-manager>
      <key-store>
        <key-store-loader>
          <class-name>com.acme.coherence.CustomKeyStoreLoader</class-name>
          <init-params>
            <init-param>
              <param-type>string</param-type>
              <param-value>foo</param-value>
            </init-param>
            <init-param>
              <param-type>string</param-type>
              <param-value>bar</param-value>
            </init-param>
          </init-params>
        </key-store-loader>
      </key-store>
    </trust-manager>
  </ssl>
</socket-provider>
----


At runtime the `CustomKeyStoreLoader` class's `load` method will be called to load the keystore.
In the configurations above the `type` parameter passed to the load method will be the default keystore type ("JKS").
The `PasswordProvider` passed to the load method will be the default null implementation that returns an empty password.


<<example-6-16,Example 6-16>> shows how to configure the keystore type and password, which will be passed as parameters
to the custom `KeyStoreLoader.load`. The example shows using the `<password>` element, but the `<password-url>` or `<password-provider>` elements can also be used to supply the password to the loader.

[#example-6-16]
==== _Example 6-16 Passing the Keystore Type and Password to a Custom KeyStore Loader_

[source,xml]
----
<socket-provider>
  <ssl>
    <identity-manager>
      <key-store>
        <key-store-loader>
          <class-name>com.acme.coherence.CustomKeyStoreLoader</class-name>
        </key-store-loader>
        <password>secret</password>
        <type>PKCS12</type>
      </key-store>
    </identity-manager>
  </ssl>
</socket-provider>
----

=== Custom PrivateKey Loader

If using private keys instead of keystores, an instance of a `com.tangosol.net.ssl.PrivateKeyLoader` can be implemented in application code and configured in the `<key-loader>` element.
The custom loader can then load a `PrivateKey` from any desired location in any required format.

As with other extension points in Coherence, the `<key-loader>` is an "instance" configuration that takes a `class-name` or a `class-factory-name` and `method-name` parameter. Optionally the configuration can also use `<init-params>` to pass parameters to the class constructor or factory method.

<<example-6-17,Example 6-16>> shows a custom `PrivateKeyLoader` class.

[#example-6-17]
==== _Example 6-17 a Custom Private Key Loader_

[source,java]
.CustomKeyStoreLoader.java
----
package com.acme.coherence;

import com.tangosol.net.PasswordProvider;
import com.tangosol.net.ssl.PrivateKeyLoader;
import java.io.IOException;
import java.security.GeneralSecurityException;
import java.security.KeyStore;

public class CustomPrivateKeyLoader
        implements PrivateKeyLoader
    {
    @Override
    public PrivateKey load(PasswordProvider password)
            throws GeneralSecurityException, IOException
        {
        // return a PrivateKey (optionally encrypted with a password)
        }
    }
----

<<example-6-18,Example 6-18>> shows how the `CustomPrivateKeyLoader` class could be configured in the `<identity-manager>` element.

[#example-6-18]
==== _Example 6-18 Configure a Custom Private Key Loader_

[source,xml]
----
<socket-provider>
  <ssl>
    <identity-manager>
        <key-loader>
           <class-name>com.acme.coherence.CustomPrivateKeyLoader</class-name>
        </key-loader>
    </identity-manager>
  </ssl>
</socket-provider>
----

At runtime the `CustomPrivateKeyLoader` class's `load` method will be called to create the `PrivateKey` instance.
In the example above there was no password configured for the key, so the `PasswordProvider` passed to the `load` method will return an empty password (`new char[0]`).
A password can be added using one of the password elements allowed in the `<identity-manager>` elements.

<<example-6-19,Example 6-16>> shows an example configuration with a password. In this example, the `PasswordProvider` will return the contents fetched from the URL `file:/coherence/security/key-pass.txt` as the key password.

[#example-6-19]
==== _Example 6-19 Configure a Password for a Custom Private Key Loader_

[source,xml]
----
<socket-provider>
  <ssl>
    <identity-manager>
      <key-loader>
        <class-name>com.acme.coherence.CustomPrivateKeyLoader</class-name>
      </key-loader>
      <password-url>file:/coherence/security/key-pass.txt</password-url>
    </identity-manager>
  </ssl>
</socket-provider>
----

=== Custom Certificate Loader

If using certificate files in the identity manager or trust manager, an instance of a `com.tangosol.net.ssl.CertificateLoader` can be implemented in application code and configured in the `<cert-loader>` element.
This class can load an array of `Certificate` instances from any desired location in the required format.

As with other extension points in Coherence, the `<cert-loader>` is an "instance" configuration that takes a `class-name` or a `class-factory-name` and `method-name` parameter. Optionally the configuration can also use `<init-params>` to pass parameters to the class constructor or factory method.

<<example-6-20,Example 6-20>> shows an example of a custom `CertificateLoader` class. The `load` method will be called to load the certificates.

[#example-6-20]
==== _Example 6-20 a Custom Certificate Loader_

[source,java]
.CustomKeyStoreLoader.java
----
package com.acme.coherence;

public class CustomCertificateLoader
        implements CertificateLoader
    {
    @Override
    public Certificate[] load()
            throws GeneralSecurityException, IOException
        {
        // return a Certificate array
        }
    }
----

<<example-6-21,Example 6-21>> shows how the `CustomCertificateLoader` class above could be configured in the identity manager.

[#example-6-21]
==== _Example 6-21 Configure a Custom Certificate Loader in an Identity Manager_

[source,xml]
----
<socket-provider>
  <ssl>
    <identity-manager>
      <key>server.pem</key>
      <cert-loader>
        <class-name>com.acme.coherence.CustomCertificateLoader</class-name>
      </cert-loader>
    </identity-manager>
  </ssl>
</socket-provider>
----

<<example-6-22,Example 6-22>> shows how the `CustomCertificateLoader` class above could be configured in the trust manager.

[#example-6-22]
==== _Example 6-22 Configure a Custom Certificate Loader in an Trust Manager_

[source,xml]
----
<socket-provider>
  <ssl>
    <trust-manager>
      <cert-loader>
        <class-name>com.acme.coherence.CustomCertificateLoader</class-name>
      </cert-loader>
    </trust-manager>
  </ssl>
</socket-provider>
----

The `load()` method of the `CertificateLoader` returns an array of certificates, so it can load multiple certificates.
It is also possible to configure multiple `<cert-loader>` elements to use multiple custom loaders.
All the certificates provided by all the `<cert>` or `<cert-loader>` elements will be combined into a single set of certificates for the SSL context to use.

<<example-6-23,Example 6-23>> shows how multiple `<cert>` and custom loaders could be configured in a trust manager.

[#example-6-23]
==== _Example 6-23 Configure Multiple Certificates and Loaders in a Trust Manager_

[source,xml]
----
<socket-provider>
  <ssl>
    <trust-manager>
      <cert>server-ca.cert</cert>
      <cert-loader>
        <class-name>com.acme.coherence.CustomCertificateLoader</class-name>
        <init-params>
          <init-param>
            <param-type>string</param-type>
            <param-value>foo</param-value>
          </init-param>
        </init-params>
      </cert-loader>
      <cert-loader>
        <class-name>com.acme.coherence.CustomCertificateLoader</class-name>
        <init-params>
          <init-param>
            <param-type>string</param-type>
            <param-value>bar</param-value>
          </init-param>
        </init-params>
      </cert-loader>
    </trust-manager>
  </ssl>
</socket-provider>
----


[#refresh]
== Refreshable KeyStores, Private Keys and Certificates

In some environments, keys and certs used for TLS are created with relatively short lifetimes.
This means that a Coherence application needs to be able to renew the keys and certs, ideally without having to restart the JVM. In versions of Coherence prior to 22.06, this was not possible, as a Keystore was loaded once when the socket provider was instantiated. From version 22.06 it is possible to specify a refresh period, which will then schedule a refresh of the SSL context, reloading any configured keystores, private keys and certificates.

The `<refresh-period>` element is used to configure the refresh time.
This is a child element of the `ssl` element, meaning the setting applies to both the identity manager and trust manager.

<<example-6-24,Example 6-24>> configures a `<refresh-period>` element with a value of `24h`, so the keys and certs will be refreshed every 24 hours.

[#example-6-24]
=== _Example 6-24 Configure a Refresh Period_

[source,xml]
----
<socket-provider>
  <ssl>
    <identity-manager>
      <key>server.pem</key>
      <cert>server.cert</cert>
    </identity-manager>
    <refresh-period>24h</refresh-period>
  </ssl>
</socket-provider>
----

Refreshable keystores, keys and certs can easily be combined with custom keystore loaders, private key loaders, and certificate loaders, so that new versions of the required SSL artifacts can be pulled from an external source.


=== Configuring a Refresh Policy

When using refreshable keys and certs it may sometimes be useful to have an additional check to determine whether a refresh should occur. This can be achieved by configuring a `<refresh-policy>` as well as a `<refresh-period>`.

The `<refresh-policy>` element is a standard Coherence `instance` configuration and should resolve to an instance
of a `com.tangosol.net.ssl.RefreshPolicy`.
When a scheduled refresh time is reached the policy is checked first (by calling the `RefreshPolicy.shouldRefresh()` method) to determine whether the refresh should go ahead.

<<example-6-25,Example 6-25>> shows an example of a custom `RefreshPolicy` implementation.

[#example-6-25]
=== _Example 6-25 A Custom Refresh Policy Class_

[source,java]
.CustomRefreshPolicy.java
----
package com.acme.coherence;

public class CustomRefreshPolicy
        implements RefreshPolicy
    {
    @Override
    public boolean shouldRefresh(Dependencies deps, ManagerDependencies depsIdMgr, ManagerDependencies depsTrustMgr)
        {
        // perform some custom logic to determine whether it is time to refresh
        return true;
        }
    }
----

<<example-6-26,Example 6-26>> shows how the custom refresh policy can then be configured as part of
the `<ssl>` element alongside the `<refresh-period>`

[#example-6-26]
=== _Example 6-26 Configure a Custom Refresh Policy_

[source,xml]
----
<socket-provider>
  <ssl>
    <identity-manager>
      <key>server.pem</key>
      <cert>server.cert</cert>
    </identity-manager>
    <refresh-period>24h</refresh-period>
    <refresh-policy>
      <class-name>com.acme.coherence.CustomRefreshPolicy</class-name>
    </refresh-policy>
  </ssl>
</socket-provider>
----

For some policies, it may be useful to know what keystores, keys or certs are currently in use to determine whether they need to be refreshed. There are a number of default methods on `RefreshPolicy` that can be overridden for this purpose.

<<example-6-27,Example 6-27>> shows how certificates used by a trust store configuration can be captured and then used to verify whether they are close to expiry. In the `CustomRefreshPolicy` below, the `trustStoreLoaded` method is called when the trust store is created to notify the policy of the certificates used by the trust store. In the `shouldRefresh` method the certificates can then be checked to determine whether they will still be valid at the next refresh interval.

[#example-6-27]
=== _Example 6-27 A Detailed Custom Certificate Refresh Policy_

[source,java]
.CustomRefreshPolicy.java
----
import com.oracle.coherence.common.net.SSLSocketProvider.Dependencies;
import com.oracle.coherence.common.util.Duration;
import com.tangosol.coherence.config.builder.SSLSocketProviderDependenciesBuilder.ManagerDependencies;
import com.tangosol.coherence.config.unit.Seconds;
import com.tangosol.net.ssl.RefreshPolicy;

import java.security.cert.Certificate;
import java.security.cert.CertificateExpiredException;
import java.security.cert.CertificateNotYetValidException;
import java.security.cert.X509Certificate;
import java.util.Date;

public class CustomRefreshPolicy
        implements RefreshPolicy
    {
    private Certificate[] certs;

    @Override
    public void trustStoreLoaded(Certificate[] certs)
        {
        this.certs = certs;
        }

    @Override
    public boolean shouldRefresh(Dependencies deps, ManagerDependencies depsIdMgr, ManagerDependencies depsTrustMgr)
        {
        if (certs == null)
            {
            return true;
            }

        // get the refresh period from the dependencies
        Seconds secs = deps.getRefreshPeriod();
        // calculate the next refresh time as a Date
        Date nextRefresh = new Date(System.currentTimeMillis() + secs.as(Duration.Magnitude.MILLI));

        for (Certificate certificate : certs)
            {
            try
                {
                // The certs are all X509 certs, so check their validity on the next refresh date
                ((X509Certificate) certificate).checkValidity(nextRefresh);
                }
            catch (CertificateExpiredException | CertificateNotYetValidException e)
                {
                // a cert will have expired, so we need to update now
                return true;
                }
            }

        // no certs should have expired at the next refresh check
        return false;
        }
    }
----

<<example-6-28,Example 6-28>> shows how the `CustomRefreshPolicy` class can then be configured in the `<ssl>` configuration.

[#example-6-28]
=== _Example 6-28 Configure the Custom Certificate Refresh Policy_

[source,xml]
----
<socket-provider>
  <ssl>
    <trust-manager>
      <ca-cert>server-ca.cert</ca-cert>
      <ca-cert>client-ca.cert</ca-cert>
    </trust-manager>
    <refresh-period>24h</refresh-period>
    <refresh-policy>
      <class-name>com.acme.coherence.CustomRefreshPolicy</class-name>
    </refresh-policy>
  </ssl>
</socket-provider>
----


[#operational]
== Operational Configuration Element Reference

This section details changes to the
https://docs.oracle.com/en/middleware/standalone/coherence/14.1.1.0/develop-applications/operational-configuration-elements.html#GUID-6FD7679F-C4A3-4B74-8B81-8C5B7929BC18[Operational Configuration Element Reference] documentation based on the SSL configuration changes introduced in Coherence 22.06.

The following elements have changes

* <<identity,identity-manager>>
* <<keystore,key-store>>
* <<ssl,ssl>>
* <<trust,trust-manager>>


[#identity]
=== identity-manager

Use in: <<ssl,ssl>>

*Description*
The <identity-manager> element contains the configuration information for initializing a javax.net.ssl.KeyManager instance.

The identity manager is responsible for managing the key material which is used to authenticate the local connection to its peer. If no key material is available, the connection cannot present authentication credentials.

*Elements*

<<table-a-25,Table A-25>> describes the subelements of the `identity-manager` element.

[#table-a-25]
*Table A-25 identity-manager Subelements*
|===
|Element |Required/ Optional |Description

| `<algorithm>`
| Optional
a| Specifies the algorithm used by the identity manager. The default value is `SunX509`.

| https://docs.oracle.com/en/middleware/standalone/coherence/14.1.1.0/develop-applications/operational-configuration-elements.html#GUID-5BB03F1C-D70C-4F44-9B09-2480796E67D9[`<provider>`]
| Optional
a| Specifies the configuration for a security provider instance.

| `<key-store>`
| Optional
a| Specifies the configuration for a key store implementation.

The `<key-store>` element cannot be specified if the `<key>`, `<key-loader>`, `<cert>` or `<cert-loader>` elements are specified.

| `<key>`
| Optional
a| Specifies the URL to load a private key from.

The `<key>` element cannot be specified if the `<key-store>` or `<key-loader>` elements are specified.

| `<key-loader>`
| Optional
a| Configures a custom implementation of `com.tangosol.net.ssl.PrivateKeyLoader` that will provide a `PrivateKey`.

A `<class-name>` subelement is used to provide the name of a class that implements the `com.tangosol.net.ssl.PrivateKeyLoader` interface. As an alternative, use a `<class-factory-name>` subelement to specify a factory class for creating `PrivateKeyLoader` instances and a `<method-name>` subelement that specifies the name of a static factory method on the factory class which performs object instantiation. Either approach can specify initialization parameters using the `<init-params>` element.

The `<key-loader>` element cannot be specified if the `<key>` element is specified.

| `<cert>`
| Optional
a| Specifies the URL to load a certificate from.

The `<cert>` element cannot be specified if the `<key-store>` element is specified.

| `<cert-loader>`
| Optional
a| Configures a custom implementation of `com.tangosol.net.ssl.CertificateLoader` that will provide a `Certificate`.

A `<class-name>` subelement is used to provide the name of a class that implements the `com.tangosol.net.ssl.CertificateLoader` interface. As an alternative, use a `<class-factory-name>` subelement to specify a factory class for creating `CertificateLoader` instances and a `<method-name>` subelement that specifies the name of a static factory method on the factory class which performs object instantiation. Either approach can specify initialization parameters using the `<init-params>` element.

The `<cert-loader>` element cannot be specified if the `<key-store>` element is specified.

| `<password>`
| Optional
a| Specifies the private key password.

This element cannot be used with the `<password-provider>` or `<password-url>` elements.

| `<password-url>`
| Optional
a| Specifies the file or simple URL to read the private key password from.

This element cannot be used with the `<password>` or `<password-provider>` elements.

| https://docs.oracle.com/en/middleware/standalone/coherence/14.1.1.0/develop-applications/operational-configuration-elements.html#GUID-C4F23EE0-5EBF-49E4-A735-7EF41A53CD9D[`<password-provider>`]
| Optional
a| Specifies a password provider implementation for retrieving the private key password.

This element cannot be used with the `<password>` or `<password-url>` elements.
|===

[#keystore]
=== key-store
Used in: <<identity,identity-manager>> and <<trust,trust-manager>>.

*Description*

The `key-store` element specifies the configuration for a key store implementation to use when implementing SSL. The key store implementation is an instance of the `java.security.KeyStore` class.

*Elements*

<<table-34,Table A-34>> describes the subelements of the `key-store` element.

[#table-a-34]
*Table A-34 key-store Subelements*

|===
|Element |Required/Optional |Description

| `<url>`
| Required if the `<key-store-loader>` is not specified
a| Specifies the Uniform Resource Locator (URL) to a key store.

The `<url>` element cannot be specified if the `<key-store-loader>` element is specified.

| `<key-store-loader>`
| Required if the `<url>` is not specified
a| Configures a custom implementation of `com.tangosol.net.ssl.KeyStoreLoader` that will provide a `KeyStore`.

A `<class-name>` subelement is used to provide the name of a class that implements the `com.tangosol.net.ssl.KeyStoreLoader` interface. As an alternative, use a `<class-factory-name>` subelement to specify a factory class for creating `KeyStoreLoader` instances and a `<method-name>` subelement that specifies the name of a static factory method on the factory class which performs object instantiation. Either approach can specify initialization parameters using the `<init-params>` element.

The `<key-store-loader>` element cannot be specified if the `<url>` element is specified.

| `<password>`
| Optional
a| Specifies the password for the key store.

This element cannot be used with the `<password-provider>` or `<password-url>` elements.

| `<password-url>`
| Optional
a| Specifies the file or simple URL to read the the key store password.

This element cannot be used with the `<password>` or `<password-provider>` elements.

| https://docs.oracle.com/en/middleware/standalone/coherence/14.1.1.0/develop-applications/operational-configuration-elements.html#GUID-C4F23EE0-5EBF-49E4-A735-7EF41A53CD9D[`<password-provider>`]
| Optional
a| Specifies a password provider implementation for retrieving the key store password.

This element cannot be used with the `<password>` or `<password-url>` elements.

| `<type>`
| Optional
a| Specifies the type of a `java.security.KeyStore` instance. The default value is `JKS`.
|===



[#ssl]
=== ssl
Used in: https://docs.oracle.com/en/middleware/standalone/coherence/14.1.1.0/develop-applications/operational-configuration-elements.html#GUID-FA62570C-D64E-417E-AFBB-133862864C65[socket-provider].

*Description*

The `<ssl>` element contains the configuration information for a socket provider that produces socket and channel implementations which use SSL. If SSL is configured for the unicast listener, the listener must be configured to use well known addresses.

*Elements*

<<table-a-86,Table A-86>> describes the subelements of the `ssl` element.

[#table-a-86]
*Table A-86 ssl Subelements*

|===
|Element |Required/ Optional |Description

| `<protocol>`
| Optional
a| Specifies the name of the protocol used by the socket and channel implementations produced by the SSL socket provider. The default value is `TLS`.

| `<provider>`
| Optional
a| Specifies the configuration for a security provider instance.

| `<executor>`
| Optional
a| Specifies the configuration information for an implementation of the `java.util.concurrent.Executor` interface.

A `<class-name>` subelement is used to provide the name of a class that implements the Executor interface. As an alternative, use a `<class-factory-name>` subelement to specify a factory class for creating Executor instances and a `<method-name>` subelement that specifies the name of a static factory method on the factory class which performs object instantiation. Either approach can specify initialization parameters using the `<init-params>` element.

| <<identity,`<identity-manager>`>>
| Optional
a| Specifies the configuration information for initializing an identity manager instance.

| <<trust,`<trust-manager>`>>
| Optional
a| Specifies the configuration information for initializing a trust manager instance.

| `<hostname-verifier>`
| Optional
a| Coherence provides a default implementation of HostnameVerifier.

Use the `<action>` subelement to specify the action that the default hostname verifier should take during the SSL handshake if there is a mismatch between the host name in the URL and the host name in the digital certificate that the server sends back as part of the SSL connection. `<action>` takes one of the following two possible values:

* *allow*: Allow all connections. There is no hostname verification. For backwards compatibility, this is the default option.

* *default*: Use the default hostname verifier to verify the host. The host name verification passes if the host name in the certificate matches the host name in the URL to which the client connects. It also allows wild-card Subject Alternate Names (SAN) and Common Names (CN). If you do not want a match against CN if SAN DNS names are present, set the system property coherence.security.ssl.verifyCNAfterSAN to false. If the URL specifies localhost, you can set the system property coherence.security.ssl.allowLocalhost to true to allow `127.0.0.1`, or the default IP address of the local machine.

You can also specify the configuration information for an implementation of the `javax.net.ssl.HostnameVerifier` interface. During the SSL handshake, if the URL's host name and the server's identification host name mismatch, the verification mechanism calls back to this instance to determine if the connection should be allowed.

A `<class-name>` subelement is used to provide the name of a class that implements the `HostnameVerifier` interface. As an alternative, use a `<class-factory-name>` subelement to specify a factory class for creating `HostnameVerifier` instances and a `<method-name>` subelement that specifies the name of a static factory method on the factory class which performs object instantiation. Either approach can specify initialization parameters using the `<init-params>` element.

For more information about host name verification, see
https://docs.oracle.com/pls/topic/lookup?ctx=en/middleware/standalone/coherence/14.1.1.0/develop-applications&id=COHSG-GUID-436A16D3-509A-4F99-944D-C878B3A480D5[Using a Custom Host Name Verifier] in _Securing Oracle Coherence_.

| `<cipher-suites>`
| Optional
a| Specifies a list of ciphers. Use the name element within the `cipher-suites` element to enter a cipher. Multiple name elements can be specified.

Use the `usage` attribute to specify whether the list of ciphers are allowed or disallowed. If the `usage` attribute value is `black-list`, then the specified ciphers are removed from the default enabled cipher list. If the usage attribute value is`` white-list``, then the specified ciphers are the enabled ciphers. The default value if the usage attribute is not specified is `white-list`.

| `<protocol-versions>`
| Optional
a| Specifies a list of protocol versions. Use the name element within the protocol-versions element to enter a protocol version. Multiple name elements can be specified.

Use the `usage` attribute to specify whether the list of protocol versions are allowed or disallowed. If the `usage` attribute value is `black-list`, then the specified protocol versions are removed from the default enabled protocol list. If the `usage` attribute value is `white-list`, then the specified protocol versions are the enabled protocols. The default value if the usage attribute is not specified is `white-list`.

| <socket-provider>
| Optional
a| Specifies the configuration information for a delegate provider for SSL. Valid values are `tcp` and `sdp`. The default value is `tcp`.

| <refresh-period>
| Optional
a| The `refresh-period` element specifies the period to use to attempt to refresh keys and certs. This is used in cases where keys or certs have a short lifetime and need to be refreshed at runtime.

If this element is omitted or is set to a value less than or equal to zero, then keys and certs will not be refreshed.

The value of this element must be in the following format:

  `(\d)+((.)(\d)+)?(MS\|ms\|S\|s\|M\|m\|H\|h\|D\|d)?`

where the first non-digits (from left to right) indicate the unit of time duration:

 -MS or ms (milliseconds)

 -S or s (seconds)

 -M or m (minutes)

 -H or h (hours)

 -D or d (days)

If the value does not contain a unit, a unit of seconds is assumed.

| <refresh-policy>
| Optional
a| The `refresh-policy` element contains the configuration info for a refresh policy that extends the `com.tangosol.net.ssl.RefreshPolicy` class.

A `<class-name>` subelement is used to provide the name of a class that implements the `RefreshPolicy` interface. As an alternative, use a `<class-factory-name>` subelement to specify a factory class for creating `RefreshPolicy` instances and a `<method-name>` subelement that specifies the name of a static factory method on the factory class which performs object instantiation. Either approach can specify initialization parameters using the `<init-params>` element.
|===


[#trust]
=== trust-manager

Use in: <<ssl,ssl>>

*Description*

The `<trust-manager>` element contains the configuration information for initializing a javax.net.ssl.TrustManager instance.

A trust manager is responsible for managing the trust material that is used when making trust decisions and for deciding whether credentials presented by a peer should be accepted.

A valid trust-manager configuration contains at least one child element.

*Elements*

<<table-a-93,Table A-93>> describes the elements of the `trust-manager` element.

[#table-a-93]
*Table A-93 trust-manager Subelements*

|===
|Element |Required/ Optional |Description

| `<algorithm>`
| Optional
a| Specifies the algorithm used by the trust manager. The default value is SunX509.

| `<provider>`
| Optional
a| Specifies the configuration for a security provider instance.

| `<key-store>`
| Optional
a| Specifies the configuration for a key store implementation.

The `<key-store>` element cannot be specified if the `<cert>` or `<cert-loader>` elements are specified.

| `<cert>`
| Optional
a| Specifies the URL to load a certificate from. Multiple `<cert>` elements can be specified to load multiple certificates.

The `<cert>` element cannot be specified if the `<key-store>` element is specified.

| `<cert-loader>`
| Optional
a| Configures a custom implementation of `com.tangosol.net.ssl.CertificateLoader` that will provide a `Certificate`. Multiple `<cert-loader>` elements can be specified to load multiple certificates.

A `<class-name>` subelement is used to provide the name of a class that implements the `com.tangosol.net.ssl.CertificateLoader` interface. As an alternative, use a `<class-factory-name>` subelement to specify a factory class for creating `CertificateLoader` instances and a `<method-name>` subelement that specifies the name of a static factory method on the factory class which performs object instantiation. Either approach can specify initialization parameters using the `<init-params>` element.

The `<cert-loader>` element cannot be specified if the `<key-store>` element is specified.
|===
