///////////////////////////////////////////////////////////////////////////////
    Copyright (c) 2000, 2022, Oracle and/or its affiliates.

    Licensed under the Universal Permissive License v 1.0 as shown at
    http://oss.oracle.com/licenses/upl.
///////////////////////////////////////////////////////////////////////////////
= Certificate-Based Security
:description: Coherence Guides
:keywords: coherence, java, documentation, guides

== Certificate-Based Security

Coherence allows you to enable an access controller to help protect against unauthorized use of cluster resources.
The default access controller implementation is based on the key management infrastructure that is part of the JDK
and uses Java Authentication and Authorization Service (JAAS) for authentication.
The default implementation is documented in the
https://docs.oracle.com/en/middleware/fusion-middleware/coherence/14.1.2/secure/using-access-controller.html#GUID-67150521-FD59-446F-9A00-A9647DFEE476[Using an Access Controller] section of the Coherence documentation.

Coherence Extend can also be configured to use the same certificate-based security mechanism to secure client access.
This requires custom implementations and configuration of the standard Extend `IdentityTransformer` and `IdentityAsserter` interfaces. Implementations of these classes are included in this example.

=== What You Will Build

The controller built in this example will use a different mechanism to verify the identity and trust of a caller.
Instead of requiring a key store containing all the possible caller's public certificates, this controller will
use a trust store to verify that the caller's certificate has been signed by a trusted CA.


// Do not change this part.
// If your example requires Java 11+ change the 1.8 below to 11
=== What You Need
:java_version: 11
include::../../internal/includes/what-you-need.adoc[tag=text]

// Do not change this part unless you have more complex build instructions.
==== Building the Example Code
include::../../internal/includes/simple-build.adoc[tag=text]

== Custom Access Controller

The default access controller has some very specific requirements and limitations regarding how it works:

- The default controller requires a Java key store that contains all the public certificates for any cluster member
that may join the cluster. This key store is loaded once when the cluster member starts.
This is straightforward in an environment where all members share a common key store, but is less practical
in environments where keys and certs are provided for individual server hosts, or are provided dynamically at runtime.

- The identity of a calling client is verified by finding its corresponding public certificate in the configured
key store using the principal name to look up the certificate. This is then used to decrypt a value that was encrypted
by the caller using its private key.

- The default controller uses an XML file to specify the permissions to apply to different principals.
This file is loaded by the default controller when the cluster member starts and cannot be altered at runtime.

For some use cases, these restrictions make the default controller impractical to use, so a custom controller is required.
The Coherence documentation does not go into details on how a custom controller has to be implemented, so that is what
this example will cover.

=== Creating a Custom Access Controller

An access controller has to implement three methods from the `com.tangosol.net.security.AccessController` interface.

[source,java]
----
void checkPermission(ClusterPermission permission, Subject subject);

SignedObject encrypt(Object o, Subject subject)
        throws IOException, GeneralSecurityException;

Object decrypt(SignedObject so, Subject subjectRemote, Subject subjectThis)
        throws ClassNotFoundException, IOException, GeneralSecurityException;
----

In this example, the required functionality has been separated out into different classes.
This makes it easier to use this example as a base for other custom controllers.

==== Permission Checking

The `checkPermission` method is required to verify that a specified `Principal` has a requested permission.
If not, the method throws an exception. In this example permission checks have been extracted into a
separate interface named `PermissionChecker` with a single `checkPermission` method. 

The example contains an implementation of `PermissionsChecker` that uses the exact same XML permissions file
checking method as the Coherence default controller.

It would be simple to then extend this example to use other custom implementations of `PermissionChecker` that used
other checking methods, for example, LDAP lookups, security groups, certificate usages, etc.

==== Encryption

The access controller `encrypt` method is used by a calling member to encrypt a value.
Coherence calls this method and passes in a value to be encrypted. The resulting `SignedObject` is sent to
the remote Coherence cluster member and decrypted using the caller's public key as part of the verification process.
In this way, the remote cluster member can assume that the caller was in possession of the subjects private and
public keys.

The `encrypt` method is quite straight forward. A private key is obtained for the specified `Subject`.
In this example, the private key comes from the subject's private credentials loaded as part of the
JAAS login process. The private keys could easily be provided from another external security system.

==== Decryption

The access controller `decrypt` method is used by a Coherence cluster member as part of the process of verifying
a remote calling subject. The token encrypted by the caller using its private key will be decrypted by the
`decrypt` method using a public key. As part of this process, trust must also be verified for the caller's subject.
The public key must be obtained for the calling subject. In the default access controller, the public key must be in the
key store the access controller is using, which also verifies trust. In this example the public key is sent by the
caller, so trust is verified using a different method.

==== The Encrypt/Decrypt Algorithm

The default access controller uses the `SHA1withDSA` encryption algorithm, which will therefore only work with
keys and certs that also use that algorithm. In this example, the keys and certs use the `SHA256withRSA` algorithm.
It is possible to change the default algorithm, but this is not well documented and requires an additional
XML configuration file. The custom controller created in this example uses a constructor parameter to allow the
algorithm to be overridden, which is much more flexible than the default controller.

==== Verifying Trust

In the default access controller, trust is verified for a caller by only using public keys that are contained in the
key store loaded by the access controller. Even if the calling subject sent public credentials, these are ignored and
only public keys in the default controller's key store are used for the decrypt process.
As already stated, this is quite restrictive and inflexible.

The custom access controller in this example verifies trust by ensuring that the caller's public key has been signed
by a trusted CA certificate contained in a trust store. A trust store is just a Java key store that contains
one or more CA certificates.

This is much more flexible as it is easier to use a known set of acceptable CA certificates and then allow any
client using a properly signed certificate to connect. As long as that client has a principal with a name that
is authorized by the `PermissionCheck` then it will be able to access the cluster.

=== The BaseAccessController Class

The example contains an abstract `BaseAccessController` class which contains a lot of the boilerplate code
required to write an access controller. This then makes it simpler to extend this example to build other
custom access controllers. The default controller built class into Coherence is final, so it is not possible
to extend it and reuse any of its code. The `BaseAccessController` contains much of the code from the
default controller extracted out into a simple base class.

The `BaseAccessController` does not contain any of the permission checking code from the default controller.
As already mentioned, this code has been extracted out into the `PermissionChecker` interface.
The `BaseAccessController` requires an implementation of a `PermisssionChecker` passed as a constructor
parameter, which is then called by the `BaseAccessController.checkPermission` method.
This again makes it simple to plug other permission checking implementations into the example.

The `BaseAccessController` has two abstract methods that subclasses must implement:

[source,java]
----
protected abstract PrivateKey getPrivateKey(Subject subject);

protected abstract Set<PublicKey> verifyTrust(Subject subject) throws GeneralSecurityException;
----

The `getPrivateKey` method uses some mechanism to supply a `PrivateKey` for a given `Subject`.

The `verifyTrust` method uses some mechanism to verify trust in a specified subject and return the set of
`PublicKey` instances to use for that `Subject`. If trust cannot be verified a  `GeneralSecurityException`
is thrown.

=== The CertAccessController Class

The access controller implementation built in this example is the `CertAccessController` class.

==== Private Keys

The `CertAccessController.getPrivateKey()` method just extracts and returns the first `PrivateKey` contained
in the subject's set of private credentials.
In this example the `Subject` will have been created as part of the JAAS login process where the principal,
private and public keys are loaded from a key store using a custom JAAS `LoginModule`.

[source,java]
.CertAccessController.java
----
@Override
protected PrivateKey getPrivateKey(Subject subject)
    {
    Set<Object> setPrivateCreds = subject.getPrivateCredentials();
    if (setPrivateCreds == null)
        {
        return null;
        }

    for (Object oCred : setPrivateCreds)
        {
        PrivateKey keyPrivate = null;
        if (oCred instanceof PrivateKey)
            {
            keyPrivate = (PrivateKey) oCred;
            }
        else if (oCred instanceof X500PrivateCredential)
            {
            keyPrivate = ((X500PrivateCredential) oCred).getPrivateKey();
            }

        if (keyPrivate != null)
            {
            return keyPrivate;
            }
        }
    return null;
    }
----

- If the `Subject` passed to the method has no private credentials, then a `null` result is returned.
- The `getPrivateKey` method iterates over the subjects' private credentials (which is a set of Object) looking for
an entry implementing either `PrivateKey` or an `X500PrivateCredential` containing a private key.
The first private key found is then returned.

As long as the Subject produced by the JAAS login contains all the required parts (private key, public key and principal), it could have been loaded by any suitable login module.

==== Trust Verification

The `CertAccessController` uses a trust store to verify a public key was signed by a trusted CA certificate.
The trust store is loaded when the `CertAccessController` class is constructed.

The file name of the trust store, its type (JKS or PKCS12) and its password are provided as constructor parameters.
Typically, as a trust store only contains CA certificates, it is not really necessary to password protect them.
The trust store is just a normal Java key store file, and is loaded from the file system in the usual way.

[source,java]
.CertAccessController.java
----
private KeyStore loadKeyStore(File file, char[] pwd, String sType)
    {
    if (file == null)
        {
        throw new IllegalArgumentException("file cannot be null");
        }
    if (sType == null || sType.isEmpty())
        {
        sType = DefaultController.KEYSTORE_TYPE;
        }
    try
        {
        KeyStore store = KeyStore.getInstance(sType);
        try (InputStream in = new FileInputStream(file))
            {
            store.load(in, pwd == null ? new char[0] : pwd);
            }
        return store;
        }
    catch (Exception e)
        {
        throw Exceptions.ensureRuntimeException(e, "Failed to load keystore: " + file.getAbsolutePath());
        }
    }
----

Once the trust store is loaded, it can be used to verify the public credentials in a Subject.
The process for this is:

- Get the list of `CertPath` instances for the `Subject`

[source,java]
.CertAccessController.java
----
private List<CertPath> findCertPaths(Subject subject)
    {
    if (subject == null)
        {
        return List.of();
        }
    return subject.getPublicCredentials()
              .stream()
              .filter(CertPath.class::isInstance)
              .map(CertPath.class::cast)
              .collect(Collectors.toList());
    }
----

- Use Java's built in `CertPathValidator` to validate the certificate paths using the trust store
In the code below, a `java.security.cert.CertPathValidator` is created to perform the trust validation.
The way this works using a `PKIXParameters` instance to hold the trust store is taken from Java's documentation
on using a `CertPathValidator`.

The `CertAccessController.verifyTrust()` method will iterate over the list of `CertPath` instances from the `Subject`.
A `Subject` could contain multiple `CertPath` instances, and as long as one of those passes validation the subject
is considered as trusted.

[source,java]
.CertAccessController.java
----
@Override
protected Set<PublicKey> verifyTrust(Subject subject) throws GeneralSecurityException
    {
    List<CertPath> list = findCertPaths(subject);
    if (list.isEmpty())
        {
        throw new GeneralSecurityException("No certificates found");
        }
    PKIXParameters parameters = new PKIXParameters(f_trustStore);
    parameters.setRevocationEnabled(false);

    CertPathValidator validator = CertPathValidator.getInstance("PKIX");
    Throwable error = null;
    for (CertPath certPath : list)
        {
        try
            {
            PKIXCertPathValidatorResult result = (PKIXCertPathValidatorResult) validator.validate(certPath, parameters);
            return Set.of(result.getPublicKey());
            }
        catch (Throwable t)
            {
            error = t;
            }
        }
    throw new GeneralSecurityException("Failed to verify subject " + subject.getPrincipals()
            .stream()
            .map(Principal::getName)
            .collect(Collectors.joining(",")), error);
    }
----

=== JAAS Login

To use an access controller, the JVM must be configured to be able to perform a JAAS login to create a `Subject` containing
a `Principal`, a set of private credentials and a set of public credentials.
In this example, a Java keystore containing a signed public/private key will be used with a custom JAAS login module.

The example code contains a custom login module class `com.oracle.coherence.guides.security.KeystoreLogin`.
The `coherence-login.jar` module contains an almost identical class, but at the time of writing this example that class
contains a bug. The `KeystoreLogin` class in the `coherence-login` module uses the name of the certificate issuer as the principal name instead of the actual certificate name as the principal name. The `KeystoreLogin` class in this example fixes that issue.

To perform a JAAS login, a JAAS configuration file is required that specifies the configuration for the `Coherence` login module. For example, the test code contains the following file:

[source]
.src/test/resources/cert-login.config
----
Coherence {
    com.oracle.coherence.guides.security.KeystoreLogin required
      keyStorePath="${coherence.security.keystore}"
      keyStoreType="PKCS12"
};
----

This files configures the login module named `Coherence` followed by its configuration inside curly brackets.
This is all standard JAAS configuration.
In this example the login module class to use is `com.oracle.coherence.guides.security.KeystoreLogin` and is marked as required.
This is followed by key/value pairs of configuration to be passed to the `KeystoreLogin` class.
The `KeystoreLogin` class requires the location of the key store and optionally the key store type.
In this example the key store location is passed in as a system property inside `${}`, so the location will
be read from the `coherence.security.keystore` system property at runtime.
This example uses PKCS12 key store types rather than the older JKS type.

==== Callback Handlers

A JAAS login module, such as the example `KeystoreLogin` uses callback handlers to provide it with values
during the login process. Typically, these are values such as a username or passwords, but could be anything
required by the login module. A login module is supplied with a callback handler and calls this with different types
of `Callback` to request the information it required.

In the case of the example `KeystoreLogin` class it requires two values at runtime.

- First is the name of the alias to use to retrieve the key and cert from the keystore, so it calls the callback handler with a `NameCallback` to retrieve the alias name.
- The second is the password to use to read the key and cert from the keystore, so it calls the callback handler with a `PasswordCallback` to retrieve the password.

As this example uses PKCS12 key stores, there is only a single password required, because PKCS12 requires any protected keys
inside the keystore to use the same password as the key store itself.

This example included a callback handler implementation in the  `src/test/java/com/oracle/coherence/guides/security/TestCallBackHandler.java` file.
This gets the password from a system property, which is ok for testing, but a more secure method may be required for production. The alias name is taken from another system property, or if that is not provided then from the Coherence member name.

==== Performing a JAAS Login

When security is enabled and when Coherence needs to execute code that requires a Subject it will first check to see
whether the current thread has a `Subject` attached. If it does that `Subject` is used, if not a JAAS login is performed
to obtain a `Subject`. This means that Coherence will work securely regardless of how it was actually started.
For example, if Coherence is started using the `com.tangosol.net.Coherence` class there will be no `Subject` initially and
Coherence will perform a JAAS login each time one is required. This could mean that a login is performed a number of times
as different threads execute that require permissions. A workaround to this is to create a custom main class that
bootstraps Coherence inside a `Subject` context.

For example:
[source,java]
----
import com.taongosol.net.Coherence;
import com.tangosol.net.security.Security;

public class SecureCoherence
    {
    public static void main (String[] args)
        {
        Subject subject = Security.login(new TestCallBackHandler());
        Subject.doAs(subject, (PrivilegedAction<Void>) () ->
            {
            Coherence.main(args);
            return null;
            });
        }
    }
----

When a login is performed using the example, the `KeystoreLogin` will call the `TestCallBackHandler` to get the
alias name and key password. It then gets the key and certificate pair for that alias from the configured key store.
These are then used to create a `Subject`.

This is all standard JAAS functionality and nothing specific to Coherence is involved.

=== Configuring the Custom Access Controller

To make Coherence use the access controller, the `<security>` section of the operation configuration file
(also known as the override file) must be configured.
This configuration is documented in the
https://docs.oracle.com/en/middleware/fusion-middleware/coherence/14.1.2/secure/using-access-controller.html#GUID-67150521-FD59-446F-9A00-A9647DFEE476[Using an Access Controller] section of the Coherence documentation.
The XML below is the configuration for the custom access controller used in this example.

[source,xml]
.cert-override.xml
----
<coherence xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
           xmlns="http://xmlns.oracle.com/coherence/coherence-operational-config"
           xsi:schemaLocation="http://xmlns.oracle.com/coherence/coherence-operational-config coherence-operational-config.xsd">

    <security-config>
        <enabled system-property="coherence.security">true</enabled>
        <access-controller>
            <class-name>com.oracle.coherence.guides.security.CertAccessController</class-name>
            <init-params>
                <init-param id="1">
                    <param-type>java.io.File</param-type>
                    <param-value system-property="coherence.security.truststore"/>
                </init-param>
                <init-param id="2">
                    <param-type>java.io.File</param-type>
                    <param-value system-property="coherence.security.permissions"/>
                </init-param>
                <init-param id="3">
                    <param-type>java.lang.Boolean</param-type>
                    <param-value system-property="coherence.security.log">true</param-value>
                </init-param>
                <init-param id="4">
                    <param-type>java.lang.String</param-type>
                    <param-value system-property="coherence.security.truststore.password"/>
                </init-param>
                <init-param id="5">
                    <param-type>java.lang.String</param-type>
                    <param-value system-property="coherence.truststore.type">PKCS12</param-value>
                </init-param>
                <init-param id="6">
                    <param-type>java.lang.String</param-type>
                    <param-value system-property="coherence.security.signature">SHA256withRSA</param-value>
                </init-param>
            </init-params>
        </access-controller>
        <callback-handler>
            <class-name>com.oracle.coherence.guides.security.TestCallBackHandler</class-name>
        </callback-handler>
    </security-config>
</coherence>
----

* The `<anabled>` element is used to enable or disable Coherence security. In this case it is enabled by default
but could be disabled by setting the `coherence.security` system property to `false`
* The `<access-controller>` element contains the configuration for the custom access controller.
** The `<class-name>` element tells Coherence to use the custom access controller class `com.oracle.coherence.guides.security.CertAccessController`
** The `<init-params>` element contains the `<init-param>` that will be converted to constructor parameters when Coherence creates an instance of `CertAccessController`
*** The first parameter is the location of the trust store file
*** The second parameter is the location of the permissions XML file
*** The third parameter is a boolean flag to enable or disable logging of permission checks
*** The fourth parameter is the trust store password, this is optional and blank by default
*** The fifth parameter is the trust store type, in this example we use PKCS12 key stores
*** The sixth parameter is the encryption algorithm to use. This must match the type of keys used, and in this example they
keys are created using the `SHA256withRSA` algorithm.
* The `<callback-handler>` element specifies the class name of the callback handler implementation to use
when Coherence performs a JAAS login.

=== Using Coherence Extend Security

Coherence Extend can be secured using the same certificate-based security mechanism and hook into the same permissions
mechanism used by the access controller. This is not really how the access controller was originally designed to be used,
it was primarily for securing access to cluster side resources.
Coherence Extend security is well documented in the
https://docs.oracle.com/en/middleware/fusion-middleware/coherence/14.1.2/secure/securing-extend-client-connections.html[Securing Extend Client Connections]
section of the documentation.

This example will show how to create and configure an `IdentityTransformer` and `IdentityAsserter` implementation that will
use the same custom access controller created earlier to secure client access.

==== Custom Identity Provider

The Extend client must use an `IdentityTransformer` to convert a `Subject` into a serializable token which is sent to the
Extend proxy server. This token it then converted back to a `Subject` by the server side `IdentityAsserter`.
The `IdentityTransformer` has a single method to implement:

[source,java]
----
Object transformIdentity(Subject subject, Service service) throws SecurityException
----

- The first parameter is the current client `Subject`, which could be `null` if security is not enabled or the calling thread is not running in the context of a `Subject`.
- The second parameter is the client side remote service, i.e. a remote cache service, remote invocation service, etc.
- The return value can be any Object that the corresponding `IdentiyAsserter` on the proxy will understand.
The token must be serializable by whichever serializer the remote service and proxy are using.

We need to decide what to use as the token in this example.
By default, if we did nothing and configured no Extend security, Coherence will serialize the Subject as the token
and deserialize it on the proxy. The problem with this is that Coherence only serializes the set of principals contained in a `Subject`, so on the proxy the `Subject` would have the correct principal name, but no certificates to allow the proxy
to authenticate and authorize the client. This means anyone could create a `Subject` with a valid principal name and the proxy would allow it. This is certainly not what we require.

The token we send needs to do three things:

* Identify the client principal name
* Send the clients public key certificate to verify trust
* Allow the proxy to verify that the client is also in possession of the client's private key

We could create a custom class that allows us to send these to the client, but Coherence already has a class
that we can re-use for this purpose, the `com.tangosol.net.security.PermissionInfo` class.
This class is actually used by cluster members for a similar task to transfer the same information between cluster members.
As the `com.tangosol.net.security` package is part of the Coherence public API we can safely use it.

The `PermissionInfo` class contains a `ClusterPermission`, the name of the remote service, a `SignedObject` and a `Subject`.
The `SignedObject` is actually the `ClusterPermission` encrypted using the subjects private key.
When the `PermissionInfo` is serialized by the client, the subject's principal and any public credentials are also
serialized, which is exactly what we want. The subjects' private credentials are never serialized or sent to the server.

We can now use this to write a custom `IdentityTransformer` as shown below:

[source,java]
.CertIdentityTransformer
----
package com.oracle.coherence.guides.security;

import com.tangosol.coherence.component.net.Security;

import com.tangosol.coherence.component.net.security.Standard;

import com.tangosol.net.ClusterPermission;
import com.tangosol.net.Service;

import com.tangosol.net.security.AccessController;
import com.tangosol.net.security.IdentityTransformer;
import com.tangosol.net.security.PermissionInfo;

import javax.security.auth.Subject;
import java.security.SignedObject;

public class CertIdentityTransformer
        implements IdentityTransformer
    {
    @Override
    public Object transformIdentity(Subject subject, Service service) throws SecurityException
        {
        try
            {
            Object oToken = null;
            if (Security.isSecurityEnabled())   // <1>
                {
                Standard          security     = (Standard) Security.getInstance();
                AccessController  controller   = security.getDependencies().getAccessController();  // <2>
                String            sServiceName = service.getInfo().getServiceName();
                String            sTarget      = "service=Proxy";// + sServiceName;
                ClusterPermission permission   = new ClusterPermission(null, sTarget, "join");  // <3>
                SignedObject      signedObject = controller.encrypt(permission, subject);       // <4>
                oToken = new PermissionInfo(permission, sServiceName, signedObject, subject);   // <5>
                }
            return oToken;
            }
        catch (Exception e)
            {
            throw new SecurityException("Failed to create identity token", e);
            }
        }
    }
----

1. If security is not enabled the token returned will be `null`
2. The identity asserter obtains the current `Security` instance, which will be an instance of
`com.tangosol.coherence.component.net.security.Standard`. This can then be used to get the current access controller.
3. A `ClusterPermission` is created, the contents of this are not particularly important as all it is really used for in this case is as a token to be encrypted to prove to the proxy that the client has the private key. Although the format of the service name is important and must be `service=<name>`.
4. The `ClusterPermission` is encrypted into a `SignedObject` using the access controller encrypt method.
5. A `PermissionInfo` instance is created and returned as the token, which Coherence will serialize and send to the proxy as part of the connection request.

==== Custom Identity Asserter

Now the Extend client has a custom `IdentityTransformer` the corresponding server side `IdentityAsserter` can be created.
An `IdentityAsserter` has a single method to implement:

[source,java]
----
Subject assertIdentity(Object oToken, Service service) throws SecurityException
----

- The first parameter for the `assertIdentity` method is the deserialized token from the client, in this case we expect it to be a `PermissionInfo` instance.
- The second parameter is a reference to the proxy service that the client is connecting to.

The `IdentityAsserter` uses the token to produce a `Subject` and assert that the subject is allowed to connect to the server, throwing a `SecurityException` if these checks fail.

The `PermissionInfo` instance passed to our custom `IdentityAsserter` will contain all the values from the client,
the `ClusterPermission`, the service name, the `SignedObject` encrypted permission, and the client `Subject` containing
the principal and any public credentials (i.e. the public key and certificate).

This can be used to write the custom `IdentityAsserter` as shown below:

[source,java]
.CertIdentityAsserter
----
package com.oracle.coherence.guides.security;

import com.tangosol.coherence.component.net.Security;

import com.tangosol.coherence.component.net.security.Standard;

import com.tangosol.net.ClusterPermission;
import com.tangosol.net.Service;

import com.tangosol.net.security.AccessController;
import com.tangosol.net.security.IdentityAsserter;
import com.tangosol.net.security.PermissionInfo;

import javax.security.auth.Subject;

import java.security.SignedObject;

import java.util.Set;

public class CertIdentityAsserter
        implements IdentityAsserter
    {
    @Override
    public Subject assertIdentity(Object oToken, Service service) throws SecurityException
        {
        if (!Security.isSecurityEnabled())    // <1>
            {
            return null;
            }

        if (!(oToken instanceof PermissionInfo))  // <2>
            {
            throw new SecurityException("Unauthorized");
            }

        PermissionInfo info         = (PermissionInfo) oToken;     // <3>
        Subject        subject      = info.getSubject();
        SignedObject   signedObject = info.getSignedPermission();

        if (subject == null)   // <4>
            {
            throw new SecurityException("Unauthorized");
            }

        if (signedObject == null)  // <5>
            {
            throw new SecurityException("Unauthorized");
            }

        try
            {
            Standard          security     = (Standard) Security.getInstance();                   // <6>
            AccessController  controller   = security.getDependencies().getAccessController();

            if (!(controller.decrypt(signedObject, subject, null) instanceof ClusterPermission))   // <7>
                {
                throw new SecurityException("Unauthorized");
                }

            String sClusterName = service.getCluster().getClusterName();
            String sServiceName = service.getInfo().getServiceName();
            String sTarget      = "service=" + sServiceName;
            controller.checkPermission(new ClusterPermission(sClusterName, sTarget, "join"), subject);  // <8>

            return new Subject(false, subject.getPrincipals(), Set.of(), Set.of()); // <9>
            }
        catch (Exception e)
            {
            throw new SecurityException("Failed to verify identity token");
            }
        }
    }
----

1. If Coherence security is not enabled there is nothing to do so return a `null` subject
2. If the received token is not a `PermissionInfo` throw a `SecurityException` to refuse the connection
3. Cast the token to a `PermissionInfo` and get the `Subject` and `SignedObject` from it
4. If the `Subject` is null, refuse the connection
5. If the `SignedObject` is null, refuse the connection
6. Obtain the current Coherence `Security` instance, from which the curren access controller can be obtained.
7. Use the access controller to decrypt the `SignedObject` and assert that it is a `ClusterPermission` instance
8. Create a new `ClusterPermission` to representing a permission request to join the Proxy service and call the
access controller `checkPermission` method to ensure the `Subject` has permissions to connect.
9. Return a `Subject` representing the client. For Extend the `Subject` should only contain the principals, any public credentials are not required and should not be included.

A few of the steps above need to be covered in more details to explain exactly where the client is authenticated
and authorized.

- In step 7, the `SignedObject` from the client is decrypted. This must produce an instance of a `ClusterPermission`
as that is what our corresponding `IdentityTransformer would have encrypted. But more is also going on here as it
it our custom access controller `CertAccessController` that also verifies trust of the client's public key and cert
during decryption. So as long as `decrypt` returns a `ClusterPermission` we can be sure that the client has the
private key corresponding to the public key we received and that the `CertAccessController` has verified trust
for that public key. If the public key was not trusted, the decrypt method would have thrown a security exception.

- In step 8, the access controller is used to check the client has permission to connect.
In the example, this is just using the same XML file permissions mechanism.
So for each client that has permission to connect, there must be an entry in the XML file with the client principal
granting it join permission to the proxy.

For example, if the proxy service is named Proxy, and the client principal name is `CN=client-one` then at a minimum
the permissions file must grant that principal "join" permissions for the Proxy service:

[source,xml]
----
   <grant>
      <principal>
         <class>javax.security.auth.x500.X500Principal</class>
         <name>CN=client-one</name>
      </principal>
      <permission>
         <target>service=Proxy</target>
         <action>join</action>
      </permission>
   </grant>
----

==== Configuring Extend Security

Coherence Extend must be configured to use the custom `IdentiyTransformer` and `IdentityAsserter` created above.
This is done in the same `<security>` section of the operational configuration file that the access controller was configured in.

[source,xml]
.cert-override.xml
----
<coherence xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
           xmlns="http://xmlns.oracle.com/coherence/coherence-operational-config"
           xsi:schemaLocation="http://xmlns.oracle.com/coherence/coherence-operational-config coherence-operational-config.xsd">

    <security-config>
        <enabled system-property="coherence.security">true</enabled>
        <access-controller>
            <class-name>com.oracle.coherence.guides.security.CertAccessController</class-name>
            <init-params>
                <init-param id="1">
                    <param-type>java.io.File</param-type>
                    <param-value system-property="coherence.security.truststore"/>
                </init-param>
                <init-param id="2">
                    <param-type>java.io.File</param-type>
                    <param-value system-property="coherence.security.permissions"/>
                </init-param>
                <init-param id="3">
                    <param-type>java.lang.Boolean</param-type>
                    <param-value system-property="coherence.security.log">true</param-value>
                </init-param>
                <init-param id="4">
                    <param-type>java.lang.String</param-type>
                    <param-value system-property="coherence.security.truststore.password"/>
                </init-param>
                <init-param id="5">
                    <param-type>java.lang.String</param-type>
                    <param-value system-property="coherence.truststore.type">PKCS12</param-value>
                </init-param>
                <init-param id="6">
                    <param-type>java.lang.String</param-type>
                    <param-value system-property="coherence.security.signature">SHA256withRSA</param-value>
                </init-param>
            </init-params>
        </access-controller>
        <callback-handler>
            <class-name>com.oracle.coherence.guides.security.TestCallBackHandler</class-name>
        </callback-handler>
        <identity-asserter>
            <class-name>com.oracle.coherence.guides.security.CertIdentityAsserter</class-name>
        </identity-asserter>
        <identity-transformer>
            <class-name>com.oracle.coherence.guides.security.CertIdentityTransformer</class-name>
        </identity-transformer>
    </security-config>
</coherence>
----

- The `IdentityAsserter` is configured just after the callback handler in the XML.
The custom `CertIdentityAsserter` class name is specified inside the `<identity-asserter>` element.
- The `IdentityTransformer` is then specified in the same way putting the `CertIdentityTransformer` class
name in the `<identity-transformer>` element.

Both the Coherence Extend client and the Proxy server must be configured to use this operational configuration.

=== Running the Example

Now that all the parts have been created, it is possible to test certificate-based security by running Coherence
and trying various test scenarios.

==== Create Keys and Certificates

As this example is all about certificate-based security, some keys and certificates will be required for testing.
In a lot of examples with keys and certs, simple self-signed certs are used.
This is not going to work for this example because the custom access controller verifies trust be ensuring
the caller's public key was signed by a trusted CA. This means the test certificates must also be signed by a CA.
We can still do this without requiring a real CA, it just requires the use of OpenSSL a few extra commands.
OpenSSL is well documented with a number of examples of how to do this available.
This example includes a shell script file `keys.sh` which will generate the files required to run the example.

From the root director of the project run

[source,bash]
----
sh keys.sh
----

This will generate a number of keys, certificates and key stores in the `certs/` directory.

==== Test Scenarios

To properly test the custom access controller and Extend identity transformer and asserter, there
are a number of scenarios to run.

The custom access controller will be configured to only trust certificates signed by a specific trusted CA ("/CN=test-ca1")
that will be in the trust store.

Cluster Member Scenarios:

1. Start the first cluster member using a principal name ("/CN=member-1") that is in the permissions XML file grant list and a certificate signed by the trusted CA ("/CN=test-ca1") this should start successfully.
2. Start a cluster member using a different principal name ("/CN=member-2") that is in the permissions XML file grant list for itself and the senior cluster member. This member uses a certificate signed by the trusted CA. This new member should start successfully and form a cluster with the senior member.
3. Start a cluster member using a principal name ("/CN=member-4"), signed by the trusted CA but is in the permissions XML file deny list for both the new member and the existing senior member. This member should fail to join the cluster.
4. Start a cluster member using a principal name ("/CN=member-5"), signed by the trusted CA but is in not in the permissions XML file for the new member nor the senior member. This member should fail to join the cluster.
5. Start a cluster member using a principal name ("/CN=member-4"), signed by the trusted CA which is in the new members permissions XML file grant list but in the senior member's "deny" list. This new member should fail to join the cluster.
6. Start a cluster member using a principal name ("/CN=member-5"), signed by the trusted CA which is in the new members permissions XML file grant list but not in the senior member's permissions XML file. This new member should fail to join the cluster.
7. Start a cluster member using a principal name ("/CN=member-1") that is in both its own and the senior member's permissions file grant list, but has a certificate signed by the untrusted CA. This member should fail to join the cluster as it is untrusted.

Extend Client Scenarios:

Start two storage enabled cluster members running Extend proxies. These will run with two different principals
("/CN=member-1" and "/CN=member-2") both signed by the trusted CA. These should start and form a cluster, as verified by the cluster member scenarios.

1. Start an Extend client using a different principal name ("/CN=member-3"), using a certificate signed by the trusted CA. The client principal is in both the client's and cluster member's permissions XML file grant list. The client should start successfully and connect to the proxy.
2. Start an Extend client using a principal name ("/CN=member-4"), using a certificate signed by the trusted CA. The client principal is in both the client and cluster permissions XML file deny list. This client should fail to connect to the proxy.
3. Start an Extend client using a principal name ("/CN=member-5"), using a certificate signed by the trusted CA. The client principal is in neither the client nor cluster permissions XML file. This client should fail to connect to the proxy.
4. Start an Extend client using a principal name ("/CN=member-4"), signed by the trusted CA which is in the client's permissions XML file grant list, but in the cluster deny list. This client should fail to connect to the proxy.
5. Start an Extend client using a principal name ("/CN=member-5"), signed by the trusted CA which is in the client's permissions XML file grant list, but not in the cluster permissions XML file. This client should fail to connect to the proxy.
6. Start an Extend client using a principal name ("/CN=member-1")using a certificate signed by the trusted CA. The client principal is in both the client's and cluster permissions XML file. This client should fail to connect to the proxy as it is untrusted.


==== Before Running the Tests

Before running the tests, build the project using the following command:

[source,bash]
----
mvn clean package -DskipTests
----

This will build the project jar file under tha `target/` directory and put the project dependencies
(`coherence.jar`) into a the `target/libs` directory

Run the script to generate the keys, certificates and key stores

[source,bash]
----
sh keys.sh
----

==== Start A Cluster Member

The first cluster member in the tests will be configured to start correctly.
The example contains a shell script named `server.sh` that will start a Coherence cluster member.
The script takes three parameters:

- the name of the principal that the server will use
- the name of the PKCS12 key store
- a boolean to set whether the cluster member is storage enabled

In a terminal window, run the following command:

[source,bash]
----
./server.sh member-1 member-1.p12 true
----

This will start a storage enable cluster member using the principal `CN=member-1` loaded from the key store
`certs/member-1.p12`

In the log displayed in the terminal, the custom access controller will log various permission requests that will
show the principal name, for example:

[source]
----
2025-04-22 16:12:40.332/4.118 Oracle Coherence GE 14.1.1.2206.13 <Info> (thread=Coherence, member=1): Allowed request for ("com.tangosol.net.ClusterPermission" "service=Management" "join") on behalf of CN=member-1
----

==== Start A Second Cluster Member

Now the first cluster member is running we can start a second member that should join the cluster.
This member will run as principal "/CN=member-2" to test scenario 2 above, where a new member in the
grant list can join the cluster.

In another terminal window, run the following command from the root directory for the project:

[source,bash]
----
./server.sh member-2 member-2.p12 true
----

This time in the console log we should see the access controller allowing permissions for principal "CN=member-2"

[source]
----
2025-04-22 16:21:44.105/1.333 Oracle Coherence GE 14.1.1.2206.13 <Info> (thread=Coherence, member=2): Allowed request for ("com.tangosol.net.ClusterPermission" "service=Management" "join") on behalf of CN=member-2
----

If we look at the log for the senior cluster member that the new member joined with, we should also see the access controller
in the senior member allowing the new member to join with the principal "CN=member-2"

[source]
----
2025-04-22 16:21:44.638/548.426 Oracle Coherence GE 14.1.1.2206.13 <Info> (thread=PagedTopic:PartitionedTopic, member=1): Allowed request for ("com.tangosol.net.ClusterPermission" "service=PartitionedTopic,cache=*" "join") on behalf of CN=member-2
----

==== Cluster Member With Denied Principal

To test scenario three, we can run a cluster member using principal "member-4" which is in the deny list of the permissions.xml file.
This member should fail to start, the log should show a PermissionException.
This member will not even have contacted the senior member because its own permissions XML file causes it to fail to start.

[source,bash]
----
./server.sh member-4 member-4.p12 false
----

This member should fail to start, the log should show a PermissionException.

[source]
----
2025-04-22 16:34:48.594/1.361 Oracle Coherence GE 14.1.1.2206.13 <Error> (thread=Coherence, member=2): com.tangosol.net.security.PermissionException: Insufficient rights to perform the operation
----

==== Cluster Member With Missing Principal

To test scenario four, we can run a cluster member using principal "member-5" which is missing the permissions.xml file.
This member will not even have contacted the senior member because its own permissions XML file causes it to fail to start.

[source,bash]
----
./server.sh member-5 member-5.p12 false
----

This member should fail to start, the log should show a PermissionException.

[source]
----
2025-04-22 16:36:45.762/1.337 Oracle Coherence GE 14.1.1.2206.13 <Error> (thread=main, member=3): java.util.concurrent.CompletionException: com.tangosol.net.security.PermissionException: Insufficient rights to perform the operation
----

==== Cluster Member Allowed In Own Permissions File Denied By The Senior Member

Test scenario five is where we run a cluster member where the principal name is in the grant list of its own
permissions XML file, but is in the deny list of the senior running cluster member.

We can run the `server.sh` script with a fourth parameter to specify the name of the permissions XML file to use.
For this scenario we will use the `cert-permissions-all.xml` file which grants access to all the test principals.

[source,bash]
----
./server.sh member-4 member-4.p12 false cert-permissions-all.xml
----

We can see in the console logs that this member allows permissions for principal "CN=member-4"

[source]
----
2025-04-22 16:44:36.938/1.874 Oracle Coherence GE 14.1.1.2206.13 <Info> (thread=Coherence, member=5): Allowed request for ("com.tangosol.net.ClusterPermission" "service=$SYS:Config,cache=*" "join") on behalf of CN=member-4
----

But the member fails to join the cluster because it will be rejected by the senior member.
In the senior member log, there will be messages similar to this:

[source]
----
2025-04-22 16:44:36.956/616.308 Oracle Coherence GE 14.1.1.2206.13 <Info> (thread=DistributedCache:$SYS:Config, member=1): Denied request for ("com.tangosol.net.ClusterPermission" "service=$SYS:Config,cache=*" "join") on behalf of CN=member-4
----

==== Cluster Member Allowed In Own Permissions File Missing From The Senior Member

Test scenario six is where we run a cluster member where the principal name is in the grant list of its own
permissions XML file, but missing from the permissions XML file on the senior running cluster member.

We can run the `server.sh` script with a fourth parameter to specify the name of the permissions XML file to use.
For this scenario we will use the `cert-permissions-all.xml` file which grants access to all the test principals.

[source,bash]
----
./server.sh member-5 member-5.p12 false cert-permissions-all.xml
----

We can see in the console logs that this member allows permissions for principal "CN=member-5"

[source]
----
2025-04-22 17:32:11.360/2.021 Oracle Coherence GE 14.1.1.2206.13 <Info> (thread=Coherence, member=3): Allowed request for ("com.tangosol.net.ClusterPermission" "service=$SYS:Config,cache=*" "join") on behalf of CN=member-5
----

But the member fails to join the cluster because it will be rejected by the senior member.
In the senior member log, there will be messages similar to this:

[source]
----
2025-04-22 17:32:11.378/3470.744 Oracle Coherence GE 14.1.1.2206.13 <Info> (thread=DistributedCache:$SYS:Config, member=1): Denied request for ("com.tangosol.net.ClusterPermission" "service=$SYS:Config,cache=*" "join") on behalf of CN=member-5
----

==== Cluster Member Using Untrusted Cert

In test scenario seven, we are testing where an attacker may create a cluster member that tries to join the cluster using a principal name that is known to be in the senior members permissions XML file.
As the attacker is unable to use a certificate signed by the trusted CA, the cluster member should fail to join because the custom access controller will not verify trust in the certificate being used.

The bad server will use "CN=member-1" as the principal name, which we know
is allowed to join the cluster because that is the same principal the senior member is using.
But the cert stored in the `untrusted.p12` key store was signed by the untrusted CA.

The example contains a script `bad-server.sh` which will run a cluster member using the bad configuration.
This member will use a trust store that contains both the trusted and untrusted CA certs.
It will also use a permissions XML file that gives its principal permissions to do anything.

In a console window, start the bad server:

[source,bash]
----
./bad-server.sh
----

In the console output, we can see the bad server fails to start. It will attempt to join with the senior member,
and the log appears to show the join, but then the senior member ejects the bad server from the cluster.

We can see the rejection in the senior member log output:

[source]
----
2025-04-22 18:01:17.644/41.492 Oracle Coherence GE 14.1.1.2206.13 <Error> (thread=DistributedCache:$SYS:Config, member=1): Security configuration mismatch or break-in attempt: (Wrapped: Remote permission check failed) Path does not chain with any of the trust anchors
2025-04-22 18:01:17.645/41.492 Oracle Coherence GE 14.1.1.2206.13 <Error> (thread=Cluster, member=1): member left due to security exception
----

==== Extend Client Using Principal With Permissions

The first Extend client scenario is to test an Extend client using a principal name in the permissions XML grant list
can connect to the Proxy.

The example contains a script named `client.sh` that runs a Coherence Extend client.
This client will connect to the cluster and put a value into a cache.
It should then be possible to see in the logs which principal names were used on the cluster members.

With the Coherence cluster running that was started for the previous cluster member scenarios, run the client
using the following command in a console window:

[source,bash]
----
./client.sh member-3 member-3.p12
----

The client will run as principal "/CN=member-3" which is in the grant list of the permissions XML file and uses
a trusted certificate. The client runs, connects to the cluster, updates a cache and exits.
The console log should not show any errors. It will show the access controller allowing the client requests.

[source]
----
2025-04-22 18:41:54.328/0.760 Oracle Coherence GE 14.1.1.2206.13 <Info> (thread=main, member=n/a): Allowed request for ("com.tangosol.net.ClusterPermission" "service=RemoteCache,cache=*" "join") on behalf of CN=member-3
----

The cluster member will also show log messages when the client connects showing the principal "/CN=member-3":

[source]
----
2025-04-22 18:41:54.528/10.080 Oracle Coherence GE 14.1.1.2206.13 <Info> (thread=Proxy:TcpAcceptor, member=1): Allowed request for ("com.tangosol.net.ClusterPermission" "service=Proxy" "join") on behalf of CN=member-3
----

The server is configured with a storage authorizer that logs cache access and the principal name that is performing that cache operation. We can see below that "CN=member-3" was used to update the cache.

[source]
----
2025-04-22 18:41:54.610/10.163 Oracle Coherence GE 14.1.1.2206.13 <Info> (thread=PartitionedCacheWorker:0x0011:4, member=1): CapturingAuthorizer: checkWrite for principals CN=member-3
----

So we can see that the correct client principal was used when executing the cache put.

==== Extend Client Using A Principal In The Deny List

The second Extend client test is where the client principal ("CN=member-4") is in the permission XML deny list.
The client should fail to start and not connect to the server.

With the Coherence cluster running that was started for the previous cluster member scenarios, run the client
using the following command in a console window:

[source,bash]
----
./client.sh member-4 member-4.p12
----

The client log will show that it fails to start with permission exceptions:

[source]
----
2025-04-22 19:19:29.463/0.774 Oracle Coherence GE 14.1.1.2206.13 <Info> (thread=main, member=n/a): Denied request for ("com.tangosol.net.ClusterPermission" "service=RemoteCache,cache=*" "join") on behalf of CN=member-4
2025-04-22 19:19:29.465/0.776 Oracle Coherence GE 14.1.1.2206.13 <Error> (thread=main, member=n/a): Caught exception in SecureClient: com.tangosol.net.security.PermissionException: Insufficient rights to perform the operation
----

In this case, the client will not have attempted to connect to the proxy because the client's own permissions file
does not have the required permissions.

==== Extend Client Using A Principal Missing From The Permissions File

The third Extend client test is where the client principal  is missing ("CN=member-5") from the permission XML file.
The client should fail to start and not connect to the server.

With the Coherence cluster running that was started for the previous cluster member scenarios, run the client
using the following command in a console window:

[source,bash]
----
./client.sh member-5 member-5.p12
----

The client log will show that it fails to start with permission exceptions:

[source]
----
2025-04-22 19:24:21.520/0.760 Oracle Coherence GE 14.1.1.2206.13 (dev-jonathanknight) <Info> (thread=main, member=n/a): Denied request for ("com.tangosol.net.ClusterPermission" "service=RemoteCache,cache=*" "join") on behalf of CN=member-5
2025-04-22 19:24:21.523/0.763 Oracle Coherence GE 14.1.1.2206.13 (dev-jonathanknight) <Error> (thread=main, member=n/a): Caught exception in SecureClient: com.tangosol.net.security.PermissionException: Insufficient rights to perform the operation
----

In this case, the client will not have attempted to connect to the proxy because the client's own permissions file
does not have the required permissions.

==== Extend Client Using Principal In Own Grant List But In Server Deny List

The fourth client scenario is where the Extend client principal ("CN=member-4") in the client's own permissions XML file,
but the principal is in the deny list in the Extend proxy permissions XML file.

We can run the `client.sh` script with a third parameter to specify the name of the permissions XML file to use.
For this scenario we will use the `cert-permissions-all.xml` file which grants access to all the test principals.

[source,bash]
----
./client.sh member-4 member-4.p12 cert-permissions-all.xml
----

The client console log will show the client logging allowed permissions for the client's principal to start the remote cache service locally, as the client is configured to allow access.

[source]
----
2025-04-24 10:03:07.254/5.794 Oracle Coherence GE 14.1.1.2206.13 (dev-jonathanknight) <Info> (thread=main, member=n/a): Allowed request for ("com.tangosol.net.ClusterPermission" "service=RemoteCache,cache=*" "join") on behalf of CN=member-4
----

But then the client will fail to connect to the proxy, because the proxy does not allow access.

[source]
----
2025-04-24 10:03:07.445/5.985 Oracle Coherence GE 14.1.1.2206.13 (dev-jonathanknight) <Error> (thread=main, member=n/a): Error while starting service "RemoteCache": com.tangosol.net.messaging.ConnectionException: could not establish a connection to one of the following addresses: [127.0.0.1:51028.63209]
----

The console log for the proxy that the client connected to should show the permission check failed for the client principal.

[source]
----
2025-04-24 10:03:07.439/22.242 Oracle Coherence GE 14.1.1.2206.13 (dev-jonathanknight) <Info> (thread=Proxy:TcpAcceptor, member=1): Denied request for ("com.tangosol.net.ClusterPermission" "service=Proxy" "join") on behalf of CN=member-4
2025-04-24 10:03:07.439/22.242 Oracle Coherence GE 14.1.1.2206.13 (dev-jonathanknight) <Error> (thread=Proxy:TcpAcceptor, member=1): Failed to create identity token: com.tangosol.net.security.PermissionException: Insufficient rights to perform the operation
----

==== Extend Client Using Principal In Own Grant List But Missing From Server

The fifth client scenario is where the Extend client principal ("CN=member-5") in the client's own permissions XML file,
but the principal is missing from the Extend proxy permissions XML file.

We can run the `client.sh` script with a third parameter to specify the name of the permissions XML file to use.
For this scenario we will use the `cert-permissions-all.xml` file which grants access to all the test principals.

[source,bash]
----
./client.sh member-5 member-5.p12 cert-permissions-all.xml
----

The client console log will show the client logging allowed permissions for the client's principal to start the remote cache service locally, as the client is configured to allow access.

[source]
----
2025-04-24 10:10:37.248/2.961 Oracle Coherence GE 14.1.1.2206.13 (dev-jonathanknight) <Info> (thread=main, member=n/a): Allowed request for ("com.tangosol.net.ClusterPermission" "service=RemoteCache,cache=*" "join") on behalf of CN=member-5
----

But then the client will fail to connect to the proxy, because the proxy does not allow access.

[source]
----
2025-04-24 10:10:37.439/3.153 Oracle Coherence GE 14.1.1.2206.13 (dev-jonathanknight) <Error> (thread=main, member=n/a): Error while starting service "RemoteCache": com.tangosol.net.messaging.ConnectionException: could not establish a connection to one of the following addresses: [127.0.0.1:51111.53504]
----

The console log for the proxy that the client connected to should show the permission check failed for the client principal.

[source]
----
2025-04-24 10:10:37.433/218.811 Oracle Coherence GE 14.1.1.2206.13 (dev-jonathanknight) <Info> (thread=Proxy:TcpAcceptor, member=1): Denied request for ("com.tangosol.net.ClusterPermission" "service=Proxy" "join") on behalf of CN=member-5
2025-04-24 10:10:37.433/218.811 Oracle Coherence GE 14.1.1.2206.13 (dev-jonathanknight) <Error> (thread=Proxy:TcpAcceptor, member=1): Failed to create identity token: com.tangosol.net.security.PermissionException: Insufficient rights to perform the operation
----

==== Extend Client Using Principal With Untrusted Certificate

In client test scenario seven, we are testing where an attacker may create a client member that tries to connect to the cluster using a principal name that is known to be in the proxy member's permissions XML file.
As the attacker is unable to use a certificate signed by the trusted CA, the client should fail to connect because the custom access controller will not verify trust in the certificate being used.

The bad client will use "CN=member-1" as the principal name, which we know
is allowed to connect to the cluster because that is the same principal the senior member is using.
But the cert stored in the `untrusted.p12` key store was signed by the untrusted CA.

The example contains a script `bad-client.sh` which will run a client using the bad configuration.
This client will use a trust store that contains both the trusted and untrusted CA certs.
It will also use a permissions XML file that gives the client principal permissions to do anything.

The client can be run using the following command:

[source,bash]
----
./bad-client.sh
----

The client console log will show the client logging allowed permissions for the client's principal to start the remote cache service locally, as the client is configured to allow access. The untrusted CA is in the trust store used
by the custom access controller on the client, so the attacker's certificate is trusted.

[source]
----
2025-04-24 10:31:58.814/0.744 Oracle Coherence GE 14.1.1.2206.13 (dev-jonathanknight) <Info> (thread=main, member=n/a): Allowed request for ("com.tangosol.net.ClusterPermission" "service=RemoteCache,cache=*" "join") on behalf of CN=member-1
----

But then the client will fail to connect to the proxy, because the proxy does not allow access.

[source]
----
2025-04-24 10:31:59.012/0.942 Oracle Coherence GE 14.1.1.2206.13 (dev-jonathanknight) <Error> (thread=main, member=n/a): Error while starting service "RemoteCache": com.tangosol.net.messaging.ConnectionException: could not establish a connection to one of the following addresses: [127.0.0.1:52049.64705]
----

The console log for the proxy that the client connected to should show the permission check failed for the client principal.

[source]
----
2025-04-24 10:31:59.006/15.367 Oracle Coherence GE 14.1.1.2206.13 (dev-jonathanknight) <Error> (thread=Proxy:TcpAcceptor, member=1): Failed to create identity token: java.security.GeneralSecurityException: Failed to verify subject CN=member-1
2025-04-24 10:31:59.006/15.367 Oracle Coherence GE 14.1.1.2206.13 (dev-jonathanknight) <Error> (thread=Proxy:TcpAcceptor, member=1): java.security.GeneralSecurityException: Failed to verify subject CN=member-1
----

=== Example Functional Tests

This example includes a functional test `CertSecurityTests` that verifies all the cluster member and Extend client
scenarios discussed above. This test uses the Coherence Bedrock test framework and generates all the required keys,
certificates, and key stores when the test runs. This test requires OpenSSL to be on the system path to run.

=== Summary

This example has shown how it is possible to use certificate base security with Coherence to secure both cluster
members and Extend clients. It should be possible to use this example as a starting point for other custom
access controller implementations.



