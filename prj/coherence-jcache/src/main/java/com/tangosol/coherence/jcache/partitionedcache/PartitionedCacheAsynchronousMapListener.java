/*
 * Copyright (c) 2000, 2020, Oracle and/or its affiliates.
 *
 * Licensed under the Universal Permissive License v 1.0 as shown at
 * http://oss.oracle.com/licenses/upl.
 */
package com.tangosol.coherence.jcache.partitionedcache;

import com.tangosol.coherence.jcache.common.CoherenceCacheEntryEvent;
import com.tangosol.coherence.jcache.common.CoherenceCacheEntryListenerRegistration;
import com.tangosol.coherence.jcache.common.CoherenceCacheEventEventDispatcher;
import com.tangosol.coherence.jcache.partitionedcache.processors.BinaryEntryHelper;

import com.tangosol.net.CacheFactory;
import com.tangosol.net.cache.CacheEvent;

import com.tangosol.util.AbstractMapListener;
import com.tangosol.util.BinaryEntry;
import com.tangosol.util.MapEvent;

import javax.cache.event.CacheEntryCreatedListener;
import javax.cache.event.CacheEntryRemovedListener;
import javax.cache.event.CacheEntryUpdatedListener;
import javax.cache.event.EventType;

/**
 * MapListener for coherence cache to implement jcache map events.
 *
 * @param <K> key type
 * @param <V> value type
 *
 * @author jf  2013.12.18
 * @version Coherence 12.1.3
 */
public class PartitionedCacheAsynchronousMapListener<K, V>
        extends AbstractMapListener
    {
    // ------ constructors --------------------------------------------------

    /**
     * Constructs a Coherence MapListener that dispatches the JCache CacheEntryEvents based on
     * JCache Synthetic decoration on the CacheEntryEvent's binaryValue.
     *
     * @param sDescription description for MapListeners
     * @param cache  the source for JCache CacheEntryEvents generated by this Coherence MapListener
     */
    PartitionedCacheAsynchronousMapListener(String sDescription, PartitionedCache<K, V> cache)
        {
        f_sDescription = sDescription;
        m_cacheSource  = cache;
        }

    // ------ AbstractMapListener methods -----------------------------------

    @Override
    public void entryInserted(MapEvent evt)
        {
        if (CacheFactory.isLogEnabled(CacheFactory.LOG_QUIET))
            {
            CacheFactory.log("entryInserted event entry=" + evt.getKey() + " value=" + evt.getNewValue(),
                             CacheFactory.LOG_QUIET);
            }

        CoherenceCacheEventEventDispatcher<K, V> dispatcher = new CoherenceCacheEventEventDispatcher<K, V>();
        CoherenceCacheEntryEvent<K, V> createdEntry = new CoherenceCacheEntryEvent<K, V>(m_cacheSource,
                                                          EventType.CREATED, (K) evt.getKey(), (V) evt.getNewValue());

        dispatcher.addEvent(CacheEntryCreatedListener.class, createdEntry);
        dispatcher.dispatch(getEventListeners());
        }

    @Override
    public void entryUpdated(MapEvent evt)
        {
        if (CacheFactory.isLogEnabled(CacheFactory.LOG_QUIET))
            {
            CacheFactory.log("entryUpdated event entry=" + evt.getKey() + " old value=" + evt.getOldValue()
                             + " new value=" + evt.getNewValue(), CacheFactory.LOG_QUIET);
            }

        CoherenceCacheEventEventDispatcher<K, V> dispatcher = new CoherenceCacheEventEventDispatcher<K, V>();
        CoherenceCacheEntryEvent<K, V> updatedEntry = new CoherenceCacheEntryEvent<K, V>(m_cacheSource,
                                                          EventType.UPDATED, (K) evt.getKey(), (V) evt.getNewValue(),
                                                          (V) evt.getOldValue());

        dispatcher.addEvent(CacheEntryUpdatedListener.class, updatedEntry);
        dispatcher.dispatch(getEventListeners());
        }

    @Override
    public void entryDeleted(MapEvent evt)
        {
        if (CacheFactory.isLogEnabled(CacheFactory.LOG_QUIET))
            {
            CacheFactory.log("entryDeleted event entry=" + evt.getKey() + " value=" + evt.getOldValue(),
                             CacheFactory.LOG_QUIET);
            }

        CoherenceCacheEventEventDispatcher<K, V> dispatcher   = new CoherenceCacheEventEventDispatcher<K, V>();
        CoherenceCacheEntryEvent<K, V>           deletedEntry = new CoherenceCacheEntryEvent<K, V>(m_cacheSource,
                EventType.REMOVED, (K) evt.getKey(), null, (V) evt.getOldValue());

        dispatcher.addEvent(CacheEntryRemovedListener.class, deletedEntry);
        dispatcher.dispatch(getEventListeners());
        }

    // ----- helpers --------------------------------------------------------

    /**
     * get JCache registered CacheEntryListenerRegistrations.
     *
     * @return iterable JCache CacheEventListeners
     */
    protected Iterable<CoherenceCacheEntryListenerRegistration<K, V>> getEventListeners()
        {
        return m_cacheSource.getRegisteredAsynchronousEventListeners();
        }

    // ----- Object methods ------------------------------------------------

    @Override
    public String toString()
        {
        return this.getClass().getSimpleName() + " cacheName=" + (m_cacheSource == null ? "" : m_cacheSource.getName())
               + " description=" + f_sDescription;
        }

    // ----- inner class ----------------------------------------------------

    /**
     * NonSyntheticEntryFilter
     */
    public static class NonSyntheticEntryFilter
            extends com.tangosol.coherence.jcache.common.NonSyntheticEntryFilter
        {
        @Override
        public boolean isJCacheSynthetic(CacheEvent evt)
            {
            // GetProcessor generates a UPDATE when updating DECO_JCACHE with JCACHE meta info about entry.
            BinaryEntry binEntry = (BinaryEntry) evt.getNewEntry();

            return BinaryEntryHelper.isJCacheSynthetic(binEntry);
            }
        }

    // ------ data members --------------------------------------------------
    protected final String                 f_sDescription;
    protected final PartitionedCache<K, V> m_cacheSource;
    }
