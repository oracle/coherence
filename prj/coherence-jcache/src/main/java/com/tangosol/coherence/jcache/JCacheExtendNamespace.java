/*
 * Copyright (c) 2000, 2020, Oracle and/or its affiliates.
 *
 * Licensed under the Universal Permissive License v 1.0 as shown at
 * http://oss.oracle.com/licenses/upl.
 */
package com.tangosol.coherence.jcache;

import com.tangosol.coherence.config.CacheConfig;
import com.tangosol.coherence.config.CacheMapping;
import com.tangosol.coherence.config.Config;
import com.tangosol.coherence.config.ResourceMappingRegistry;
import com.tangosol.coherence.config.ServiceSchemeRegistry;
import com.tangosol.coherence.config.builder.ListBasedAddressProviderBuilder;
import com.tangosol.coherence.config.scheme.LocalScheme;
import com.tangosol.coherence.config.scheme.RemoteCacheScheme;
import com.tangosol.coherence.config.scheme.ServiceScheme;

import com.tangosol.coherence.jcache.common.ContainerHelper;

import com.tangosol.config.ConfigurationException;
import com.tangosol.config.injection.Injector;
import com.tangosol.config.injection.SimpleInjector;
import com.tangosol.config.xml.AbstractNamespaceHandler;
import com.tangosol.config.xml.ProcessingContext;

import com.tangosol.internal.net.service.extend.remote.DefaultRemoteCacheServiceDependencies;
import com.tangosol.internal.net.service.peer.initiator.DefaultTcpInitiatorDependencies;

import com.tangosol.net.CacheFactory;
import com.tangosol.net.events.InterceptorRegistry;

import com.tangosol.run.xml.XmlElement;

import com.tangosol.util.Base;
import com.tangosol.util.RegistrationBehavior;
import com.tangosol.util.ResourceRegistry;

import java.net.URI;

/**
 * A {@link com.tangosol.config.xml.NamespaceHandler} to enable and enhance Coherence-based
 * configurations to be used with the Coherence-based JCache Extend implementation
 *
 * @author bo  2013.11.06
 * @author jf  2014.06.12
 * @since Coherence 12.2.1
 */

public class JCacheExtendNamespace
        extends AbstractNamespaceHandler
    {
    // ----- NamespaceHandler interface -------------------------------------

    /**
     * <pre>
     * {@code
     *    <!-- Generated by JCacheExtendNamespace -->
     *    <caching-scheme-mapping>
     *        <cache-mapping>
     *            <cache-name>jcache-partitioned-*</cache-name>
     *             <scheme-name>jcache-extend-tcp</scheme-name>
     *        </cache-mapping>
     *         <cache-mapping>
     *             <cache-name>jcache-configurations</cache-name>
     *             <scheme-name>jcache-extend-tcp</scheme-name>
     *        </cache-mapping>
     *    </caching-scheme-mapping>
     *    <caching-schemes>
     *        <remote-cache-scheme>
     *             <scheme-name>jcache-extend-tcp</scheme-name>
     *             <!-- TODO: scope-name probably needed within container context. -->
     *             <!--  <scope-name>jcache-extend</scope-name>  -->
     *             <service-name>JCacheTCPProxyService</service-name>
     *             <proxy-service-name>TCPProxyService</proxy-service-name>
     *             <initiator-config>
     *                 <tcp-initiator>
     *                     <name-service-addresses>
     *                         <socket-address>
     *                             <address system-property="coherence.remote.address">127.0.0.1</address>
     *                             <port system-property="coherence.clusterport">7574</port>
     *                         </socket-address>
     *                     </name-service-addresses>
     *                 </tcp-initiator>
     *             </initiator-config>
     *        </remote-cache-scheme>
     *    </caching-schemes>
     * }
     * </pre>
     */
    @Override
    public void onEndNamespace(ProcessingContext processingContext, XmlElement xmlElement, String s, URI uri)
        {
        CacheConfig cacheConfig = processingContext.getCookie(CacheConfig.class);

        if (cacheConfig == null)
            {
            throw new ConfigurationException("Can't locate the Coherence Configuration.  This only occurs when the "
                + uri + " namespace is used outside of a Coherence Cache Configuration", "Please ensure that the "
                    + uri + " is defined with in the scope of a Coherence Cache Configuration");
            }
        else
            {
            ResourceRegistry        registryResources     = processingContext.getResourceRegistry();
            ServiceSchemeRegistry   registryServices      = cacheConfig.getServiceSchemeRegistry();
            ResourceMappingRegistry registryCacheMappings = cacheConfig.getMappingRegistry();

            // register a jcache-lifecycle-interceptor to enable container activation
            // for coherence based jcache implementation. The registration name is used for lookup in junit test
            // that validates that interceptor was called.
            registryResources.getResource(InterceptorRegistry.class)
                .registerEventInterceptor("jcache-lifecycle-interceptor",
                                          new ContainerHelper.JCacheLifecycleInterceptor(),
                                          RegistrationBehavior.ALWAYS);

            // we may need to inject some values into our services
            Injector injector = new SimpleInjector();

            // ---- ensure the cache mapping for the jcache configuration is defined ----
            CacheMapping mapping = registryCacheMappings.findCacheMapping(CoherenceBasedCache.JCACHE_CONFIG_CACHE_NAME);

            // register a specific non-wildcard mapping for CoherenceBasedCache.JCACHE_CONFIG_CACHE_NAME
            if (mapping == null || mapping.usesWildcard())
                {
                mapping = new CacheMapping(CoherenceBasedCache.JCACHE_CONFIG_CACHE_NAME,
                                           CoherenceBasedCache.JCACHE_EXTEND_SCHEME_NAME);
                registryCacheMappings.register(mapping);
                }

            // ---- ensure the <jcache-extend-tcp scheme for the jcache partitioned caches is defined ----
            ServiceScheme schemeService =
                registryServices.findSchemeBySchemeName(CoherenceBasedCache.JCACHE_EXTEND_SCHEME_NAME);

            if (schemeService == null)
                {
                // construct the RemoteCacheScheme
                RemoteCacheScheme schemeRemote = new RemoteCacheScheme();

                schemeRemote.setSchemeName(CoherenceBasedCache.JCACHE_EXTEND_SCHEME_NAME);
                schemeRemote.setServiceName(CoherenceBasedCache.JCACHE_EXTEND_SERVICE_NAME);

                DefaultTcpInitiatorDependencies initiatorDependencies = new DefaultTcpInitiatorDependencies();

                // Workaround for evaluating system properties when generating a remote-scheme configuration element.
                // TODO: if this technique is acceptable short-term workaround, refer to existing Coherence constants
                // for next 2 lines.
                String nameserviceAddress = (String) Config.getProperty("coherence.remote.address", "127.0.0.1");
                int clusterport = Config.getInteger("coherence.clusterport", 7574);

                CacheFactory
                    .log("JCacheExtendNamespace.onEndNamespace processing: nameservice address and port looked up via system properties:"
                         + nameserviceAddress + ":" + clusterport, Base.LOG_INFO);

                ListBasedAddressProviderBuilder bldr = new ListBasedAddressProviderBuilder().add(nameserviceAddress, clusterport);
                initiatorDependencies.setNameServiceAddressProviderBuilder(bldr);

                DefaultRemoteCacheServiceDependencies dependencies = new DefaultRemoteCacheServiceDependencies();

                dependencies.setRemoteServiceName(CoherenceBasedCache.JCACHE_EXTEND_PROXY_SERVICE_NAME);
                dependencies.setInitiatorDependencies(initiatorDependencies);

                injector.inject(dependencies, registryResources);

                schemeRemote.setServiceDependencies(dependencies);

                injector.inject(schemeRemote, registryResources);

                // register the RemoteScheme
                registryServices.register(schemeRemote);
                }

            // ---- ensure the cache mapping for the jcache partitioned caches is defined ----
            mapping = registryCacheMappings.findCacheMapping(CoherenceBasedCache.JCACHE_PARTITIONED_CACHE_NAME_PATTERN);

            if (mapping == null)
                {
                mapping = new CacheMapping(CoherenceBasedCache.JCACHE_PARTITIONED_CACHE_NAME_PATTERN,
                                           CoherenceBasedCache.JCACHE_EXTEND_SCHEME_NAME);
                registryCacheMappings.register(mapping);
                }

            // ---- ensure the <local-scheme> for the jcache local caches is defined ----
            schemeService = registryServices.findSchemeBySchemeName(CoherenceBasedCache.JCACHE_LOCAL_SCHEME_NAME);

            if (schemeService == null)
                {
                // construct the LocalScheme
                LocalScheme schemeLocal = new LocalScheme();

                schemeLocal.setSchemeName(CoherenceBasedCache.JCACHE_LOCAL_SCHEME_NAME);
                schemeLocal.setServiceName(CoherenceBasedCache.JCACHE_LOCAL_SERVICE_NAME);

                injector.inject(schemeLocal, registryResources);

                // register the LocalScheme
                registryServices.register(schemeLocal);
                }

            // ---- ensure the cache mapping for the jcache local caches is defined ----
            mapping = registryCacheMappings.findCacheMapping(CoherenceBasedCache.JCACHE_LOCAL_CACHE_NAME_PATTERN);

            if (mapping == null)
                {
                mapping = new CacheMapping(CoherenceBasedCache.JCACHE_LOCAL_CACHE_NAME_PATTERN,
                                           CoherenceBasedCache.JCACHE_LOCAL_SCHEME_NAME);
                registryCacheMappings.register(mapping);
                }
            }
        }
    }
