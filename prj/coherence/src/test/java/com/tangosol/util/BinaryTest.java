/*
 * Copyright (c) 2000, 2020, Oracle and/or its affiliates.
 *
 * Licensed under the Universal Permissive License v 1.0 as shown at
 * http://oss.oracle.com/licenses/upl.
 */

package com.tangosol.util;


import com.tangosol.io.nio.ByteBufferOutputStream;

import java.io.DataOutput;
import java.io.DataOutputStream;
import java.io.IOException;
import java.io.OutputStream;

import java.nio.ByteBuffer;

import java.util.Arrays;
import java.util.Random;

import org.junit.Test;

import static org.junit.Assert.*;

import static util.BinaryUtils.*;


/**
* Unit tests for Binary functionality.
*
* @author cp  2006.04.??
*/
public class BinaryTest
        extends ExternalizableHelper
    {
    // ----- unit tests -----------------------------------------------------

    /**
    * Test {@link Binary#calculateNaturalPartition(int)}.
    */
    @Test
    public void testCalculateNaturalPartition()
        {
        Binary bin   = new Binary(new byte[] {124});
        int    nHash = bin.hashCode();
        assertEquals(nHash,     bin.calculateNaturalPartition(0));
        assertEquals(nHash % 7, bin.calculateNaturalPartition(7));

        // Check portability. Verify that partition values are consistent
        // with those generated by C++ and .NET
        assertEquals(-1, (new Binary()).calculateNaturalPartition(0));

        byte ab[] = new byte[256];
        for (int i = 0, b = Byte.MIN_VALUE; i < 256; ++i, ++b)
            {
            ab[i] = (byte) b;
            }

        int aiExpected[] =
            {
            -1069182126, -1220369468,  776729214,   1498202856, -953657525,  -1339070499,  690370151,   1579222769,
            -828499104,  -1181144074,  546339404,   1469532890, -906764423,  -1091244049,  670940757,   1358597827,
            -571309258,  -1426738272,  872210970,   1157354124, -627095761,  -1382516807,  881927683,   1133909653,
            -752284924,  -1540473966,  1025993256,  1243634366, -733688035,  -1555824757,  977972785,   1296932519,
            -81022054,   -1943239924,  354800310,   1646453280, -62490749,   -1958656235,  306714287,   1699685945,
            -168805464,  -2097738946,  469654148,   1828284946, -224526415,  -2053451993,  479436445,   1804905995,
            -425942018,  -1852075160,  143835858,   2140533316, -504272921,  -1762240655,  268371659,   2029532765,
            -397988916,  -1623188646,  105466592,   1900968566, -282398763,  -1741824189,  19173113,    1982053999,
            -1231433022, -1046551980,  1486337006,  797999992,  -1309403429, -957143475,   1610250231,  687687521,
            -1203610896, -817534362,   1447836636,  558566218,  -1087398167, -936857985,   1361182661,  640077651,
            -1422998874, -601230800,   1159766922,  841454364,  -1404893505, -616286679,   1112369043,  894064389,
            -1510651244, -755860990,   1274751928,  1023154990, -1567060339, -710951397,   1284960161,  999415607,
            -1913130486, -84884836,    1677300518,  352232368,  -1969605101, -40040827,    1687443263,  328427433,
            -2094237128, -198489426,   1830951700,  438643586,  -2076066271, -213479753,   1783619341,  491319195,
            -1874795922, -414723336,   2119074626,  155825108,  -1758648713, -534112543,   2032355163,  237270989,
            -1633981860, -375629110,   1888815984,  127024102,  -1711886779, -286155053,   2012794729,  16777215,
             771559538,   1526341860, -1007455906, -1259060792,  714134635,   1570235645, -996231865,  -1281784367,
             589731904,   1411492054, -852952724,  -1171273222,  608918617,   1397517519, -901431947,  -1119744541,
             810156054,   1196241024, -565944006,  -1455205972,  925352975,   1075901593, -651582173,  -1372678731,
             1049724964,  1234614450, -794826488,  -1483155042,  972835901,   1325104299, -671994607,  -1594548857,
             378745018,   1637089324, -123907690,  -1885708032,  301921443,   1727644725, -1010289,    -1997036263,
             407419016,   1867483166, -163128924,  -2126386894,  522550417,   1747078151, -248832579,  -2043925205,
             186917086,   2082672712, -450215438,  -1842515612,  206169287,   2068763729, -498629141,  -1790921347,
             100641004,   1928894586, -336475712,  -1661535914,  43150581,    1972722787, -325317159,  -1684325041,
             1528910306,  740712820,  -1255198514, -1037565864,  1548523003,  726377837,  -1304234793, -985283519,
             1442503120,  587065670,  -1141589764, -856455062,   1385635273,  630205791,  -1130791707, -878818189,
             1184252294,  831615248,  -1466425174, -543223748,   1107002783,  922531081,  -1342839629, -655174619,
             1213057460,  1061878050, -1505515368, -784033778,   1327500717,  942095675,  -1590793087, -701932521,
             1615819050,  390611388,  -1908338682, -112844656,   1730327859,  270894501,  -1993550817, -30677879,
             1855256856,  429115790,  -2137352140, -140662622,   1777941761,  519966103,  -2013832147, -252678981,
             2113429838,  184504792,  -1812594590, -453955340,   2056627543,  227710401,  -1801730949, -476252947,
             1931733372,  69523946,   -1657960368, -366298938,   1951280485,  55123443,   -1707062199, -314082081
            };

        assertEquals(-2018391514, (new Binary(ab)).calculateNaturalPartition(0));

        for (int i = 0; i < ab.length; ++i)
            {
            bin   = new Binary(ab, i, 1);
            nHash = bin.hashCode();

            int nPart = bin.calculateNaturalPartition(0);
            assertEquals(aiExpected[i], nPart);
            assertEquals(nHash,         nPart);
            }
        }

    /**
    * Test {@link Binary#memchr(byte[], int, int, byte)} and
    * {@link Binary#memchr(byte[], int, int, byte, boolean)}.
    */
    @Test
    public void testMemChr()
        {
        // check if we can find only what we know to be there
        byte[] ab  = new byte[] {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};

        for (int i = 0; i <= 0xFF; ++i)
            {
            for (int of = 0; of < ab.length; ++of)
                {
                for (int cb = 0; cb <= ab.length - of; ++cb)
                    {
                    int ofExpected = (i >= of && i < of + cb) ? i : -1;
                    int ofResult   = -1;

                    try
                        {
                        assertTrue((ofResult = Binary.memchr(ab, of, cb, (byte) i)) == ofExpected);
                        assertTrue((ofResult = Binary.memchr(ab, of, cb, (byte) i, true)) == ofExpected);
                        assertTrue((ofResult = Binary.memchr(ab, of, cb, (byte) i, false)) == ofExpected);
                        }
                    catch (RuntimeException e)
                        {
                        throw new WrapperException(e, "i=" + i + ", of=" + of
                                + ", cb=" + cb + ", ofExpected=" + ofExpected
                                + ", ofResult=" + ofResult);
                        }
                    }
                }
            }

        // test forwards versus backwards
        ab = new byte[] {0, 1, 2, 3, 4, 0, 1, 2, 3, 4};
        for (int i = 0; i < 10; ++i)
            {
            int ofExpected = i < 5 ? i : -1;
            int ofReverse  = i < 5 ? i + 5 : -1;
            int ofResult   = -1;

            try
                {
                assertTrue((ofResult = Binary.memchr(ab, 0, ab.length, (byte) i)) == ofExpected);
                assertTrue((ofResult = Binary.memchr(ab, 0, ab.length, (byte) i, true)) == ofReverse);
                assertTrue((ofResult = Binary.memchr(ab, 0, ab.length, (byte) i, false)) == ofExpected);
                }
            catch (RuntimeException e)
                {
                throw new WrapperException(e, "i=" + i
                        + ", ofExpected=" + ofExpected + ", ofResult=" + ofResult);
                }
            }
        }

    /**
    * Test {@link Binary#memmem(byte[], int, int, byte[], int, int)} and
    * {@link Binary#memmem(byte[], int, int, byte[], int, int, boolean)}.
    */
    @Test
    public void testMemMem()
        {
        Random rnd = getRandom();
        for (int i = 0; i < 100000; ++i)
            {
            String sHaystack  = getRandomString(0, 100, true);
            String sNeedle;
            if (rnd.nextBoolean())
                {
                int n = sHaystack.length();
                int of  = n == 0 ? 0 : rnd.nextInt(n);
                n -= of;
                int cb  = n == 0 ? 0 : rnd.nextInt(n);
                sNeedle = sHaystack.substring(of, of+cb);
                }
            else
                {
                sNeedle = getRandomString(0, rnd.nextInt(100), true);
                }

            byte[] abHaystack = str2bytes(sHaystack);
            byte[] abNeedle   = str2bytes(sNeedle);

            int ofStringF = sHaystack.indexOf(sNeedle);
            int ofBytesF1 = Binary.memmem(abHaystack, 0, abHaystack.length, abNeedle, 0, abNeedle.length);
            int ofBytesF2 = Binary.memmem(abHaystack, 0, abHaystack.length, abNeedle, 0, abNeedle.length, false);

            assertTrue(ofStringF == ofBytesF1);
            assertTrue(ofStringF == ofBytesF2);

            int ofStringB = sHaystack.lastIndexOf(sNeedle);
            int ofBytesB  = Binary.memmem(abHaystack, 0, abHaystack.length, abNeedle, 0, abNeedle.length, true);

            assertTrue(ofStringB == ofBytesB);
            }
        }

    /**
    * Test {@link Binary#memcmp(byte[], int, int, byte[], int, int)}.
    */
    @Test
    public void testMemCmp()
        {
        byte[] NONE      = new byte[] {};
        byte[] ZEROS     = new byte[] {0, 0, 0, 0, 0};
        byte[] ONES      = new byte[] {1, 1, 1, 1, 1};
        byte[] ZERO_ONE  = new byte[] {0, 1, 0, 1, 0};

        // zero-length tests (offsets are irrelevant)
        assertTrue(Binary.memcmp(NONE, 0, 0, NONE, 0, 0) == 0);
        assertTrue(Binary.memcmp(NONE, 0, 0, ONES, 0, 0) == 0);
        assertTrue(Binary.memcmp(NONE, 0, 0, ONES, 3, 0) == 0);
        assertTrue(Binary.memcmp(ZEROS, 1, 0, ONES, 3, 0) == 0);

        // different length tests (no dif in values)
        assertTrue(Binary.memcmp(ZEROS, 2, 1, NONE, 0, 0) > 0);
        assertTrue(Binary.memcmp(NONE, 0, 0, ZEROS, 1, 1) < 0);
        assertTrue(Binary.memcmp(ONES, 0, 1, NONE, 0, 0) >  0);
        assertTrue(Binary.memcmp(NONE, 0, 0, ONES, 2, 1) <  0);
        assertTrue(Binary.memcmp(ZEROS, 1, 2, ZERO_ONE, 2, 1) > 0);
        assertTrue(Binary.memcmp(ONES, 1, 1, ZERO_ONE, 1, 2) < 0);

        // different values (length irrelevant)
        assertTrue(Binary.memcmp(ONES, 1, 1, ZEROS, 1, 2) > 0);
        assertTrue(Binary.memcmp(ONES, 1, 2, ZEROS, 1, 1) > 0);
        assertTrue(Binary.memcmp(ONES, 1, 2, ZEROS, 1, 2) > 0);
        assertTrue(Binary.memcmp(ONES, 1, 3, ZERO_ONE, 1, 3) > 0);

        Random rnd = getRandom();
        for (int i = 0; i < 100000; ++i)
            {
            String s1 = getRandomString(0, 100, true);
            String s2;
            if (rnd.nextBoolean())
                {
                int n  = s1.length();
                int of = n == 0 ? 0 : rnd.nextInt(n);
                n -= of;
                int cb = n == 0 ? 0 : rnd.nextInt(n);
                s2 = s1.substring(of, of+cb);
                }
            else
                {
                s2 = getRandomString(0, rnd.nextInt(100), true);
                }

            byte[] ab1 = str2bytes(s1);
            byte[] ab2 = str2bytes(s2);
            int    of1 = 0;
            int    of2 = 0;
            int    cb1 = ab1.length;
            int    cb2 = ab2.length;
            int    cb  = Math.min(cb1, cb2);

            assertTrue(s1.compareTo(s2) == Binary.memcmp(ab1, of1, cb1, ab2, of2, cb2));
            assertTrue(Binary.equals(ab1, of1, ab2, of2, cb) == (Binary.memcmp(ab1, of1, cb, ab2, of2, cb) == 0));

            // vary offset and length
            if (cb1 > 0)
                {
                switch (rnd.nextInt(3))
                    {
                    case 0:
                        {
                        // adjust offset
                        int cbAdjust = rnd.nextInt(cb1);
                        of1 += cbAdjust;
                        cb1 -= cbAdjust;
                        s1   = s1.substring(cbAdjust);
                        }
                        break;

                    case 1:
                        {
                        // adjust length
                        int cbAdjust = rnd.nextInt(cb1);
                        cb1 -= cbAdjust;
                        s1   = s1.substring(0, cb1);
                        }
                        break;

                    case 2:
                        {
                        // adjust offset and length
                        int cbAdjust1 = rnd.nextInt(cb1);
                        int cbAdjust2 = rnd.nextInt(cb1);
                        if (cbAdjust1 + cbAdjust2 <= cb1)
                            {
                            of1 += cbAdjust1;
                            cb1 -= cbAdjust1 + cbAdjust2;
                            s1   = s1.substring(cbAdjust1, cbAdjust1 + cb1);
                            }
                        }
                        break;
                    }
                }

            if (cb2 > 0)
                {
                switch (rnd.nextInt(3))
                    {
                    case 0:
                        {
                        // adjust offset
                        int cbAdjust = rnd.nextInt(cb2);
                        of2 += cbAdjust;
                        cb2 -= cbAdjust;
                        s2   = s2.substring(cbAdjust);
                        }
                        break;

                    case 1:
                        {
                        // adjust length
                        int cbAdjust = rnd.nextInt(cb2);
                        cb2 -= cbAdjust;
                        s2   = s2.substring(0, cb2);
                        }
                        break;

                    case 2:
                        {
                        // adjust offset and length
                        int cbAdjust1 = rnd.nextInt(cb2);
                        int cbAdjust2 = rnd.nextInt(cb2);
                        if (cbAdjust1 + cbAdjust2 <= cb2)
                            {
                            of2 += cbAdjust1;
                            cb2 -= cbAdjust1 + cbAdjust2;
                            s2   = s2.substring(cbAdjust1, cbAdjust1 + cb2);
                            }
                        }
                        break;
                    }
                }

            assertTrue(s1.compareTo(s2) == Binary.memcmp(ab1, of1, cb1, ab2, of2, cb2));
            }
        }

    /**
    * Test {@link Binary#equals(byte[], int, byte[], int, int)}.
    */
    @Test
    public void testEquals()
        {
        assertTrue(str2bin("12345").equals(str2bin("12345")));
        assertFalse(str2bin("123456").equals(str2bin("12345")));
        assertFalse(str2bin("12345").equals(str2bin("123456")));
        assertFalse(str2bin("02345").equals(str2bin("12345")));

        for (int i = 0; i < 100000; ++i)
            {
            String s1 = getRandomString(0, 10, true);
            String s2 = getRandomString(0, 10, true);
            assertTrue(s1.equals(s2) ==
                    str2bin(s1).equals(str2bin(s2)));
            }
        }

    /**
    * Test {@link Binary#memcpy(byte[], int, byte[], int, int)}.
    */
    @Test
    public void testMemCpy()
        {
        byte[] ab1 = new byte[0];
        byte[] ab2 = new byte[0];
        Binary.memcpy(ab1, 0, ab2, 0, 0);
        assertTrue(Arrays.equals(ab1, ab2));

        ab1 = new byte[] {1, 2, 3, 4, 5};
        ab2 = new byte[ab1.length];
        Binary.memcpy(ab1, 0, ab2, 0, ab1.length);
        assertTrue(Arrays.equals(ab1, ab2));

        ab1 = new byte[] {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
        ab2 = new byte[] {0, 1, 2, 3, 4, 0, 1, 2, 3, 4};
        Binary.memcpy(ab1, 0, ab1, 5, 5);
        assertTrue(Arrays.equals(ab1, ab2));

        ab1 = new byte[] {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
        ab2 = new byte[] {0, 0, 1, 2, 3, 4, 5, 6, 7, 8};
        Binary.memcpy(ab1, 0, ab1, 1, 9);
        assertTrue(Arrays.equals(ab1, ab2));

        ab1 = new byte[] {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
        ab2 = new byte[] {1, 2, 3, 4, 5, 6, 7, 8, 9, 9};
        Binary.memcpy(ab1, 1, ab1, 0, 9);
        assertTrue(Arrays.equals(ab1, ab2));
        }

    /**
    * Test binary concatenation.
    * <ul>
    * <li>{@link Binary#concat(Binary)}
    * </ul>
    */
    @Test
    public void testConcat()
        {
        for (int i = 0; i < 100000; ++i)
            {
            String s1 = getRandomString(0, 100, true);
            String s2 = getRandomString(0, 100, true);
            assertTrue(str2bin(s1.concat(s2)).equals(
                    str2bin(s1).concat(str2bin(s2))));
            }
        }

    /**
    * Test binary sequence reversal.
    * <ul>
    * <li>{@link Binary#reverse()}
    * </ul>
    */
    @Test
    public void testReverse()
        {
        for (int i = 0; i < 100000; ++i)
            {
            String s   = getRandomString(0, 100, true);
            Binary bin = str2bin(s);
            assertTrue(str2bin(new StringBuffer(s).reverse().toString()).equals(bin.reverse()));
            assertTrue(bin.reverse().reverse().equals(bin));
            }
        }

    /**
    * Test the various "search for a byte within a binary" methods.
    * <ul>
    * <li>{@link Binary#indexOf(byte)}
    * <li>{@link Binary#indexOf(byte, int)}
    * <li>{@link Binary#lastIndexOf(byte)}
    * <li>{@link Binary#lastIndexOf(byte, int)}
    * </ul>
    */
    @Test
    public void testIndexOf()
        {
        Random rnd = getRandom();
        for (int i = 0; i < 100000; ++i)
            {
            String sHaystack = getRandomString(0, 100, true);
            char   chNeedle  = (char) (32 + rnd.nextInt(127 - 32));

            Binary binHaystack = str2bin(sHaystack);
            byte   bNeedle     = (byte) chNeedle;

            assertTrue(sHaystack.indexOf(chNeedle) == binHaystack.indexOf(bNeedle));
            assertTrue(sHaystack.lastIndexOf(chNeedle) == binHaystack.lastIndexOf(bNeedle));

            for (int of = -10, cb = sHaystack.length() + 10; of < cb; ++of)
                {
                assertTrue(sHaystack.indexOf(chNeedle, of) == binHaystack.indexOf(bNeedle, of));
                assertTrue(sHaystack.lastIndexOf(chNeedle, of) == binHaystack.lastIndexOf(bNeedle, of));

                if (i < 100)
                    {
                    // on some of the test runs, try looking for all possible
                    // bytes
                    for (int b = 0x00; b <= 0xFF; ++b)
                        {
                        assertTrue(sHaystack.indexOf((char) b, of) == binHaystack.indexOf((byte) b, of));
                        assertTrue(sHaystack.lastIndexOf((char) b, of) == binHaystack.lastIndexOf((byte) b, of));
                        }
                    }
                }
            }
        }

    /**
    * Test the various "search for a binary within a binary" methods.
    * <ul>
    * <li>{@link Binary#indexOf(Binary)}
    * <li>{@link Binary#indexOf(Binary, int)}
    * <li>{@link Binary#lastIndexOf(Binary)}
    * <li>{@link Binary#lastIndexOf(Binary, int)}
    * </ul>
    */
    @Test
    public void testIndexOfBinary()
        {
        Random rnd = getRandom();
        for (int i = 0; i < 100000; ++i)
            {
            String sValue   = getRandomString(0, 100, true);
            String sFind    = getRandomString(0, rnd.nextInt(120), true);
            int    ofSub    = rnd.nextInt(sValue.length() + 1);
            int    cbSub    = rnd.nextInt(sValue.length() - ofSub + 1);
            String sCertain = sValue.substring(ofSub, ofSub + cbSub);

            Binary binValue   = str2bin(sValue);
            Binary binFind    = str2bin(sFind);
            Binary binCertain = str2bin(sCertain);
            int    of         = 0;

            int    ofStr = 0;
            int    ofBin = 0;

            try
                {
                assertTrue((ofStr = sValue.indexOf(sFind)) == (ofBin = binValue.indexOf(binFind)));
                assertTrue((ofStr = sValue.indexOf(sCertain)) == (ofBin = binValue.indexOf(binCertain)));

                assertTrue((ofStr = sValue.lastIndexOf(sFind)) == (ofBin = binValue.lastIndexOf(binFind)));
                assertTrue((ofStr = sValue.lastIndexOf(sCertain)) == (ofBin = binValue.lastIndexOf(binCertain)));

                int cb;
                for (of = -10, cb = sValue.length() + 10; of < cb; ++of)
                    {
                    assertTrue((ofStr = sValue.indexOf(sFind, of)) == (ofBin = binValue.indexOf(binFind, of)));
                    assertTrue((ofStr = sValue.lastIndexOf(sCertain, of)) == (ofBin = binValue.lastIndexOf(binCertain, of)));
                    }
                }
            catch (Throwable e)
                {
                out("*** Error in indexOf()");
                out("value   =" + binValue);
                out("find    =" + binFind);
                out("certain =" + binCertain);
                if (of != 0)
                    {
                    out("of      =" + of);
                    }
                out("control =" + ofStr);
                out("result  =" + ofBin);

                if (e instanceof Error)
                    {
                    throw (Error) e;
                    }
                throw ensureRuntimeException(e);
                }
            }
        }

    /**
    * Test the various binary matching methods.
    * <ul>
    * <li>{@link Binary#startsWith(Binary)}
    * <li>{@link Binary#startsWith(Binary, int)}
    * <li>{@link Binary#endsWith(Binary)}
    * <li>{@link Binary#regionMatches(int, Binary, int, int)}
    * </ul>
    */
    @Test
    public void testMatchingBinary()
        {
        Random rnd = getRandom();
        for (int i = 0; i < 100000; ++i)
            {
            String  sValue      = getRandomString(0, 100, true);
            String  sFind       = getRandomString(0, rnd.nextInt(120), true);
            int     ofSub       = rnd.nextInt(sValue.length() + 1);
            int     cbSub       = rnd.nextInt(sValue.length() - ofSub + 1);
            String  sCertain    = sValue.substring(ofSub, ofSub + cbSub);

            Binary  binValue    = str2bin(sValue);
            Binary  binFind     = str2bin(sFind);
            Binary  binCertain  = str2bin(sCertain);
            int     of          = 0;

            String  sTest       = "";
            boolean fStr        = false;
            boolean fBin        = false;

            try
                {
                sTest = "startsWith";
                assertTrue((fStr = sValue.startsWith(sFind)) == (fBin = binValue.startsWith(binFind)));
                assertTrue((fStr = sValue.startsWith(sCertain)) == (fBin = binValue.startsWith(binCertain)));

                sTest = "endsWith";
                assertTrue((fStr = sValue.endsWith(sFind)) == (fBin = binValue.endsWith(binFind)));
                assertTrue((fStr = sValue.endsWith(sCertain)) == (fBin = binValue.endsWith(binCertain)));

                int cb;
                for (of = -10, cb = sValue.length() + 10; of < cb; ++of)
                    {
                    sTest = "startsWith";
                    assertTrue((fStr = sValue.startsWith(sFind, of)) == (fBin = binValue.startsWith(binFind, of)));

                    sTest = "regionMatches";
                    for (int ofCertain = 0, cbCertain = sCertain.length(); ofCertain < cbCertain; ++ofCertain)
                        {
                        assertTrue((fStr = sValue.regionMatches(of, sCertain, ofCertain, cbCertain - ofCertain)) == (fBin = binValue.regionMatches(of, binCertain, ofCertain, cbCertain - ofCertain)));
                        }
                    }
                }
            catch (Throwable e)
                {
                out("*** Error in " + sTest + "()");
                out("value   =" + binValue);
                out("find    =" + binFind);
                out("certain =" + binCertain);
                if (of != 0)
                    {
                    out("of      =" + of);
                    }
                out("control =" + fStr);
                out("result  =" + fBin);

                if (e instanceof Error)
                    {
                    throw (Error) e;
                    }
                throw ensureRuntimeException(e);
                }
            }
        }

    /**
    * Test the "replace a byte with a byte" method.
    * <ul>
    * <li>{@link Binary#replace(byte, byte)}
    * </ul>
    */
    @Test
    public void testReplace()
        {
        Random rnd = getRandom();
        for (int i = 0; i < 100000; ++i)
            {
            String sValue = getRandomString(0, 100, true);
            char   chOld  = (char) (32 + rnd.nextInt(127 - 32));
            char   chNew  = (char) (32 + rnd.nextInt(127 - 32));

            Binary binValue = str2bin(sValue);
            byte bOld = (byte) chOld;
            byte bNew = (byte) chNew;

            assertTrue(str2bin(sValue.replace(chOld, chNew)).equals(binValue.replace(bOld, bNew)));
            }
        }

    /**
    * Test the "replace a binary with a binary" method.
    * <ul>
    * <li>{@link Binary#replace(Binary, Binary)}
    * </ul>
    */
    @Test
    public void testReplaceBinary()
        {
        Random rnd = getRandom();
        for (int i = 0; i < 100000; ++i)
            {
            String sValue = getRandomString(0, 100, true);
            String sOld   = getRandomString(0, rnd.nextInt(120), true);
            String sNew   = getRandomString(0, rnd.nextInt(120), true);

            Binary binValue = str2bin(sValue);
            Binary binOld   = str2bin(sOld);
            Binary binNew   = str2bin(sNew);

            String sResult   = null;
            Binary binResult = null;
            try
                {
                sResult   = replace(sValue, sOld, sNew);
                binResult = binValue.replace(binOld, binNew);
                assertTrue(str2bin(sResult).equals(binResult));
                }
            catch (Throwable e)
                {
                out("*** Error in replace()");
                out("value  =" + new Binary(str2bytes(sValue)));
                out("old    =" + new Binary(str2bytes(sOld)));
                out("new    =" + new Binary(str2bytes(sNew)));
                Binary binControl = new Binary(str2bytes(sResult));
                out("control=" + binControl);
                out("result =" + binResult);
                out("binControl.startsWith(binResult)=" + binControl.startsWith(binResult));
                if (e instanceof Error)
                    {
                    throw (Error) e;
                    }
                throw ensureRuntimeException(e);
                }
            }
        }

    /**
    * Test the writeTo() methods
    */
    @Test
    public void testWriteTo()
        {
        try
            {
            for (int i = 0; i < 3; i++)
                {
                testWriteToHelper(str2bin(getRandomString(0, 100, true)), i);
                testWriteToHelper(Binary.NO_BINARY, i);
                }
            }
        catch (IOException e)
            {
            throw ensureRuntimeException(e);
            }
        }

    /**
    * Helper method for testWriteTo()
    *
    * @param bin  the binary to write
    */
    private void testWriteToHelper(Binary bin, int nIter)
            throws IOException
        {
        OutputStream os;
        ByteBuffer   buf = ByteBuffer.allocate(bin.length());
        switch (nIter)
            {
            case 0:
                bin.writeTo(buf);
                break;
            case 1:
                os = new ByteBufferOutputStream(buf);
                bin.writeTo(os);
                os.close();
                break;
            case 2:
                os = new DataOutputStream(new ByteBufferOutputStream(buf));
                bin.writeTo((DataOutput) os);
                os.close();
                break;
            }
        Binary binComp = new Binary(buf.array(), 0, bin.length());
        assertTrue(bin.equals(binComp));
        assertTrue(binComp.equals(bin));
        }
    }
