///////////////////////////////////////////////////////////////////////////////
    Copyright (c) 2000, 2022, Oracle and/or its affiliates.

    Licensed under the Universal Permissive License v 1.0 as shown at
    http://oss.oracle.com/licenses/upl.
///////////////////////////////////////////////////////////////////////////////
= Coherence CDI

// DO NOT remove this header - it might look like a duplicate of the header above, but
// both they serve a purpose, and the docs will look wrong if it is removed.
== Coherence CDI

Coherence CDI provides support for http://cdi-spec.org/[CDI] (Contexts and Dependency  Injection) within Coherence
cluster members.

It allows you both to inject Coherence-managed resources, such as `NamedMap`, `NamedCache` and `Session`  instances into
CDI managed beans, to inject CDI beans into Coherence-managed resources, such as event interceptors and cache stores,
and to handle Coherence server-side events using CDI observer methods.

In addition, Coherence CDI provides support for automatic injection of transient objects upon deserialization.
This allows you to inject CDI managed beans such as services and repositories (to use DDD nomenclature) into transient
objects, such as entry processor and even data class instances, greatly simplifying implementation of true Domain Driven
applications.

== Usage

In order to use Coherence CDI, you need to declare it as a dependency in your `pom.xml`:

[source,xml,subs="attributes+"]
----
    <dependency>
        <groupId>{coherence-maven-group-id}</groupId>
        <artifactId>coherence-cdi-server</artifactId>
        <version>{version-coherence-maven}</version>
    </dependency>
----

Once the necessary dependency is in place, you can start using CDI to inject Coherence objects into managed CDI beans,
and vice versa, as the following sections describe.

* <<inject-coherence-objects,Injecting Coherence Objects into CDI Beans>>
 ** <<inject-namedmap,Injecting `NamedMap`, NamedCache`, and related objects>>
  *** <<inject-views,Injecting `NamedMap` or `NamedCache` Views>>
 ** <<inject-namedtopic,Injecting `NamedTopic` and related objects>>
 ** <<other-injection-points,Other Supported Injection Points>>
  *** <<inject-cluster,`Cluster` and `OperationalContext` Injection>>
  *** <<inject-ccf,Named `Session` Injection>>
  *** <<inject-serializer,`Serializer` Injection>>
* <<inject-into-coherence,Injecting CDI Beans into Coherence-managed Objects>>
 ** <<cdi-events,Using CDI Observers to Handle Coherence Server-Side Events>>
  *** <<cdi-event-types,Observer specific event types>>
  *** <<cdi-events-filter,Filter the events to be observed>>
  *** <<cdi-events-transform,Transform the events to be observed>>
  *** <<cdi-events-scopes,Observe events for maps and caches in specific scopes or services>>
  *** <<cdi-events-async,Using Asynchronous Observers>>
* <<inject-transient,Injecting CDI Beans into Transient Objects>>
 ** <<transient-injectable,Making transient classes `Injectable`>>
* <<filter-bindings,Filter Binding Annotations>>
* <<extractor-binding,Extractor Binding Annotations>>
 ** <<extractor-binding-built-in,Built-In Extractor Binding Annotations>>
  *** <<extractor-binding-property,@PropertyExtractor>>
  *** <<extractor-binding-chained,@ChainedExtractor>>
  *** <<extractor-binding-pof,@PofExtractor>>
 ** <<extractor-binding-custom,Custom Extractor Binding Annotations>>
* <<transformer-binding,MapEventTransformer Binding Annotations>>

[#inject-coherence-objects]
=== Injecting Coherence Objects into CDI Beans

CDI, and dependency injection in general, make it easy for application classes to declare the dependencies they need and
let the runtime provide them when necessary.
This makes the applications easier to develop, test and reason about, and the code extremely clean.

Coherence CDI allows you to do the same for Coherence objects, such as `Cluster`, `Session`, `NamedMap`,`NamedCache`,
`ContinuousQueryCache`, `ConfigurableCacheFactory`, etc.

[#inject-namedmap]
==== Injecting `NamedMap`, `NamedCache` and related objects

In order to inject an instance of a `NamedMap` into your CDI bean, you simply need to define an injection point for it:

[source,java]
----
import javax.inject.Inject;

@Inject
private NamedMap<Long, Person> people;
----

In the example above we've assumed that the map name you want to inject is the same as the name of the field you are
injecting into, `people`.
If that's not the case, you can use `@Name` qualifier to specify the name of the map you want to obtain explicitly:

[source,java]
----
import com.oracle.coherence.cdi.Name;
import javax.inject.Inject;

@Inject
@Name("people")
private NamedMap<Long, Person> m_people;
----

This is also what you have to do if you are using constructor injection or setter injection:

[source,java]
----
import com.oracle.coherence.cdi.Name;
import javax.inject.Inject;

@Inject
public MyClass(@Name("people") NamedMap<Long, Person> people) {
    ...
}

@Inject
public void setPeople(@Name("people") NamedMap<Long, Person> people) {
    ...
}
----

All the examples above assume that you want to use the default scope, which is often, but not always the case.
For example, you may have an Extend client that connects  to multiple Coherence clusters, in which case you would have
multiple scopes.

In this case you would use `@SessionName` qualifier to specify the name of the configured `Session`,
that will be used to supply the cache or map:

[source,java]
----
import com.oracle.coherence.cdi.SessionName;
import javax.inject.Inject;

@Inject
@SessionName("Products")
private NamedCache<Long, Product> products;

@Inject
@SessionName("Customers")
private NamedCache<Long, Customer> customers;
----

You can replace `NamedMap` or `NamedCache` in any of the examples above with `AsyncNamedCache` and `AsyncNamedCache`
respectively, in order to inject  asynchronous variant of those APIs:

[source,java]
----
import com.oracle.coherence.cdi.SessionName;
import javax.inject.Inject;

@Inject
private AsyncNamedMap<Long, Person> people;

@Inject
@SessionName("Products")
private AsyncNamedCache<Long, Person> Product;
----

[#inject-views]
===== Inject Views
You can also inject *views*, by simply adding `View` qualifier to either `NamedMap` or `NamedCache`:

[source,java]
----
import com.oracle.coherence.cdi.View;
import javax.inject.Inject;

@Inject
@View
private NamedMap<Long, Person> people;

@Inject
@View
private NamedCache<Long, Product> products;
----

The examples above are equivalent, and both will bring *all* the data from the backing map into a local view, as they
will use `AlwaysFilter` when constructing a view.
If you want to limit the data in the view to a subset, you can implement a <<filter-bindings,Custom FilterBinding>>
(recommended), or use a built-in `@WhereFilter` for convenience, which allows you to specify a filter using CohQL:

[source,java]
----
import com.oracle.coherence.cdi.Name;
import com.oracle.coherence.cdi.View;
import com.oracle.coherence.cdi.WhereFilter;
import javax.inject.Inject;

@Inject
@View
@WhereFilter("gender = 'MALE'")
@Name("people")
private NamedMap<Long, Person> men;

@Inject
@View
@WhereFilter("gender = 'FEMALE'")
@Name("people")
private NamedMap<Long, Person> women;
----

The  *views* also support transformation of the entry values on the server, in order to reduce both the amount of data
stored locally, and the amount of data transferred over the network.
For example, you may have a complex `Person` objects in the backing map, but only need their names in order to populate
a drop down on the client UI.

In that case, you can implement a custom <<custom-extractor,ExtractorBinding>> (recommended), or use a built-in
`@PropertyExtractor` for convenience:

[source,java]
----
import com.oracle.coherence.cdi.Name;
import com.oracle.coherence.cdi.View;
import com.oracle.coherence.cdi.PropertyExtractor;
import javax.inject.Inject;

@Inject
@View
@PropertyExtractor("fullName")
@Name("people")
private NamedMap<Long, String> names;
----

Note that the value type in the example above has changed from `Person` to `String`, due to server-side transformation
caused by the specified `@PropertyExtractor`.

[#inject-namedtopic]
==== Injecting `NamedTopic` and related objects

In order to inject an instance of a `NamedTopic` into your CDI bean, you simply need to define an injection point for it:

[source,java]
----
import com.tangosol.net.NamedTopic;
import javax.inject.Inject;

@Inject
private NamedTopic<Order> orders;
----

In the example above we've assumed that the topic name you want to inject is the same as the name of the field you are
injecting into, in this case `orders`.
If that's not the case, you  can use `@Name` qualifier to specify the name of the topic you want to obtain explicitly:

[source,java]
----
import com.oracle.coherence.cdi.Name;
import com.tangosol.net.NamedTopic;
import javax.inject.Inject;

@Inject
@Name("orders")
private NamedTopic<Order> topic;
----

This is also what you have to do if you are using constructor or setter injection instead:

[source,java]
----
import com.oracle.coherence.cdi.Name;
import com.tangosol.net.NamedTopic;
import javax.inject.Inject;

@Inject
public MyClass(@Name("orders") NamedTopic<Order> orders) {
    ...
}

@Inject
public void setOrdersTopic(@Name("orders") NamedTopic<Order> orders) {
    ...
}
----

All the examples above assume that you want to use the default scope, which is often, but not always the case.
For example, you may have an Extend client that connects to multiple Coherence clusters, in which case you would have
multiple scopes.

In this case you would use `@SessionName` qualifier to specify the name of the configured `Session`,
that will be used to supply the topic:

[source,java]
----
import com.oracle.coherence.cdi.SessionName;
import com.tangosol.net.NamedTopic;
import javax.inject.Inject;

@Inject
@SessionName("Finance")
private NamedTopic<PaymentRequest> payments;

@Inject
@SessionName("Shipping")
private NamedTopic<ShippingRequest> shipments;
----

The examples above allow you to inject a `NamedTopic` instance into your CDI bean, but it is often simpler and more
convenient to inject `Publisher` or `Subscriber` for a given topic instead.

This can be easily accomplished by replacing `NamedTopic<T>` in any of the examples above with either `Publisher<T>`:

[source,java]
----
import com.oracle.coherence.cdi.Name;
import com.oracle.coherence.cdi.SessionName;
import javax.inject.Inject;

@Inject
private Publisher<Order> orders;

@Inject
@Name("orders")
private Publisher<Order> m_orders;

@Inject
@SessionName("Finance")
private Publisher<PaymentRequest> payments;
----

or `Subscriber<T>`:

[source,java]
----
import com.oracle.coherence.cdi.Name;
import com.oracle.coherence.cdi.SessionName;
import javax.inject.Inject;

@Inject
private Subscriber<Order> orders;

@Inject
@Name("orders")
private Subscriber<Order> m_orders;

@Inject
@SessionName("Finance")
private Subscriber<PaymentRequest> payments;
----

Topic metadata, such as topic name (based on either injection point name or the explicit name from `@Name` annotation),
scope and message type, will be used under the hood to retrieve the `NamedTopic`, and to obtain `Publisher` or
`Subscriber` from it.

Additionally, if you want to place your `Subscriber`s into a subscriber group (effectively turning a topic into a
queue), you can easily accomplish that by adding `@SubscriberGroup` qualifier to the injection point:

[source,java]
----
import com.oracle.coherence.cdi.SubscriberGroup;
import javax.inject.Inject;

@Inject
@SubscriberGroup("orders-queue")
private Subscriber<Order> orders;
----

[#other-injection-points]
==== Other Supported Injection Points

While the injection of a `NamedMap`, `NamedCache`, `NamedTopic`, and related instances, as shown above,  is probably
the single most used feature of Coherence CDI, it is certainly not the only one.
The following sections describe other Coherence artifacts that can be injected using Coherence CDI.

[#inject-cluster]
===== `Cluster` and `OperationalContext` Injection

If you need an instance of a `Cluster` interface somewhere in your application, you can easily obtain it via injection:

[source,java]
----
import com.tangosol.net.Cluster;
import javax.inject.Inject;

@Inject
private Cluster cluster;
----

You can do the same if you need an instance of an `OperationalContext`:

[source,java]
----
import com.tangosol.net.OperationalContext;
import javax.inject.Inject;

@Inject
private OperationalContext ctx;
----

[#inject-ccf]
===== Named `Session` Injection

On rare occasions when you need to use a `Session` directly, Coherence CDI makes it trivial to do so.

Coherence will create a default `Session` when the CDI server starts, this will be created using the normal default
cache configuration file.
Other named sessions can be configured as CDI beans of type `SessionConfiguration`.

For example:

[source,java]
----
import com.oracle.coherence.cdi.SessionInitializer;
import javax.enterprise.context.ApplicationScoped;

@ApplicationScoped
public class MySession
        implements SessionInitializer
    {
    public String getName()
        {
        return "Foo";
        }
    // implement session configuration methods
    }
----
The bean above will create the configuration for a `Session` named `Foo`. When the CDI server starts the session
will be created and can then be injected into other beans.

A simpler way to create a `SessionConfiguration` is to implement the `SessionIntializer` interface and annotate the class.
For example:

[source,java]
----
import com.oracle.coherence.cdi.ConfigUri;
import com.oracle.coherence.cdi.Scope;
import com.oracle.coherence.cdi.SessionInitializer;
import javax.enterprise.context.ApplicationScoped;
import javax.inject.Named;

@ApplicationScoped
@Named("Foo")
@Scope("Foo")
@ConfigUri("my-coherence-config.xml")
public class MySession
        implements SessionInitializer
    {
    }
----
The above configuration will create a `Session` bean with a name of `Foo` a scoep of `Foo` with an underlying
`ConfigurableCacheFactory` created from the `my-coherence-config.xml` configuration file.

To obtain an instance of the default `Session`, all you need to do is inject it into the
class which needs to use it:

[source,java]
----
import com.tangosol.net.Session;
import javax.inject.Inject;

@Inject
private Session session;
----

If you need a specific named `Session` you can simply qualify one using `@Name` qualifier and
specifying the `Session` name:

[source,java]
----
import com.oracle.coherence.cdi.Name;
import javax.inject.Inject;

@Inject
@Name("SessionOne")
private Session sessionOne;

@Inject
@Name("SessionTwo")
private Session sessionTwo;
----

[#inject-serializer]
===== `Serializer` Injection

While in most cases you won't have to deal with serializers directly, Coherence CDI makes it simple to obtain named
serializers (and to register new ones) when you need.

To get a default `Serializer` for the current context class loader, you can simply inject it:

[source,java]
----
import com.tangosol.io.Serializer;
import javax.inject.Inject;

@Inject
private Serializer defaultSerializer;
----

However, it may be more useful to inject one of the named serializers defined in the operational configuration, which
can be easily accomplished using `@Name` qualifier:

[source,java]
----
import com.oracle.coherence.cdi.Name;
import javax.inject.Inject;

@Inject
@Name("java")
private Serializer javaSerializer;

@Inject
@Name("pof")
private Serializer pofSerializer;
----

In addition to the serializers defined in the operational config, the example above will also perform `BeanManager`
lookup for a named bean that implements `Serializer` interface.

That means that if you implemented a custom `Serializer` bean, such as:

[source,java]
----
import com.tangosol.io.Serializer;
import javax.enterprise.context.ApplicationScoped;
import javax.inject.Named;

@Named("json")
@ApplicationScoped
public class JsonSerializer implements Serializer {
    ...
}
----

it would be automatically discovered and registered by the CDI, and you would then be able to inject it just as easily
as the named serializers defined in the operational config:

[source,java]
----
import com.oracle.coherence.cdi.Name;
import javax.inject.Inject;

@Inject
@Name("json")
private Serializer jsonSerializer;
----

===== Inject a POF `Serializer` With a Specific POF Configuration

POF serializers can be injected by using both the `@Name` and `@ConfigUri` qualifiers to inject a POF serializer
which uses a specific POF configuration file.

[source,java]
----
import com.oracle.coherence.cdi.ConfigUri;
import com.oracle.coherence.cdi.Name;
import javax.inject.Inject;

@Inject
@Name("pof")
@ConfigUri("test-pof-config.xml")
private Serializer pofSerializer;
----

The code above will inject a POF serializer that uses `test-pof-config.xml` as its configuration file.

[#inject-into-coherence]
=== Injecting CDI Beans into Coherence-managed Objects

Coherence has a number of server-side extension points, which allow users to customize application  behavior in
different ways, typically by configuring their extensions within various sections of the  cache configuration file.
For example, the users can implement event interceptors and cache stores,  in order to handle server-side events and
integrate with the external data stores and other services.

Coherence CDI provides a way to inject named CDI beans into these extension points using custom  configuration
namespace handler.

[source,xml]
----
<cache-config xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xmlns="http://xmlns.oracle.com/coherence/coherence-cache-config"
        xmlns:cdi="class://com.oracle.coherence.cdi.server.CdiNamespaceHandler"
        xsi:schemaLocation="http://xmlns.oracle.com/coherence/coherence-cache-config coherence-cache-config.xsd">
----

Once you've declared the handler for the `cdi` namespace above, you can specify `<cdi:bean>` element in any place
where you would normally use `<class-name>` or `<class-factory-name>` elements:

[source,xml]
----
<?xml version="1.0"?>

<cache-config xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xmlns="http://xmlns.oracle.com/coherence/coherence-cache-config"
        xmlns:cdi="class://com.oracle.coherence.cdi.server.CdiNamespaceHandler"
        xsi:schemaLocation="http://xmlns.oracle.com/coherence/coherence-cache-config coherence-cache-config.xsd">

    <interceptors>
        <interceptor>
            <instance>
                <cdi:bean>registrationListener</cdi:bean>
            </instance>
        </interceptor>
        <interceptor>
            <instance>
                <cdi:bean>activationListener</cdi:bean>
            </instance>
        </interceptor>
    </interceptors>

    <caching-scheme-mapping>
        <cache-mapping>
            <cache-name>*</cache-name>
            <scheme-name>distributed-scheme</scheme-name>
            <interceptors>
                <interceptor>
                    <instance>
                        <cdi:bean>cacheListener</cdi:bean>
                    </instance>
                </interceptor>
            </interceptors>
        </cache-mapping>
    </caching-scheme-mapping>

    <caching-schemes>
        <distributed-scheme>
            <scheme-name>distributed-scheme</scheme-name>
            <service-name>PartitionedCache</service-name>
            <local-storage system-property="coherence.distributed.localstorage">true</local-storage>
            <partition-listener>
                <cdi:bean>partitionListener</cdi:bean>
            </partition-listener>
            <member-listener>
                <cdi:bean>memberListener</cdi:bean>
            </member-listener>
            <backing-map-scheme>
                <local-scheme/>
            </backing-map-scheme>
            <autostart>true</autostart>
            <interceptors>
                <interceptor>
                    <instance>
                        <cdi:bean>storageListener</cdi:bean>
                    </instance>
                </interceptor>
            </interceptors>
        </distributed-scheme>
    </caching-schemes>
</cache-config>
----

Note that you can only inject _named_ CDI beans (beans with an explicit `@Named` annotations) via  `<cdi:bean>` element.
For example, the `cacheListener` interceptor bean used above would look similar to this:

[source,java]
----
@ApplicationScoped
@Named("cacheListener")
@EntryEvents(INSERTING)
public class MyCacheListener
        implements EventInterceptor<EntryEvent<Long, String>> {
    @Override
    public void onEvent(EntryEvent<Long, String> e) {
        // handle INSERTING event
    }
}
----

Also keep in mind that only `@ApplicationScoped` beans can be injected, which implies that they  may be shared.
For example, because we've used a wildcard, `*`, as a cache name within the cache mapping in the example above, the same
instance of `cacheListener` will receive events from multiple caches.

This is typically fine, as the event itself provides the details about the context that raised it, including cache name,
and the service it was raised from, but it does imply that any shared state that you may have within your listener class
shouldn't be context-specific, and it must be safe for concurrent access from multiple threads.
If you can't guarantee the latter, you may want to declare the `onEvent` method as `synchronized`, to ensure only one
thread at a time can access any shared state you may have.

[#cdi-events]
==== Using CDI Observers to Handle Coherence Server-Side Events

While the above examples show that you can implement any Coherence `EventInterceptor` as a CDI bean and register it
using `<cdi:bean>` element within the cache configuration file, Coherence CDI  also provides a much simpler way to
accomplish the same goal using standard CDI Events and Observers.

For example, to observe events raised by a `NamedMap` with the name `people`, with keys of type `Long` and values of
type
`Person`, you would define a CDI observer such as this one:

[source,java]
----
private void onMapChange(@Observes @MapName("people") EntryEvent<Long, Person> event) {
    // handle all events raised by the 'people' map/cache
}
----

[#cdi-event-types]
===== Observe Specific Event Types

The observer method above will receive all events for the `people` map, but you can also control the types of events
received using event qualifiers:

[source,java]
----
private void onUpdate(@Observes @Updated @MapName("people") EntryEvent<Long, Person> event) {
    // handle UPDATED events raised by the 'people' map/cache
}

private void onChange(@Observes @Inserted @Updated @Removed @MapName("people") EntryEvent<?, ?> event) {
    // handle INSERTED, UPDATED and REMOVED events raised by the 'people' map/cache
}
----

[#cdi-events-filter]
===== Filter Observed Events

The events observed can be restricted further by using a Coherence `Filter`.
If a filter has been specified, the events will be filtered on the server and will never be sent to the client.
The filter that will be used is specified using a qualifier annotation that is itself annotated with `@FilterBinding`.

You can implement a <<filter-bindings,Custom FilterBinding>> (recommended), or use a built-in `@WhereFilter` for
convenience, which allows you to specify a filter using CohQL.

For example to receive all event types in the `people` map, but only for `People` with a `lastName` property value of
`Smith`, the built-in `@WhereFilter` annotation can be used:

[source,java]
----
@WhereFilter("lastName = 'Smith'")
private void onMapChange(@Observes @MapName("people") EntryEvent<Long, Person> event) {
    // handle all events raised by the 'people' map/cache
}
----


[#cdi-events-transform]
===== Transform Observed Events

When an event observer does not want to receive the full cache or map value in an event, the event can be transformed
into a different value to be observed. This is achieved using a `MapEventTransformer` that is applied to the observer
method using either an `ExtractorBinding` annotation or a `MapEventTransformerBinding` annotation.
Transformation of events happens on the server so can make observer's more efficient as they do not need to receive
the original event with the full old and new values.

*Transforming Events Using ExtractorBinding Annotations*

An `ExtractorBinding` annotation is an annotation that represents a Coherence `ValueExtractor`.
When an observer method has been annotated with an `ExtractorBinding` annotation the resulting `ValueExtractor` is
applied to the event's values and a new event will be returned to the observer containing just the extracted
properties.

For example, an event observer that is observing events from a map named `people`, but only requires the last name,
the built in `@PropertyExtractor` annotation can be used.

[source,java]
----
@PropertyExtractor("lastName")
private void onMapChange(@Observes @MapName("people") EntryEvent<Long, String> event) {
    // handle all events raised by the 'people' map/cache
}
----

Unlike the previous examples above the received events of type `EntryEvent<Long, Person>` this method will receive
events of type `EntryEvent<Long, String>` because the property extractor will be applied to the `Person`
values in the original event to extract just the `lastName` property, creating a new event with `String` values.

There are a number of built in `ExtractorBinding` annotations, and it is also possible to create custom
`ExtractorBinding` annotation - see the <<custom-extractor,Custom ExtractorBinding Annotations>> section below.

Multiple extractor binding annotations can be added to an injection point, in which case multiple properties will be
extracted, and the event will contain a `List` of the extracted property values.

For example, if the `Person` also contains an `address` field of type `Address` that contains a `city` field, this
can be extracted with a `@ChainedExtractor` annotation. By combining this with the `@PropertyExtractor` in the
example above both the `lastName` and `city` can be observed in the event.
[source,java]
----
@PropertyExtractor("lastName")
@ChainedExtractor({"address", "city"})
private void onMapChange(@Observes @MapName("people") EntryEvent<Long, List<String>> event) {
    // handle all events raised by the 'people' map/cache
}
----

Note, now the event is of type `EntryEvent<Long, List<String>>` because multiple extracted values will be returned the
event value is a `List` and in this case both properties are of tyep `String`, so the value can be `List<String>`.


*Transforming Events Using MapEventTransformerBinding Annotations*

If more complex event transformations are required than just extracting properties from event values, a custom
`MapEventTransformerBinding` can be created that will produce a custom `MapEventTransformer` instance that will be
applied to the observer's events.
See the <<custom-transformer,Custom MapEventTransformerBinding Annotations>> section below for details on how to create
`MapEventTransformerBinding` annotations.



[#cdi-events-scopes]
===== Observe Events for Maps and Caches in Specific Services and Scopes

In addition, to the `@MapName` qualifier, you can also use `@ServiceName` and `@ScopeName` qualifiers as a way to limit
the events received.

The examples above show only how to handle ``EntryEvent``s, but the same applies to all other server-side event types:

[source,java]
----
private void onActivated(@Observes @Activated LifecycleEvent event) {
    // handle cache factory activation
}

private void onCreatedPeople(@Observes @Created @MapName("people") CacheLifecycleEvent event) {
    // handle creation of the 'people' map/cache
}

private void onExecuted(@Observes @Executed @MapName("people") @Processor(Uppercase.class) EntryProcessorEvent event) {
    // intercept 'Uppercase` entry processor execution against 'people' map/cache
}
----

[#cdi-events-async]
===== Using Asynchronous Observers

All the examples above used synchronous observers by specifying `@Observes` qualifier for each observer method.
However, Coherence CDI fully supports asynchronous CDI observers as well.
All you need to do is replace `@Observes` with `@ObservesAsync` in any of the examples above.

[source,java]
----
private void onActivated(@ObservesAsync @Activated LifecycleEvent event) {
    // handle cache factory activation
}

private void onCreatedPeople(@ObservesAsync @Created @MapName("people") CacheLifecycleEvent event) {
    // handle creation of the 'people' map/cache
}

private void onExecuted(@ObservesAsync @Executed @MapName("people") @Processor(Uppercase.class) EntryProcessorEvent event) {
    // intercept 'Uppercase` entry processor execution against 'people', map/cache
}
----

[WARNING]
====

Coherence events fall into two categories: pre- and post-commit events.
All the events whose name ends  with `"ing"`, such as `Inserting`, `Updating`, `Removing` or `Executing` are
pre-commit, which means that they can either modify the data or even veto the operation by throwing an exception,
but in  order to do so they must be synchronous to ensure that they are executed on the same thread that is
executing the operation that triggered the event.

That means that you can _observe_ them using asynchronous CDI observers, but if you want to mutate the set of
entries that are part of the event payload, or veto the event by throwing an exception, you must use synchronous
CDI observer.
====

[#inject-transient]
=== Injecting CDI Beans into Transient Objects

Using CDI to inject Coherence objects into your application classes, and CDI beans into Coherence-managed objects will
allow you to support many use cases where dependency injection may be useful, but it doesn't cover an important use
case that is somewhat specific to Coherence.

Coherence is a distributed system, and it uses serialization in order to send both the data and the  processing requests
from one cluster member (or remote client) to another, as well as to store data, both in memory and on disk.

Processing requests, such as entry processors and aggregators, have to be deserialized on a target cluster member(s) in
order to be executed. In some cases, they could benefit from dependency injection in order to avoid service lookups.

Similarly, while the data is stored in a serialized, binary format, it may need to be deserialized into user supplied
classes for server-side processing, such as when executing entry processors and aggregators. In this case, data classes
can often also benefit from dependency injection (in order to support Domain-Driven Design (DDD), for example).

While these transient objects are not managed by the CDI container, Coherence CDI does support their injection during
deserialization, but for performance reasons requires that you explicitly opt-in by implementing
`com.oracle.coherence.cdi.Injectable` interface.

[#transient-injectable]
==== Making transient classes `Injectable`

While not technically a true marker interface, `Injectable` can be treated as such for all intents and purposes.
All you need to do is add it to the `implements` clause of your class in order for injection on deserialization to
kick in:

[source,java]
----
public class InjectableBean
        implements Injectable, Serializable {

    @Inject
    private Converter<String, String> converter;

    private String text;

    InjectableBean() {
    }

    InjectableBean(String text) {
        this.text = text;
    }

    String getConvertedText() {
        return converter.convert(text);
    }
}
----

Assuming that you have the following `Converter` service implementation in your application, it will be injected
into `InjectableBean` during deserialization, and the `getConvertedText` method will return the value of the `text`
field converted to upper case:

[source,java]
----
@ApplicationScoped
public class ToUpperConverter
        implements Converter<String, String> {
    @Override
    public String convert(String s) {
        return s.toUpperCase();
    }
}
----

NOTE: If your `Injectable` class has `@PostConstruct` callback method, it will be called after the injection.
However, because we have no control over object's lifecycle after that point, `@PreDestroy` callback will *never* be called).

You should note that the above functionality is not dependent on the serialization format and will work with both
Java and POF serialization (or any other custom serializer), and for any object that is  deserialized on any Coherence
member (or even on a remote client).

While the deserialized transient objects are not true CDI managed beans, being able to inject CDI managed dependencies
into them upon deserialization will likely satisfy most dependency injection requirements you will ever have in those
application components.
We hope you'll find it useful.


[#filter-bindings]
=== FilterBinding Annotations

As already mentioned above, when creating views or subscribing to events, the view or events can be modified using
`Filters`.
The exact `Filter` implementation injected will be determined by the view or event observers qualifiers.
Specifically any qualifier annotation that is itself annotated with the `@FilterBinding` annotation.
This should be a familiar pattern to anyone who has worked with CDI interceptors.

For example, if there is an injection point for a view that is a filtered view of an underlying map, but the filter
required
is more complex than those provided by the build in qualifiers, or is some custom filter implementation.
The steps required are:

* Create a custom annotation class to represent the required `Filter`.
* Create a bean class implementing `com.oracle.coherence.cdi.FilterFactory` annotated with the custom annotation that
will be the factory for producing instances of the custom `Filter`.
* Annotate the view injection point with the custom annotation.

==== Create the Custom Filter Annotation

Creating the filter annotation is simply creating a normal Java annotation class that is annotated with
the `@com.oracle.coherence.cdi.FilterBinding` annotation.

[source,java]
----
@Inherited
@FilterBinding  // <1>
@Documented
@Retention(RetentionPolicy.RUNTIME)
public @interface CustomFilter {
}
----
<1> The most important part is that this new annotation is annotated with `FilterBinding` so that the Coherence CDI
extensions can recognise that it represents a `Filter`.

==== Create the Custom Filter Factory

Once the custom annotation has been created a `FilterFactories` implementation can be created that will be responsible
for producing instances of the required `Filter`.

[source,java]
----
@ApplicationScoped    // <1>
@CustomFilter         // <2>
static class CustomFilterSupplier
        implements FilterFactory<CustomFilter, Object>
    {
    @Override
    public Filter<Object> create(CustomFilter annotation)
        {
        return new CustomComplexFilter(); // <3>
        }
    }
----
<1> The `CustomFilterSupplier` class has been annotated with `@ApplicationScoped` to make is discoverable by CDI.
<2> The `CustomFilterSupplier` class has been annotated with the new filter binding annotation `@CustomFilter`
so that the Coherence CDI extension can locate it when it needs to create `Filters`.
<3> The `CustomFilterSupplier` implements the `FilterFactories` interface's `create` method where it creates the
custom `Filter` implementation.

==== Annotate the Injection Point

Now there is both a custom annotation, and an annotated `FilterFactories`, the injection point requiring the `Filter`
can be annotated with the new annotation.

[source,java]
----
@Inject
@View
@CustomFilter
private NamedMap<Long, Person> people;
----

As well as views, custom filter binding annotations can also be used for event observers.
For example if there is an event observer method that should only receive events matching the same custom `Filter`
then the method can be annotated with the same custom filter annotation.

[source,java]
----
@CustomFilter
private void onPerson(@Observes @MapName("people") EntryEvent<Long, Person> event) {
----

[#extractor-binding]
=== ExtractorBinding Annotations

Extractor bindings are annotations that are themselves annotated with `@ExtractorBinding` and are used in conjunction
with an implementation of `com.oracle.coherence.cdi.ExtractorFactory` to produce Coherence `ValueExtractor` instances.

There are a number of built-in extractor binding annotations in the Coherence CDI module and it is a simple process
to provide custom implementations.

[#extractor-binding-built-in]
==== Built-In ExtractorBinding Annotations

[#extractor-binding-property]
===== PropertyExtractor

The `@PropertyExtractor` annotation can used to obtain an extractor that extracts a named property from an object.
The value field of the `@PropertyExtractor` annotation is name of the property to extract.

For example, this `@PropertyExtractor` annotation represents a `ValueExtractor` that will extract the `lastName`
property from a value.
[source,java]
----
@PropertyExtractor("lastName")
----

The extractor produced will be an instance of `com.tangosol.util.extractor.UniversalExtractor`,
so the example above is the same as calling:
[source,java]
----
new UniversalExtractor("lastName");
----

The `@PropertyExtractor` annotation can be applied multiple times to create a `MultiExtractor` that will extract
a `List` of properties from a value.

For example, if there was a map named `people`, where the map values are instances of `Person`, that has a `firstName`
and a `lastName` property. The event observer below would observe events on that map, but the event received would only
contain the event key, and a `List` containing the extracted `firstName` and `lastName` from the original event.
where the event values will be a list of
[source,java]
----
@PropertyExtractor("firstName")
@PropertyExtractor("lastName")
private void onPerson(@Observes @MapName("people") EntryEvent<Long, List<String>> event) {
----

[#extractor-binding-chained]
===== ChainedExtractor

The `@ChainedExtractor` annotation can be used to extract a chain of properties.

For example, a `Person` instance might contain an `address` property that contains a `city` property.
The `@ChainedExtractor` takes the chain of fields to be extracted, in this case, extract the `address` from `Person`
and then extract the `city` from the `address`.
[source,java]
----
@ChainedExtractor("address", "city")
----

Each of the property names is used to create a `UniversalExtractor`, and the array of these extractors is used to
create an instance of `com.tangosol.util.extractor.ChainedExtractor`.

The example above would be the same as calling:
[source,java]
----
UniversalExtractor[] chain = new UniversalExtractor[] {
        new UniversalExtractor("address"),
        new UniversalExtractor("city")
};
ChainedExtractor extractor = new ChainedExtractor(chain);
----

[#extractor-binding-pof]
===== PofExtractor

The `@PofExtractor` annotation can be used to produce extractors that can extract properties from POF encoded values.
The value passed to the `@PofExtractor` annotation is the POF path to navigate to the property to extract.

For example, if a `Person` value has been serialized using POF with a `lastName` property at index `4` a `@PofExtractor`
annotation could be used like this:
[source,java]
----
@PofExtractor(index = 4)
----

The code above will create a Coherence `com.tangosol.util.extractor.PofExtractor` equivalent to calling:
[source,java]
----
com.tangosol.util.extractor.PofExtractor(null, 4);
----

Sometimes (for example when dealing with certain types of `Number`) the `PofExtractor` needs to know they type to be
extracted. In this case the `type` value can be set in the `@PofExtractor` annotation.

For example, if a `Book` value had a `sales` field of type `Long` at POF index 2, the `sales` field could be
extracted using the following `@PofExtractor` annotation:
[source,java]
----
@PofExtractor(index = {2}, type = Long.class)
----

The code above will create a Coherence `com.tangosol.util.extractor.PofExtractor` equivalent to calling:
[source,java]
----
com.tangosol.util.extractor.PofExtractor(Long.class, 2);
----

The `index` value for a `@PofExtractor` annotation is an int array so multiple POF index values can be passed to navigate
down a chain of properties to extract. For example if `Person` contained an `Address` at POF index `5` and `Address`
contained a `city` property at POF index `3` the `city` could be extracted from a `Person` using the `@PofExtractor`
annotation like this:
[source,java]
----
@PofExtractor(index = {5, 3})
----

Alternatively if the value that will be extracted from is annotated with `com.tangosol.io.pof.schema.annotation.PortableType`
and the POF serialization code for the class has been generated using the Coherence
`com.tangosol.io.pof.generator.PortableTypeGenerator` then property names can be passed to the `@PofExtractor` annotation
using its `path` field.

For example to extract the `lastName` field from a POF serialized `Person` the `@PofExtractor` annotation can be
used like this:
[source,java]
----
@PofExtractor(path = "lastName")
----

the `address` `city` example would be:
[source,java]
----
@PofExtractor(path = {"address", "city"})
----


and the `Book` `sales` example would be:
[source,java]
----
@PofExtractor(path = "sales", type Long.class)
----

[#extractor-binding-custom]
==== Custom ExtractorBinding Annotations

When the built-in extractor bindings are not suitable, or when a custom `ValueExtractor` implementation is required,
then a custom extractor binding annotation can be created with a corresponding `com.oracle.coherence.cdi.ExtractorFactory`
implementation.
The steps required are:

* Create a custom annotation class to represent the required `ValueExtractor`.
* Create a bean class implementing `com.oracle.coherence.cdi.ExtractorFactory` annotated with the custom annotation that
will be the factory for producing instances of the custom `ValueExtractor`.
* Annotate the view injection point with the custom annotation.

==== Create the Custom Extractor Annotation

Creating the extractor annotation is simply creating a normal Java annotation class which is annotated with
the `@com.oracle.coherence.cdi.ExtractorBinding` annotation.

[source,java]
----
@Inherited
@ExtractorBinding  // <1>
@Documented
@Retention(RetentionPolicy.RUNTIME)
public @interface CustomExtractor {
}
----
<1> The most important part is that this new annotation has been annotated with `ExtractorBinding` so that the
Coherence CDI extensions can recognise that it represents a `ValueExtractor`.

==== Create the Custom Extractor Factory

Once the custom annotation has been created an `ExtractorFactory` implementation can be created that will be responsible
for producing instances of the required `ValueExtractor`.

[source,java]
----
@ApplicationScoped    // <1>
@CustomExtractor      // <2>
static class CustomExtractorSupplier
        implements ExtractorFactory<CustomExtractor, Object, Object>
    {
    @Override
    public ValueExtractor<Object, Object> create(CustomExtractor annotation)
        {
        return new CustomComplexExtractor(); // <3>
        }
    }
----
<1> The `CustomExtractorSupplier` class has been annotated with `@ApplicationScoped` to make is discoverable by CDI.
<2> The `CustomExtractorSupplier` class has been annotated with the new extractor binding annotation `@CustomExtractor`
so that the Coherence CDI extension can locate it when it needs to create `ValueExtractor` instances.
<3> The `CustomExtractorSupplier` implements the `ExtractorFactory` interface's `create` method where it creates the
custom `ValueExtractor` implementation.

==== Annotate the Injection Point

Now there is both a custom annotation, and an annotated `ExtractorFactory`, the injection point requiring the
`ValueExtractor` can be annotated with the new annotation.

[source,java]
----
@Inject
@View
@CustomExtractor
private NamedMap<Long, String> people;
----

As well as views, custom filter binding annotations can also be used for event observers.
For example if there is an event observer method that should only receive transformed events using the custom extractor
to transform the event:

[source,java]
----
@CustomExtractor
private void onPerson(@Observes @MapName("people") EntryEvent<Long, String> event) {
----


[#transformer-binding]
=== MapEventTransformerBinding Annotations

Coherence CDI supports event observers that can observe events for cache, or map, entries
(see the <<cdi-events,Events>> section). The observer method can be annotated with a `MapEventTransformerBinding`
annotation to indicate that the observer requires a transformer to be applied to the original event before it is observed.

There are no built-in `MapEventTransformerBinding` annotations, this feature is to support use of custom
`MapEventTransformer` implementations.

The steps to create and use a `MapEventTransformerBinding` annotation are:

* Create a custom annotation class to represent the required `MapEventTransformer`.
* Create a bean class implementing `com.oracle.coherence.cdi.MapEventTransformerFactory` annotated with the custom
annotation that will be the factory for producing instances of the custom `MapEventTransformer`.
* Annotate the view injection point with the custom annotation.

==== Create the Custom Extractor Annotation

Creating the extractor annotation is simply creating a normal Java annotation class which is annotated with
the `@com.oracle.coherence.cdi.MapEventTransformerBinding` annotation.

[source,java]
----
@Inherited
@MapEventTransformerBinding  // <1>
@Documented
@Retention(RetentionPolicy.RUNTIME)
public @interface CustomTransformer {
}
----
<1> The most important part is that this new annotation has been annotated with `MapEventTransformerBinding` so that the
Coherence CDI extensions can recognise that it represents a `MapEventTransformer`.

==== Create the Custom Extractor Factory

Once the custom annotation has been created an `MapEventTransformerFactory` implementation can be created that will be
responsible for producing instances of the required `MapEventTransformer`.

[source,java]
----
@ApplicationScoped      // <1>
@CustomTransformer      // <2>
static class CustomTransformerSupplier
        implements MapEventTransformerFactory<CustomTransformer, Object, Object, Object>
    {
    @Override
    public MapEventTransformer<Object, Object, Object> create(CustomTransformer annotation)
        {
        return new CustomComplexTransformer(); // <3>
        }
    }
----
<1> The `CustomTransformerSupplier` class has been annotated with `@ApplicationScoped` to make is discoverable by CDI.
<2> The `CustomTransformerSupplier` class has been annotated with the new extractor binding annotation `@CustomTransformer`
so that the Coherence CDI extension can locate it when it needs to create `MapEventTransformer` instances.
<3> The `CustomTransformerSupplier` implements the `MapEventTransformerFactory` interface's `create` method where it
creates the custom `MapEventTransformer` implementation.

==== Annotate the Injection Point

Now there is both a custom annotation, and an annotated `MapEventTransformerFactory`, the observer method
requiring the `MapEventTransformer` can be annotated with the new annotation.

[source,java]
----
@CustomTransformer
private void onPerson(@Observes @MapName("people") EntryEvent<Long, String> event) {
----
