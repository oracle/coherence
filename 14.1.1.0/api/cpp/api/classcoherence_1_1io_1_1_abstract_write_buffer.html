<!--
  Copyright (c) 2000, 2020, Oracle and/or its affiliates.

  Licensed under the Universal Permissive License v 1.0 as shown at
  http://oss.oracle.com/licenses/upl.
-->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Oracle&amp;reg; Fusion Middleware C++ API Reference for Oracle Coherence: AbstractWriteBuffer Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<b>Oracle&reg; Fusion Middleware C++ API Reference for Oracle Coherence<br>14c (14.1.1.0.2 Internal-lsho-mac-0716.2020.0219)</b><br>F23533-01
<!-- Generated by Doxygen 1.5.3 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li class="current"><a href="classes.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul>
</div>
<div class="tabs">
  <ul>
    <li><a href="classes.html"><span>Alphabetical&nbsp;List</span></a></li>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul>
</div>
<div class="nav">
<a class="el" href="namespacecoherence.html">coherence</a>::<a class="el" href="namespacecoherence_1_1io.html">io</a>::<a class="el" href="classcoherence_1_1io_1_1_abstract_write_buffer.html">AbstractWriteBuffer</a></div>
<h1>AbstractWriteBuffer Class Reference</h1><!-- doxytag: class="coherence::io::AbstractWriteBuffer" --><!-- doxytag: inherits="coherence::lang::Object,coherence::io::WriteBuffer" --><code>#include &lt;<a class="el" href="_abstract_write_buffer_8hpp-source.html">coherence/io/AbstractWriteBuffer.hpp</a>&gt;</code>
<p>
Inherits <a class="el" href="classcoherence_1_1lang_1_1_object.html">Object</a>, and <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html">WriteBuffer</a>.
<p>
Inherited by <a class="el" href="classcoherence_1_1io_1_1_delegating_write_buffer.html">DelegatingWriteBuffer</a>, and <a class="el" href="classcoherence_1_1io_1_1_octet_array_write_buffer.html">OctetArrayWriteBuffer</a>.
<p>

<p>
<a href="classcoherence_1_1io_1_1_abstract_write_buffer-members.html">List of all members.</a><hr><a name="_details"></a><h2>Detailed Description</h2>
The <a class="el" href="classcoherence_1_1io_1_1_abstract_write_buffer.html" title="The AbstractWriteBuffer is a partial implementation of the WriteBuffer interface...">AbstractWriteBuffer</a> is a partial implementation of the <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html" title="The WriteBuffer interface represents an in-memory block of binary data that is being...">WriteBuffer</a> interface intended to be used as a base class for easily creating concrete <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html" title="The WriteBuffer interface represents an in-memory block of binary data that is being...">WriteBuffer</a> implementations. 
<p>
This implementation is explicitly not thread-safe.<p>
<dl class="author" compact><dt><b>Author:</b></dt><dd>jh 2008.01.08 </dd></dl>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="5b310f5b3b4a79c7cde67e22f5bfd543"></a><!-- doxytag: member="coherence::io::AbstractWriteBuffer::Handle" ref="5b310f5b3b4a79c7cde67e22f5bfd543" args="" -->
typedef spec::Handle&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1io_1_1_abstract_write_buffer.html#5b310f5b3b4a79c7cde67e22f5bfd543">Handle</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classcoherence_1_1io_1_1_abstract_write_buffer.html" title="The AbstractWriteBuffer is a partial implementation of the WriteBuffer interface...">AbstractWriteBuffer</a> Handle definition. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="9dff753690c2fde7f2096982681b2fe3"></a><!-- doxytag: member="coherence::io::AbstractWriteBuffer::View" ref="9dff753690c2fde7f2096982681b2fe3" args="" -->
typedef spec::View&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1io_1_1_abstract_write_buffer.html#9dff753690c2fde7f2096982681b2fe3">View</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classcoherence_1_1io_1_1_abstract_write_buffer.html" title="The AbstractWriteBuffer is a partial implementation of the WriteBuffer interface...">AbstractWriteBuffer</a> View definition. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f6b6cf6ce7af189584f0d92db3187844"></a><!-- doxytag: member="coherence::io::AbstractWriteBuffer::Holder" ref="f6b6cf6ce7af189584f0d92db3187844" args="" -->
typedef spec::Holder&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1io_1_1_abstract_write_buffer.html#f6b6cf6ce7af189584f0d92db3187844">Holder</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classcoherence_1_1io_1_1_abstract_write_buffer.html" title="The AbstractWriteBuffer is a partial implementation of the WriteBuffer interface...">AbstractWriteBuffer</a> Holder definition. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="517544dd75095d44e95ef13177cd51d1"></a><!-- doxytag: member="coherence::io::AbstractWriteBuffer::Handle" ref="517544dd75095d44e95ef13177cd51d1" args="" -->
typedef this_spec::Handle&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1io_1_1_abstract_write_buffer.html#517544dd75095d44e95ef13177cd51d1">Handle</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classcoherence_1_1io_1_1_write_buffer.html" title="The WriteBuffer interface represents an in-memory block of binary data that is being...">WriteBuffer</a> Handle definition. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="375d9e85f5e19469d1d6a1acae1cb6e4"></a><!-- doxytag: member="coherence::io::AbstractWriteBuffer::View" ref="375d9e85f5e19469d1d6a1acae1cb6e4" args="" -->
typedef this_spec::View&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1io_1_1_abstract_write_buffer.html#375d9e85f5e19469d1d6a1acae1cb6e4">View</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classcoherence_1_1io_1_1_write_buffer.html" title="The WriteBuffer interface represents an in-memory block of binary data that is being...">WriteBuffer</a> View definition. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f1873c9683c4393b457a15cfd79dded0"></a><!-- doxytag: member="coherence::io::AbstractWriteBuffer::Holder" ref="f1873c9683c4393b457a15cfd79dded0" args="" -->
typedef this_spec::Holder&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1io_1_1_abstract_write_buffer.html#f1873c9683c4393b457a15cfd79dded0">Holder</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classcoherence_1_1io_1_1_write_buffer.html" title="The WriteBuffer interface represents an in-memory block of binary data that is being...">WriteBuffer</a> Holder definition. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="3767e7d25e7b7307dc1aa2b2c6fffae0"></a><!-- doxytag: member="coherence::io::AbstractWriteBuffer::BinaryView" ref="3767e7d25e7b7307dc1aa2b2c6fffae0" args="" -->
typedef <a class="el" href="classcoherence_1_1lang_1_1_typed_handle.html">TypedHandle</a><br>
&lt; const <br>
<a class="el" href="classcoherence_1_1util_1_1_binary.html">coherence::util::Binary</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1io_1_1_abstract_write_buffer.html#3767e7d25e7b7307dc1aa2b2c6fffae0">BinaryView</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Binary View definition. <br></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="98aece443414aae10a32229f6551cb07"></a><!-- doxytag: member="coherence::io::AbstractWriteBuffer::getMaximumCapacity" ref="98aece443414aae10a32229f6551cb07" args="() const " -->
virtual size32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1io_1_1_abstract_write_buffer.html#98aece443414aae10a32229f6551cb07">getMaximumCapacity</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determine the maximum number of octets that the buffer can hold.<p>
If the maximum size is greater than the current size, then the buffer is expected to resize itself as necessary up to the maximum size in order to contain the data given to it.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the maximum number of octets of data that the <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html" title="The WriteBuffer interface represents an in-memory block of binary data that is being...">WriteBuffer</a> can hold</dd></dl>
 <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="c4155ac8ed31d610926fb8370b5ce220"></a><!-- doxytag: member="coherence::io::AbstractWriteBuffer::write" ref="c4155ac8ed31d610926fb8370b5ce220" args="(size32_t ofDest, Array&lt; octet_t &gt;::View vabSrc)" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1io_1_1_abstract_write_buffer.html#c4155ac8ed31d610926fb8370b5ce220">write</a> (size32_t ofDest, <a class="el" href="classcoherence_1_1lang_1_1_array.html">Array</a>&lt; octet_t &gt;::<a class="el" href="classcoherence_1_1io_1_1_abstract_write_buffer.html#9dff753690c2fde7f2096982681b2fe3">View</a> vabSrc)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Store the specified octets at the specified offset within the buffer.<p>
For purposes of side-effects and potential exceptions, this method is functionally equivalent to the following code: <pre><code>
 write(ofDest, vabSrc, 0, vabSrc.length);
 </code></pre><p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ofDest</em>&nbsp;</td><td>the offset within this buffer to store the passed data </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vabSrc</em>&nbsp;</td><td>the array of octets to store in this buffer</td></tr>
  </table>
</dl>
 <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="5f56076b0c2b2f90978cfb34b65ab9f2"></a><!-- doxytag: member="coherence::io::AbstractWriteBuffer::write" ref="5f56076b0c2b2f90978cfb34b65ab9f2" args="(size32_t ofDest, ReadBuffer::View vBufSrc)" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1io_1_1_abstract_write_buffer.html#5f56076b0c2b2f90978cfb34b65ab9f2">write</a> (size32_t ofDest, <a class="el" href="classcoherence_1_1io_1_1_read_buffer.html#9dff753690c2fde7f2096982681b2fe3">ReadBuffer::View</a> vBufSrc)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Store the contents of the specified <a class="el" href="classcoherence_1_1io_1_1_read_buffer.html" title="The ReadBuffer interface represents an in-memory block of binary data.">ReadBuffer</a> at the specified offset within this buffer.<p>
For purposes of side-effects and potential exceptions, this method is functionally equivalent to the following code: <pre><code>
 <a class="el" href="classcoherence_1_1lang_1_1_array.html#9dff753690c2fde7f2096982681b2fe3" title="Array&lt;T&gt; View definition.">Array&lt;octet_t&gt;::View</a> vabSrc = vBufSrc-&gt;<a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#bf95b164a1ea4034951baeeb5795581d" title="Returns an octet array that holds the complete contents of this WriteBuffer.">toOctetArray()</a>;
 write(ofDest, vabSrc, 0, vabSrc-&gt;length);
 </code></pre><p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ofDest</em>&nbsp;</td><td>the offset within this buffer to store the passed data </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vBufSrc</em>&nbsp;</td><td>the array of octets to store in this buffer</td></tr>
  </table>
</dl>
 <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="16af07961edb726be9a778b3289625b3"></a><!-- doxytag: member="coherence::io::AbstractWriteBuffer::write" ref="16af07961edb726be9a778b3289625b3" args="(size32_t ofDest, ReadBuffer::View vBufSrc, size32_t ofSrc, size32_t cbSrc)" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1io_1_1_abstract_write_buffer.html#16af07961edb726be9a778b3289625b3">write</a> (size32_t ofDest, <a class="el" href="classcoherence_1_1io_1_1_read_buffer.html#9dff753690c2fde7f2096982681b2fe3">ReadBuffer::View</a> vBufSrc, size32_t ofSrc, size32_t cbSrc)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Store the specified portion of the contents of the specified <a class="el" href="classcoherence_1_1io_1_1_read_buffer.html" title="The ReadBuffer interface represents an in-memory block of binary data.">ReadBuffer</a> at the specified offset within this buffer.<p>
For purposes of side-effects and potential exceptions, this method is functionally equivalent to the following code: <pre><code>
 <a class="el" href="classcoherence_1_1lang_1_1_array.html#9dff753690c2fde7f2096982681b2fe3" title="Array&lt;T&gt; View definition.">Array&lt;octet_t&gt;::View</a> vabSrc = vbufSrc.toOctetArray(ofSrc, cbSrc);
 write(ofDest, vabSrc, 0, vabSrc-&gt;length);
 </code></pre><p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ofDest</em>&nbsp;</td><td>the offset within this buffer to store the passed data </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vBufSrc</em>&nbsp;</td><td>the source <a class="el" href="classcoherence_1_1io_1_1_read_buffer.html" title="The ReadBuffer interface represents an in-memory block of binary data.">ReadBuffer</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ofSrc</em>&nbsp;</td><td>the offset within the passed <a class="el" href="classcoherence_1_1io_1_1_read_buffer.html" title="The ReadBuffer interface represents an in-memory block of binary data.">ReadBuffer</a> to copy from </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cbSrc</em>&nbsp;</td><td>the number of octets to copy from the passed <a class="el" href="classcoherence_1_1io_1_1_read_buffer.html" title="The ReadBuffer interface represents an in-memory block of binary data.">ReadBuffer</a></td></tr>
  </table>
</dl>
 <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="6f149e4cddbdd51b25e1faefef9fc7f1"></a><!-- doxytag: member="coherence::io::AbstractWriteBuffer::retain" ref="6f149e4cddbdd51b25e1faefef9fc7f1" args="(size32_t of)" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1io_1_1_abstract_write_buffer.html#6f149e4cddbdd51b25e1faefef9fc7f1">retain</a> (size32_t of)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Starting with the octet at offset <code>of</code>, retain the remainder of this <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html" title="The WriteBuffer interface represents an in-memory block of binary data that is being...">WriteBuffer</a>, such that the octet at offset <code>of</code> is shifted to offset 0, the octet at offset <code>of + 1</code> is shifted to offset 1, and so on up to the octet at offset <code><a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#e4914e7cc4d1fa65343870ceb7d6bce4" title="Determine the length of the data that is in the buffer.">length()</a> - 1</code>, which is shifted to offset <code><a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#e4914e7cc4d1fa65343870ceb7d6bce4" title="Determine the length of the data that is in the buffer.">length()</a> - of - 1</code>.<p>
After this method, the length of of the buffer as indicated by the <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#e4914e7cc4d1fa65343870ceb7d6bce4" title="Determine the length of the data that is in the buffer.">length()</a> method will be equal to <code><a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#e4914e7cc4d1fa65343870ceb7d6bce4" title="Determine the length of the data that is in the buffer.">length()</a> - of</code>.<p>
This method is functionally equivalent to the following code: <pre><code>
 retain(of, <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#e4914e7cc4d1fa65343870ceb7d6bce4" title="Determine the length of the data that is in the buffer.">length()</a> - of);
 </code></pre><p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>of</em>&nbsp;</td><td>the offset of the first octet within the <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html" title="The WriteBuffer interface represents an in-memory block of binary data that is being...">WriteBuffer</a> that will be retained</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IndexOutOfBoundsException</em>&nbsp;</td><td>if <code>of</code> is greater than <code><a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#e4914e7cc4d1fa65343870ceb7d6bce4" title="Determine the length of the data that is in the buffer.">length()</a></code></td></tr>
  </table>
</dl>
 <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ae048282c7011eedc2e0492f6421ea73"></a><!-- doxytag: member="coherence::io::AbstractWriteBuffer::clear" ref="ae048282c7011eedc2e0492f6421ea73" args="()" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1io_1_1_abstract_write_buffer.html#ae048282c7011eedc2e0492f6421ea73">clear</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the length of the buffer as indicated by the <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#e4914e7cc4d1fa65343870ceb7d6bce4" title="Determine the length of the data that is in the buffer.">length()</a> method to zero.<p>
The effect on the capacity of the buffer is implementation-specific; some implementations are expected to retain the same capacity while others are expected to shrink accordingly. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="41828514a26a2878b3ccf330a6692d35"></a><!-- doxytag: member="coherence::io::AbstractWriteBuffer::getWriteBuffer" ref="41828514a26a2878b3ccf330a6692d35" args="(size32_t of)" -->
virtual <br>
<a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#5b310f5b3b4a79c7cde67e22f5bfd543">WriteBuffer::Handle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1io_1_1_abstract_write_buffer.html#41828514a26a2878b3ccf330a6692d35">getWriteBuffer</a> (size32_t of)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain a <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html" title="The WriteBuffer interface represents an in-memory block of binary data that is being...">WriteBuffer</a> starting at a particular offset within this <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html" title="The WriteBuffer interface represents an in-memory block of binary data that is being...">WriteBuffer</a>.<p>
This is functionally equivalent to: <code><pre>
 return getWriteBuffer(of, <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#d99ad17e6d872d67be7e6c7928107871" title="Determine the maximum number of octets that the buffer can hold.">getMaximumCapacity()</a> - of);
 </pre></code><p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>of</em>&nbsp;</td><td>the beginning index, inclusive</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html" title="The WriteBuffer interface represents an in-memory block of binary data that is being...">WriteBuffer</a> that represents a portion of this <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html" title="The WriteBuffer interface represents an in-memory block of binary data that is being...">WriteBuffer</a></dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IndexOutOfBoundsException</em>&nbsp;</td><td>if <code>of</code> is larger than the <code><a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#d99ad17e6d872d67be7e6c7928107871" title="Determine the maximum number of octets that the buffer can hold.">getMaximumCapacity()</a></code> of this <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html" title="The WriteBuffer interface represents an in-memory block of binary data that is being...">WriteBuffer</a></td></tr>
  </table>
</dl>
 <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="4705238531efa86bcd19c14e72a06691"></a><!-- doxytag: member="coherence::io::AbstractWriteBuffer::getWriteBuffer" ref="4705238531efa86bcd19c14e72a06691" args="(size32_t of, size32_t cb)" -->
virtual <br>
<a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#5b310f5b3b4a79c7cde67e22f5bfd543">WriteBuffer::Handle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1io_1_1_abstract_write_buffer.html#4705238531efa86bcd19c14e72a06691">getWriteBuffer</a> (size32_t of, size32_t cb)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain a <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html" title="The WriteBuffer interface represents an in-memory block of binary data that is being...">WriteBuffer</a> for a portion of this <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html" title="The WriteBuffer interface represents an in-memory block of binary data that is being...">WriteBuffer</a>.<p>
Use of the resulting buffer will correspond to using this buffer directly but with the offset being passed to the buffer methods automatically having <code>of</code> added. As a result, the length of this buffer can be modified by writing to the new buffer; however, changes made directly to this buffer will not affect the length of the new buffer.<p>
Note that the resulting <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html" title="The WriteBuffer interface represents an in-memory block of binary data that is being...">WriteBuffer</a> is limited in the number of octets that can be written to it; in other words, its <code><a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#d99ad17e6d872d67be7e6c7928107871" title="Determine the maximum number of octets that the buffer can hold.">getMaximumCapacity()</a></code> must return the same value as was passed in <code>cb</code>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>of</em>&nbsp;</td><td>the offset of the first octet within this <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html" title="The WriteBuffer interface represents an in-memory block of binary data that is being...">WriteBuffer</a> to map to offset 0 of the new <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html" title="The WriteBuffer interface represents an in-memory block of binary data that is being...">WriteBuffer</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cb</em>&nbsp;</td><td>the number of octets to cover in the resulting <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html" title="The WriteBuffer interface represents an in-memory block of binary data that is being...">WriteBuffer</a></td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html" title="The WriteBuffer interface represents an in-memory block of binary data that is being...">WriteBuffer</a> that represents a portion of this <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html" title="The WriteBuffer interface represents an in-memory block of binary data that is being...">WriteBuffer</a></dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IndexOutOfBoundsException</em>&nbsp;</td><td>if <code>of + cb</code> is larger than the <code><a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#d99ad17e6d872d67be7e6c7928107871" title="Determine the maximum number of octets that the buffer can hold.">getMaximumCapacity()</a></code> of this <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html" title="The WriteBuffer interface represents an in-memory block of binary data that is being...">WriteBuffer</a></td></tr>
  </table>
</dl>
 <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="89885b79495825a0c9e505145140bbd6"></a><!-- doxytag: member="coherence::io::AbstractWriteBuffer::getReadBuffer" ref="89885b79495825a0c9e505145140bbd6" args="() const " -->
virtual <a class="el" href="classcoherence_1_1io_1_1_read_buffer.html#9dff753690c2fde7f2096982681b2fe3">ReadBuffer::View</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1io_1_1_abstract_write_buffer.html#89885b79495825a0c9e505145140bbd6">getReadBuffer</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a <a class="el" href="classcoherence_1_1io_1_1_read_buffer.html" title="The ReadBuffer interface represents an in-memory block of binary data.">ReadBuffer</a> object that is a snapshot of this WriteBuffer's data.<p>
This method is functionally equivalent to the following code: <pre><code>
 <a class="el" href="classcoherence_1_1lang_1_1_array.html#9dff753690c2fde7f2096982681b2fe3" title="Array&lt;T&gt; View definition.">Array&lt;octet_t&gt;::View</a> vab = <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#bf95b164a1ea4034951baeeb5795581d" title="Returns an octet array that holds the complete contents of this WriteBuffer.">toOctetArray()</a>;
 return OctetArrayReadBuffer::create(vab, 0, vab-&gt;<a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#e4914e7cc4d1fa65343870ceb7d6bce4" title="Determine the length of the data that is in the buffer.">length()</a>, true);
 </code></pre><p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a <a class="el" href="classcoherence_1_1io_1_1_read_buffer.html" title="The ReadBuffer interface represents an in-memory block of binary data.">ReadBuffer</a> that reflects the point-in-time contents of this <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html" title="The WriteBuffer interface represents an in-memory block of binary data that is being...">WriteBuffer</a>; the returned <a class="el" href="classcoherence_1_1io_1_1_read_buffer.html" title="The ReadBuffer interface represents an in-memory block of binary data.">ReadBuffer</a> is inherently immutable</dd></dl>
 <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="34981d00ec23693a125764191ca55b26"></a><!-- doxytag: member="coherence::io::AbstractWriteBuffer::toOctetArray" ref="34981d00ec23693a125764191ca55b26" args="() const " -->
virtual <a class="el" href="classcoherence_1_1lang_1_1_array.html">Array</a><br>
&lt; octet_t &gt;::<a class="el" href="classcoherence_1_1io_1_1_abstract_write_buffer.html#9dff753690c2fde7f2096982681b2fe3">View</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1io_1_1_abstract_write_buffer.html#34981d00ec23693a125764191ca55b26">toOctetArray</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns an octet array that holds the complete contents of this <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html" title="The WriteBuffer interface represents an in-memory block of binary data that is being...">WriteBuffer</a>.<p>
This method is functionally equivalent to the following code: <pre><code>
 return <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#e1d7c3c5eb5c4e09e9e3e05d67db6070" title="Get a ReadBuffer object to read data from this buffer.">getUnsafeReadBuffer()</a>-&gt;<a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#bf95b164a1ea4034951baeeb5795581d" title="Returns an octet array that holds the complete contents of this WriteBuffer.">toOctetArray()</a>;
 </code></pre><p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the contents of this <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html" title="The WriteBuffer interface represents an in-memory block of binary data that is being...">WriteBuffer</a> as an octet array</dd></dl>
 <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="2903d5e0353f66672700dfc86212d098"></a><!-- doxytag: member="coherence::io::AbstractWriteBuffer::toBinary" ref="2903d5e0353f66672700dfc86212d098" args="() const " -->
virtual <a class="el" href="classcoherence_1_1lang_1_1_typed_handle.html">BinaryView</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1io_1_1_abstract_write_buffer.html#2903d5e0353f66672700dfc86212d098">toBinary</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a new Binary object that holds the complete contents of this <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html" title="The WriteBuffer interface represents an in-memory block of binary data that is being...">WriteBuffer</a>.<p>
This method is functionally equivalent to the following code: <pre><code>
 return <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#e1d7c3c5eb5c4e09e9e3e05d67db6070" title="Get a ReadBuffer object to read data from this buffer.">getUnsafeReadBuffer()</a>-&gt;<a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#4246cefa85f1cb45f2c01f80bc18c6c3" title="Returns a new Binary object that holds the complete contents of this WriteBuffer...">toBinary()</a>;
 </code></pre><p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the contents of this <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html" title="The WriteBuffer interface represents an in-memory block of binary data that is being...">WriteBuffer</a> as a Binary object</dd></dl>
<dl class="since" compact><dt><b>Since:</b></dt><dd>Coherence 3.7.1</dd></dl>
 <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="0338e19cd048eabb226fb660341207f6"></a><!-- doxytag: member="coherence::io::AbstractWriteBuffer::getBufferOutput" ref="0338e19cd048eabb226fb660341207f6" args="(size32_t of=0)" -->
virtual <br>
<a class="el" href="classcoherence_1_1io_1_1_write_buffer_1_1_buffer_output.html#5b310f5b3b4a79c7cde67e22f5bfd543">BufferOutput::Handle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1io_1_1_abstract_write_buffer.html#0338e19cd048eabb226fb660341207f6">getBufferOutput</a> (size32_t of=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a <a class="el" href="classcoherence_1_1io_1_1_write_buffer_1_1_buffer_output.html" title="The BufferOutput interface represents a data output stream on top of a WriteBuffer...">BufferOutput</a> object to write data to this buffer starting at a particular offset.<p>
Note that each call to this method will return a new <a class="el" href="classcoherence_1_1io_1_1_write_buffer_1_1_buffer_output.html" title="The BufferOutput interface represents a data output stream on top of a WriteBuffer...">BufferOutput</a> object, with the possible exception being that a zero-length non-resizing <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html" title="The WriteBuffer interface represents an in-memory block of binary data that is being...">WriteBuffer</a> could always return the same instance (since it is not writable).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>of</em>&nbsp;</td><td>the offset of the first octet of this buffer that the <a class="el" href="classcoherence_1_1io_1_1_write_buffer_1_1_buffer_output.html" title="The BufferOutput interface represents a data output stream on top of a WriteBuffer...">BufferOutput</a> will write to</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a <a class="el" href="classcoherence_1_1io_1_1_write_buffer_1_1_buffer_output.html" title="The BufferOutput interface represents a data output stream on top of a WriteBuffer...">BufferOutput</a> that will write to this buffer</dd></dl>
 <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="26e4264a0c869f0a21aecc893f820291"></a><!-- doxytag: member="coherence::io::AbstractWriteBuffer::getAppendingBufferOutput" ref="26e4264a0c869f0a21aecc893f820291" args="()" -->
virtual <br>
<a class="el" href="classcoherence_1_1io_1_1_write_buffer_1_1_buffer_output.html#5b310f5b3b4a79c7cde67e22f5bfd543">BufferOutput::Handle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1io_1_1_abstract_write_buffer.html#26e4264a0c869f0a21aecc893f820291">getAppendingBufferOutput</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a <a class="el" href="classcoherence_1_1io_1_1_write_buffer_1_1_buffer_output.html" title="The BufferOutput interface represents a data output stream on top of a WriteBuffer...">BufferOutput</a> object to write data to this buffer.<p>
The <a class="el" href="classcoherence_1_1io_1_1_write_buffer_1_1_buffer_output.html" title="The BufferOutput interface represents a data output stream on top of a WriteBuffer...">BufferOutput</a> object returned by this method is set to append to the <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html" title="The WriteBuffer interface represents an in-memory block of binary data that is being...">WriteBuffer</a>, meaning that its offset is pre-set to the <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#e4914e7cc4d1fa65343870ceb7d6bce4" title="Determine the length of the data that is in the buffer.">length()</a> of this buffer.<p>
This is functionally equivalent to: <pre><code>
 return getBufferOutput(<a class="el" href="classcoherence_1_1io_1_1_write_buffer.html#e4914e7cc4d1fa65343870ceb7d6bce4" title="Determine the length of the data that is in the buffer.">length()</a>);
 </code></pre><p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a <a class="el" href="classcoherence_1_1io_1_1_write_buffer_1_1_buffer_output.html" title="The BufferOutput interface represents a data output stream on top of a WriteBuffer...">BufferOutput</a> configured to append to this buffer</dd></dl>
 <br></td></tr>
<tr><td colspan="2"><br><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <br>
<a class="el" href="classcoherence_1_1io_1_1_write_buffer_1_1_buffer_output.html#5b310f5b3b4a79c7cde67e22f5bfd543">BufferOutput::Handle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1io_1_1_abstract_write_buffer.html#a85caa36fef86d69907997419846e72c">instantiateBufferOutput</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Factory method: Instantiate a BufferOutput object to write data to the <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html" title="The WriteBuffer interface represents an in-memory block of binary data that is being...">WriteBuffer</a>.  <a href="#a85caa36fef86d69907997419846e72c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classcoherence_1_1lang_1_1_array.html">Array</a><br>
&lt; octet_t &gt;::<a class="el" href="classcoherence_1_1io_1_1_abstract_write_buffer.html#5b310f5b3b4a79c7cde67e22f5bfd543">Handle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1io_1_1_abstract_write_buffer.html#9e2078b87f3271fbbf9076d3718c8e3e">tmpbuf</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a small buffer for formating data.  <a href="#9e2078b87f3271fbbf9076d3718c8e3e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classcoherence_1_1lang_1_1_array.html">Array</a><br>
&lt; octet_t &gt;::<a class="el" href="classcoherence_1_1io_1_1_abstract_write_buffer.html#5b310f5b3b4a79c7cde67e22f5bfd543">Handle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1io_1_1_abstract_write_buffer.html#8f784da88c684fc3ffbe84fcda8c8bd9">tmpbuf</a> (size32_t cb)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a buffer for formating data.  <a href="#8f784da88c684fc3ffbe84fcda8c8bd9"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d38fe8b5abdd5f1999bb4bbdf7dd1cbd"></a><!-- doxytag: member="coherence::io::AbstractWriteBuffer::m_habBuf" ref="d38fe8b5abdd5f1999bb4bbdf7dd1cbd" args="" -->
<a class="el" href="classcoherence_1_1lang_1_1_member_handle.html">MemberHandle</a>&lt; <a class="el" href="classcoherence_1_1lang_1_1_array.html">Array</a><br>
&lt; octet_t &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1io_1_1_abstract_write_buffer.html#d38fe8b5abdd5f1999bb4bbdf7dd1cbd">m_habBuf</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A temp buffer to use for building the data to write. <br></td></tr>
<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1io_1_1_abstract_write_buffer_1_1_abstract_buffer_output.html">AbstractBufferOutput</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classcoherence_1_1io_1_1_abstract_write_buffer_1_1_abstract_buffer_output.html" title="AbstractBufferOutput is a concrete implementation of BufferOutput for the non-concrete...">AbstractBufferOutput</a> is a concrete implementation of BufferOutput for the non-concrete <a class="el" href="classcoherence_1_1io_1_1_abstract_write_buffer.html" title="The AbstractWriteBuffer is a partial implementation of the WriteBuffer interface...">AbstractWriteBuffer</a> implementation.  <a href="classcoherence_1_1io_1_1_abstract_write_buffer_1_1_abstract_buffer_output.html#_details">More...</a><br></td></tr>
</table>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="a85caa36fef86d69907997419846e72c"></a><!-- doxytag: member="coherence::io::AbstractWriteBuffer::instantiateBufferOutput" ref="a85caa36fef86d69907997419846e72c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classcoherence_1_1io_1_1_write_buffer_1_1_buffer_output.html#5b310f5b3b4a79c7cde67e22f5bfd543">BufferOutput::Handle</a> instantiateBufferOutput           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Factory method: Instantiate a BufferOutput object to write data to the <a class="el" href="classcoherence_1_1io_1_1_write_buffer.html" title="The WriteBuffer interface represents an in-memory block of binary data that is being...">WriteBuffer</a>. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a new BufferOutput writing to this <a class="el" href="classcoherence_1_1io_1_1_read_buffer.html" title="The ReadBuffer interface represents an in-memory block of binary data.">ReadBuffer</a> </dd></dl>

<p>Reimplemented in <a class="el" href="classcoherence_1_1io_1_1_delegating_write_buffer.html#a85caa36fef86d69907997419846e72c">DelegatingWriteBuffer</a>, and <a class="el" href="classcoherence_1_1io_1_1_octet_array_write_buffer.html#a85caa36fef86d69907997419846e72c">OctetArrayWriteBuffer</a>.</p>

</div>
</div><p>
<a class="anchor" name="9e2078b87f3271fbbf9076d3718c8e3e"></a><!-- doxytag: member="coherence::io::AbstractWriteBuffer::tmpbuf" ref="9e2078b87f3271fbbf9076d3718c8e3e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classcoherence_1_1lang_1_1_array.html">Array</a>&lt;octet_t&gt;::<a class="el" href="classcoherence_1_1io_1_1_abstract_write_buffer.html#5b310f5b3b4a79c7cde67e22f5bfd543">Handle</a> tmpbuf           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get a small buffer for formating data. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a small octet array </dd></dl>

</div>
</div><p>
<a class="anchor" name="8f784da88c684fc3ffbe84fcda8c8bd9"></a><!-- doxytag: member="coherence::io::AbstractWriteBuffer::tmpbuf" ref="8f784da88c684fc3ffbe84fcda8c8bd9" args="(size32_t cb)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classcoherence_1_1lang_1_1_array.html">Array</a>&lt;octet_t&gt;::<a class="el" href="classcoherence_1_1io_1_1_abstract_write_buffer.html#5b310f5b3b4a79c7cde67e22f5bfd543">Handle</a> tmpbuf           </td>
          <td>(</td>
          <td class="paramtype">size32_t&nbsp;</td>
          <td class="paramname"> <em>cb</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get a buffer for formating data. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cb</em>&nbsp;</td><td>the minimum size for the buffer</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>an octet array that is at least <code>cb</code> octets long </dd></dl>

</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li>coherence/io/<a class="el" href="_abstract_write_buffer_8hpp-source.html">AbstractWriteBuffer.hpp</a></ul>
<center>
  Copyright &copy; 2000, 2020, Oracle and/or its affiliates.
  Licensed under the Universal Permissive License v 1.0 as shown at
  http://oss.oracle.com/licenses/upl.
</center>
</BODY>
</HTML>
