<!--
  Copyright (c) 2000, 2020, Oracle and/or its affiliates.

  Licensed under the Universal Permissive License v 1.0 as shown at
  http://oss.oracle.com/licenses/upl.
-->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Oracle&amp;reg; Fusion Middleware C++ API Reference for Oracle Coherence: Managed Class Template Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<b>Oracle&reg; Fusion Middleware C++ API Reference for Oracle Coherence<br>14c (14.1.1.0.2 Internal-lsho-mac-0716.2020.0219)</b><br>F23533-01
<!-- Generated by Doxygen 1.5.3 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li class="current"><a href="classes.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul>
</div>
<div class="tabs">
  <ul>
    <li><a href="classes.html"><span>Alphabetical&nbsp;List</span></a></li>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul>
</div>
<div class="nav">
<a class="el" href="namespacecoherence.html">coherence</a>::<a class="el" href="namespacecoherence_1_1lang.html">lang</a>::<a class="el" href="classcoherence_1_1lang_1_1_managed.html">Managed</a></div>
<h1>Managed Class Template Reference</h1><!-- doxytag: class="coherence::lang::Managed" --><!-- doxytag: inherits="coherence::lang::Object" --><code>#include &lt;<a class="el" href="_managed_8hpp-source.html">coherence/lang/Managed.hpp</a>&gt;</code>
<p>
Inherits <a class="el" href="classcoherence_1_1lang_1_1_object.html">Object</a>.
<p>

<p>
<a href="classcoherence_1_1lang_1_1_managed-members.html">List of all members.</a><hr><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;class T&gt;<br>
 class coherence::lang::Managed&lt; T &gt;</h3>

<a class="el" href="classcoherence_1_1lang_1_1_managed.html" title="Managed is an adaptor class which transforms a pre-existing class into a Coherence...">Managed</a> is an adaptor class which transforms a pre-existing class into a Coherence managed <a class="el" href="classcoherence_1_1lang_1_1_object.html" title="Object is the base class for all Coherence managed objects.">Object</a>. 
<p>
The resulting object will be usable both as the supplied data type and as a Coherence managed object. As a managed object it is suitable for storage in Coherence caches.<p>
The managed object must be created using its associated static create methods, which support either default construction, or copy construction from the custom type. The managed object's life-cycle is dictated by reference counting, and it may not be manually deleted.<p>
To be compatible with the <a class="el" href="classcoherence_1_1lang_1_1_managed.html" title="Managed is an adaptor class which transforms a pre-existing class into a Coherence...">Managed</a> template the following set of functions must be defined for the supplied type: <ul>
<li>
zero parameter constructor (public or protected): <code>CustomType::CustomType()</code> </li>
<li>
copy constructor (public or protected): <code>CustomType::CustomType(const CustomType&amp;)</code> </li>
<li>
equality comparison operator: <code>bool operator==(const CustomType&amp;, const CustomType&amp;)</code> </li>
<li>
basic_stream output function: <code>template&lt;typename Char, typename Traits&gt; std::basic_ostream&lt;Char, Traits&gt;&amp; operator&lt;&lt;(std::basic_ostream&lt;Char, Traits&gt;&amp; out, const CustomType&amp;)</code> </li>
<li>
hash function: <code>size_t hash_value(const CustomType&amp;)</code> </li>
</ul>
<p>
A example of a conforming class would be: <div class="fragment"><pre class="fragment"> <span class="keyword">class </span>Address
   {
   <span class="keyword">public</span>:
     Address(<span class="keyword">const</span> std::string&amp; sCity, <span class="keyword">const</span> std::String&amp; sState, <span class="keywordtype">int</span> nZip)
       : m_sCity(sCity), m_sState(sState), m_nZip(nZip) {}

     Address(<span class="keyword">const</span> Address&amp; that)
       : m_sCity(that.m_sCity), m_sState(that.m_sState), m_nZip(that.m_nZip) {}

   <span class="keyword">protected</span>:
     Address()
       : m_nZip(0) {}

   <span class="keyword">public</span>:
     std::string  getCity()<span class="keyword">  const </span>{<span class="keywordflow">return</span> m_sCity;}
     std::string  getState()<span class="keyword"> const </span>{<span class="keywordflow">return</span> m_sState;}
     <span class="keywordtype">int</span>          getZip()<span class="keyword">   const </span>{<span class="keywordflow">return</span> m_nZip;}

   <span class="keyword">private</span>:
     <span class="keyword">const</span> std::string m_sCity;
     <span class="keyword">const</span> std::string m_sState;
     <span class="keyword">const</span> <span class="keywordtype">int</span>         m_nZip;
   };

 <span class="keywordtype">bool</span> operator==(<span class="keyword">const</span> Address&amp; addra, <span class="keyword">const</span> Address&amp; addrb)
   {
   <span class="keywordflow">return</span> addra.getZip()   == addrb.getZip() &amp;&amp;
          addra.getState() == addrb.getState() &amp;&amp;
          addra.getCity()  == addrb.getCity();
   }

 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Char, <span class="keyword">typename</span> Traits, <span class="keyword">class</span> T&gt; std::basic_ostream&lt;Char, Traits&gt;&amp; operator&lt;&lt;(std::basic_ostream&lt;Char, Traits&gt;&amp; out, <span class="keyword">const</span> Address&amp; addr)
   {
   out &lt;&lt; addr.getCity() &lt;&lt; <span class="stringliteral">", "</span> &lt;&lt; addr.getState() &lt;&lt; <span class="stringliteral">"  "</span> &lt;&lt; addr.getZip();
   <span class="keywordflow">return</span> out;
   }

 <span class="keywordtype">size_t</span> hash_value(<span class="keyword">const</span> Address&amp; addr)
   {
   <span class="keywordflow">return</span> (<span class="keywordtype">size_t</span>) addr.getZip();
   }
</pre></div><p>
Serialization support may be added by specializing the following free-functions: <ul>
<li>
serializer: <code>void serialize&lt;CustomType&gt;(coherence::io::pof::PofWriter::Handle, const CustomType&amp;)</code> </li>
<li>
deserializer: <code>CustomType deserialize&lt;CustomType&gt;(coherence::io::pof::PofReader::Handle)</code> </li>
</ul>
<p>
The serialization functions do not need to be defined within the source file of the original data type. They only need to be linked into the application, and registered with the SystemPofContext via the COH_REGISTER_MANAGED_CLASS macro.<p>
<div class="fragment"><pre class="fragment"><span class="preprocessor"> #include "coherence/io/pof/SystemPofContext.hpp"</span>

<span class="preprocessor"> #include "Address.hpp"</span>

 <span class="keyword">using namespace </span>coherence::io::pof;

 COH_REGISTER_MANAGED_CLASS(1234, Address);

 <span class="keyword">template</span>&lt;&gt; <span class="keywordtype">void</span> serialize&lt;Address&gt;(PofWriter::Handle hOut, <span class="keyword">const</span> Address&amp; addr)
   {
   hOut-&gt;writeString(0, addr.getCity());
   hOut-&gt;writeString(1, addr.getState());
   hOut-&gt;writeInt32 (2, addr.getZip());
   }

 <span class="keyword">template</span>&lt;&gt; Address deserialize&lt;Address&gt;(PofReader::Handle hIn)
   {
   std::string sCity  = hIn-&gt;readString(0);
   std::string sState = hIn-&gt;readString(1);
   <span class="keywordtype">int</span>         nZip   = hIn-&gt;readInt32 (2);

   <span class="keywordflow">return</span> Address(sCity, sState, nZip);
   }
</pre></div><p>
An example usage of the resulting managed type would be: <div class="fragment"><pre class="fragment"> <span class="comment">// construct the non-managed version as usual</span>
 Address office(<span class="stringliteral">"Redwood Shores"</span>, <span class="stringliteral">"CA"</span>, 94065);

 <span class="comment">// the managed version can be initialized from the non-managed version</span>
 <span class="comment">// the result is a new object, which does not reference the original</span>
 Managed&lt;Address&gt;::View vOffice = Managed&lt;Address&gt;::create(office);
 <a class="code" href="classcoherence_1_1lang_1_1_string.html#9dff753690c2fde7f2096982681b2fe3" title="String View definition.">String::View</a>           vKey    = <span class="stringliteral">"Oracle"</span>;

 <span class="comment">// the managed version is suitable for use with caches</span>
 hCache-&gt;put(vKey, vAddr);
 vOffice = cast&lt;Managed&lt;Address&gt;::View&gt;(hCache-&gt;get(vKey));

 <span class="comment">// the non-managed class's public methods/fields remain accessible</span>
 assert(vOffice-&gt;getCity()  == office.getCity());
 assert(vOffice-&gt;getState() == office.getState());
 assert(vOffice-&gt;getZip()   == office.getZip());

 <span class="comment">// conversion back to the non-managed type may be performed using the</span>
 <span class="comment">// non-managed class's copy constructor.</span>
 Address officeOut = *vOffice;
</pre></div><p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classcoherence_1_1io_1_1pof_1_1_pof_reader.html" title="The PofReader interface provides the capability of reading a set of non-primitive...">coherence::io::pof::PofReader</a> <p>
<a class="el" href="classcoherence_1_1io_1_1pof_1_1_pof_writer.html" title="The PofWriter interface provides the capability of writing a set of non-primitive...">coherence::io::pof::PofWriter</a> <p>
<a class="el" href="classcoherence_1_1io_1_1pof_1_1_system_pof_context.html" title="System-wide PofContext implementation that allows POF user types to be registered...">coherence::io::pof::SystemPofContext</a></dd></dl>
<dl class="author" compact><dt><b>Author:</b></dt><dd>mf 2007.07.05 </dd></dl>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="5b310f5b3b4a79c7cde67e22f5bfd543"></a><!-- doxytag: member="coherence::lang::Managed::Handle" ref="5b310f5b3b4a79c7cde67e22f5bfd543" args="" -->
typedef spec::Handle&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1lang_1_1_managed.html#5b310f5b3b4a79c7cde67e22f5bfd543">Handle</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Managed&lt;T&gt; Handle definition. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="9dff753690c2fde7f2096982681b2fe3"></a><!-- doxytag: member="coherence::lang::Managed::View" ref="9dff753690c2fde7f2096982681b2fe3" args="" -->
typedef spec::View&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1lang_1_1_managed.html#9dff753690c2fde7f2096982681b2fe3">View</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Managed&lt;T&gt; View definition. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f6b6cf6ce7af189584f0d92db3187844"></a><!-- doxytag: member="coherence::lang::Managed::Holder" ref="f6b6cf6ce7af189584f0d92db3187844" args="" -->
typedef spec::Holder&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1lang_1_1_managed.html#f6b6cf6ce7af189584f0d92db3187844">Holder</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Managed&lt;T&gt; Holder definition. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="c1ca5bc5e4053f39c773e937074cd9d4"></a><!-- doxytag: member="coherence::lang::Managed::BoxedType" ref="c1ca5bc5e4053f39c773e937074cd9d4" args="" -->
typedef T&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1lang_1_1_managed.html#c1ca5bc5e4053f39c773e937074cd9d4">BoxedType</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The boxed class type. <br></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1lang_1_1_managed.html#95352586fb2c6d4358977e2f115c4ced">equals</a> (<a class="el" href="classcoherence_1_1lang_1_1_object.html#9dff753690c2fde7f2096982681b2fe3">Object::View</a> v) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return true iff the specified <a class="el" href="classcoherence_1_1lang_1_1_object.html" title="Object is the base class for all Coherence managed objects.">Object</a> is "equal" to this <a class="el" href="classcoherence_1_1lang_1_1_object.html" title="Object is the base class for all Coherence managed objects.">Object</a>.<p>
This method <a class="el" href="classcoherence_1_1lang_1_1implements.html" title="The implements template specifies a list of interfaces which a class or interface...">implements</a> an <em>equivalence relation</em> on Objects: <ul>
<li>
It is <em>reflexive</em>: for any non-null handle <code>h</code>, <code>h-&gt;equals(h)</code> must return <code>true</code>. </li>
<li>
It is <em>symmetric</em>: for any non-null handles <code>h1</code> and <code>h2</code>, <code>h1-&gt;equals(h2)</code> should return <code>true</code> if and only if <code>h2-&gt;equals(h1)</code> returns <code>true</code>. </li>
<li>
It is <em>transitive</em>: for any non-null handles <code>h1</code>, <code>h2</code>, and <code>h3</code>, if <code>h1-&gt;equals(h2)</code> returns <code>true</code> and <code>h2-&gt;equals(h3)</code> returns <code>true</code>, then <code>h1-&gt;equals(h3)</code> should return <code>true</code>. </li>
<li>
It is <em>consistent</em>: for any non-null handles <code>h1</code> and <code>h2</code>, multiple invocations of <code>h1-&gt;equals(h2)</code> consistently return <code>true</code> or consistently return <code>false</code>, provided no information used in comparisons on the objects is modified. </li>
<li>
If the supplied handle is <code>NULL</code> then <code>false</code> must be returned. </li>
</ul>
<p>
The default implementation is a reference equality comparison.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>v</em>&nbsp;</td><td>the <a class="el" href="classcoherence_1_1lang_1_1_object.html#9dff753690c2fde7f2096982681b2fe3" title="Object View definition.">Object::View</a> to compare against, may be <code>NULL</code></td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>true</code> iff the given handle references an <a class="el" href="classcoherence_1_1lang_1_1_object.html" title="Object is the base class for all Coherence managed objects.">Object</a> that is "equal" to this <a class="el" href="classcoherence_1_1lang_1_1_object.html" title="Object is the base class for all Coherence managed objects.">Object</a></dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classcoherence_1_1lang_1_1_object.html#5e1c753fb7aa49f9f9aab9d0cc662ba9" title="Compare two Objects for equality.">equals(Object::View v1, Object::View v2)</a></dd></dl>
  <a href="#95352586fb2c6d4358977e2f115c4ced"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classcoherence_1_1lang_1_1_typed_handle.html">TypedHandle</a><br>
&lt; const <a class="el" href="classcoherence_1_1lang_1_1_string.html">String</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1lang_1_1_managed.html#893ed753a1b5374ef08f75bb59dd66d9">toString</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Output a human-readable description of this <a class="el" href="classcoherence_1_1lang_1_1_object.html" title="Object is the base class for all Coherence managed objects.">Object</a> to the given stream.<p>
Note that when overriding this method the return type must be TypedHandle&lt;const String&gt; rather then <a class="el" href="classcoherence_1_1lang_1_1_string.html#9dff753690c2fde7f2096982681b2fe3" title="String View definition.">String::View</a>. These two types are assignment compatible but not equivalent and declaring the override with <a class="el" href="classcoherence_1_1lang_1_1_string.html#9dff753690c2fde7f2096982681b2fe3" title="String View definition.">String::View</a> will not be a compatible override.<p>
coherence::lang::operator&lt;&lt;(std::ostream, Object::View) is defined and will call into the toString method, to output Objects. If a managed <a class="el" href="classcoherence_1_1lang_1_1_string.html" title="A managed C-style (NUL terminated) string.">String</a> object is desired, the COH_TO_STRING macro can be used to build up a <a class="el" href="classcoherence_1_1lang_1_1_string.html" title="A managed C-style (NUL terminated) string.">String</a> from streamable contents and is generally how <a class="el" href="classcoherence_1_1lang_1_1_object.html#893ed753a1b5374ef08f75bb59dd66d9" title="Output a human-readable description of this Object to the given stream.">toString()</a> will be implemented.<p>
<div class="fragment"><pre class="fragment"> <a class="code" href="classcoherence_1_1lang_1_1_object.html#9dff753690c2fde7f2096982681b2fe3" title="Object View definition.">Object::View</a> vKey   = ...
 <a class="code" href="classcoherence_1_1lang_1_1_object.html#9dff753690c2fde7f2096982681b2fe3" title="Object View definition.">Object::View</a> vValue = ...
 std::cout &lt;&lt; vKey &lt;&lt; <span class="stringliteral">" = "</span> &lt;&lt; vValue &lt;&lt; std::endl;

 <a class="code" href="classcoherence_1_1lang_1_1_string.html#9dff753690c2fde7f2096982681b2fe3" title="String View definition.">String::View</a> vs = COH_TO_STRING(vKey &lt;&lt; <span class="stringliteral">" = "</span> &lt;&lt; vValue);
</pre></div><p>
The COH_TO_STRING macro is also the most common way to implement the toString method. For example:<p>
<div class="fragment"><pre class="fragment"> <span class="keyword">virtual</span> TypedHandle&lt;const String&gt; Person::toString()<span class="keyword"> const</span>
<span class="keyword">     </span>{
     <span class="keywordflow">return</span> COH_TO_STRING(<span class="stringliteral">"Name: "</span> &lt;&lt; f_sName &lt;&lt; <span class="stringliteral">" SSN: "</span> &lt;&lt; f_nSSN);
     }
</pre></div><p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a string representation of this object</dd></dl>
  <a href="#893ed753a1b5374ef08f75bb59dd66d9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual size32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1lang_1_1_managed.html#7eccbcd534ab222690ab767a40df14fb">hashCode</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a hash code value for the <a class="el" href="classcoherence_1_1lang_1_1_object.html" title="Object is the base class for all Coherence managed objects.">Object</a>.<p>
This method is supported for the benefit of hash-based containers.<p>
The general contract of <code>hashCode</code> is: <ul>
<li>
Whenever it is invoked on the same <a class="el" href="classcoherence_1_1lang_1_1_object.html" title="Object is the base class for all Coherence managed objects.">Object</a> more than once during an execution of an application, the <code>hashCode</code> method must consistently return the same value, provided no information used in <code>equals</code> comparisons on the object is modified. This value need not remain consistent from one execution of an application to another execution of the same application. </li>
<li>
If two Objects are equal according to the <code>equals</code> method, then calling the <code>hashCode</code> method on each of the two Objects must produce the same value. </li>
<li>
It is <em>not</em> required that if two Objects are unequal according to the <code>equals</code> method, then calling the <code>hashCode</code> method on each of the two objects must produce distinct results. However, the programmer should be aware that producing distinct results for unequal objects may improve the performance of hash-based containers. </li>
</ul>
<p>
The default implementation is identity based.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a hash code value for this <a class="el" href="classcoherence_1_1lang_1_1_object.html" title="Object is the base class for all Coherence managed objects.">Object</a></dd></dl>
  <a href="#7eccbcd534ab222690ab767a40df14fb"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1lang_1_1_managed.html#0be75425cb8e4ae478e48c46fccc4b69">Managed</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new Managed&lt;T&gt; instance with the default initial T value.  <a href="#0be75425cb8e4ae478e48c46fccc4b69"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1lang_1_1_managed.html#74ce46b54f9aaad376bb4d7bdceea1b7">Managed</a> (const T &amp;t)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new Managed&lt;T&gt; instance.  <a href="#74ce46b54f9aaad376bb4d7bdceea1b7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e7355049a663f0e2257a828a743adbcb"></a><!-- doxytag: member="coherence::lang::Managed::Managed" ref="e7355049a663f0e2257a828a743adbcb" args="(const Managed&lt; T &gt; &amp;that)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1lang_1_1_managed.html#e7355049a663f0e2257a828a743adbcb">Managed</a> (const <a class="el" href="classcoherence_1_1lang_1_1_managed.html">Managed</a>&lt; T &gt; &amp;that)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy constructor. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual T &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1lang_1_1_managed.html#62a34f9ce7164997b4ec19d6be625a40">getManagedObject</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the reference to the managed T object.  <a href="#62a34f9ce7164997b4ec19d6be625a40"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual const T &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcoherence_1_1lang_1_1_managed.html#0620616fd0232ee592e1c268a569297d">getManagedObject</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the constant reference to managed T object.  <a href="#0620616fd0232ee592e1c268a569297d"></a><br></td></tr>
</table>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="0be75425cb8e4ae478e48c46fccc4b69"></a><!-- doxytag: member="coherence::lang::Managed::Managed" ref="0be75425cb8e4ae478e48c46fccc4b69" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcoherence_1_1lang_1_1_managed.html">Managed</a>           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a new Managed&lt;T&gt; instance with the default initial T value. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the new Managed&lt;T&gt; </dd></dl>

</div>
</div><p>
<a class="anchor" name="74ce46b54f9aaad376bb4d7bdceea1b7"></a><!-- doxytag: member="coherence::lang::Managed::Managed" ref="74ce46b54f9aaad376bb4d7bdceea1b7" args="(const T &amp;t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcoherence_1_1lang_1_1_managed.html">Managed</a>           </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&nbsp;</td>
          <td class="paramname"> <em>t</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a new Managed&lt;T&gt; instance. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>t</em>&nbsp;</td><td>the initial value for the templated type </td></tr>
  </table>
</dl>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="62a34f9ce7164997b4ec19d6be625a40"></a><!-- doxytag: member="coherence::lang::Managed::getManagedObject" ref="62a34f9ce7164997b4ec19d6be625a40" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual T&amp; getManagedObject           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the reference to the managed T object. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the managed object </dd></dl>

</div>
</div><p>
<a class="anchor" name="0620616fd0232ee592e1c268a569297d"></a><!-- doxytag: member="coherence::lang::Managed::getManagedObject" ref="0620616fd0232ee592e1c268a569297d" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const T&amp; getManagedObject           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the constant reference to managed T object. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the managed object </dd></dl>

</div>
</div><p>
<a class="anchor" name="95352586fb2c6d4358977e2f115c4ced"></a><!-- doxytag: member="coherence::lang::Managed::equals" ref="95352586fb2c6d4358977e2f115c4ced" args="(Object::View v) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool equals           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcoherence_1_1lang_1_1_object.html#9dff753690c2fde7f2096982681b2fe3">Object::View</a>&nbsp;</td>
          <td class="paramname"> <em>v</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return true iff the specified <a class="el" href="classcoherence_1_1lang_1_1_object.html" title="Object is the base class for all Coherence managed objects.">Object</a> is "equal" to this <a class="el" href="classcoherence_1_1lang_1_1_object.html" title="Object is the base class for all Coherence managed objects.">Object</a>.<p>
This method <a class="el" href="classcoherence_1_1lang_1_1implements.html" title="The implements template specifies a list of interfaces which a class or interface...">implements</a> an <em>equivalence relation</em> on Objects: <ul>
<li>
It is <em>reflexive</em>: for any non-null handle <code>h</code>, <code>h-&gt;equals(h)</code> must return <code>true</code>. </li>
<li>
It is <em>symmetric</em>: for any non-null handles <code>h1</code> and <code>h2</code>, <code>h1-&gt;equals(h2)</code> should return <code>true</code> if and only if <code>h2-&gt;equals(h1)</code> returns <code>true</code>. </li>
<li>
It is <em>transitive</em>: for any non-null handles <code>h1</code>, <code>h2</code>, and <code>h3</code>, if <code>h1-&gt;equals(h2)</code> returns <code>true</code> and <code>h2-&gt;equals(h3)</code> returns <code>true</code>, then <code>h1-&gt;equals(h3)</code> should return <code>true</code>. </li>
<li>
It is <em>consistent</em>: for any non-null handles <code>h1</code> and <code>h2</code>, multiple invocations of <code>h1-&gt;equals(h2)</code> consistently return <code>true</code> or consistently return <code>false</code>, provided no information used in comparisons on the objects is modified. </li>
<li>
If the supplied handle is <code>NULL</code> then <code>false</code> must be returned. </li>
</ul>
<p>
The default implementation is a reference equality comparison.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>v</em>&nbsp;</td><td>the <a class="el" href="classcoherence_1_1lang_1_1_object.html#9dff753690c2fde7f2096982681b2fe3" title="Object View definition.">Object::View</a> to compare against, may be <code>NULL</code></td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>true</code> iff the given handle references an <a class="el" href="classcoherence_1_1lang_1_1_object.html" title="Object is the base class for all Coherence managed objects.">Object</a> that is "equal" to this <a class="el" href="classcoherence_1_1lang_1_1_object.html" title="Object is the base class for all Coherence managed objects.">Object</a></dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classcoherence_1_1lang_1_1_object.html#5e1c753fb7aa49f9f9aab9d0cc662ba9" title="Compare two Objects for equality.">equals(Object::View v1, Object::View v2)</a></dd></dl>
 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>v</em>&nbsp;</td><td>the object to compare against</td></tr>
  </table>
</dl>
This method delegates to the custom types equality operator. 
<p>Reimplemented from <a class="el" href="classcoherence_1_1lang_1_1_object.html#95352586fb2c6d4358977e2f115c4ced">Object</a>.</p>

</div>
</div><p>
<a class="anchor" name="893ed753a1b5374ef08f75bb59dd66d9"></a><!-- doxytag: member="coherence::lang::Managed::toString" ref="893ed753a1b5374ef08f75bb59dd66d9" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classcoherence_1_1lang_1_1_typed_handle.html">TypedHandle</a>&lt;const <a class="el" href="classcoherence_1_1lang_1_1_string.html">String</a>&gt; toString           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Output a human-readable description of this <a class="el" href="classcoherence_1_1lang_1_1_object.html" title="Object is the base class for all Coherence managed objects.">Object</a> to the given stream.<p>
Note that when overriding this method the return type must be TypedHandle&lt;const String&gt; rather then <a class="el" href="classcoherence_1_1lang_1_1_string.html#9dff753690c2fde7f2096982681b2fe3" title="String View definition.">String::View</a>. These two types are assignment compatible but not equivalent and declaring the override with <a class="el" href="classcoherence_1_1lang_1_1_string.html#9dff753690c2fde7f2096982681b2fe3" title="String View definition.">String::View</a> will not be a compatible override.<p>
coherence::lang::operator&lt;&lt;(std::ostream, Object::View) is defined and will call into the toString method, to output Objects. If a managed <a class="el" href="classcoherence_1_1lang_1_1_string.html" title="A managed C-style (NUL terminated) string.">String</a> object is desired, the COH_TO_STRING macro can be used to build up a <a class="el" href="classcoherence_1_1lang_1_1_string.html" title="A managed C-style (NUL terminated) string.">String</a> from streamable contents and is generally how <a class="el" href="classcoherence_1_1lang_1_1_object.html#893ed753a1b5374ef08f75bb59dd66d9" title="Output a human-readable description of this Object to the given stream.">toString()</a> will be implemented.<p>
<div class="fragment"><pre class="fragment"> <a class="code" href="classcoherence_1_1lang_1_1_object.html#9dff753690c2fde7f2096982681b2fe3" title="Object View definition.">Object::View</a> vKey   = ...
 <a class="code" href="classcoherence_1_1lang_1_1_object.html#9dff753690c2fde7f2096982681b2fe3" title="Object View definition.">Object::View</a> vValue = ...
 std::cout &lt;&lt; vKey &lt;&lt; <span class="stringliteral">" = "</span> &lt;&lt; vValue &lt;&lt; std::endl;

 <a class="code" href="classcoherence_1_1lang_1_1_string.html#9dff753690c2fde7f2096982681b2fe3" title="String View definition.">String::View</a> vs = COH_TO_STRING(vKey &lt;&lt; <span class="stringliteral">" = "</span> &lt;&lt; vValue);
</pre></div><p>
The COH_TO_STRING macro is also the most common way to implement the toString method. For example:<p>
<div class="fragment"><pre class="fragment"> <span class="keyword">virtual</span> TypedHandle&lt;const String&gt; Person::toString()<span class="keyword"> const</span>
<span class="keyword">     </span>{
     <span class="keywordflow">return</span> COH_TO_STRING(<span class="stringliteral">"Name: "</span> &lt;&lt; f_sName &lt;&lt; <span class="stringliteral">" SSN: "</span> &lt;&lt; f_nSSN);
     }
</pre></div><p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a string representation of this object</dd></dl>
 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>out</em>&nbsp;</td><td>the stream to write to</td></tr>
  </table>
</dl>
This method delegates to the custom types stream operator. (operator&lt;&lt;) 
<p>Reimplemented from <a class="el" href="classcoherence_1_1lang_1_1_object.html#893ed753a1b5374ef08f75bb59dd66d9">Object</a>.</p>

</div>
</div><p>
<a class="anchor" name="7eccbcd534ab222690ab767a40df14fb"></a><!-- doxytag: member="coherence::lang::Managed::hashCode" ref="7eccbcd534ab222690ab767a40df14fb" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual size32_t hashCode           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return a hash code value for the <a class="el" href="classcoherence_1_1lang_1_1_object.html" title="Object is the base class for all Coherence managed objects.">Object</a>.<p>
This method is supported for the benefit of hash-based containers.<p>
The general contract of <code>hashCode</code> is: <ul>
<li>
Whenever it is invoked on the same <a class="el" href="classcoherence_1_1lang_1_1_object.html" title="Object is the base class for all Coherence managed objects.">Object</a> more than once during an execution of an application, the <code>hashCode</code> method must consistently return the same value, provided no information used in <code>equals</code> comparisons on the object is modified. This value need not remain consistent from one execution of an application to another execution of the same application. </li>
<li>
If two Objects are equal according to the <code>equals</code> method, then calling the <code>hashCode</code> method on each of the two Objects must produce the same value. </li>
<li>
It is <em>not</em> required that if two Objects are unequal according to the <code>equals</code> method, then calling the <code>hashCode</code> method on each of the two objects must produce distinct results. However, the programmer should be aware that producing distinct results for unequal objects may improve the performance of hash-based containers. </li>
</ul>
<p>
The default implementation is identity based.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a hash code value for this <a class="el" href="classcoherence_1_1lang_1_1_object.html" title="Object is the base class for all Coherence managed objects.">Object</a></dd></dl>
 
<p>
This method delegates to the global hash function specialized for the custom type. 
<p>Reimplemented from <a class="el" href="classcoherence_1_1lang_1_1_object.html#7eccbcd534ab222690ab767a40df14fb">Object</a>.</p>

</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li>coherence/lang/<a class="el" href="_managed_8hpp-source.html">Managed.hpp</a></ul>
<center>
  Copyright &copy; 2000, 2020, Oracle and/or its affiliates.
  Licensed under the Universal Permissive License v 1.0 as shown at
  http://oss.oracle.com/licenses/upl.
</center>
</BODY>
</HTML>
